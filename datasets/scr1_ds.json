{"text": "/// Copyright by Syntacore LLC \u00a9 2016-2021. See LICENSE for details\n/// @file       <scr1_cg.sv>\n/// @brief      SCR1 clock gate primitive\n///\n\n`include \"scr1_arch_description.svh\"\n\n`ifdef SCR1_CLKCTRL_EN\nmodule scr1_cg (\n    input   logic   clk,\n    input   logic   clk_en,\n    input   logic   test_mode,\n    output  logic   clk_out\n);\n\n// The code below is a clock gate model for simulation.\n// For synthesis, it should be replaced by implementation-specific\n// clock gate code.\n\nlogic latch_en;\n\nalways_latch begin\n    if (~clk) begin\n        latch_en <= test_mode | clk_en;\n    end\nend\n\nassign clk_out  = latch_en & clk;\n\nendmodule : scr1_cg\n\n`endif // SCR1_CLKCTRL_EN\n"}
{"text": "/// Copyright by Syntacore LLC \u00a9 2016-2021. See LICENSE for details\n/// @file       <scr1_clk_ctrl.sv>\n/// @brief      SCR1 clock control\n///\n\n`include \"scr1_arch_description.svh\"\n\n`ifdef SCR1_CLKCTRL_EN\nmodule scr1_clk_ctrl (\n    input   logic   clk,                            // Clock control module clock\n    input   logic   rst_n,                          // Clock control module reset\n    input   logic   test_mode,                      // DFT Test Mode\n    input   logic   test_rst_n,                     // DFT Test reset\n\n    input   logic   pipe2clkctl_sleep_req_i,        // CLK disable request from pipe\n    input   logic   pipe2clkctl_wake_req_i,         // CLK enable request from pipe\n\n    output  logic   clkctl2pipe_clk_alw_on_o,       // Not gated pipe CLK\n    output  logic   clkctl2pipe_clk_o,              // Gated pipe\n    output  logic   clkctl2pipe_clk_en_o,           // CLK enabled flag\n    output  logic   clkctl2pipe_clk_dbgc_o          // CLK for pipe debug subsystem\n);\n\nlogic ctrl_rst_n;\n\nassign clkctl2pipe_clk_alw_on_o = clk;\nassign clkctl2pipe_clk_dbgc_o   = clk;\nassign ctrl_rst_n   = (test_mode) ? test_rst_n : rst_n;\n\nalways_ff @(posedge clk, negedge ctrl_rst_n) begin\n    if (~ctrl_rst_n) begin\n        clkctl2pipe_clk_en_o <= 1'b1;\n    end else begin\n        if (clkctl2pipe_clk_en_o) begin\n            if (pipe2clkctl_sleep_req_i & ~pipe2clkctl_wake_req_i) begin\n                clkctl2pipe_clk_en_o <= 1'b0;\n            end\n        end else begin // ~clkctl2pipe_clk_en_o\n            if (pipe2clkctl_wake_req_i) begin\n                clkctl2pipe_clk_en_o <= 1'b1;\n            end\n        end // pipeline\n    end\nend\n\nscr1_cg i_scr1_cg_pipe (\n    .clk        (clk                 ),\n    .clk_en     (clkctl2pipe_clk_en_o),\n    .test_mode  (test_mode           ),\n    .clk_out    (clkctl2pipe_clk_o   )\n);\n\nendmodule : scr1_clk_ctrl\n\n`endif // SCR1_CLKCTRL_EN\n"}
{"text": "/// Copyright by Syntacore LLC \u00a9 2016-2021. See LICENSE for details\n/// @file       <scr1_core_top.sv>\n/// @brief      SCR1 core top\n///\n\n`include \"scr1_arch_description.svh\"\n`include \"scr1_arch_types.svh\"\n`include \"scr1_memif.svh\"\n\n`ifdef SCR1_DBG_EN\n`include \"scr1_tapc.svh\"\n`include \"scr1_dm.svh\"\n`include \"scr1_hdu.svh\"\n`endif // SCR1_DBG_EN\n\n`ifdef SCR1_IPIC_EN\n`include \"scr1_ipic.svh\"\n`endif // SCR1_IPIC_EN\n\nmodule scr1_core_top (\n    // Common\n    input   logic                                   pwrup_rst_n,                // Power-Up reset\n    input   logic                                   rst_n,                      // Regular reset\n    input   logic                                   cpu_rst_n,                  // CPU reset\n    input   logic                                   test_mode,                  // DFT Test Mode\n    input   logic                                   test_rst_n,                 // DFT Test Reset\n    input   logic                                   clk,                        // Core clock\n    output  logic                                   core_rst_n_o,               // Core reset\n    output  logic                                   core_rdc_qlfy_o,            // Core RDC qualifier\n`ifdef SCR1_DBG_EN\n    output  logic                                   sys_rst_n_o,                // System reset\n    output  logic                                   sys_rdc_qlfy_o,             // System RDC qualifier\n`endif // SCR1_DBG_EN\n\n    // Fuses\n    input   logic [`SCR1_XLEN-1:0]                  core_fuse_mhartid_i,        // Fuse MHARTID value\n`ifdef SCR1_DBG_EN\n    input   logic [31:0]                            tapc_fuse_idcode_i,         // Fuse IDCODE value\n`endif // SCR1_DBG_EN\n\n    // IRQ\n`ifdef SCR1_IPIC_EN\n    input   logic [SCR1_IRQ_LINES_NUM-1:0]          core_irq_lines_i,           // External interrupt request lines\n`else\n    input   logic                                   core_irq_ext_i,             // External interrupt request\n`endif // SCR1_IPIC_EN\n    input   logic                                   core_irq_soft_i,            // Software generated interrupt request\n    input   logic                                   core_irq_mtimer_i,          // Machine timer interrupt request\n\n    // Memory-mapped external timer\n    input   logic [63:0]                            core_mtimer_val_i,          // Machine timer value\n\n`ifdef SCR1_DBG_EN\n    // Debug Interface\n    input   logic                                   tapc_trst_n,                // Test Reset (TRSTn)\n    input   logic                                   tapc_tck,                   // Test Clock (TCK)\n    input   logic                                   tapc_tms,                   // Test Mode Select (TMS)\n    input   logic                                   tapc_tdi,                   // Test Data Input (TDI)\n    output  logic                                   tapc_tdo,                   // Test Data Output (TDO)\n    output  logic                                   tapc_tdo_en,                // TDO Enable, signal for TDO buffer control\n`endif // SCR1_DBG_EN\n\n    // Instruction Memory Interface\n    input   logic                                   imem2core_req_ack_i,        // IMEM request acknowledge\n    output  logic                                   core2imem_req_o,            // IMEM request\n    output  type_scr1_mem_cmd_e                     core2imem_cmd_o,            // IMEM command\n    output  logic [`SCR1_IMEM_AWIDTH-1:0]           core2imem_addr_o,           // IMEM address\n    input   logic [`SCR1_IMEM_DWIDTH-1:0]           imem2core_rdata_i,          // IMEM read data\n    input   type_scr1_mem_resp_e                    imem2core_resp_i,           // IMEM response\n\n    // Data Memory Interface\n    input   logic                                   dmem2core_req_ack_i,        // DMEM request acknowledge\n    output  logic                                   core2dmem_req_o,            // DMEM request\n    output  type_scr1_mem_cmd_e                     core2dmem_cmd_o,            // DMEM command\n    output  type_scr1_mem_width_e                   core2dmem_width_o,          // DMEM data width\n    output  logic [`SCR1_DMEM_AWIDTH-1:0]           core2dmem_addr_o,           // DMEM address\n    output  logic [`SCR1_DMEM_DWIDTH-1:0]           core2dmem_wdata_o,          // DMEM write data\n    input   logic [`SCR1_DMEM_DWIDTH-1:0]           dmem2core_rdata_i,          // DMEM read data\n    input   type_scr1_mem_resp_e                    dmem2core_resp_i            // DMEM response\n);\n\n//-------------------------------------------------------------------------------\n// Local parameters\n//-------------------------------------------------------------------------------\nlocalparam int unsigned SCR1_CORE_TOP_RST_SYNC_STAGES_NUM               = 2;\n\n//-------------------------------------------------------------------------------\n// Local signals declaration\n//-------------------------------------------------------------------------------\n\n// Reset Logic\n`ifdef SCR1_DBG_EN\n`else // SCR1_DBG_EN\nlogic                                           core_rst_n_in_sync;\nlogic                                           core_rst_n_qlfy;\nlogic                                           core_rst_n_status;\n`endif // SCR1_DBG_EN\nlogic                                           core_rst_n;\nlogic                                           core_rst_n_status_sync;\nlogic                                           core_rst_status;\nlogic                                           core2hdu_rdc_qlfy;\nlogic                                           core2dm_rdc_qlfy;\nlogic                                           pwrup_rst_n_sync;\nlogic                                           rst_n_sync;\nlogic                                           cpu_rst_n_sync;\n\n`ifdef SCR1_DBG_EN\n// TAPC-DM Interface\nlogic                                           tapc_dmi_ch_sel;\nlogic [SCR1_DBG_DMI_CH_ID_WIDTH-1:0]            tapc_dmi_ch_id;\nlogic                                           tapc_dmi_ch_capture;\nlogic                                           tapc_dmi_ch_shift;\nlogic                                           tapc_dmi_ch_update;\nlogic                                           tapc_dmi_ch_tdi;\nlogic                                           tapc_dmi_ch_tdo;\n//\nlogic                                           tapc_dmi_ch_sel_tapout;\nlogic [SCR1_DBG_DMI_CH_ID_WIDTH-1:0]            tapc_dmi_ch_id_tapout;\nlogic                                           tapc_dmi_ch_capture_tapout;\nlogic                                           tapc_dmi_ch_shift_tapout;\nlogic                                           tapc_dmi_ch_update_tapout;\nlogic                                           tapc_dmi_ch_tdi_tapout;\nlogic                                           tapc_dmi_ch_tdo_tapin;\n//\nlogic                                           dmi_req;\nlogic                                           dmi_wr;\nlogic [SCR1_DBG_DMI_ADDR_WIDTH-1:0]             dmi_addr;\nlogic [SCR1_DBG_DMI_DATA_WIDTH-1:0]             dmi_wdata;\nlogic                                           dmi_resp;\nlogic [SCR1_DBG_DMI_DATA_WIDTH-1:0]             dmi_rdata;\n// TAPC-SCU Interface\nlogic                                           tapc_scu_ch_sel;\nlogic                                           tapc_scu_ch_sel_tapout;\nlogic                                           tapc_scu_ch_tdo;\nlogic                                           tapc_ch_tdo;\n// SCU nets\nlogic                                           sys_rst_n;\nlogic                                           sys_rst_status;\nlogic                                           hdu_rst_n;\nlogic                                           hdu2dm_rdc_qlfy;\nlogic                                           ndm_rst_n;\nlogic                                           dm_rst_n;\nlogic                                           hart_rst_n;\n`endif // SCR1_DBG_EN\n\n`ifdef SCR1_DBG_EN\n// DM-Pipeline Interface\n// HART Run Control i/f\nlogic                                           dm_active;\nlogic                                           dm_cmd_req;\ntype_scr1_hdu_dbgstates_e                       dm_cmd;\nlogic                                           dm_cmd_resp;\nlogic                                           dm_cmd_resp_qlfy;\nlogic                                           dm_cmd_rcode;\nlogic                                           dm_hart_event;\nlogic                                           dm_hart_event_qlfy;\ntype_scr1_hdu_hartstatus_s                      dm_hart_status;\ntype_scr1_hdu_hartstatus_s                      dm_hart_status_qlfy;\n\n// Program Buffer - HART instruction execution i/f\nlogic [SCR1_HDU_PBUF_ADDR_WIDTH-1:0]            dm_pbuf_addr;\nlogic [SCR1_HDU_PBUF_ADDR_WIDTH-1:0]            dm_pbuf_addr_qlfy;\nlogic [SCR1_HDU_CORE_INSTR_WIDTH-1:0]           dm_pbuf_instr;\n\n// HART Abstract Data regs i/f\nlogic                                           dm_dreg_req;\nlogic                                           dm_dreg_req_qlfy;\nlogic                                           dm_dreg_wr;\nlogic [SCR1_HDU_DATA_REG_WIDTH-1:0]             dm_dreg_wdata;\nlogic                                           dm_dreg_resp;\nlogic                                           dm_dreg_fail;\nlogic [SCR1_HDU_DATA_REG_WIDTH-1:0]             dm_dreg_rdata;\n\nlogic [`SCR1_XLEN-1 : 0]                        dm_pc_sample;\nlogic [`SCR1_XLEN-1 : 0]                        dm_pc_sample_qlfy;\n`endif // SCR1_DBG_EN\n\n`ifdef SCR1_CLKCTRL_EN\n// Global clock gating logic\nlogic                                           sleep_pipe;\nlogic                                           wake_pipe;\nlogic                                           clk_pipe;\nlogic                                           clk_pipe_en;\nlogic                                           clk_dbgc;\nlogic                                           clk_alw_on;\n`endif // SCR1_CLKCTRL_EN\n\n\n//-------------------------------------------------------------------------------\n// Reset Logic\n//-------------------------------------------------------------------------------\n`ifdef SCR1_DBG_EN\nscr1_scu    i_scu (\n    // Global signals\n    .pwrup_rst_n                (pwrup_rst_n        ),\n    .rst_n                      (rst_n              ),\n    .cpu_rst_n                  (cpu_rst_n          ),\n    .test_mode                  (test_mode          ),\n    .test_rst_n                 (test_rst_n         ),\n    .clk                        (clk                ),\n\n    // TAPC scan-chains\n    .tapcsync2scu_ch_sel_i      (tapc_scu_ch_sel    ),\n    .tapcsync2scu_ch_id_i       ('0                 ),\n    .tapcsync2scu_ch_capture_i  (tapc_dmi_ch_capture),\n    .tapcsync2scu_ch_shift_i    (tapc_dmi_ch_shift  ),\n    .tapcsync2scu_ch_update_i   (tapc_dmi_ch_update ),\n    .tapcsync2scu_ch_tdi_i      (tapc_dmi_ch_tdi    ),\n    .scu2tapcsync_ch_tdo_o      (tapc_scu_ch_tdo    ),\n\n    // Input sync resets:\n    .ndm_rst_n_i                (ndm_rst_n          ),\n    .hart_rst_n_i               (hart_rst_n         ),\n\n    // Generated resets\n    .sys_rst_n_o                (sys_rst_n          ),\n    .core_rst_n_o               (core_rst_n         ),\n    .dm_rst_n_o                 (dm_rst_n           ),\n    .hdu_rst_n_o                (hdu_rst_n          ),\n\n    // Resets statuses\n    .sys_rst_status_o           (sys_rst_status     ),\n    .core_rst_status_o          (core_rst_status    ),\n\n    // Reset Domain Crossing (RDC) qualifiers\n    .sys_rdc_qlfy_o             (sys_rdc_qlfy_o     ),\n    .core_rdc_qlfy_o            (core_rdc_qlfy_o    ),\n    .core2hdu_rdc_qlfy_o        (core2hdu_rdc_qlfy  ),\n    .core2dm_rdc_qlfy_o         (core2dm_rdc_qlfy   ),\n    .hdu2dm_rdc_qlfy_o          (hdu2dm_rdc_qlfy    )\n);\n\nassign sys_rst_n_o      = sys_rst_n;\n\n// Reset inputs are assumed synchronous\nassign pwrup_rst_n_sync = pwrup_rst_n;\n\n`else // SCR1_DBG_EN\n\n// Reset inputs are assumed synchronous\nassign pwrup_rst_n_sync   = pwrup_rst_n;\nassign rst_n_sync         = rst_n;\nassign cpu_rst_n_sync     = cpu_rst_n;\nassign core_rst_n_in_sync = rst_n_sync & cpu_rst_n_sync;\n\n// Core Reset: core_rst_n\nscr1_reset_qlfy_adapter_cell_sync i_core_rstn_qlfy_adapter_cell_sync (\n    .rst_n              (pwrup_rst_n_sync  ),\n    .clk                (clk               ),\n    .test_rst_n         (test_rst_n        ),\n    .test_mode          (test_mode         ),\n    .reset_n_in_sync    (core_rst_n_in_sync),\n    .reset_n_out_qlfy   (core_rst_n_qlfy   ),\n    .reset_n_out        (core_rst_n        ),\n    .reset_n_status     (core_rst_n_status )\n);\n\nscr1_data_sync_cell #(\n    .STAGES_AMOUNT      (SCR1_CORE_TOP_RST_SYNC_STAGES_NUM)\n) i_core_rstn_status_sync (\n    .rst_n               (pwrup_rst_n_sync      ),\n    .clk                 (clk                   ),\n    .data_in             (core_rst_n_status     ),\n    .data_out            (core_rst_n_status_sync)\n);\n\nassign core_rst_status      = ~core_rst_n_status_sync;\nassign core_rdc_qlfy_o      = core_rst_n_qlfy;\n\n`endif // SCR1_DBG_EN\nassign core_rst_n_o         = core_rst_n;\n\n//-------------------------------------------------------------------------------\n// SCR1 pipeline\n//-------------------------------------------------------------------------------\nscr1_pipe_top i_pipe_top (\n    // Control\n    .pipe_rst_n                     (core_rst_n             ),\n`ifdef SCR1_DBG_EN\n    .pipe2hdu_rdc_qlfy_i            (core2hdu_rdc_qlfy      ),\n    .dbg_rst_n                      (hdu_rst_n              ),\n`endif // SCR1_DBG_EN\n`ifndef SCR1_CLKCTRL_EN\n    .clk                            (clk                    ),\n`else // SCR1_CLKCTRL_EN\n    .clk                            (clk_pipe               ),\n    .pipe2clkctl_sleep_req_o        (sleep_pipe             ),\n    .pipe2clkctl_wake_req_o         (wake_pipe              ),\n    .clkctl2pipe_clk_alw_on_i       (clk_alw_on             ),\n    .clkctl2pipe_clk_dbgc_i         (clk_dbgc               ),\n    .clkctl2pipe_clk_en_i           (clk_pipe_en            ),\n`endif // SCR1_CLKCTRL_EN\n\n    // Instruction memory interface\n    .pipe2imem_req_o                (core2imem_req_o        ),\n    .pipe2imem_cmd_o                (core2imem_cmd_o        ),\n    .pipe2imem_addr_o               (core2imem_addr_o       ),\n    .imem2pipe_req_ack_i            (imem2core_req_ack_i    ),\n    .imem2pipe_rdata_i              (imem2core_rdata_i      ),\n    .imem2pipe_resp_i               (imem2core_resp_i       ),\n\n    // Data memory interface\n    .pipe2dmem_req_o                (core2dmem_req_o        ),\n    .pipe2dmem_cmd_o                (core2dmem_cmd_o        ),\n    .pipe2dmem_width_o              (core2dmem_width_o      ),\n    .pipe2dmem_addr_o               (core2dmem_addr_o       ),\n    .pipe2dmem_wdata_o              (core2dmem_wdata_o      ),\n    .dmem2pipe_req_ack_i            (dmem2core_req_ack_i    ),\n    .dmem2pipe_rdata_i              (dmem2core_rdata_i      ),\n    .dmem2pipe_resp_i               (dmem2core_resp_i       ),\n\n`ifdef SCR1_DBG_EN\n    // Debug interface:\n    .dbg_en                         (1'b1                   ),\n    // Debug interface:\n    // DM <-> Pipeline: HART Run Control i/f\n    .dm2pipe_active_i               (dm_active              ),\n    .dm2pipe_cmd_req_i              (dm_cmd_req             ),\n    .dm2pipe_cmd_i                  (dm_cmd                 ),\n    .pipe2dm_cmd_resp_o             (dm_cmd_resp            ),\n    .pipe2dm_cmd_rcode_o            (dm_cmd_rcode           ),\n    .pipe2dm_hart_event_o           (dm_hart_event          ),\n    .pipe2dm_hart_status_o          (dm_hart_status         ),\n\n    // DM <-> Pipeline: Program Buffer - HART instruction execution i/f\n    .pipe2dm_pbuf_addr_o            (dm_pbuf_addr           ),\n    .dm2pipe_pbuf_instr_i           (dm_pbuf_instr          ),\n\n    // DM <-> Pipeline: HART Abstract Data regs i/f\n    .pipe2dm_dreg_req_o             (dm_dreg_req            ),\n    .pipe2dm_dreg_wr_o              (dm_dreg_wr             ),\n    .pipe2dm_dreg_wdata_o           (dm_dreg_wdata          ),\n    .dm2pipe_dreg_resp_i            (dm_dreg_resp           ),\n    .dm2pipe_dreg_fail_i            (dm_dreg_fail           ),\n    .dm2pipe_dreg_rdata_i           (dm_dreg_rdata          ),\n\n    // DM <-> Pipeline: PC i/f\n    .pipe2dm_pc_sample_o            (dm_pc_sample           ),\n`endif // SCR1_DBG_EN\n\n    // IRQ\n`ifdef SCR1_IPIC_EN\n    .soc2pipe_irq_lines_i           (core_irq_lines_i       ),\n`else // SCR1_IPIC_EN\n    .soc2pipe_irq_ext_i             (core_irq_ext_i         ),\n`endif // SCR1_IPIC_EN\n    .soc2pipe_irq_soft_i            (core_irq_soft_i        ),\n    .soc2pipe_irq_mtimer_i          (core_irq_mtimer_i      ),\n\n    // Memory-mapped external timer\n    .soc2pipe_mtimer_val_i          (core_mtimer_val_i      ),\n\n    // Fuse\n    .soc2pipe_fuse_mhartid_i        (core_fuse_mhartid_i    )\n);\n\n\n`ifdef SCR1_DBG_EN\n//-------------------------------------------------------------------------------\n// TAP Controller (TAPC)\n//-------------------------------------------------------------------------------\nscr1_tapc i_tapc (\n    // JTAG signals\n    .tapc_trst_n                    (tapc_trst_n               ),\n    .tapc_tck                       (tapc_tck                  ),\n    .tapc_tms                       (tapc_tms                  ),\n    .tapc_tdi                       (tapc_tdi                  ),\n    .tapc_tdo                       (tapc_tdo                  ),\n    .tapc_tdo_en                    (tapc_tdo_en               ),\n\n    // Fuses\n    .soc2tapc_fuse_idcode_i         (tapc_fuse_idcode_i        ),\n\n    // DMI/SCU scan-chains\n    .tapc2tapcsync_scu_ch_sel_o     (tapc_scu_ch_sel_tapout    ),\n    .tapc2tapcsync_dmi_ch_sel_o     (tapc_dmi_ch_sel_tapout    ),\n    .tapc2tapcsync_ch_id_o          (tapc_dmi_ch_id_tapout     ),\n    .tapc2tapcsync_ch_capture_o     (tapc_dmi_ch_capture_tapout),\n    .tapc2tapcsync_ch_shift_o       (tapc_dmi_ch_shift_tapout  ),\n    .tapc2tapcsync_ch_update_o      (tapc_dmi_ch_update_tapout ),\n    .tapc2tapcsync_ch_tdi_o         (tapc_dmi_ch_tdi_tapout    ),\n    .tapcsync2tapc_ch_tdo_i         (tapc_dmi_ch_tdo_tapin     )\n);\n\nscr1_tapc_synchronizer i_tapc_synchronizer (\n    // System common signals\n    .pwrup_rst_n                    (pwrup_rst_n_sync          ),\n    .dm_rst_n                       (dm_rst_n                  ),\n    .clk                            (clk                       ),\n\n    // JTAG common signals\n    .tapc_trst_n                    (tapc_trst_n               ),\n    .tapc_tck                       (tapc_tck                  ),\n\n    // DMI/SCU scan-chains\n    .tapc2tapcsync_scu_ch_sel_i     (tapc_scu_ch_sel_tapout    ),\n    .tapcsync2scu_ch_sel_o          (tapc_scu_ch_sel           ),\n    .tapc2tapcsync_dmi_ch_sel_i     (tapc_dmi_ch_sel_tapout    ),\n    .tapcsync2dmi_ch_sel_o          (tapc_dmi_ch_sel           ),\n\n    .tapc2tapcsync_ch_id_i          (tapc_dmi_ch_id_tapout     ),\n    .tapcsync2core_ch_id_o          (tapc_dmi_ch_id            ),\n    .tapc2tapcsync_ch_capture_i     (tapc_dmi_ch_capture_tapout),\n    .tapcsync2core_ch_capture_o     (tapc_dmi_ch_capture       ),\n    .tapc2tapcsync_ch_shift_i       (tapc_dmi_ch_shift_tapout  ),\n    .tapcsync2core_ch_shift_o       (tapc_dmi_ch_shift         ),\n    .tapc2tapcsync_ch_update_i      (tapc_dmi_ch_update_tapout ),\n    .tapcsync2core_ch_update_o      (tapc_dmi_ch_update        ),\n    .tapc2tapcsync_ch_tdi_i         (tapc_dmi_ch_tdi_tapout    ),\n    .tapcsync2core_ch_tdi_o         (tapc_dmi_ch_tdi           ),\n    .tapc2tapcsync_ch_tdo_i         (tapc_dmi_ch_tdo_tapin     ),\n    .tapcsync2core_ch_tdo_o         (tapc_ch_tdo               )\n);\nassign tapc_ch_tdo = (tapc_scu_ch_tdo & tapc_scu_ch_sel)\n                   | (tapc_dmi_ch_tdo & tapc_dmi_ch_sel);\n\nscr1_dmi i_dmi (\n    .rst_n                      (dm_rst_n           ),\n    .clk                        (clk                ),\n\n    // TAP scan-chains\n    .tapcsync2dmi_ch_sel_i      (tapc_dmi_ch_sel    ),\n    .tapcsync2dmi_ch_id_i       (tapc_dmi_ch_id "}
{"text": "    ),\n    .tapcsync2dmi_ch_capture_i  (tapc_dmi_ch_capture),\n    .tapcsync2dmi_ch_shift_i    (tapc_dmi_ch_shift  ),\n    .tapcsync2dmi_ch_update_i   (tapc_dmi_ch_update ),\n    .tapcsync2dmi_ch_tdi_i      (tapc_dmi_ch_tdi    ),\n    .dmi2tapcsync_ch_tdo_o      (tapc_dmi_ch_tdo    ),\n\n    // DMI\n    .dm2dmi_resp_i              (dmi_resp           ),\n    .dm2dmi_rdata_i             (dmi_rdata          ),\n    .dmi2dm_req_o               (dmi_req            ),\n    .dmi2dm_wr_o                (dmi_wr             ),\n    .dmi2dm_addr_o              (dmi_addr           ),\n    .dmi2dm_wdata_o             (dmi_wdata          )\n);\n\n`endif // SCR1_DBG_EN\n\n\n`ifdef SCR1_DBG_EN\n\n//-------------------------------------------------------------------------------\n// Debug Module (DM)\n//-------------------------------------------------------------------------------\nassign dm_cmd_resp_qlfy    = dm_cmd_resp   & {$bits(dm_cmd_resp){hdu2dm_rdc_qlfy}};\nassign dm_hart_event_qlfy  = dm_hart_event & {$bits(dm_hart_event){hdu2dm_rdc_qlfy}};\nassign dm_hart_status_qlfy.dbg_state = hdu2dm_rdc_qlfy ? dm_hart_status.dbg_state\n                                                       : SCR1_HDU_DBGSTATE_RESET;\nassign dm_hart_status_qlfy.except    = dm_hart_status.except;\nassign dm_hart_status_qlfy.ebreak    = dm_hart_status.ebreak;\nassign dm_pbuf_addr_qlfy   = dm_pbuf_addr  & {$bits(dm_pbuf_addr){hdu2dm_rdc_qlfy}};\nassign dm_dreg_req_qlfy    = dm_dreg_req   & {$bits(dm_dreg_req){hdu2dm_rdc_qlfy}};\nassign dm_pc_sample_qlfy   = dm_pc_sample  & {$bits(dm_pc_sample){core2dm_rdc_qlfy}};\n\nscr1_dm i_dm (\n    // Common signals\n    .rst_n                      (dm_rst_n               ),\n    .clk                        (clk                    ),\n\n    // DM internal interface\n    .dmi2dm_req_i               (dmi_req                ),\n    .dmi2dm_wr_i                (dmi_wr                 ),\n    .dmi2dm_addr_i              (dmi_addr               ),\n    .dmi2dm_wdata_i             (dmi_wdata              ),\n    .dm2dmi_resp_o              (dmi_resp               ),\n    .dm2dmi_rdata_o             (dmi_rdata              ),\n\n    // DM <-> Pipeline: HART Run Control i/f\n    .ndm_rst_n_o                (ndm_rst_n              ),\n    .hart_rst_n_o               (hart_rst_n             ),\n    .dm2pipe_active_o           (dm_active              ),\n    .dm2pipe_cmd_req_o          (dm_cmd_req             ),\n    .dm2pipe_cmd_o              (dm_cmd                 ),\n    .pipe2dm_cmd_resp_i         (dm_cmd_resp_qlfy       ),\n    .pipe2dm_cmd_rcode_i        (dm_cmd_rcode           ),\n    .pipe2dm_hart_event_i       (dm_hart_event_qlfy     ),\n    .pipe2dm_hart_status_i      (dm_hart_status_qlfy    ),\n\n    .soc2dm_fuse_mhartid_i      (core_fuse_mhartid_i    ),\n    .pipe2dm_pc_sample_i        (dm_pc_sample_qlfy      ),\n\n    // DM <-> Pipeline: HART Abstract Command / Program Buffer i/f\n    .pipe2dm_pbuf_addr_i        (dm_pbuf_addr_qlfy      ),\n    .dm2pipe_pbuf_instr_o       (dm_pbuf_instr          ),\n\n    // DM <-> Pipeline: HART Abstract Data regs i/f\n    .pipe2dm_dreg_req_i         (dm_dreg_req_qlfy       ),\n    .pipe2dm_dreg_wr_i          (dm_dreg_wr             ),\n    .pipe2dm_dreg_wdata_i       (dm_dreg_wdata          ),\n    .dm2pipe_dreg_resp_o        (dm_dreg_resp           ),\n    .dm2pipe_dreg_fail_o        (dm_dreg_fail           ),\n    .dm2pipe_dreg_rdata_o       (dm_dreg_rdata          )\n);\n`endif // SCR1_DBG_EN\n\n\n`ifdef SCR1_CLKCTRL_EN\n//-------------------------------------------------------------------------------\n// Global clock gating logic\n//-------------------------------------------------------------------------------\nscr1_clk_ctrl i_clk_ctrl (\n    .clk                            (clk        ),\n    .rst_n                          (core_rst_n ),\n    .test_mode                      (test_mode  ),\n    .test_rst_n                     (test_rst_n ),\n\n    // Sleep/wake interface\n    .pipe2clkctl_sleep_req_i        (sleep_pipe ),\n    .pipe2clkctl_wake_req_i         (wake_pipe  ),\n\n    // Clocks\n    .clkctl2pipe_clk_alw_on_o       (clk_alw_on ),\n    .clkctl2pipe_clk_o              (clk_pipe   ),\n    .clkctl2pipe_clk_en_o           (clk_pipe_en),\n    .clkctl2pipe_clk_dbgc_o         (clk_dbgc   )\n);\n`endif // SCR1_CLKCTRL_EN\n\nendmodule : scr1_core_top\n"}
{"text": "/// Copyright by Syntacore LLC \u00a9 2016-2021. See LICENSE for details\n/// @file       <scr1_dm.sv>\n/// @brief      Debug Module (DM)\n///\n\n//------------------------------------------------------------------------------\n //\n // Functionality:\n // - Allows debugger to perform a system reset (ndm_rst)\n // - Allows debugger to control the HART's state\n // - Provides debugger with information about the current HART's state\n // - Provides debugger with Abstract Command interface that allows to:\n //   - Access MPRF registers\n //   - Access CSR registers\n //   - Access memory with the same view and permission as the hart has\n // - Provides debugger with Abstract Command status information (busy flag and error code)\n // - Provides debugger with Program Buffer functionality that allows to execute\n //   small programs on a halted HART\n //\n // Structure:\n // - DM <-> DMI interface\n // - DM registers:\n //   - DMCONTROL\n //   - DMSTATUS\n // - Abstract Command Control logic\n // - Abstract Command FSM\n // - Abstract Command Status logic\n // - Abstract Instruction logic\n // - Abstract registers:\n //   - COMMAND\n //   - ABSTRACTAUTO\n //   - PROGBUF0..5\n //   - DATA0..1\n // - DHI FSM\n // - HART command registers\n // - DHI interface\n //\n//\n\n`include \"scr1_arch_description.svh\"\n\n`ifdef SCR1_DBG_EN\n`include \"scr1_csr.svh\"\n`include \"scr1_dm.svh\"\n\nmodule scr1_dm (\n    // System\n    input  logic                                    rst_n,                      // DM reset\n    input  logic                                    clk,                        // DM clock\n\n    // DM internal interface\n    input  logic                                    dmi2dm_req_i,               // DMI request\n    input  logic                                    dmi2dm_wr_i,                // DMI write\n    input  logic [SCR1_DBG_DMI_ADDR_WIDTH-1:0]      dmi2dm_addr_i,              // DMI address\n    input  logic [SCR1_DBG_DMI_DATA_WIDTH-1:0]      dmi2dm_wdata_i,             // DMI write data\n    output logic                                    dm2dmi_resp_o,              // DMI response\n    output logic [SCR1_DBG_DMI_DATA_WIDTH-1:0]      dm2dmi_rdata_o,             // DMI read data\n\n    // DM <-> Pipeline: HART Run Control i/f\n    output logic                                    ndm_rst_n_o,                // Non-DM Reset output\n    output logic                                    hart_rst_n_o,               // HART reset output\n    output logic                                    dm2pipe_active_o,           // Debug Module active flag\n    output logic                                    dm2pipe_cmd_req_o,          // Request to pipe\n    output type_scr1_hdu_dbgstates_e                dm2pipe_cmd_o,              // Command to pipe\n    input  logic                                    pipe2dm_cmd_resp_i,         // Response to Debug Module\n    input  logic                                    pipe2dm_cmd_rcode_i,        // HART Command return code: 0 - Ok; 1 - Error\n    input  logic                                    pipe2dm_hart_event_i,       // HART event flag\n    input  type_scr1_hdu_hartstatus_s               pipe2dm_hart_status_i,      // HART Status\n\n    input  logic [`SCR1_XLEN-1:0]                   soc2dm_fuse_mhartid_i,      // RO MHARTID value\n    input  logic [`SCR1_XLEN-1:0]                   pipe2dm_pc_sample_i,        // RO PC value for sampling\n\n    // HART Abstract Command / Program Buffer i/f\n    input  logic [SCR1_HDU_PBUF_ADDR_WIDTH-1:0]     pipe2dm_pbuf_addr_i,        // Program Buffer address\n    output logic [SCR1_HDU_CORE_INSTR_WIDTH-1:0]    dm2pipe_pbuf_instr_o,       // Program Buffer instruction\n\n    // HART Abstract Data regs i/f\n    input  logic                                    pipe2dm_dreg_req_i,         // Abstract Data Register request\n    input  logic                                    pipe2dm_dreg_wr_i,          // Abstract Data Register write\n    input  logic [`SCR1_XLEN-1:0]                   pipe2dm_dreg_wdata_i,       // Abstract Data Register write data\n    output logic                                    dm2pipe_dreg_resp_o,        // Abstract Data Register response\n    output logic                                    dm2pipe_dreg_fail_o,        // Abstract Data Register fail - possibly not needed ?\n    output logic [`SCR1_XLEN-1:0]                   dm2pipe_dreg_rdata_o        // Abstract Data Register read data\n);\n\n//------------------------------------------------------------------------------\n// Local types declaration\n//------------------------------------------------------------------------------\n\ntypedef enum logic [3:0] {\n    ABS_STATE_IDLE,\n    ABS_STATE_ERR,\n    ABS_STATE_EXEC,\n    ABS_STATE_XREG_RW,\n    ABS_STATE_MEM_SAVE_XREG,\n    ABS_STATE_MEM_SAVE_XREG_FORADDR,\n    ABS_STATE_MEM_RW,\n    ABS_STATE_MEM_RETURN_XREG,\n    ABS_STATE_MEM_RETURN_XREG_FORADDR,\n    ABS_STATE_CSR_RO,\n    ABS_STATE_CSR_SAVE_XREG,\n    ABS_STATE_CSR_RW,\n    ABS_STATE_CSR_RETURN_XREG\n} type_scr1_abs_fsm_e;\n\ntypedef enum logic [2:0] {\n    DHI_STATE_IDLE,\n    DHI_STATE_EXEC,\n    DHI_STATE_EXEC_RUN,\n    DHI_STATE_EXEC_HALT,\n    DHI_STATE_HALT_REQ,\n    DHI_STATE_RESUME_REQ,\n    DHI_STATE_RESUME_RUN\n} type_scr1_dhi_fsm_e;\n\ntypedef enum logic [SCR1_DBG_ABSTRACTCS_CMDERR_WDTH:0] {\n    ABS_ERR_NONE      = (SCR1_DBG_ABSTRACTCS_CMDERR_WDTH+1)'('d0),\n    ABS_ERR_BUSY      = (SCR1_DBG_ABSTRACTCS_CMDERR_WDTH+1)'('d1),\n    ABS_ERR_CMD       = (SCR1_DBG_ABSTRACTCS_CMDERR_WDTH+1)'('d2),\n    ABS_ERR_EXCEPTION = (SCR1_DBG_ABSTRACTCS_CMDERR_WDTH+1)'('d3),\n    ABS_ERR_NOHALT    = (SCR1_DBG_ABSTRACTCS_CMDERR_WDTH+1)'('d4)\n} type_scr1_abs_err_e;\n\n\n//------------------------------------------------------------------------------\n// Local parameters declaration\n//------------------------------------------------------------------------------\n\n// Abstract instruction opcode parameters\nlocalparam      SCR1_OP_SYSTEM      = 7'b111_0011;\nlocalparam      SCR1_OP_LOAD        = 7'b000_0011;\nlocalparam      SCR1_OP_STORE       = 7'b010_0011;\n\n// Abstract instruction funct3 parameters\nlocalparam      SCR1_FUNCT3_CSRRW       = 3'b001;\nlocalparam      SCR1_FUNCT3_CSRRS       = 3'b010;\nlocalparam      SCR1_FUNCT3_SB          = 3'b000;\nlocalparam      SCR1_FUNCT3_SH          = 3'b001;\nlocalparam      SCR1_FUNCT3_SW          = 3'b010;\nlocalparam      SCR1_FUNCT3_LW          = 3'b010;\nlocalparam      SCR1_FUNCT3_LBU         = 3'b100;\nlocalparam      SCR1_FUNCT3_LHU         = 3'b101;\n\n// DMCONTROL parameters\n//------------------------------------------------------------------------------\nlocalparam      DMCONTROL_HARTRESET     = 1'd0;\nlocalparam      DMCONTROL_RESERVEDB     = 1'd0;\nlocalparam      DMCONTROL_HASEL         = 1'd0;\nlocalparam      DMCONTROL_HARTSELLO     = 1'd0;\nlocalparam      DMCONTROL_HARTSELHI     = 1'd0;\nlocalparam      DMCONTROL_RESERVEDA     = 1'd0;\n\n// DMSTATUS parameters\n//------------------------------------------------------------------------------\nlocalparam      DMSTATUS_RESERVEDC      = 1'd0;\nlocalparam      DMSTATUS_IMPEBREAK      = 1'd1;\nlocalparam      DMSTATUS_RESERVEDB      = 1'd0;\nlocalparam      DMSTATUS_ALLUNAVAIL     = 1'd0;\nlocalparam      DMSTATUS_ANYUNAVAIL     = 1'd0;\nlocalparam      DMSTATUS_ALLANYUNAVAIL  = 1'd0;\nlocalparam      DMSTATUS_ALLANYNONEXIST = 1'b0;\nlocalparam      DMSTATUS_AUTHENTICATED  = 1'd1;\nlocalparam      DMSTATUS_AUTHBUSY       = 1'd0;\nlocalparam      DMSTATUS_RESERVEDA      = 1'd0;\nlocalparam      DMSTATUS_DEVTREEVALID   = 1'd0;\nlocalparam      DMSTATUS_VERSION        = 2'd2;\n\n// HARTINFO parameters\n//------------------------------------------------------------------------------\nlocalparam      HARTINFO_RESERVEDB      = 1'd0;\nlocalparam      HARTINFO_NSCRATCH       = 4'd1;\nlocalparam      HARTINFO_RESERVEDA      = 1'd0;\nlocalparam      HARTINFO_DATAACCESS     = 1'd0;\nlocalparam      HARTINFO_DATASIZE       = 4'd1;\nlocalparam      HARTINFO_DATAADDR       = 12'h7b2;\n\n// ABSTRACTCS parameters\n//------------------------------------------------------------------------------\nlocalparam      ABSTRACTCS_RESERVEDD    = 1'd0;\nlocalparam      ABSTRACTCS_PROGBUFSIZE  = 5'd6;\nlocalparam      ABSTRACTCS_RESERVEDC    = 1'd0;\nlocalparam      ABSTRACTCS_RESERVEDB    = 1'd0;\nlocalparam      ABSTRACTCS_RESERVEDA    = 1'd0;\nlocalparam      ABSTRACTCS_DATACOUNT    = 4'd2;\n\nlocalparam      ABS_CMD_HARTREG         = 1'd0;\nlocalparam      ABS_CMD_HARTMEM         = 2'd2;\nlocalparam      ABS_CMD_HARTREG_CSR     = 4'b0000;\nlocalparam      ABS_CMD_HARTREG_INTFPU  = 4'b0001;\nlocalparam      ABS_CMD_HARTREG_INT     = 7'b000_0000;\nlocalparam      ABS_CMD_HARTREG_FPU     = 7'b000_0001;\nlocalparam      ABS_EXEC_EBREAK         = 32'b000000000001_00000_000_00000_1110011;\n\n//------------------------------------------------------------------------------\n// Local signals declaration\n//------------------------------------------------------------------------------\n\n// DM <-> DMI interface internal signals\n//------------------------------------------------------------------------------\n\n// Register selection signals\nlogic                                             dmi_req_dmcontrol;\nlogic                                             dmi_req_abstractcs;\nlogic                                             dmi_req_abstractauto;\nlogic                                             dmi_req_command;\nlogic                                             dmi_rpt_command;\nlogic                                             dmi_req_data0;\nlogic                                             dmi_req_data1;\nlogic                                             dmi_req_progbuf0;\nlogic                                             dmi_req_progbuf1;\nlogic                                             dmi_req_progbuf2;\nlogic                                             dmi_req_progbuf3;\nlogic                                             dmi_req_progbuf4;\nlogic                                             dmi_req_progbuf5;\n\nlogic                                             dmi_req_any;\n\n// Registers write request signals\nlogic                                             dmcontrol_wr_req;\nlogic                                             abstractcs_wr_req;\nlogic                                             data0_wr_req;\nlogic                                             data1_wr_req;\nlogic                                             dreg_wr_req;\nlogic                                             command_wr_req;\nlogic                                             autoexec_wr_req;\nlogic                                             progbuf0_wr_req;\nlogic                                             progbuf1_wr_req;\nlogic                                             progbuf2_wr_req;\nlogic                                             progbuf3_wr_req;\nlogic                                             progbuf4_wr_req;\nlogic                                             progbuf5_wr_req;\n\n// DM registers\n//------------------------------------------------------------------------------\n\n// DM clock enable signals\nlogic                                             clk_en_dm;\nlogic                                             clk_en_dm_ff;\n\n// DMCONTROL register signals\nlogic                                             dmcontrol_haltreq_ff;\nlogic                                             dmcontrol_haltreq_next;\nlogic                                             dmcontrol_resumereq_ff;\nlogic                                             dmcontrol_resumereq_next;\nlogic                                             dmcontrol_ackhavereset_ff;\nlogic                                             dmcontrol_ackhavereset_next;\nlogic                                             dmcontrol_ndmreset_ff;\nlogic                                             dmcontrol_ndmreset_next;\nlogic                                             dmcontrol_dmactive_ff;\nlogic                                             dmcontrol_dmactive_next;\n\n// Auxilary Skip Reset On Powerup register\nlogic                                             havereset_skip_pwrup_ff;\nlogic                                             havereset_skip_pwrup_next;\n\n// DMSTATUS register signals\nlogic                                             dmstatus_allany_havereset_ff;\nlogic                                             dmstatus_allany_havereset_next;\nlogic                                             dmstatus_allany_resumeack_ff;\nlogic                                             dmstatus_allany_resumeack_next;\nlogic                                             dmstatus_allany_halted_ff;\nlogic                                             dmstatus_allany_halted_next;\n\n// Abstract command control logic signals\n//------------------------------------------------------------------------------\n\nlogic [SCR1_DBG_DMI_DATA_WIDTH-1:0]               abs_cmd;\n\nlogic                                             abs_cmd_csr_ro;\nlogic [SCR1_DBG_COMMAND_TYPE_WDTH:0]              abs_cmd_type;\nlogic                                             abs_cmd_regacs;\nlogic [SCR1_DBG_COMMAND_ACCESSREG_REGNO_HI-12:0]  abs_cmd_regtype;\nlogic [6:0]                                       abs_cmd_regfile;\nlogic                                             abs_cmd_regwr;\nlogic [SCR1_DBG_COMMAND_ACCESSREG_SIZE_WDTH:0]    abs_cmd_regsize;\nlogic                                             abs_cmd_execprogbuf;\nlogic                                             abs_cmd_regvalid;\nlogic [2:0]                                       abs_cmd_memsize;\nlogic                                             abs_cmd_memwr;\nlogic                                             abs_cmd_memvalid;\n\nlogic                                             abs_cmd_regsize_vd;\nlogic                                             abs_cmd_memsize_vd;\n\nlogic                                             abs_cmd_wr_ff;\nlogic                                             abs_cmd_wr_next;\nlogic                                             abs_cmd_postexec_ff;\nlogic                                             abs_cmd_postexec_next;\nlogic [11:0]                                      abs_cmd_regno;\nlogic [11:0]                                      abs_cmd_regno_ff;\nlogic [1:0]                                       abs_cmd_size_ff;\nlogic [1:0]                                       abs_cmd_size_next;\n\nlogic                                             abs_reg_access_csr;\nlogic                                             abs_reg_access_mprf;\n\nlogic                                             abs_cmd_hartreg_vd;\nlogic                                             abs_cmd_hartmem_vd;\n\nlogic                                             abs_cmd_reg_access_req;\nlogic                                             abs_cmd_csr_access_req;\nlogic                                             abs_cmd_mprf_access_req;\nlogic                                             abs_cmd_execprogbuf_req;\n\nlogic                                             abs_cmd_csr_ro_access_vd;\nlogic                                             abs_cmd_csr_rw_access_vd;\nlogic                                             abs_cmd_mprf_access_vd;\nlogic                                             abs_cmd_mem_access_vd;\n\n// Abstract FSM signals\n//------------------------------------------------------------------------------\n\ntype_scr1_abs_fsm_e                               abs_fsm_ff;\ntype_scr1_abs_fsm_e                               abs_fsm_next;\nlogic                                             abs_fsm_idle;\nlogic                                             abs_fsm_exec;\nlogic                                             abs_fsm_csr_ro;\nlogic                                             abs_fsm_err;\nlogic                                             abs_fsm_use_addr;\n\n// Abstract registers\n//------------------------------------------------------------------------------\n\nlogic                                             clk_en_abs;\n\n// ABSTRACTCS register signals\nlogic                                             abstractcs_busy;\nlogic                                             abstractcs_ro_en;\n\n// COMMAND register signals\nlogic [`SCR1_XLEN-1:0]                            abs_command_ff;\nlogic [`SCR1_XLEN-1:0]                            abs_command_next;\n\n// ABSTRACTAUTO register signals\nlogic                                             abs_autoexec_ff;\nlogic                                             abs_autoexec_next;\n\n// Program buffer registers\nlogic [`SCR1_XLEN-1:0]                            abs_progbuf0_ff;\nlogic [`SCR1_XLEN-1:0]                            abs_progbuf1_ff;\nlogic [`SCR1_XLEN-1:0]                            abs_progbuf2_ff;\nlogic [`SCR1_XLEN-1:0]                            abs_progbuf3_ff;\nlogic [`SCR1_XLEN-1:0]                            abs_progbuf4_ff;\nlogic [`SCR1_XLEN-1:0]                            abs_progbuf5_ff;\n\n// Data 0/1 registers\nlogic                                             data0_xreg_save;\nlogic [`SCR1_XLEN-1:0]                            abs_data0_ff;\nlogic [`SCR1_XLEN-1:0]                            abs_data0_next;\nlogic [`SCR1_XLEN-1:0]                            abs_data1_ff;\nlogic [`SCR1_XLEN-1:0]                            abs_data1_next;\n\n// Abstract command status logic signals\n//------------------------------------------------------------------------------\n\n// Abstract error exception flag register\nlogic                                             abs_err_exc_upd;\nlogic                                             abs_err_exc_ff;\nlogic                                             abs_err_exc_next;\n\nlogic                                             abs_err_acc_busy_upd;\nlogic                                             abs_err_acc_busy_ff;\nlogic                                             abs_err_acc_busy_next;\n\ntype_scr1_abs_err_e                               abstractcs_cmderr_ff;\ntype_scr1_abs_err_e                               abstractcs_cmderr_next;\n\n// Abstract instruction signals\n//------------------------------------------------------------------------------\n\n// Abstract instruction execution request register\nlogic                                             abs_exec_req_next;\nlogic                                             abs_exec_req_ff;\n\n// Abstract instruction register\nlogic [4:0]                                       abs_instr_rd;\nlogic [4:0]                                       abs_instr_rs1;\nlogic [4:0]                                       abs_instr_rs2;\nlogic [2:0]                                       abs_instr_mem_funct3;\nlogic [`SCR1_XLEN-1:0]                            abs_exec_instr_next;\nlogic [`SCR1_XLEN-1:0]                            abs_exec_instr_ff;\n\n// DHI FSM signals\n//------------------------------------------------------------------------------\n\ntype_scr1_dhi_fsm_e                               dhi_fsm_next;\ntype_scr1_dhi_fsm_e                               dhi_fsm_ff;\ntype_scr1_dhi_fsm_e                               dhi_req;\n\nlogic                                             dhi_fsm_idle;\nlogic                                             dhi_fsm_exec;\nlogic                                             dhi_fsm_exec_halt;\nlogic                                             dhi_fsm_halt_req;\nlogic                                             dhi_fsm_resume_req;\n\n// DHI interface signals\n//------------------------------------------------------------------------------\n\nlogic                                             cmd_resp_ok;\nlogic                                             hart_rst_unexp;\nlogic                                             halt_req_vd;\nlogic                                             resume_req_vd;\n\nlogic                                             dhi_resp;\nlogic                                             dhi_resp_exc;\n\nlogic                                             hart_pbuf_ebreak_ff;\nlogic                                             hart_pbuf_ebreak_next;\n\n// HART command registers\n//-----------------------------------------------------------------------"}
{"text": "-------\n\nlogic                                             hart_cmd_req_ff;\nlogic                                             hart_cmd_req_next;\n\ntype_scr1_hdu_dbgstates_e                         hart_cmd_ff;\ntype_scr1_hdu_dbgstates_e                         hart_cmd_next;\n\n// HART state signals\n//------------------------------------------------------------------------------\n\nlogic                                             hart_state_reset;\nlogic                                             hart_state_run;\nlogic                                             hart_state_drun;\nlogic                                             hart_state_dhalt;\n\n//------------------------------------------------------------------------------\n// DM <-> DMI interface\n//------------------------------------------------------------------------------\n\n// Register selection logic\n//------------------------------------------------------------------------------\n\nalways_comb begin\n    dmi_req_dmcontrol    = dmi2dm_req_i & (dmi2dm_addr_i == SCR1_DBG_DMCONTROL);\n    dmi_req_abstractcs   = dmi2dm_req_i & (dmi2dm_addr_i == SCR1_DBG_ABSTRACTCS);\n    dmi_req_abstractauto = dmi2dm_req_i & (dmi2dm_addr_i == SCR1_DBG_ABSTRACTAUTO);\n    dmi_req_data0        = dmi2dm_req_i & (dmi2dm_addr_i == SCR1_DBG_DATA0);\n    dmi_req_data1        = dmi2dm_req_i & (dmi2dm_addr_i == SCR1_DBG_DATA1);\n    dmi_req_command      = dmi2dm_req_i & (dmi2dm_addr_i == SCR1_DBG_COMMAND);\n    dmi_rpt_command      = (abs_autoexec_ff & dmi_req_data0);\n    dmi_req_progbuf0     = dmi2dm_req_i & (dmi2dm_addr_i == SCR1_DBG_PROGBUF0);\n    dmi_req_progbuf1     = dmi2dm_req_i & (dmi2dm_addr_i == SCR1_DBG_PROGBUF1);\n    dmi_req_progbuf2     = dmi2dm_req_i & (dmi2dm_addr_i == SCR1_DBG_PROGBUF2);\n    dmi_req_progbuf3     = dmi2dm_req_i & (dmi2dm_addr_i == SCR1_DBG_PROGBUF3);\n    dmi_req_progbuf4     = dmi2dm_req_i & (dmi2dm_addr_i == SCR1_DBG_PROGBUF4);\n    dmi_req_progbuf5     = dmi2dm_req_i & (dmi2dm_addr_i == SCR1_DBG_PROGBUF5);\nend\n\nassign dmi_req_any = dmi_req_command  | dmi_rpt_command  | dmi_req_abstractauto\n                   | dmi_req_data0    | dmi_req_data1    | dmi_req_progbuf0\n                   | dmi_req_progbuf1 | dmi_req_progbuf2 | dmi_req_progbuf3\n                   | dmi_req_progbuf4 | dmi_req_progbuf5;\n\n\n// Read data multiplexer\n//------------------------------------------------------------------------------\n\nalways_comb begin\n    dm2dmi_rdata_o = '0;\n\n    case (dmi2dm_addr_i)\n        SCR1_DBG_DMSTATUS: begin\n            dm2dmi_rdata_o[SCR1_DBG_DMSTATUS_RESERVEDC_HI:\n                           SCR1_DBG_DMSTATUS_RESERVEDC_LO]     = DMSTATUS_RESERVEDC;\n            dm2dmi_rdata_o[SCR1_DBG_DMSTATUS_IMPEBREAK]        = DMSTATUS_IMPEBREAK;\n            dm2dmi_rdata_o[SCR1_DBG_DMSTATUS_RESERVEDB_HI:\n                           SCR1_DBG_DMSTATUS_RESERVEDB_LO]     = DMSTATUS_RESERVEDB;\n            dm2dmi_rdata_o[SCR1_DBG_DMSTATUS_ALLHAVERESET]     = dmstatus_allany_havereset_ff;\n            dm2dmi_rdata_o[SCR1_DBG_DMSTATUS_ANYHAVERESET]     = dmstatus_allany_havereset_ff;\n            dm2dmi_rdata_o[SCR1_DBG_DMSTATUS_ALLRESUMEACK]     = dmstatus_allany_resumeack_ff;\n            dm2dmi_rdata_o[SCR1_DBG_DMSTATUS_ANYRESUMEACK]     = dmstatus_allany_resumeack_ff;\n            dm2dmi_rdata_o[SCR1_DBG_DMSTATUS_ALLNONEXISTENT]   = DMSTATUS_ALLANYNONEXIST;\n            dm2dmi_rdata_o[SCR1_DBG_DMSTATUS_ANYNONEXISTENT]   = DMSTATUS_ALLANYNONEXIST;\n            dm2dmi_rdata_o[SCR1_DBG_DMSTATUS_ALLUNAVAIL]       = DMSTATUS_ALLANYUNAVAIL;\n            dm2dmi_rdata_o[SCR1_DBG_DMSTATUS_ANYUNAVAIL]       = DMSTATUS_ALLANYUNAVAIL;\n            dm2dmi_rdata_o[SCR1_DBG_DMSTATUS_ALLRUNNING]       = ~dmstatus_allany_halted_ff;\n            dm2dmi_rdata_o[SCR1_DBG_DMSTATUS_ANYRUNNING]       = ~dmstatus_allany_halted_ff;\n            dm2dmi_rdata_o[SCR1_DBG_DMSTATUS_ALLHALTED]        = dmstatus_allany_halted_ff;\n            dm2dmi_rdata_o[SCR1_DBG_DMSTATUS_ANYHALTED]        = dmstatus_allany_halted_ff;\n            dm2dmi_rdata_o[SCR1_DBG_DMSTATUS_AUTHENTICATED]    = DMSTATUS_AUTHENTICATED;\n            dm2dmi_rdata_o[SCR1_DBG_DMSTATUS_AUTHBUSY]         = DMSTATUS_AUTHBUSY;\n            dm2dmi_rdata_o[SCR1_DBG_DMSTATUS_RESERVEDA]        = DMSTATUS_RESERVEDA;\n            dm2dmi_rdata_o[SCR1_DBG_DMSTATUS_DEVTREEVALID]     = DMSTATUS_DEVTREEVALID;\n            dm2dmi_rdata_o[SCR1_DBG_DMSTATUS_VERSION_HI:\n                           SCR1_DBG_DMSTATUS_VERSION_LO]       = DMSTATUS_VERSION;\n        end\n\n        SCR1_DBG_DMCONTROL: begin\n            dm2dmi_rdata_o[SCR1_DBG_DMCONTROL_HALTREQ]         = dmcontrol_haltreq_ff;\n            dm2dmi_rdata_o[SCR1_DBG_DMCONTROL_RESUMEREQ]       = dmcontrol_resumereq_ff;\n            dm2dmi_rdata_o[SCR1_DBG_DMCONTROL_HARTRESET]       = DMCONTROL_HARTRESET;\n            dm2dmi_rdata_o[SCR1_DBG_DMCONTROL_ACKHAVERESET]    = dmcontrol_ackhavereset_ff;\n            dm2dmi_rdata_o[SCR1_DBG_DMCONTROL_RESERVEDB]       = DMCONTROL_RESERVEDB;\n            dm2dmi_rdata_o[SCR1_DBG_DMCONTROL_HASEL]           = DMCONTROL_HASEL;\n            dm2dmi_rdata_o[SCR1_DBG_DMCONTROL_HARTSELLO_HI:\n                           SCR1_DBG_DMCONTROL_HARTSELLO_LO]    = DMCONTROL_HARTSELLO;\n            dm2dmi_rdata_o[SCR1_DBG_DMCONTROL_HARTSELHI_HI:\n                           SCR1_DBG_DMCONTROL_HARTSELHI_LO]    = DMCONTROL_HARTSELHI;\n            dm2dmi_rdata_o[SCR1_DBG_DMCONTROL_RESERVEDA_HI:\n                           SCR1_DBG_DMCONTROL_RESERVEDA_LO]    = DMCONTROL_RESERVEDA;\n            dm2dmi_rdata_o[SCR1_DBG_DMCONTROL_NDMRESET]        = dmcontrol_ndmreset_ff;\n            dm2dmi_rdata_o[SCR1_DBG_DMCONTROL_DMACTIVE]        = dmcontrol_dmactive_ff;\n        end\n\n        SCR1_DBG_ABSTRACTCS: begin\n            dm2dmi_rdata_o[SCR1_DBG_ABSTRACTCS_RESERVEDD_HI:\n                           SCR1_DBG_ABSTRACTCS_RESERVEDD_LO]   = ABSTRACTCS_RESERVEDD;\n            dm2dmi_rdata_o[SCR1_DBG_ABSTRACTCS_PROGBUFSIZE_HI:\n                           SCR1_DBG_ABSTRACTCS_PROGBUFSIZE_LO] = ABSTRACTCS_PROGBUFSIZE;\n            dm2dmi_rdata_o[SCR1_DBG_ABSTRACTCS_RESERVEDC_HI:\n                           SCR1_DBG_ABSTRACTCS_RESERVEDC_LO]   = ABSTRACTCS_RESERVEDC;\n            dm2dmi_rdata_o[SCR1_DBG_ABSTRACTCS_BUSY]           = abstractcs_busy;\n            dm2dmi_rdata_o[SCR1_DBG_ABSTRACTCS_RESERVEDB]      = ABSTRACTCS_RESERVEDB;\n            dm2dmi_rdata_o[SCR1_DBG_ABSTRACTCS_CMDERR_HI:\n                           SCR1_DBG_ABSTRACTCS_CMDERR_LO]      = abstractcs_cmderr_ff;\n            dm2dmi_rdata_o[SCR1_DBG_ABSTRACTCS_RESERVEDA_HI:\n                           SCR1_DBG_ABSTRACTCS_RESERVEDA_LO]   = ABSTRACTCS_RESERVEDA;\n            dm2dmi_rdata_o[SCR1_DBG_ABSTRACTCS_DATACOUNT_HI:\n                           SCR1_DBG_ABSTRACTCS_DATACOUNT_LO]   = ABSTRACTCS_DATACOUNT;\n        end\n\n        SCR1_DBG_HARTINFO: begin\n            dm2dmi_rdata_o[SCR1_DBG_HARTINFO_RESERVEDB_HI:\n                           SCR1_DBG_HARTINFO_RESERVEDB_LO]     = HARTINFO_RESERVEDB;\n            dm2dmi_rdata_o[SCR1_DBG_HARTINFO_NSCRATCH_HI:\n                           SCR1_DBG_HARTINFO_NSCRATCH_LO]      = HARTINFO_NSCRATCH;\n            dm2dmi_rdata_o[SCR1_DBG_HARTINFO_RESERVEDA_HI:\n                           SCR1_DBG_HARTINFO_RESERVEDA_LO]     = HARTINFO_RESERVEDA;\n            dm2dmi_rdata_o[SCR1_DBG_HARTINFO_DATAACCESS]       = HARTINFO_DATAACCESS;\n            dm2dmi_rdata_o[SCR1_DBG_HARTINFO_DATASIZE_HI:\n                           SCR1_DBG_HARTINFO_DATASIZE_LO]      = HARTINFO_DATASIZE;\n            dm2dmi_rdata_o[SCR1_DBG_HARTINFO_DATAADDR_HI:\n                           SCR1_DBG_HARTINFO_DATAADDR_LO]      = HARTINFO_DATAADDR;\n        end\n\n        SCR1_DBG_ABSTRACTAUTO: dm2dmi_rdata_o[0] = abs_autoexec_ff;\n        SCR1_DBG_DATA0       : dm2dmi_rdata_o    = abs_data0_ff;\n        SCR1_DBG_DATA1       : dm2dmi_rdata_o    = abs_data1_ff;\n        SCR1_DBG_PROGBUF0    : dm2dmi_rdata_o    = abs_progbuf0_ff;\n        SCR1_DBG_PROGBUF1    : dm2dmi_rdata_o    = abs_progbuf1_ff;\n        SCR1_DBG_PROGBUF2    : dm2dmi_rdata_o    = abs_progbuf2_ff;\n        SCR1_DBG_PROGBUF3    : dm2dmi_rdata_o    = abs_progbuf3_ff;\n        SCR1_DBG_PROGBUF4    : dm2dmi_rdata_o    = abs_progbuf4_ff;\n        SCR1_DBG_PROGBUF5    : dm2dmi_rdata_o    = abs_progbuf5_ff;\n        SCR1_DBG_HALTSUM0    : dm2dmi_rdata_o[0] = dmstatus_allany_halted_ff;\n\n        default: begin\n            dm2dmi_rdata_o = '0;\n        end\n    endcase\nend\n\n// Response\nassign dm2dmi_resp_o = 1'b1;\n\n// Write requests signals\n//------------------------------------------------------------------------------\n\nassign dmcontrol_wr_req  = dmi_req_dmcontrol    & dmi2dm_wr_i;\nassign data0_wr_req      = dmi_req_data0        & dmi2dm_wr_i;\nassign data1_wr_req      = dmi_req_data1        & dmi2dm_wr_i;\nassign dreg_wr_req       = pipe2dm_dreg_req_i   & pipe2dm_dreg_wr_i;\nassign command_wr_req    = dmi_req_command      & dmi2dm_wr_i;\nassign autoexec_wr_req   = dmi_req_abstractauto & dmi2dm_wr_i;\nassign progbuf0_wr_req   = dmi_req_progbuf0     & dmi2dm_wr_i;\nassign progbuf1_wr_req   = dmi_req_progbuf1     & dmi2dm_wr_i;\nassign progbuf2_wr_req   = dmi_req_progbuf2     & dmi2dm_wr_i;\nassign progbuf3_wr_req   = dmi_req_progbuf3     & dmi2dm_wr_i;\nassign progbuf4_wr_req   = dmi_req_progbuf4     & dmi2dm_wr_i;\nassign progbuf5_wr_req   = dmi_req_progbuf5     & dmi2dm_wr_i;\nassign abstractcs_wr_req = dmi_req_abstractcs   & dmi2dm_wr_i;\n\n// HART state signals\n//------------------------------------------------------------------------------\n\nassign hart_state_reset = (pipe2dm_hart_status_i.dbg_state == SCR1_HDU_DBGSTATE_RESET);\nassign hart_state_run   = (pipe2dm_hart_status_i.dbg_state == SCR1_HDU_DBGSTATE_RUN);\nassign hart_state_dhalt = (pipe2dm_hart_status_i.dbg_state == SCR1_HDU_DBGSTATE_DHALTED);\nassign hart_state_drun  = (pipe2dm_hart_status_i.dbg_state == SCR1_HDU_DBGSTATE_DRUN);\n\n//------------------------------------------------------------------------------\n// DM registers\n//------------------------------------------------------------------------------\n//\n // Registers:\n // - DM clock enable register\n // - Auxilary Skip Reset On Powerup register\n // - DMCONTROL register\n // - DMSTATUS register\n\n// DM clock enable logic\n//------------------------------------------------------------------------------\n\nassign clk_en_dm = dmcontrol_wr_req | dmcontrol_dmactive_ff | clk_en_dm_ff;\n\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        clk_en_dm_ff <= 1'b0;\n    end else if (clk_en_dm) begin\n        clk_en_dm_ff <= dmcontrol_dmactive_ff;\n    end\nend\n\nassign dm2pipe_active_o = clk_en_dm_ff;\n\n// DMCONTROL register\n//------------------------------------------------------------------------------\n\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        dmcontrol_dmactive_ff     <= 1'b0;\n        dmcontrol_ndmreset_ff     <= 1'b0;\n        dmcontrol_ackhavereset_ff <= 1'b0;\n        dmcontrol_haltreq_ff      <= 1'b0;\n        dmcontrol_resumereq_ff    <= 1'b0;\n    end else if (clk_en_dm) begin\n        dmcontrol_dmactive_ff     <= dmcontrol_dmactive_next;\n        dmcontrol_ndmreset_ff     <= dmcontrol_ndmreset_next;\n        dmcontrol_ackhavereset_ff <= dmcontrol_ackhavereset_next;\n        dmcontrol_haltreq_ff      <= dmcontrol_haltreq_next;\n        dmcontrol_resumereq_ff    <= dmcontrol_resumereq_next;\n    end\nend\n\nassign dmcontrol_dmactive_next = dmcontrol_wr_req\n                               ? dmi2dm_wdata_i[SCR1_DBG_DMCONTROL_DMACTIVE]\n                               : dmcontrol_dmactive_ff;\n\nalways_comb begin\n    dmcontrol_ndmreset_next     = dmcontrol_ndmreset_ff;\n    dmcontrol_ackhavereset_next = dmcontrol_ackhavereset_ff;\n    dmcontrol_haltreq_next      = dmcontrol_haltreq_ff;\n    dmcontrol_resumereq_next    = dmcontrol_resumereq_ff;\n    if (~dmcontrol_dmactive_ff) begin\n        dmcontrol_ndmreset_next     = 1'b0;\n        dmcontrol_ackhavereset_next = 1'b0;\n        dmcontrol_haltreq_next      = 1'b0;\n        dmcontrol_resumereq_next    = 1'b0;\n    end else if (dmcontrol_wr_req) begin\n        dmcontrol_ndmreset_next     = dmi2dm_wdata_i[SCR1_DBG_DMCONTROL_NDMRESET];\n        dmcontrol_ackhavereset_next = dmi2dm_wdata_i[SCR1_DBG_DMCONTROL_ACKHAVERESET];\n        dmcontrol_haltreq_next      = dmi2dm_wdata_i[SCR1_DBG_DMCONTROL_HALTREQ];\n        dmcontrol_resumereq_next    = dmi2dm_wdata_i[SCR1_DBG_DMCONTROL_RESUMEREQ];\n    end\nend\n\n// Reset signal for system controlled by Debug Module\nassign hart_rst_n_o = ~dmcontrol_ndmreset_ff;\nassign ndm_rst_n_o  = ~dmcontrol_ndmreset_ff;\n\n// Skip reset on powerup register\n//------------------------------------------------------------------------------\n\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        havereset_skip_pwrup_ff <= 1'b1;\n    end else if (clk_en_dm) begin\n        havereset_skip_pwrup_ff <= havereset_skip_pwrup_next;\n    end\nend\n\nassign havereset_skip_pwrup_next = ~dmcontrol_dmactive_ff  ? 1'b1\n                                 : havereset_skip_pwrup_ff ? hart_state_reset & ndm_rst_n_o & hart_rst_n_o\n                                                           : havereset_skip_pwrup_ff;\n\n// DMSTATUS register\n//------------------------------------------------------------------------------\n\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        dmstatus_allany_havereset_ff <= 1'b0;\n        dmstatus_allany_resumeack_ff <= 1'b0;\n        dmstatus_allany_halted_ff    <= 1'b0;\n    end else if (clk_en_dm) begin\n        dmstatus_allany_havereset_ff <= dmstatus_allany_havereset_next;\n        dmstatus_allany_resumeack_ff <= dmstatus_allany_resumeack_next;\n        dmstatus_allany_halted_ff    <= dmstatus_allany_halted_next;\n    end\nend\n\nassign dmstatus_allany_havereset_next = ~dmcontrol_dmactive_ff                      ? 1'b0\n                                      : ~havereset_skip_pwrup_ff & hart_state_reset ? 1'b1\n                                      : dmcontrol_ackhavereset_ff                   ? 1'b0\n                                                                                    : dmstatus_allany_havereset_ff;\nassign dmstatus_allany_resumeack_next = ~dmcontrol_dmactive_ff  ? 1'b0\n                                      : ~dmcontrol_resumereq_ff ? 1'b0\n                                      : hart_state_run          ? 1'b1\n                                                                : dmstatus_allany_resumeack_ff;\n\nassign dmstatus_allany_halted_next    = ~dmcontrol_dmactive_ff ? 1'b0\n                                      : hart_state_dhalt       ? 1'b1\n                                      : hart_state_run         ? 1'b0\n                                                               : dmstatus_allany_halted_ff;\n\n//------------------------------------------------------------------------------\n// Abstract Command control logic\n//------------------------------------------------------------------------------\n//\n // Consists of the following functional units:\n // - Abstract command decoder\n // - Abstract command access valid flags\n // - Abstract command control registers\n\nassign clk_en_abs = clk_en_dm & dmcontrol_dmactive_ff;\n\n// Abstract command decoder\n//------------------------------------------------------------------------------\n\nassign abs_cmd = dmi_req_command ? dmi2dm_wdata_i : abs_command_ff;\n\nalways_comb begin\n    abs_cmd_regno       = abs_cmd[SCR1_DBG_COMMAND_ACCESSREG_REGNO_LO +: 12];\n\n    abs_cmd_csr_ro      = (abs_cmd_regno == SCR1_CSR_ADDR_MISA)\n                        | (abs_cmd_regno == SCR1_CSR_ADDR_MVENDORID)\n                        | (abs_cmd_regno == SCR1_CSR_ADDR_MARCHID)\n                        | (abs_cmd_regno == SCR1_CSR_ADDR_MIMPID)\n                        | (abs_cmd_regno == SCR1_CSR_ADDR_MHARTID)\n                        | (abs_cmd_regno == SCR1_HDU_DBGCSR_ADDR_DPC);\n\n    abs_cmd_type        = abs_cmd[SCR1_DBG_COMMAND_TYPE_HI:SCR1_DBG_COMMAND_TYPE_LO];\n    abs_cmd_regacs      = abs_cmd[SCR1_DBG_COMMAND_ACCESSREG_TRANSFER];\n    abs_cmd_regtype     = abs_cmd[SCR1_DBG_COMMAND_ACCESSREG_REGNO_HI:12];\n    abs_cmd_regfile     = abs_cmd[11:5];\n    abs_cmd_regsize     = abs_cmd[SCR1_DBG_COMMAND_ACCESSREG_SIZE_HI:\n                                  SCR1_DBG_COMMAND_ACCESSREG_SIZE_LO];\n    abs_cmd_regwr       = abs_cmd[SCR1_DBG_COMMAND_ACCESSREG_WRITE];\n    abs_cmd_execprogbuf = abs_cmd[SCR1_DBG_COMMAND_ACCESSREG_POSTEXEC];\n\n    abs_cmd_regvalid    = ~(|{abs_cmd[SCR1_DBG_COMMAND_ACCESSREG_RESERVEDB],\n                              abs_cmd[SCR1_DBG_COMMAND_ACCESSREG_RESERVEDA]});\n\n    abs_cmd_memsize     = abs_cmd[SCR1_DBG_COMMAND_ACCESSMEM_AAMSIZE_HI:\n                                  SCR1_DBG_COMMAND_ACCESSMEM_AAMSIZE_LO];\n    abs_cmd_memwr       = abs_cmd[SCR1_DBG_COMMAND_ACCESSMEM_WRITE];\n\n    abs_cmd_memvalid    = ~(|{abs_cmd[SCR1_DBG_COMMAND_ACCESSMEM_AAMVIRTUAL],\n                              abs_cmd[SCR1_DBG_COMMAND_ACCESSMEM_AAMPOSTINC],\n                              abs_cmd[SCR1_DBG_COMMAND_ACCESSMEM_RESERVEDB_HI:\n                                      SCR1_DBG_COMMAND_ACCESSMEM_RESERVEDB_HI],\n                              abs_cmd[SCR1_DBG_COMMAND_ACCESSMEM_RESERVEDA_HI:\n                                      SCR1_DBG_COMMAND_ACCESSMEM_RESERVEDA_HI]});\nend\n\nassign abs_reg_access_csr  = (abs_cmd_regtype == ABS_CMD_HARTREG_CSR);\nassign abs_reg_access_mprf = (abs_cmd_regtype == ABS_CMD_HARTREG_INTFPU)\n                           & (abs_cmd_regfile == ABS_CMD_HARTREG_INT);\n\n// Abstract command access request and valid flags\n//------------------------------------------------------------------------------\n\nassign abs_cmd_regsize_vd       = (abs_cmd_regsize == 3'h2);\nassign abs_cmd_memsize_vd       = (abs_cmd_memsize < 3'h3);\n\nassign abs_cmd_hartreg_vd       = (abs_cmd_type == ABS_CMD_HARTREG) & abs_cmd_regvalid;\nassign abs_cmd_hartmem_vd       = (abs_cmd_type == ABS_CMD_HARTMEM) & abs_cmd_memvalid;\n\n// Abstract command requests\nassign abs_cmd_reg_access_req   = abs_cmd_hartreg_vd     & abs_cmd_regacs;\nassign abs_cmd_csr_access_req   = abs_cmd_reg_access_req & abs_reg_access_csr;\nassign abs_cmd_mprf_access_req  = abs_cmd_reg_access_req & abs_reg_access_mprf;\nassign abs_cmd_execprogbuf_req  = abs_cmd_hartreg_vd     & abs_cmd_execprogbuf;\n\n// Abstract command access valid flags\nassign abs_cmd_csr_ro_access_vd = abs_cmd_csr_access_req  & abs_cmd_regsize_vd & ~abs_cmd_regwr\n                                & ~abs_cmd_execprogbuf    & abs_cmd_csr_ro     & hart_state_run;\nassign abs_cmd_csr_rw_access_vd = abs_cmd_csr_access_req  & abs_cmd_regsize_vd\n                                & (abs_cmd_regwr | ~abs_cmd_csr_ro_access_vd);\nassign abs_cmd_mprf_access_vd   = abs_cmd_mprf_access_req & abs_cmd_regsize_vd;\nassign abs_cmd_mem_access_vd    = abs_cmd_hartmem_vd & abs_cmd_memsize_vd;\n\n// Abstract command control registers\n//------------------------------------------------------------------------------\n\nalways_ff @(posedge clk) begin\n    if (clk_en_abs & abs_fsm_idle) begin\n        abs_cmd_postexec_ff <= abs_cmd_postexec_next;\n        abs_cmd_wr_ff       <= abs_cmd_wr_next;\n        abs_cmd_regno_ff    <= abs_cmd_regno;\n        abs_cmd_size_ff     <= abs_cmd_size_next;\n    end\nend\n\nalways_comb begin\n    abs_cmd_wr_next       = 1'b0;\n    abs_cmd_postexec_next = 1'b0;\n    abs_cmd_size_next     = abs_cmd_size_ff;\n    if ((command_wr_req | dmi_rpt_command) & hart_state_dhalt & abs_fsm_idle) begin\n        if (abs_cmd_csr_rw_access_vd) begin\n            abs_cmd_wr_next       = abs_cmd_regwr;\n            abs_cmd_postexec_next = abs_cmd_execprogbuf;\n        end else if (abs_cmd_mprf_access_vd) begin\n            abs_cmd_wr_next       = abs_cmd_regwr;\n            abs_cmd_size_next     = abs_cmd_regsize[1:0];\n            abs_cmd_postexec_next = abs_cmd_execprogbuf;\n        end else if (abs_cmd_mem_access_vd) begin\n            abs_cmd_wr_next       = abs_cmd_memwr;\n            abs_cmd_size_next     = abs_cmd_memsize[1:0];\n        end\n    end\nend\n\n//------------------------------------------------------------------------------\n// Abstract command FSM\n//--------------------------"}
{"text": "----------------------------------------------------\n\nalways_ff @(posedge clk) begin\n    if (clk_en_dm) begin\n        if (~dmcontrol_dmactive_ff) begin\n            abs_fsm_ff <= ABS_STATE_IDLE;\n        end else begin\n            abs_fsm_ff <= abs_fsm_next;\n        end\n    end\nend\n\nalways_comb begin\n    abs_fsm_next = abs_fsm_ff;\n\n    case (abs_fsm_ff)\n        ABS_STATE_IDLE: begin\n            if (command_wr_req | dmi_rpt_command) begin\n                case (1'b1)\n                    abs_cmd_csr_ro_access_vd: abs_fsm_next = ABS_STATE_CSR_RO;\n                    abs_cmd_csr_rw_access_vd: abs_fsm_next = hart_state_dhalt ? ABS_STATE_CSR_SAVE_XREG : ABS_STATE_ERR;\n                    abs_cmd_mprf_access_vd  : abs_fsm_next = hart_state_dhalt ? ABS_STATE_XREG_RW       : ABS_STATE_ERR;\n                    abs_cmd_execprogbuf_req : abs_fsm_next = ABS_STATE_EXEC;\n                    abs_cmd_mem_access_vd   : abs_fsm_next = hart_state_dhalt ? ABS_STATE_MEM_SAVE_XREG : ABS_STATE_ERR;\n                    default                 : abs_fsm_next = ABS_STATE_ERR;\n                endcase\n            end\n        end\n\n        ABS_STATE_EXEC: begin\n            if (dhi_resp) begin\n                if (dhi_resp_exc | abs_err_acc_busy_ff) begin\n                    abs_fsm_next = ABS_STATE_ERR;\n                end else begin\n                    abs_fsm_next = ABS_STATE_IDLE;\n                end\n            end\n        end\n\n        ABS_STATE_XREG_RW: begin\n            if (dhi_resp) begin\n                case (1'b1)\n                    abs_err_acc_busy_ff: abs_fsm_next = ABS_STATE_ERR;\n                    abs_cmd_postexec_ff: abs_fsm_next = ABS_STATE_EXEC;\n                    default            : abs_fsm_next = ABS_STATE_IDLE;\n                endcase\n            end\n        end\n\n        ABS_STATE_CSR_RO       : abs_fsm_next = abs_err_acc_busy_ff ? ABS_STATE_ERR             : ABS_STATE_IDLE;\n        ABS_STATE_CSR_SAVE_XREG: abs_fsm_next = dhi_resp            ? ABS_STATE_CSR_RW          : ABS_STATE_CSR_SAVE_XREG;\n        ABS_STATE_CSR_RW       : abs_fsm_next = dhi_resp            ? ABS_STATE_CSR_RETURN_XREG : ABS_STATE_CSR_RW;\n\n        ABS_STATE_CSR_RETURN_XREG: begin\n            if (dhi_resp) begin\n                case (1'b1)\n                    abs_err_exc_ff      : abs_fsm_next = ABS_STATE_ERR;\n                    abs_err_acc_busy_ff : abs_fsm_next = ABS_STATE_ERR;\n                    abs_cmd_postexec_ff : abs_fsm_next = ABS_STATE_EXEC;\n                    default             : abs_fsm_next = ABS_STATE_IDLE;\n                endcase\n            end\n        end\n\n        ABS_STATE_MEM_SAVE_XREG         : abs_fsm_next = dhi_resp ? ABS_STATE_MEM_SAVE_XREG_FORADDR   : ABS_STATE_MEM_SAVE_XREG;\n        ABS_STATE_MEM_SAVE_XREG_FORADDR : abs_fsm_next = dhi_resp ? ABS_STATE_MEM_RW                  : ABS_STATE_MEM_SAVE_XREG_FORADDR;\n        ABS_STATE_MEM_RW                : abs_fsm_next = dhi_resp ? ABS_STATE_MEM_RETURN_XREG         : ABS_STATE_MEM_RW;\n        ABS_STATE_MEM_RETURN_XREG       : abs_fsm_next = dhi_resp ? ABS_STATE_MEM_RETURN_XREG_FORADDR : ABS_STATE_MEM_RETURN_XREG;\n\n        ABS_STATE_MEM_RETURN_XREG_FORADDR: begin\n            if (dhi_resp) begin\n                case (1'b1)\n                    abs_err_exc_ff: abs_fsm_next = ABS_STATE_ERR;\n                    abs_err_acc_busy_ff : abs_fsm_next = ABS_STATE_ERR;\n                    abs_cmd_postexec_ff : abs_fsm_next = ABS_STATE_EXEC;\n                    default             : abs_fsm_next = ABS_STATE_IDLE;\n                endcase\n            end\n        end\n\n        ABS_STATE_ERR: begin\n            if (abstractcs_wr_req & (abstractcs_cmderr_next == 3'b0)) begin\n                abs_fsm_next = ABS_STATE_IDLE;\n            end\n        end\n    endcase\n\n    if (~abs_fsm_idle & hart_state_reset) begin\n        abs_fsm_next    = ABS_STATE_ERR;\n    end\nend\n\nassign abs_fsm_idle     = (abs_fsm_ff == ABS_STATE_IDLE);\nassign abs_fsm_exec     = (abs_fsm_ff == ABS_STATE_EXEC);\nassign abs_fsm_csr_ro   = (abs_fsm_ff == ABS_STATE_CSR_RO);\nassign abs_fsm_err      = (abs_fsm_ff == ABS_STATE_ERR);\nassign abs_fsm_use_addr = (abs_fsm_ff == ABS_STATE_MEM_SAVE_XREG_FORADDR)\n                        | (abs_fsm_ff == ABS_STATE_MEM_RETURN_XREG_FORADDR);\n\n//------------------------------------------------------------------------------\n// Abstract command status logic\n//------------------------------------------------------------------------------\n\n// Abstract command access busy error register\n//------------------------------------------------------------------------------\n\nassign abs_err_acc_busy_upd = clk_en_abs & (abs_fsm_idle | dmi_req_any);\n\nalways_ff @(posedge clk) begin\n    if (abs_err_acc_busy_upd) abs_err_acc_busy_ff <= abs_err_acc_busy_next;\nend\n\nassign abs_err_acc_busy_next = ~abs_fsm_idle & dmi_req_any;\n\n// Abstract command access exception error register\n//------------------------------------------------------------------------------\n\nassign abs_err_exc_upd = clk_en_abs & (abs_fsm_idle | (dhi_resp & dhi_resp_exc));\n\nalways_ff @(posedge clk) begin\n    if (abs_err_exc_upd) abs_err_exc_ff <= abs_err_exc_next;\nend\n\nassign abs_err_exc_next = ~abs_fsm_idle & dhi_resp & dhi_resp_exc;\n\n//------------------------------------------------------------------------------\n// Abstract Instruction logic\n//------------------------------------------------------------------------------\n//\n // Cosists of the following functional units:\n // - Instruction execution request register\n // - Instruction memory FUNCT3 field multiplexer\n // - Instruction RS1 multiplexer\n // - Instruction RD multiplexer\n // - Abstract Instruction register\n\n// Abstract instruction execution request register\n//------------------------------------------------------------------------------\n\nassign abs_exec_req_next = ~(abs_fsm_idle | abs_fsm_csr_ro | abs_fsm_err) & ~dhi_resp;\n\nalways_ff @(posedge clk) begin\n    if (clk_en_dm) begin\n        if (~dmcontrol_dmactive_ff) begin\n            abs_exec_req_ff <= 1'b0;\n        end else begin\n            abs_exec_req_ff <= abs_exec_req_next;\n        end\n    end\nend\n\n// Abstract instruction memory FUNCT3 field multiplexer\n//------------------------------------------------------------------------------\n\nalways_comb begin\n    case (abs_cmd_size_ff)\n        2'b00  : abs_instr_mem_funct3 = abs_cmd_wr_ff ? SCR1_FUNCT3_SB : SCR1_FUNCT3_LBU;\n        2'b01  : abs_instr_mem_funct3 = abs_cmd_wr_ff ? SCR1_FUNCT3_SH : SCR1_FUNCT3_LHU;\n        2'b10  : abs_instr_mem_funct3 = abs_cmd_wr_ff ? SCR1_FUNCT3_SW : SCR1_FUNCT3_LW;\n        default: abs_instr_mem_funct3 = SCR1_FUNCT3_SB;\n    endcase\nend\n\n// Abstract instruction RS1 multiplexer\n//------------------------------------------------------------------------------\n\nalways_comb begin\n    abs_instr_rs1 = 5'h0;\n    case (abs_fsm_ff)\n        ABS_STATE_XREG_RW                : abs_instr_rs1 = abs_cmd_wr_ff ? 5'h0 : abs_cmd_regno_ff[4:0];\n        ABS_STATE_CSR_SAVE_XREG          : abs_instr_rs1 = 5'h5;\n        ABS_STATE_MEM_SAVE_XREG          : abs_instr_rs1 = 5'h5;\n        ABS_STATE_CSR_RETURN_XREG        : abs_instr_rs1 = 5'h5;\n        ABS_STATE_MEM_RETURN_XREG        : abs_instr_rs1 = 5'h5;\n        ABS_STATE_CSR_RW                 : abs_instr_rs1 = abs_cmd_wr_ff ? 5'h5 : 5'h0;\n        ABS_STATE_MEM_SAVE_XREG_FORADDR  : abs_instr_rs1 = 5'h6;\n        ABS_STATE_MEM_RETURN_XREG_FORADDR: abs_instr_rs1 = 5'h6;\n        ABS_STATE_MEM_RW                 : abs_instr_rs1 = 5'h6;\n        default                          : begin end\n    endcase\nend\n\nassign abs_instr_rs2 = 5'h5;\n\n// Abstract instruction RD multiplexer\n//------------------------------------------------------------------------------\n\nalways_comb begin\n    abs_instr_rd  = 5'h0;\n    case (abs_fsm_ff)\n        ABS_STATE_XREG_RW                : abs_instr_rd = abs_cmd_wr_ff ? abs_cmd_regno_ff[4:0] : 5'h0;\n        ABS_STATE_CSR_SAVE_XREG          : abs_instr_rd = abs_cmd_wr_ff ? 5'h5 : 5'h0;\n        ABS_STATE_MEM_SAVE_XREG          : abs_instr_rd = abs_cmd_wr_ff ? 5'h5 : 5'h0;\n        ABS_STATE_CSR_RW                 : abs_instr_rd = abs_cmd_wr_ff ? 5'h0 : 5'h5;\n        ABS_STATE_MEM_RW                 : abs_instr_rd = abs_cmd_wr_ff ? 5'h0 : 5'h5;\n        ABS_STATE_CSR_RETURN_XREG        : abs_instr_rd = 5'h5;\n        ABS_STATE_MEM_RETURN_XREG        : abs_instr_rd = 5'h5;\n        ABS_STATE_MEM_SAVE_XREG_FORADDR  : abs_instr_rd = 5'h6;\n        ABS_STATE_MEM_RETURN_XREG_FORADDR: abs_instr_rd = 5'h6;\n        default                          : begin end\n    endcase\nend\n\n// Abstract instruction register\n//------------------------------------------------------------------------------\n\nalways_ff @(posedge clk) begin\n    if (clk_en_abs) begin\n        abs_exec_instr_ff <= abs_exec_instr_next;\n    end\nend\n\nalways_comb begin\n    abs_exec_instr_next = abs_exec_instr_ff;\n    case (abs_fsm_ff)\n        ABS_STATE_XREG_RW,\n        ABS_STATE_CSR_SAVE_XREG,\n        ABS_STATE_CSR_RETURN_XREG,\n        ABS_STATE_MEM_SAVE_XREG,\n        ABS_STATE_MEM_SAVE_XREG_FORADDR,\n        ABS_STATE_MEM_RETURN_XREG,\n        ABS_STATE_MEM_RETURN_XREG_FORADDR: begin\n            abs_exec_instr_next = {SCR1_HDU_DBGCSR_ADDR_DSCRATCH0, abs_instr_rs1, SCR1_FUNCT3_CSRRW, abs_instr_rd, SCR1_OP_SYSTEM};\n        end\n\n        ABS_STATE_CSR_RW: begin\n            abs_exec_instr_next = abs_cmd_wr_ff\n                                ? {abs_cmd_regno_ff[11:0], abs_instr_rs1, SCR1_FUNCT3_CSRRW, abs_instr_rd, SCR1_OP_SYSTEM}\n                                : {abs_cmd_regno_ff[11:0], abs_instr_rs1, SCR1_FUNCT3_CSRRS, abs_instr_rd, SCR1_OP_SYSTEM};\n        end\n\n        ABS_STATE_MEM_RW: begin\n            abs_exec_instr_next = abs_cmd_wr_ff\n                                ? {7'h0,  abs_instr_rs2, abs_instr_rs1, abs_instr_mem_funct3, 5'h0,         SCR1_OP_STORE}\n                                : {12'h0,                abs_instr_rs1, abs_instr_mem_funct3, abs_instr_rd, SCR1_OP_LOAD};\n        end\n\n        default: begin end\n    endcase\nend\n\n//------------------------------------------------------------------------------\n// Abstract registers\n//------------------------------------------------------------------------------\n//\n // Registers:\n // - ABSTRACTCS register\n // - COMMAND register\n // - ABSTRACTAUTO register\n // - PROGBUF0..5 registers\n // - DATA0..1 registers\n\n// ABSTRACTCS register\n//------------------------------------------------------------------------------\n\nalways_ff @(posedge clk) begin\n    if (clk_en_dm) begin\n        if (~dmcontrol_dmactive_ff) begin\n            abstractcs_cmderr_ff <= ABS_ERR_NONE;\n        end else begin\n            abstractcs_cmderr_ff <= abstractcs_cmderr_next;\n        end\n    end\nend\n\nalways_comb begin\n    abstractcs_cmderr_next = abstractcs_cmderr_ff;\n\n    case (abs_fsm_ff)\n        ABS_STATE_IDLE: begin\n            if (command_wr_req | dmi_rpt_command) begin\n                if (abs_cmd_hartreg_vd) begin\n                    case (1'b1)\n                        abs_cmd_reg_access_req : begin\n                            case (1'b1)\n                                abs_cmd_csr_rw_access_vd: abstractcs_cmderr_next = hart_state_dhalt\n                                                                                 ? abstractcs_cmderr_ff\n                                                                                 : ABS_ERR_NOHALT;\n                                abs_cmd_mprf_access_vd  : abstractcs_cmderr_next = hart_state_dhalt\n                                                                                 ? abstractcs_cmderr_ff\n                                                                                 : ABS_ERR_NOHALT;\n                                abs_cmd_csr_ro_access_vd: abstractcs_cmderr_next = abstractcs_cmderr_ff;\n                                default                 : abstractcs_cmderr_next = ABS_ERR_CMD;\n                            endcase\n                        end\n                        abs_cmd_execprogbuf_req         : abstractcs_cmderr_next = abstractcs_cmderr_ff;\n                        default                         : abstractcs_cmderr_next = ABS_ERR_CMD;\n                    endcase\n                end else if (abs_cmd_hartmem_vd) begin\n                    abstractcs_cmderr_next = ~abs_cmd_memsize_vd ? ABS_ERR_CMD\n                                           : ~hart_state_dhalt   ? ABS_ERR_NOHALT\n                                                                 : abstractcs_cmderr_ff;\n                end else begin\n                    abstractcs_cmderr_next = ABS_ERR_CMD;\n                end\n            end\n        end\n\n        ABS_STATE_EXEC: begin\n            if (dhi_resp) begin\n                if (dhi_resp_exc) begin\n                    abstractcs_cmderr_next = ABS_ERR_EXCEPTION;\n                end else if (abs_err_acc_busy_ff) begin\n                    abstractcs_cmderr_next = ABS_ERR_BUSY;\n                end\n            end\n        end\n\n        ABS_STATE_XREG_RW,\n        ABS_STATE_CSR_RO: begin\n            if (abs_err_acc_busy_ff) begin\n                abstractcs_cmderr_next = ABS_ERR_BUSY;\n            end\n        end\n\n        ABS_STATE_CSR_RETURN_XREG,\n        ABS_STATE_MEM_RETURN_XREG_FORADDR: begin\n            if (dhi_resp) begin\n                case (1'b1)\n                    abs_err_exc_ff     : abstractcs_cmderr_next = ABS_ERR_EXCEPTION;\n                    abs_err_acc_busy_ff: abstractcs_cmderr_next = ABS_ERR_BUSY;\n                    default:             abstractcs_cmderr_next = abstractcs_cmderr_ff;\n                endcase\n            end\n        end\n\n        ABS_STATE_ERR: begin\n            if (dmi_req_abstractcs & dmi2dm_wr_i) begin\n                abstractcs_cmderr_next = type_scr1_abs_err_e'(logic'(abstractcs_cmderr_ff)\n                                       & (~dmi2dm_wdata_i[SCR1_DBG_ABSTRACTCS_CMDERR_HI:\n                                                          SCR1_DBG_ABSTRACTCS_CMDERR_LO]));\n            end\n        end\n\n        default: begin\n        end\n    endcase\n\n    if (~abs_fsm_idle & hart_state_reset) begin\n        abstractcs_cmderr_next = ABS_ERR_EXCEPTION;\n    end\nend\n\nassign abstractcs_busy = ~abs_fsm_idle & ~abs_fsm_err;\n\n// Abstract COMMAND register\n//------------------------------------------------------------------------------\n\nalways_ff @(posedge clk) begin\n    if (clk_en_dm) abs_command_ff <= abs_command_next;\nend\n\nassign abs_command_next = ~dmcontrol_dmactive_ff          ? '0\n                        : (command_wr_req & abs_fsm_idle) ? dmi2dm_wdata_i\n                                                          : abs_command_ff;\n\n// Abstract ABSTRACTAUTO register\n//------------------------------------------------------------------------------\n\nalways_ff @(posedge clk) begin\n    if (clk_en_dm) abs_autoexec_ff <= abs_autoexec_next;\nend\n\nassign abs_autoexec_next = ~dmcontrol_dmactive_ff           ? 1'b0\n                         : (autoexec_wr_req & abs_fsm_idle) ? dmi2dm_wdata_i[0]\n                                                            : abs_autoexec_ff;\n\n// Program Buffer registers\n//------------------------------------------------------------------------------\n\nalways_ff @(posedge clk) begin\n    if (clk_en_abs & abs_fsm_idle) begin\n        if (progbuf0_wr_req) abs_progbuf0_ff <= dmi2dm_wdata_i;\n        if (progbuf1_wr_req) abs_progbuf1_ff <= dmi2dm_wdata_i;\n        if (progbuf2_wr_req) abs_progbuf2_ff <= dmi2dm_wdata_i;\n        if (progbuf3_wr_req) abs_progbuf3_ff <= dmi2dm_wdata_i;\n        if (progbuf4_wr_req) abs_progbuf4_ff <= dmi2dm_wdata_i;\n        if (progbuf5_wr_req) abs_progbuf5_ff <= dmi2dm_wdata_i;\n    end\nend\n\n// Data 0 register\n//------------------------------------------------------------------------------\n\nalways_ff @(posedge clk) begin\n    if (clk_en_abs) begin\n        abs_data0_ff <= abs_data0_next;\n    end\nend\n\nassign data0_xreg_save = dreg_wr_req & ~abs_cmd_wr_ff;\n\nalways_comb begin\n    abs_data0_next = abs_data0_ff;\n\n    case (abs_fsm_ff)\n        ABS_STATE_IDLE           : abs_data0_next = data0_wr_req    ? dmi2dm_wdata_i       : abs_data0_ff;\n        ABS_STATE_EXEC           : abs_data0_next = dreg_wr_req     ? pipe2dm_dreg_wdata_i : abs_data0_ff;\n        ABS_STATE_CSR_SAVE_XREG  : abs_data0_next = dreg_wr_req     ? pipe2dm_dreg_wdata_i : abs_data0_ff;\n        ABS_STATE_CSR_RETURN_XREG: abs_data0_next = dreg_wr_req     ? pipe2dm_dreg_wdata_i : abs_data0_ff;\n        ABS_STATE_MEM_SAVE_XREG  : abs_data0_next = dreg_wr_req     ? pipe2dm_dreg_wdata_i : abs_data0_ff;\n        ABS_STATE_MEM_RETURN_XREG: abs_data0_next = dreg_wr_req     ? pipe2dm_dreg_wdata_i : abs_data0_ff;\n        ABS_STATE_XREG_RW        : abs_data0_next = data0_xreg_save ? pipe2dm_dreg_wdata_i : abs_data0_ff;\n\n        ABS_STATE_CSR_RO: begin\n            case (abs_cmd_regno_ff[11:0])\n                SCR1_CSR_ADDR_MISA     : abs_data0_next = SCR1_CSR_MISA;\n                SCR1_CSR_ADDR_MVENDORID: abs_data0_next = SCR1_CSR_MVENDORID;\n                SCR1_CSR_ADDR_MARCHID  : abs_data0_next = SCR1_CSR_MARCHID;\n                SCR1_CSR_ADDR_MIMPID   : abs_data0_next = SCR1_CSR_MIMPID;\n                SCR1_CSR_ADDR_MHARTID  : abs_data0_next = soc2dm_fuse_mhartid_i;\n                default                : abs_data0_next = pipe2dm_pc_sample_i;\n            endcase\n        end\n\n        default : begin end\n    endcase\nend\n\n// Data 1 register\n//------------------------------------------------------------------------------\n\nalways_ff @(posedge clk) begin\n    if (clk_en_abs) begin\n        abs_data1_ff <= abs_data1_next;\n    end\nend\n\nalways_comb begin\n    abs_data1_next = abs_data1_ff;\n    case (abs_fsm_ff)\n        ABS_STATE_IDLE                   : abs_data1_next = data1_wr_req ? dmi2dm_wdata_i       : abs_data1_ff;\n        ABS_STATE_MEM_SAVE_XREG_FORADDR  : abs_data1_next = dreg_wr_req  ? pipe2dm_dreg_wdata_i : abs_data1_ff;\n        ABS_STATE_MEM_RETURN_XREG_FORADDR: abs_data1_next = dreg_wr_req  ? pipe2dm_dreg_wdata_i : abs_data1_ff;\n        default                          : begin end\n    endcase\nend\n\n//------------------------------------------------------------------------------\n// Debug Hart Interface : control\n//------------------------------------------------------------------------------\n\nassign cmd_resp_ok    = pipe2dm_cmd_resp_i & ~pipe2dm_cmd_rcode_i;\nassign hart_rst_unexp = ~dhi_fsm_idle      & ~dhi_fsm_halt_req & hart_state_reset;\n\nassign halt_req_vd    = dmcontrol_haltreq_ff   & ~hart_state_dhalt;\nassign resume_req_vd  = dmcontrol_resumereq_ff & ~dmstatus_allany_resumeack_ff\n                      & hart_state_dhalt;\n\n// DHI fsm\n//------------------------------------------------------------------------------\n\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        dhi_fsm_ff   <= DHI_STATE_IDLE;\n    end else if (clk_en_dm) begin\n        dhi_fsm_ff <= dhi_fsm_next;\n    end\nend\n\nalways_comb begin\n    dhi_fsm_next = dhi_fsm_ff;\n    if (~hart_rst_unexp & dmcontrol_dmactive_ff) begin\n        // Normal work\n        case (dhi_fsm_ff)\n            DHI_STATE_IDLE      : dhi_fsm_next = dhi_req;\n            DHI_STATE_EXEC      : dhi_fsm_next = cmd_resp_ok      ? DHI_STATE_EXEC_RUN   : DHI_STATE_EXEC;\n            DHI_STATE_EXEC_RUN  : dhi_fsm_next = hart_state_drun  ? DHI_STATE_EXEC_HALT  : DHI_STATE_EXEC_RUN;\n            DHI_STATE_HALT_REQ  : dhi_fsm_next = cmd_resp_ok      ? DHI_STATE_EXEC_HALT  : DHI_STATE_HALT_REQ;\n            DHI_STATE_EXEC_HALT : dhi_fsm_next = hart_state_dhalt ? DHI_STATE_IDLE       : DHI_STATE_EXEC_HALT;\n            DHI_STATE_RESUME_REQ: dhi_fsm_next = cmd_resp_ok      ? DHI_STATE_RESUME_RUN : DHI_STATE_RESUME_REQ;\n            DHI_STATE_RESUME_RUN: dhi_fsm_next = hart_state_run   ? DHI_STATE_IDLE       : DHI_STATE_RESUME_RUN;\n            default             : dhi_fsm_next = dhi_fsm_ff;\n        endcase\n    end else begin\n        // In case of DM reset or core unexpected reset\n        dhi_fsm_next = DHI_STATE_IDLE;\n    end\nend\n\nassign dhi_fsm_idle       = (dhi_fsm_ff == DHI_STATE_IDLE);\nassign dhi_fsm_halt_req   = (dhi_fsm_ff == DHI_STATE_HALT_REQ);\nassign dhi_fsm_exec       = (dhi_fsm_ff =="}
{"text": " DHI_STATE_EXEC);\nassign dhi_fsm_exec_halt  = (dhi_fsm_ff == DHI_STATE_EXEC_HALT);\nassign dhi_fsm_resume_req = (dhi_fsm_ff == DHI_STATE_RESUME_REQ);\n\nalways_comb begin\n    case (1'b1)\n        abs_exec_req_ff: dhi_req = DHI_STATE_EXEC;\n        halt_req_vd    : dhi_req = DHI_STATE_HALT_REQ;\n        resume_req_vd  : dhi_req = DHI_STATE_RESUME_REQ;\n        default        : dhi_req = DHI_STATE_IDLE;\n    endcase\nend\n\nassign dhi_resp     = dhi_fsm_exec_halt    & hart_state_dhalt;\nassign dhi_resp_exc = pipe2dm_hart_event_i & pipe2dm_hart_status_i.except\n                                           & ~pipe2dm_hart_status_i.ebreak;\n\n// HART command registers\n//------------------------------------------------------------------------------\n\n// HART command request register\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        hart_cmd_req_ff <= 1'b0;\n    end else if (clk_en_dm) begin\n        hart_cmd_req_ff <= hart_cmd_req_next;\n    end\nend\n\nassign hart_cmd_req_next = (dhi_fsm_exec | dhi_fsm_halt_req | dhi_fsm_resume_req)\n                         & ~cmd_resp_ok & dmcontrol_dmactive_ff;\n\n// HART command register\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        hart_cmd_ff <= SCR1_HDU_DBGSTATE_RUN;\n    end else if (clk_en_dm) begin\n        hart_cmd_ff <= hart_cmd_next;\n    end\nend\n\nalways_comb begin\n    hart_cmd_next = SCR1_HDU_DBGSTATE_RUN;\n    if (dmcontrol_dmactive_ff) begin\n        case (dhi_fsm_ff)\n            DHI_STATE_EXEC      : hart_cmd_next = SCR1_HDU_DBGSTATE_DRUN;\n            DHI_STATE_HALT_REQ  : hart_cmd_next = SCR1_HDU_DBGSTATE_DHALTED;\n            DHI_STATE_RESUME_REQ: hart_cmd_next = SCR1_HDU_DBGSTATE_RUN;\n            default             : hart_cmd_next = dm2pipe_cmd_o;\n        endcase\n    end\nend\n\nassign dm2pipe_cmd_req_o = hart_cmd_req_ff;\nassign dm2pipe_cmd_o     = hart_cmd_ff;\n\n//------------------------------------------------------------------------------\n// Debug Hart Interface : program buffer\n//------------------------------------------------------------------------------\n\n// Program Buffer execution EBREAK flag\n//------------------------------------------------------------------------------\n\nalways_ff @(posedge clk) begin\n    if (clk_en_dm) hart_pbuf_ebreak_ff <= hart_pbuf_ebreak_next;\nend\n\nassign hart_pbuf_ebreak_next = abs_fsm_exec & (dm2pipe_pbuf_instr_o == ABS_EXEC_EBREAK);\n\n// Program Buffer instruction multiplexer\n//------------------------------------------------------------------------------\n\nalways_comb begin\n    dm2pipe_pbuf_instr_o = ABS_EXEC_EBREAK;\n\n    if (abs_fsm_exec & ~hart_pbuf_ebreak_ff) begin\n        case (pipe2dm_pbuf_addr_i)\n            3'h0: dm2pipe_pbuf_instr_o = abs_progbuf0_ff;\n            3'h1: dm2pipe_pbuf_instr_o = abs_progbuf1_ff;\n            3'h2: dm2pipe_pbuf_instr_o = abs_progbuf2_ff;\n            3'h3: dm2pipe_pbuf_instr_o = abs_progbuf3_ff;\n            3'h4: dm2pipe_pbuf_instr_o = abs_progbuf4_ff;\n            3'h5: dm2pipe_pbuf_instr_o = abs_progbuf5_ff;\n            default: begin end\n        endcase\n    end else if (pipe2dm_pbuf_addr_i == 3'b0) begin\n        dm2pipe_pbuf_instr_o = abs_exec_instr_ff;\n    end\nend\n\n//------------------------------------------------------------------------------\n// Debug Hart Interface : abstract command data\n//------------------------------------------------------------------------------\n\nassign dm2pipe_dreg_resp_o  = 1'b1;\nassign dm2pipe_dreg_fail_o  = 1'b0;\nassign dm2pipe_dreg_rdata_o = abs_fsm_use_addr ? abs_data1_ff : abs_data0_ff;\n\n`ifdef SCR1_TRGT_SIMULATION\n//------------------------------------------------------------------------------\n// Assertions\n//------------------------------------------------------------------------------\n\nSVA_DM_X_CONTROL : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    !$isunknown({dmi2dm_req_i, pipe2dm_dreg_req_i, pipe2dm_cmd_resp_i,\n                 pipe2dm_hart_event_i})\n) else $error(\"DM error: control signals is X - %0b\", {dmi2dm_req_i,\n              pipe2dm_dreg_req_i, pipe2dm_cmd_resp_i, pipe2dm_hart_event_i});\n\nSVA_DM_X_DMI : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    dmi2dm_req_i |-> !$isunknown({dmi2dm_wr_i, dmi2dm_addr_i, dmi2dm_wdata_i})\n) else $error(\"DM error: data signals is X on dmi\");\n\nSVA_DM_X_HART_PBUF : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    !$isunknown (pipe2dm_pbuf_addr_i)\n) else $error(\"DM error: data signals is X on hart_pbuf\");\n\nSVA_DM_X_HART_DREG : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    pipe2dm_dreg_req_i |-> !$isunknown({pipe2dm_dreg_wr_i, pipe2dm_dreg_wdata_i})\n) else $error(\"DM error: data signals is X on hart_dreg\");\n\nSVA_DM_X_HART_CMD : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    pipe2dm_cmd_resp_i |-> !$isunknown({pipe2dm_cmd_rcode_i})\n) else $error(\"DM error: data signals is X on dm2pipe_cmd_o\");\n\nSVA_DM_X_HART_EVENT : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    pipe2dm_hart_event_i |-> !$isunknown(pipe2dm_hart_status_i)\n) else $error(\"DM error: data signals is X on pipe2dm_hart_event_i\");\n\n`endif // SCR1_TRGT_SIMULATION\n\nendmodule : scr1_dm\n\n`endif // SCR1_DBG_EN\n"}
{"text": "/// Copyright by Syntacore LLC \u00a9 2016-2021. See LICENSE for details\n/// @file       <scr1_dmem_ahb.sv>\n/// @brief      Data memory AHB bridge\n///\n\n`include \"scr1_ahb.svh\"\n`include \"scr1_memif.svh\"\n\nmodule scr1_dmem_ahb (\n    // Control Signals\n    input   logic                           rst_n,\n    input   logic                           clk,\n\n    // Core Interface\n    output  logic                           dmem_req_ack,\n    input   logic                           dmem_req,\n    input   type_scr1_mem_cmd_e             dmem_cmd,\n    input   type_scr1_mem_width_e           dmem_width,\n    input   logic   [SCR1_AHB_WIDTH-1:0]    dmem_addr,\n    input   logic   [SCR1_AHB_WIDTH-1:0]    dmem_wdata,\n    output  logic   [SCR1_AHB_WIDTH-1:0]    dmem_rdata,\n    output  type_scr1_mem_resp_e            dmem_resp,\n\n    // AHB Interface\n    output  logic   [3:0]                   hprot,\n    output  logic   [2:0]                   hburst,\n    output  logic   [2:0]                   hsize,\n    output  logic   [1:0]                   htrans,\n    output  logic                           hmastlock,\n    output  logic   [SCR1_AHB_WIDTH-1:0]    haddr,\n    output  logic                           hwrite,\n    output  logic   [SCR1_AHB_WIDTH-1:0]    hwdata,\n    input   logic                           hready,\n    input   logic   [SCR1_AHB_WIDTH-1:0]    hrdata,\n    input   logic                           hresp\n\n);\n\n//-------------------------------------------------------------------------------\n// Local Parameters\n//-------------------------------------------------------------------------------\n`ifndef SCR1_DMEM_AHB_OUT_BP\nlocalparam  SCR1_FIFO_WIDTH = 2;\nlocalparam  SCR1_FIFO_CNT_WIDTH = $clog2(SCR1_FIFO_WIDTH+1);\n`endif // SCR1_DMEM_AHB_OUT_BP\n\n//-------------------------------------------------------------------------------\n// Local type declaration\n//-------------------------------------------------------------------------------\ntypedef enum logic {\n    SCR1_FSM_ADDR = 1'b0,\n    SCR1_FSM_DATA = 1'b1\n`ifdef SCR1_XPROP_EN\n    ,\n    SCR1_FSM_ERR  = 1'bx\n`endif // SCR1_XPROP_EN\n} type_scr1_fsm_e;\n\ntypedef struct packed {\n    logic                           hwrite;\n    logic   [2:0]                   hwidth;\n    logic   [SCR1_AHB_WIDTH-1:0]    haddr;\n    logic   [SCR1_AHB_WIDTH-1:0]    hwdata;\n} type_scr1_req_fifo_s;\n\ntypedef struct packed {\n    logic   [2:0]                   hwidth;\n    logic   [1:0]                   haddr;\n    logic   [SCR1_AHB_WIDTH-1:0]    hwdata;\n} type_scr1_data_fifo_s;\n\ntypedef struct packed {\n    logic                           hresp;\n    logic   [2:0]                   hwidth;\n    logic   [1:0]                   haddr;\n    logic   [SCR1_AHB_WIDTH-1:0]    hrdata;\n} type_scr1_resp_fifo_s;\n\n//-------------------------------------------------------------------------------\n// Local functions\n//-------------------------------------------------------------------------------\nfunction automatic logic   [2:0] scr1_conv_mem2ahb_width (\n    input   type_scr1_mem_width_e    dmem_width\n);\n    logic   [2:0]   tmp;\nbegin\n    case (dmem_width)\n        SCR1_MEM_WIDTH_BYTE : begin\n            tmp = SCR1_HSIZE_8B;\n        end\n        SCR1_MEM_WIDTH_HWORD : begin\n            tmp = SCR1_HSIZE_16B;\n        end\n        SCR1_MEM_WIDTH_WORD : begin\n            tmp = SCR1_HSIZE_32B;\n        end\n        default : begin\n            tmp = SCR1_HSIZE_ERR;\n        end\n    endcase\n    return tmp;\nend\nendfunction : scr1_conv_mem2ahb_width\n\nfunction automatic logic[SCR1_AHB_WIDTH-1:0] scr1_conv_mem2ahb_wdata (\n    input   logic   [1:0]                   dmem_addr,\n    input   type_scr1_mem_width_e           dmem_width,\n    input   logic   [SCR1_AHB_WIDTH-1:0]    dmem_wdata\n);\n    logic   [SCR1_AHB_WIDTH-1:0]  tmp;\nbegin\n`ifdef SCR1_XPROP_EN\n    tmp = 'x;\n`else // SCR1_XPROP_EN\n    tmp = '0;\n`endif // SCR1_XPROP_EN\n    case (dmem_width)\n        SCR1_MEM_WIDTH_BYTE : begin\n            case (dmem_addr)\n                2'b00 : begin\n                    tmp[7:0]   = dmem_wdata[7:0];\n                end\n                2'b01 : begin\n                    tmp[15:8]  = dmem_wdata[7:0];\n                end\n                2'b10 : begin\n                    tmp[23:16] = dmem_wdata[7:0];\n                end\n                2'b11 : begin\n                    tmp[31:24] = dmem_wdata[7:0];\n                end\n                default : begin\n                end\n            endcase\n        end\n        SCR1_MEM_WIDTH_HWORD : begin\n            case (dmem_addr[1])\n                1'b0 : begin\n                    tmp[15:0]  = dmem_wdata[15:0];\n                end\n                1'b1 : begin\n                    tmp[31:16] = dmem_wdata[15:0];\n                end\n                default : begin\n                end\n            endcase\n        end\n        SCR1_MEM_WIDTH_WORD : begin\n            tmp = dmem_wdata;\n        end\n        default : begin\n        end\n    endcase\n    return tmp;\nend\nendfunction : scr1_conv_mem2ahb_wdata\n\nfunction automatic logic[SCR1_AHB_WIDTH-1:0] scr1_conv_ahb2mem_rdata (\n    input   logic [2:0]                 hwidth,\n    input   logic [1:0]                 haddr,\n    input   logic [SCR1_AHB_WIDTH-1:0]  hrdata\n);\n    logic   [SCR1_AHB_WIDTH-1:0]  tmp;\nbegin\n`ifdef SCR1_XPROP_EN\n    tmp = 'x;\n`else // SCR1_XPROP_EN\n    tmp = '0;\n`endif // SCR1_XPROP_EN\n    case (hwidth)\n        SCR1_HSIZE_8B : begin\n            case (haddr)\n                2'b00 : tmp[7:0] = hrdata[7:0];\n                2'b01 : tmp[7:0] = hrdata[15:8];\n                2'b10 : tmp[7:0] = hrdata[23:16];\n                2'b11 : tmp[7:0] = hrdata[31:24];\n                default : begin\n                end\n            endcase\n        end\n        SCR1_HSIZE_16B : begin\n            case (haddr[1])\n                1'b0 : tmp[15:0] = hrdata[15:0];\n                1'b1 : tmp[15:0] = hrdata[31:16];\n                default : begin\n                end\n            endcase\n        end\n        SCR1_HSIZE_32B : begin\n            tmp = hrdata;\n        end\n        default : begin\n        end\n    endcase\n    return tmp;\nend\nendfunction : scr1_conv_ahb2mem_rdata\n\n//-------------------------------------------------------------------------------\n// Local signal declaration\n//-------------------------------------------------------------------------------\ntype_scr1_fsm_e                             fsm;\nlogic                                       req_fifo_rd;\nlogic                                       req_fifo_wr;\nlogic                                       req_fifo_up;\n`ifdef SCR1_DMEM_AHB_OUT_BP\ntype_scr1_req_fifo_s                        req_fifo_new;\ntype_scr1_req_fifo_s                        req_fifo_r;\ntype_scr1_req_fifo_s [0:0]                  req_fifo;\n`else // SCR1_DMEM_AHB_OUT_BP\ntype_scr1_req_fifo_s [0:SCR1_FIFO_WIDTH-1]  req_fifo;\ntype_scr1_req_fifo_s [0:SCR1_FIFO_WIDTH-1]  req_fifo_new;\nlogic       [SCR1_FIFO_CNT_WIDTH-1:0]       req_fifo_cnt;\nlogic       [SCR1_FIFO_CNT_WIDTH-1:0]       req_fifo_cnt_new;\n`endif // SCR1_DMEM_AHB_OUT_BP\nlogic                                       req_fifo_empty;\nlogic                                       req_fifo_full;\n\ntype_scr1_data_fifo_s                       data_fifo;\ntype_scr1_resp_fifo_s                       resp_fifo;\nlogic                                       resp_fifo_hready;\n\n//-------------------------------------------------------------------------------\n// Interface to Core\n//-------------------------------------------------------------------------------\nassign dmem_req_ack = ~req_fifo_full;\nassign req_fifo_wr  = ~req_fifo_full & dmem_req;\n\nassign dmem_rdata = scr1_conv_ahb2mem_rdata(resp_fifo.hwidth, resp_fifo.haddr, resp_fifo.hrdata);\n\nassign dmem_resp = (resp_fifo_hready)\n                    ? (resp_fifo.hresp == SCR1_HRESP_OKAY)\n                        ? SCR1_MEM_RESP_RDY_OK\n                        : SCR1_MEM_RESP_RDY_ER\n                    : SCR1_MEM_RESP_NOTRDY ;\n\n//-------------------------------------------------------------------------------\n// REQ_FIFO\n//-------------------------------------------------------------------------------\n`ifdef SCR1_DMEM_AHB_OUT_BP\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        req_fifo_full <= 1'b0;\n    end else begin\n        if (~req_fifo_full) begin\n            req_fifo_full <= dmem_req & ~req_fifo_rd;\n        end else begin\n            req_fifo_full <= ~req_fifo_rd;\n        end\n    end\nend\nassign req_fifo_empty = ~(req_fifo_full | dmem_req);\n\nassign req_fifo_up = ~req_fifo_rd & req_fifo_wr;\nalways_ff @(posedge clk) begin\n    if (req_fifo_up) begin\n        req_fifo_r <= req_fifo_new;\n    end\nend\n\nassign req_fifo_new.hwrite = dmem_req ? (dmem_cmd == SCR1_MEM_CMD_WR)       : 1'b0;\nassign req_fifo_new.hwidth = dmem_req ? scr1_conv_mem2ahb_width(dmem_width) : '0;\nassign req_fifo_new.haddr  = dmem_req ? dmem_addr                           : '0;\nassign req_fifo_new.hwdata = (dmem_req & (dmem_cmd == SCR1_MEM_CMD_WR))\n                                ? scr1_conv_mem2ahb_wdata(dmem_addr[1:0], dmem_width, dmem_wdata)\n                                : '0;\nassign req_fifo[0] = (req_fifo_full) ? req_fifo_r: req_fifo_new;\n\n`else // SCR1_DMEM_AHB_OUT_BP\nalways_comb begin\n    req_fifo_up      = 1'b0;\n    req_fifo_cnt_new = req_fifo_cnt;\n    req_fifo_new     = req_fifo;\n    case ({req_fifo_rd, req_fifo_wr})\n        2'b00 : begin\n            // nothing todo\n        end\n        2'b01: begin\n            // FIFO write\n            req_fifo_up = 1'b1;\n            req_fifo_new[req_fifo_cnt].hwrite = (dmem_cmd == SCR1_MEM_CMD_WR);\n            req_fifo_new[req_fifo_cnt].hwidth = scr1_conv_mem2ahb_width(dmem_width);\n            req_fifo_new[req_fifo_cnt].haddr  = dmem_addr;\n            req_fifo_new[req_fifo_cnt].hwdata = scr1_conv_mem2ahb_wdata(dmem_addr[1:0], dmem_width, dmem_wdata);\n            req_fifo_cnt_new = req_fifo_cnt + 1'b1;\n        end\n        2'b10 : begin\n            // FIFO read\n            req_fifo_up = 1'b1;\n            req_fifo_new[0] = req_fifo_new[1];\n            req_fifo_new[1].hwrite = 1'b0;\n            req_fifo_new[1].hwidth = SCR1_HSIZE_32B;\n`ifdef SCR1_XPROP_EN\n            req_fifo_new[1].haddr  = 'x;\n            req_fifo_new[1].hwdata = 'x;\n`endif // SCR1_XPROP_EN\n            req_fifo_cnt_new = req_fifo_cnt - 1'b1;\n        end\n        2'b11 : begin\n            // Read and Write FIFO. It is possible only when fifo_cnt = 1\n            req_fifo_up = 1'b1;\n            req_fifo_new[0].hwrite = (dmem_cmd == SCR1_MEM_CMD_WR);\n            req_fifo_new[0].hwidth = scr1_conv_mem2ahb_width(dmem_width);\n            req_fifo_new[0].haddr  = dmem_addr;\n            req_fifo_new[0].hwdata = scr1_conv_mem2ahb_wdata(dmem_addr[1:0], dmem_width, dmem_wdata);\n        end\n        default : begin\n`ifdef SCR1_XPROP_EN\n            req_fifo_up      = 'x;\n            req_fifo_cnt_new = 'x;\n            req_fifo_new     = 'x;\n`endif // SCR1_XPROP_EN\n        end\n    endcase\nend\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        req_fifo_cnt <= '0;\n    end else begin\n        if (req_fifo_up) begin\n            req_fifo_cnt <= req_fifo_cnt_new;\n        end\n    end\nend\nassign req_fifo_full  = (req_fifo_cnt == SCR1_FIFO_WIDTH);\nassign req_fifo_empty = ~(|req_fifo_cnt);\n\nalways_ff @(posedge clk) begin\n    if (req_fifo_up) begin\n        req_fifo <= req_fifo_new;\n    end\nend\n`endif // SCR1_DMEM_AHB_OUT_BP\n//-------------------------------------------------------------------------------\n// FSM\n//-------------------------------------------------------------------------------\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        fsm <= SCR1_FSM_ADDR;\n    end else begin\n        case (fsm)\n            SCR1_FSM_ADDR : begin\n                if (hready) begin\n                    fsm <= (req_fifo_empty) ? SCR1_FSM_ADDR : SCR1_FSM_DATA;\n                end\n            end\n            SCR1_FSM_DATA : begin\n                if (hready) begin\n                    if (hresp == SCR1_HRESP_OKAY) begin\n                        fsm <= (req_fifo_empty) ? SCR1_FSM_ADDR : SCR1_FSM_DATA;\n                    end else begin\n                        fsm <= SCR1_FSM_ADDR;\n                    end\n                end\n            end\n            default : begin\n`ifdef SCR1_XPROP_EN\n                fsm <= SCR1_FSM_ERR;\n`endif // SCR1_XPROP_EN\n            end\n        endcase\n    end\nend\n\nalways_comb begin\n    req_fifo_rd = 1'b0;\n    case (fsm)\n        SCR1_FSM_ADDR : begin\n            if (hready) begin\n                req_fifo_rd = ~req_fifo_empty;\n            end\n        end\n        SCR1_FSM_DATA : begin\n            if (hready) begin\n                req_fifo_rd = ~req_fifo_empty & (hresp == SCR1_HRESP_OKAY);\n            end\n        end\n        default : begin\n            req_fifo_rd = 1'bx;\n        end\n    endcase\nend\n\n//-------------------------------------------------------------------------------\n// FIFO data\n//-------------------------------------------------------------------------------\nalways_ff @(posedge clk) begin\n    case (fsm)\n        SCR1_FSM_ADDR : begin\n            if (~req_fifo_empty) begin\n                data_fifo.hwidth <= req_fifo[0].hwidth;\n                data_fifo.haddr  <= req_fifo[0].haddr[1:0];\n                data_fifo.hwdata <= req_fifo[0].hwdata;\n            end\n        end\n        SCR1_FSM_DATA : begin\n            if (hready) begin\n                if (hresp == SCR1_HRESP_OKAY) begin\n                    if (~req_fifo_empty) begin\n                        data_fifo.hwidth <= req_fifo[0].hwidth;\n                        data_fifo.haddr  <= req_fifo[0].haddr[1:0];\n                        data_fifo.hwdata <= req_fifo[0].hwdata;\n                    end\n                end\n            end\n        end\n        default : begin\n        end\n    endcase\nend\n\n//-------------------------------------------------------------------------------\n// FIFO response\n//-------------------------------------------------------------------------------\n`ifdef SCR1_DMEM_AHB_IN_BP\nassign resp_fifo_hready = (fsm == SCR1_FSM_DATA) ? hready : 1'b0;\nassign resp_fifo.hresp  = hresp;\nassign resp_fifo.hwidth = data_fifo.hwidth;\nassign resp_fifo.haddr  = data_fifo.haddr;\nassign resp_fifo.hrdata = hrdata;\n`else // SCR1_DMEM_AHB_IN_BP\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        resp_fifo_hready <= 1'b0;\n    end else begin\n        resp_fifo_hready <= (fsm == SCR1_FSM_DATA) ? hready : 1'b0;\n    end\nend\n\nalways_ff @(posedge clk) begin\n    if (hready & (fsm == SCR1_FSM_DATA)) begin\n        resp_fifo.hresp  <= hresp;\n        resp_fifo.hwidth <= data_fifo.hwidth;\n        resp_fifo.haddr  <= data_fifo.haddr;\n        resp_fifo.hrdata <= hrdata;\n    end\nend\n`endif // SCR1_DMEM_AHB_IN_BP\n\n//-------------------------------------------------------------------------------\n// Interface to AHB\n//-------------------------------------------------------------------------------\nassign hprot[SCR1_HPROT_DATA]  = 1'b1;\nassign hprot[SCR1_HPROT_PRV]   = 1'b0;\nassign hprot[SCR1_HPROT_BUF]   = 1'b0;\nassign hprot[SCR1_HPROT_CACHE] = 1'b0;\n\nassign hburst       = SCR1_HBURST_SINGLE;\nassign hsize        = req_fifo[0].hwidth;\nassign hmastlock    = 1'b0;\n\nalways_comb begin\n    htrans = SCR1_HTRANS_IDLE;\n    case (fsm)\n        SCR1_FSM_ADDR : begin\n            if (~req_fifo_empty) begin\n                htrans = SCR1_HTRANS_NONSEQ;\n            end\n        end\n        SCR1_FSM_DATA : begin\n            if (hready) begin\n                if (hresp == SCR1_HRESP_OKAY) begin\n                    if (~req_fifo_empty) begin\n                        htrans = SCR1_HTRANS_NONSEQ;\n                    end\n                end\n            end\n        end\n        default : begin\n            htrans = SCR1_HTRANS_ERR;\n        end\n    endcase\nend\n\nassign haddr  = req_fifo[0].haddr;\nassign hwrite = req_fifo[0].hwrite;\nassign hwdata = data_fifo.hwdata;\n\nendmodule : scr1_dmem_ahb\n"}
{"text": "/// Copyright by Syntacore LLC \u00a9 2016-2021. See LICENSE for details\n/// @file       <scr1_dmem_router.sv>\n/// @brief      Data memory router\n///\n`include \"scr1_memif.svh\"\n`include \"scr1_arch_description.svh\"\n\nmodule scr1_dmem_router\n#(\n    parameter SCR1_PORT1_ADDR_MASK      = `SCR1_DMEM_AWIDTH'hFFFF0000,\n    parameter SCR1_PORT1_ADDR_PATTERN   = `SCR1_DMEM_AWIDTH'h00010000,\n    parameter SCR1_PORT2_ADDR_MASK      = `SCR1_DMEM_AWIDTH'hFFFF0000,\n    parameter SCR1_PORT2_ADDR_PATTERN   = `SCR1_DMEM_AWIDTH'h00020000\n)\n(\n    // Control signals\n    input   logic                           rst_n,\n    input   logic                           clk,\n\n    // Core interface\n    output  logic                           dmem_req_ack,\n    input   logic                           dmem_req,\n    input   type_scr1_mem_cmd_e             dmem_cmd,\n    input   type_scr1_mem_width_e           dmem_width,\n    input   logic [`SCR1_DMEM_AWIDTH-1:0]   dmem_addr,\n    input   logic [`SCR1_DMEM_DWIDTH-1:0]   dmem_wdata,\n    output  logic [`SCR1_DMEM_DWIDTH-1:0]   dmem_rdata,\n    output  type_scr1_mem_resp_e            dmem_resp,\n\n    // PORT0 interface\n    input   logic                           port0_req_ack,\n    output  logic                           port0_req,\n    output  type_scr1_mem_cmd_e             port0_cmd,\n    output  type_scr1_mem_width_e           port0_width,\n    output  logic [`SCR1_DMEM_AWIDTH-1:0]   port0_addr,\n    output  logic [`SCR1_DMEM_DWIDTH-1:0]   port0_wdata,\n    input   logic [`SCR1_DMEM_DWIDTH-1:0]   port0_rdata,\n    input   type_scr1_mem_resp_e            port0_resp,\n\n    // PORT1 interface\n    input   logic                           port1_req_ack,\n    output  logic                           port1_req,\n    output  type_scr1_mem_cmd_e             port1_cmd,\n    output  type_scr1_mem_width_e           port1_width,\n    output  logic [`SCR1_DMEM_AWIDTH-1:0]   port1_addr,\n    output  logic [`SCR1_DMEM_DWIDTH-1:0]   port1_wdata,\n    input   logic [`SCR1_DMEM_DWIDTH-1:0]   port1_rdata,\n    input   type_scr1_mem_resp_e            port1_resp,\n\n    // PORT2 interface\n    input   logic                           port2_req_ack,\n    output  logic                           port2_req,\n    output  type_scr1_mem_cmd_e             port2_cmd,\n    output  type_scr1_mem_width_e           port2_width,\n    output  logic [`SCR1_DMEM_AWIDTH-1:0]   port2_addr,\n    output  logic [`SCR1_DMEM_DWIDTH-1:0]   port2_wdata,\n    input   logic [`SCR1_DMEM_DWIDTH-1:0]   port2_rdata,\n    input   type_scr1_mem_resp_e            port2_resp\n);\n\n//-------------------------------------------------------------------------------\n// Local types declaration\n//-------------------------------------------------------------------------------\ntypedef enum logic {\n    SCR1_FSM_ADDR,\n    SCR1_FSM_DATA\n} type_scr1_fsm_e;\n\ntypedef enum logic [1:0] {\n    SCR1_SEL_PORT0,\n    SCR1_SEL_PORT1,\n    SCR1_SEL_PORT2\n} type_scr1_sel_e;\n\n//-------------------------------------------------------------------------------\n// Local signal declaration\n//-------------------------------------------------------------------------------\ntype_scr1_fsm_e                 fsm;\ntype_scr1_sel_e                 port_sel;\ntype_scr1_sel_e                 port_sel_r;\nlogic [`SCR1_DMEM_DWIDTH-1:0]   sel_rdata;\ntype_scr1_mem_resp_e            sel_resp;\nlogic                           sel_req_ack;\n\n//-------------------------------------------------------------------------------\n// FSM\n//-------------------------------------------------------------------------------\nalways_comb begin\n    port_sel    = SCR1_SEL_PORT0;\n    if ((dmem_addr & SCR1_PORT1_ADDR_MASK) == SCR1_PORT1_ADDR_PATTERN) begin\n        port_sel    = SCR1_SEL_PORT1;\n    end else if ((dmem_addr & SCR1_PORT2_ADDR_MASK) == SCR1_PORT2_ADDR_PATTERN) begin\n        port_sel    = SCR1_SEL_PORT2;\n    end\nend\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        fsm         <= SCR1_FSM_ADDR;\n        port_sel_r  <= SCR1_SEL_PORT0;\n    end else begin\n        case (fsm)\n            SCR1_FSM_ADDR : begin\n                if (dmem_req & sel_req_ack) begin\n                    fsm         <= SCR1_FSM_DATA;\n                    port_sel_r  <= port_sel;\n                end\n            end\n            SCR1_FSM_DATA : begin\n                case (sel_resp)\n                    SCR1_MEM_RESP_RDY_OK : begin\n                        if (dmem_req & sel_req_ack) begin\n                            fsm         <= SCR1_FSM_DATA;\n                            port_sel_r  <= port_sel;\n                        end else begin\n                            fsm <= SCR1_FSM_ADDR;\n                        end\n                    end\n                    SCR1_MEM_RESP_RDY_ER : begin\n                        fsm <= SCR1_FSM_ADDR;\n                    end\n                    default : begin\n                    end\n                endcase\n            end\n            default : begin\n            end\n        endcase\n    end\nend\n\nalways_comb begin\n    if ((fsm == SCR1_FSM_ADDR) | ((fsm == SCR1_FSM_DATA) & (sel_resp == SCR1_MEM_RESP_RDY_OK))) begin\n        case (port_sel)\n            SCR1_SEL_PORT0  : sel_req_ack   = port0_req_ack;\n            SCR1_SEL_PORT1  : sel_req_ack   = port1_req_ack;\n            SCR1_SEL_PORT2  : sel_req_ack   = port2_req_ack;\n            default         : sel_req_ack   = 1'b0;\n        endcase\n    end else begin\n        sel_req_ack = 1'b0;\n    end\nend\n\nalways_comb begin\n    case (port_sel_r)\n        SCR1_SEL_PORT0  : begin\n            sel_rdata   = port0_rdata;\n            sel_resp    = port0_resp;\n        end\n        SCR1_SEL_PORT1  : begin\n            sel_rdata   = port1_rdata;\n            sel_resp    = port1_resp;\n        end\n        SCR1_SEL_PORT2  : begin\n            sel_rdata   = port2_rdata;\n            sel_resp    = port2_resp;\n        end\n        default         : begin\n            sel_rdata   = '0;\n            sel_resp    = SCR1_MEM_RESP_RDY_ER;\n        end\n    endcase\nend\n\n//-------------------------------------------------------------------------------\n// Interface to core\n//-------------------------------------------------------------------------------\nassign dmem_req_ack = sel_req_ack;\nassign dmem_rdata   = sel_rdata;\nassign dmem_resp    = sel_resp;\n\n//-------------------------------------------------------------------------------\n// Interface to PORT0\n//-------------------------------------------------------------------------------\nalways_comb begin\n    port0_req = 1'b0;\n    case (fsm)\n        SCR1_FSM_ADDR : begin\n            port0_req = dmem_req & (port_sel == SCR1_SEL_PORT0);\n        end\n        SCR1_FSM_DATA : begin\n            if (sel_resp == SCR1_MEM_RESP_RDY_OK) begin\n                port0_req = dmem_req & (port_sel == SCR1_SEL_PORT0);\n            end\n        end\n        default : begin\n        end\n    endcase\nend\n\n`ifdef SCR1_XPROP_EN\nassign port0_cmd    = (port_sel == SCR1_SEL_PORT0) ? dmem_cmd   : SCR1_MEM_CMD_ERROR;\nassign port0_width  = (port_sel == SCR1_SEL_PORT0) ? dmem_width : SCR1_MEM_WIDTH_ERROR;\nassign port0_addr   = (port_sel == SCR1_SEL_PORT0) ? dmem_addr  : 'x;\nassign port0_wdata  = (port_sel == SCR1_SEL_PORT0) ? dmem_wdata : 'x;\n`else // SCR1_XPROP_EN\nassign port0_cmd    = dmem_cmd  ;\nassign port0_width  = dmem_width;\nassign port0_addr   = dmem_addr ;\nassign port0_wdata  = dmem_wdata;\n`endif // SCR1_XPROP_EN\n\n//-------------------------------------------------------------------------------\n// Interface to PORT1\n//-------------------------------------------------------------------------------\nalways_comb begin\n    port1_req = 1'b0;\n    case (fsm)\n        SCR1_FSM_ADDR : begin\n            port1_req = dmem_req & (port_sel == SCR1_SEL_PORT1);\n        end\n        SCR1_FSM_DATA : begin\n            if (sel_resp == SCR1_MEM_RESP_RDY_OK) begin\n                port1_req = dmem_req & (port_sel == SCR1_SEL_PORT1);\n            end\n        end\n        default : begin\n        end\n    endcase\nend\n\n`ifdef SCR1_XPROP_EN\nassign port1_cmd    = (port_sel == SCR1_SEL_PORT1) ? dmem_cmd   : SCR1_MEM_CMD_ERROR;\nassign port1_width  = (port_sel == SCR1_SEL_PORT1) ? dmem_width : SCR1_MEM_WIDTH_ERROR;\nassign port1_addr   = (port_sel == SCR1_SEL_PORT1) ? dmem_addr  : 'x;\nassign port1_wdata  = (port_sel == SCR1_SEL_PORT1) ? dmem_wdata : 'x;\n`else // SCR1_XPROP_EN\nassign port1_cmd    = dmem_cmd  ;\nassign port1_width  = dmem_width;\nassign port1_addr   = dmem_addr ;\nassign port1_wdata  = dmem_wdata;\n`endif // SCR1_XPROP_EN\n\n//-------------------------------------------------------------------------------\n// Interface to PORT2\n//-------------------------------------------------------------------------------\nalways_comb begin\n    port2_req = 1'b0;\n    case (fsm)\n        SCR1_FSM_ADDR : begin\n            port2_req = dmem_req & (port_sel == SCR1_SEL_PORT2);\n        end\n        SCR1_FSM_DATA : begin\n            if (sel_resp == SCR1_MEM_RESP_RDY_OK) begin\n                port2_req = dmem_req & (port_sel == SCR1_SEL_PORT2);\n            end\n        end\n        default : begin\n        end\n    endcase\nend\n\n`ifdef SCR1_XPROP_EN\nassign port2_cmd    = (port_sel == SCR1_SEL_PORT2) ? dmem_cmd   : SCR1_MEM_CMD_ERROR;\nassign port2_width  = (port_sel == SCR1_SEL_PORT2) ? dmem_width : SCR1_MEM_WIDTH_ERROR;\nassign port2_addr   = (port_sel == SCR1_SEL_PORT2) ? dmem_addr  : 'x;\nassign port2_wdata  = (port_sel == SCR1_SEL_PORT2) ? dmem_wdata : 'x;\n`else // SCR1_XPROP_EN\nassign port2_cmd    = dmem_cmd  ;\nassign port2_width  = dmem_width;\nassign port2_addr   = dmem_addr ;\nassign port2_wdata  = dmem_wdata;\n`endif // SCR1_XPROP_EN\n\n`ifdef SCR1_TRGT_SIMULATION\n//-------------------------------------------------------------------------------\n// Assertion\n//-------------------------------------------------------------------------------\n\nSCR1_SVA_DMEM_RT_XCHECK : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    dmem_req |-> !$isunknown({port_sel, dmem_cmd, dmem_width})\n    ) else $error(\"DMEM router Error: unknown values\");\n\n`endif // SCR1_TRGT_SIMULATION\n\nendmodule : scr1_dmem_router\n"}
{"text": "/// Copyright by Syntacore LLC \u00a9 2016-2021. See LICENSE for details\n/// @file       <scr1_dmi.sv>\n/// @brief      Debug Module Interface (DMI)\n///\n\n//------------------------------------------------------------------------------\n //\n // Functionality:\n // - Provides TAPC with access to Debug Module (DM) and DTMCS\n //\n // Structure:\n // - DMI <-> TAP interface\n // - DMI <-> DM interface\n //\n//------------------------------------------------------------------------------\n\n`include \"scr1_arch_description.svh\"\n\n`ifdef SCR1_DBG_EN\n`include \"scr1_dm.svh\"\n\nmodule scr1_dmi (\n    // System\n    input  logic                                    rst_n,                      // DMI unit reset\n    input  logic                                    clk,                        // DMI unit clock\n\n    // TAP interface\n    input  logic                                    tapcsync2dmi_ch_sel_i,      // Debug Transport Module Chain Select\n    input  logic [SCR1_DBG_DMI_CH_ID_WIDTH-1:0]     tapcsync2dmi_ch_id_i,       // Debug Transport Module Chain ID\n    input  logic                                    tapcsync2dmi_ch_capture_i,  // Debug Transport Module Chain Capture\n    input  logic                                    tapcsync2dmi_ch_shift_i,    // Debug Transport Module Chain Shift\n    input  logic                                    tapcsync2dmi_ch_update_i,   // Debug Transport Module Chain Update\n    input  logic                                    tapcsync2dmi_ch_tdi_i,      // Debug Transport Module Chain TDI\n    output logic                                    dmi2tapcsync_ch_tdo_o,      // Debug Transport Module Chain TDO\n\n    // DM interface\n    input logic                                     dm2dmi_resp_i,              // DMI response\n    input logic [SCR1_DBG_DMI_DATA_WIDTH-1:0]       dm2dmi_rdata_i,             // DMI read data\n    output logic                                    dmi2dm_req_o,               // DMI request\n    output logic                                    dmi2dm_wr_o,                // DMI write\n    output logic [SCR1_DBG_DMI_ADDR_WIDTH-1:0]      dmi2dm_addr_o,              // DMI address\n    output logic [SCR1_DBG_DMI_DATA_WIDTH-1:0]      dmi2dm_wdata_o              // DMI write data\n);\n\n//------------------------------------------------------------------------------\n// Local parameters declaration\n//------------------------------------------------------------------------------\n\n// Debug Transport Module Status parameters\n//------------------------------------------------------------------------------\n\nlocalparam    DTMCS_RESERVEDB_HI = 5'd31;\nlocalparam    DTMCS_RESERVEDB_LO = 5'd18;\nlocalparam    DTMCS_DMIHARDRESET = 5'd17;\nlocalparam    DTMCS_DMIRESET     = 5'd16;\nlocalparam    DTMCS_RESERVEDA    = 5'd15;\nlocalparam    DTMCS_IDLE_HI      = 5'd14;\nlocalparam    DTMCS_IDLE_LO      = 5'd12;\nlocalparam    DTMCS_DMISTAT_HI   = 5'd11;\nlocalparam    DTMCS_DMISTAT_LO   = 5'd10;\nlocalparam    DTMCS_ABITS_HI     = 5'd9;\nlocalparam    DTMCS_ABITS_LO     = 5'd4;\nlocalparam    DTMCS_VERSION_HI   = 5'd3;\nlocalparam    DTMCS_VERSION_LO   = 5'd0;\n\n// Debug Module Interface parameters\n//------------------------------------------------------------------------------\n\nlocalparam    DMI_OP_LO   = 5'd0;\nlocalparam    DMI_OP_HI   = DMI_OP_LO   + SCR1_DBG_DMI_OP_WIDTH   - 1;\nlocalparam    DMI_DATA_LO = DMI_OP_HI   + 1;\nlocalparam    DMI_DATA_HI = DMI_DATA_LO + SCR1_DBG_DMI_DATA_WIDTH - 1;\nlocalparam    DMI_ADDR_LO = DMI_DATA_HI + 1;\nlocalparam    DMI_ADDR_HI = DMI_ADDR_LO + SCR1_DBG_DMI_ADDR_WIDTH - 1;\n\n//------------------------------------------------------------------------------\n// Local signals declaration\n//------------------------------------------------------------------------------\n\n// TAP data register\nlogic                                               tap_dr_upd;\nlogic [SCR1_DBG_DMI_DR_DMI_ACCESS_WIDTH-1:0]        tap_dr_ff;\nlogic [SCR1_DBG_DMI_DR_DMI_ACCESS_WIDTH-1:0]        tap_dr_shift;\nlogic [SCR1_DBG_DMI_DR_DMI_ACCESS_WIDTH-1:0]        tap_dr_rdata;\nlogic [SCR1_DBG_DMI_DR_DMI_ACCESS_WIDTH-1:0]        tap_dr_next;\n\n// DM read data register\nlogic                                               dm_rdata_upd;\nlogic [SCR1_DBG_DMI_DATA_WIDTH-1:0]                 dm_rdata_ff;\n\nlogic                                               tapc_dmi_access_req;\nlogic                                               tapc_dtmcs_sel;\n\n//------------------------------------------------------------------------------\n// DMI <-> TAP interface\n//------------------------------------------------------------------------------\n\n// TAPC read data multiplexer\n//------------------------------------------------------------------------------\n\nassign tapc_dtmcs_sel = (tapcsync2dmi_ch_id_i == 1'd1);\n\n// DMI operation is always successful in the current implementation\nalways_comb begin\n    tap_dr_rdata = '0;\n\n    if(tapc_dtmcs_sel) begin\n        tap_dr_rdata[DTMCS_RESERVEDB_HI:DTMCS_RESERVEDB_LO] = 'b0;\n        tap_dr_rdata[DTMCS_DMIHARDRESET]                    = 'b0;\n        tap_dr_rdata[DTMCS_DMIRESET]                        = 'b0;\n        tap_dr_rdata[DTMCS_RESERVEDA]                       = 'b0;\n        tap_dr_rdata[DTMCS_IDLE_HI:DTMCS_IDLE_LO]           = 'b0;\n        tap_dr_rdata[DTMCS_DMISTAT_HI:DTMCS_DMISTAT_LO]     = 'b0;\n        tap_dr_rdata[DTMCS_ABITS_HI  :DTMCS_ABITS_LO]       = SCR1_DBG_DMI_ADDR_WIDTH;\n        tap_dr_rdata[DTMCS_VERSION_LO]                      = 1'b1;\n    end else begin\n        tap_dr_rdata[DMI_ADDR_HI:DMI_ADDR_LO]               = 'b0;\n        tap_dr_rdata[DMI_DATA_HI:DMI_DATA_LO]               = dm_rdata_ff;\n        tap_dr_rdata[DMI_OP_HI  :DMI_OP_LO]                 = 'b0;\n    end\nend\n\nassign tap_dr_shift = tapc_dtmcs_sel\n                    ? {9'b0, tapcsync2dmi_ch_tdi_i, tap_dr_ff[SCR1_DBG_DMI_DR_DTMCS_WIDTH-1:1]}\n                    : {tapcsync2dmi_ch_tdi_i, tap_dr_ff[SCR1_DBG_DMI_DR_DMI_ACCESS_WIDTH-1:1]};\n\n// TAP data register\n//------------------------------------------------------------------------------\n\nassign tap_dr_upd = tapcsync2dmi_ch_capture_i | tapcsync2dmi_ch_shift_i;\n\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        tap_dr_ff <= '0;\n    end else if(tap_dr_upd) begin\n        tap_dr_ff <= tap_dr_next;\n    end\nend\n\nassign tap_dr_next = tapcsync2dmi_ch_capture_i ? tap_dr_rdata\n                   : tapcsync2dmi_ch_shift_i   ? tap_dr_shift\n                                               : tap_dr_ff;\n\nassign dmi2tapcsync_ch_tdo_o = tap_dr_ff[0];\n\n//------------------------------------------------------------------------------\n// DMI <-> DM interface\n//------------------------------------------------------------------------------\n\nassign tapc_dmi_access_req = tapcsync2dmi_ch_update_i & tapcsync2dmi_ch_sel_i\n                           & (tapcsync2dmi_ch_id_i == 2'd2);\n\nalways_comb begin\n    dmi2dm_req_o           = 1'b0;\n    dmi2dm_wr_o            = 1'b0;\n    dmi2dm_addr_o          = 1'b0;\n    dmi2dm_wdata_o         = 1'b0;\n\n    if(tapc_dmi_access_req) begin\n        dmi2dm_req_o   = tap_dr_ff[DMI_OP_HI  :DMI_OP_LO] != 2'b00;\n        dmi2dm_wr_o    = tap_dr_ff[DMI_OP_HI  :DMI_OP_LO] == 2'b10;\n        dmi2dm_addr_o  = tap_dr_ff[DMI_ADDR_HI:DMI_ADDR_LO];\n        dmi2dm_wdata_o = tap_dr_ff[DMI_DATA_HI:DMI_DATA_LO];\n    end\nend\n\n// DM read data register\n//------------------------------------------------------------------------------\n\nassign dm_rdata_upd = dmi2dm_req_o & dm2dmi_resp_i & ~dmi2dm_wr_o;\n\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        dm_rdata_ff <= '0;\n    end else if (dm_rdata_upd) begin\n        dm_rdata_ff <= dm2dmi_rdata_i;\n    end\nend\n\nendmodule : scr1_dmi\n\n`endif // SCR1_DBG_EN\n"}
{"text": "/// Copyright by Syntacore LLC \u00a9 2016-2020. See LICENSE for details\n/// @file       <scr1_dp_memory.sv>\n/// @brief      Dual-port synchronous memory with byte enable inputs\n///\n\n`include \"scr1_arch_description.svh\"\n\n`ifdef SCR1_TCM_EN\nmodule scr1_dp_memory\n#(\n    parameter SCR1_WIDTH    = 32,\n    parameter SCR1_SIZE     = `SCR1_IMEM_AWIDTH'h00010000,\n    parameter SCR1_NBYTES   = SCR1_WIDTH / 8\n)\n(\n    input   logic                           clk,\n    // Port A\n    input   logic                           rena,\n    input   logic [$clog2(SCR1_SIZE)-1:2]   addra,\n    output  logic [SCR1_WIDTH-1:0]          qa,\n    // Port B\n    input   logic                           renb,\n    input   logic                           wenb,\n    input   logic [SCR1_NBYTES-1:0]         webb,\n    input   logic [$clog2(SCR1_SIZE)-1:2]   addrb,\n    input   logic [SCR1_WIDTH-1:0]          datab,\n    output  logic [SCR1_WIDTH-1:0]          qb\n);\n\n`ifdef SCR1_TRGT_FPGA_INTEL\n//-------------------------------------------------------------------------------\n// Local signal declaration\n//-------------------------------------------------------------------------------\n `ifdef SCR1_TRGT_FPGA_INTEL_MAX10\n(* ramstyle = \"M9K\" *)    logic [SCR1_NBYTES-1:0][7:0]  memory_array  [0:(SCR1_SIZE/SCR1_NBYTES)-1];\n `elsif SCR1_TRGT_FPGA_INTEL_ARRIAV\n(* ramstyle = \"M10K\" *)   logic [SCR1_NBYTES-1:0][7:0]  memory_array  [0:(SCR1_SIZE/SCR1_NBYTES)-1];\n `endif\nlogic [3:0] wenbb;\n//-------------------------------------------------------------------------------\n// Port B memory behavioral description\n//-------------------------------------------------------------------------------\nassign wenbb = {4{wenb}} & webb;\nalways_ff @(posedge clk) begin\n    if (wenb) begin\n        if (wenbb[0]) begin\n            memory_array[addrb][0] <= datab[0+:8];\n        end\n        if (wenbb[1]) begin\n            memory_array[addrb][1] <= datab[8+:8];\n        end\n        if (wenbb[2]) begin\n            memory_array[addrb][2] <= datab[16+:8];\n        end\n        if (wenbb[3]) begin\n            memory_array[addrb][3] <= datab[24+:8];\n        end\n    end\n    qb <= memory_array[addrb];\nend\n//-------------------------------------------------------------------------------\n// Port A memory behavioral description\n//-------------------------------------------------------------------------------\nalways_ff @(posedge clk) begin\n    qa <= memory_array[addra];\nend\n\n`else // SCR1_TRGT_FPGA_INTEL\n\n// CASE: OTHERS - SCR1_TRGT_FPGA_XILINX, SIMULATION, ASIC etc\n\nlocalparam int unsigned RAM_SIZE_WORDS = SCR1_SIZE/SCR1_NBYTES;\n\n//-------------------------------------------------------------------------------\n// Local signal declaration\n//-------------------------------------------------------------------------------\n `ifdef SCR1_TRGT_FPGA_XILINX\n(* ram_style = \"block\" *)  logic  [SCR1_WIDTH-1:0]  ram_block  [RAM_SIZE_WORDS-1:0];\n `else  // ASIC or SIMULATION\nlogic  [SCR1_WIDTH-1:0]  ram_block  [RAM_SIZE_WORDS-1:0];\n `endif\n//-------------------------------------------------------------------------------\n// Port A memory behavioral description\n//-------------------------------------------------------------------------------\nalways_ff @(posedge clk) begin\n    if (rena) begin\n        qa <= ram_block[addra];\n    end\nend\n\n//-------------------------------------------------------------------------------\n// Port B memory behavioral description\n//-------------------------------------------------------------------------------\nalways_ff @(posedge clk) begin\n    if (wenb) begin\n        for (int i=0; i<SCR1_NBYTES; i++) begin\n            if (webb[i]) begin\n                ram_block[addrb][i*8 +: 8] <= datab[i*8 +: 8];\n            end\n        end\n    end\n    if (renb) begin\n        qb <= ram_block[addrb];\n    end\nend\n\n`endif // SCR1_TRGT_FPGA_INTEL\n\nendmodule : scr1_dp_memory\n\n`endif // SCR1_TCM_EN\n"}
{"text": "/// Copyright by Syntacore LLC  2016-2021. See LICENSE for details\n/// @file       <scr1_imem_ahb.sv>\n/// @brief      Instruction memory AHB bridge\n///\n\n`include \"scr1_ahb.svh\"\n`include \"scr1_memif.svh\"\n\nmodule scr1_imem_ahb (\n    // Control Signals\n    input   logic                           rst_n,\n    input   logic                           clk,\n\n    // Core Interface\n    output  logic                           imem_req_ack,\n    input   logic                           imem_req,\n    input   logic   [SCR1_AHB_WIDTH-1:0]    imem_addr,\n    output  logic   [SCR1_AHB_WIDTH-1:0]    imem_rdata,\n    output  type_scr1_mem_resp_e            imem_resp,\n\n    // AHB Interface\n    output  logic   [3:0]                   hprot,\n    output  logic   [2:0]                   hburst,\n    output  logic   [2:0]                   hsize,\n    output  logic   [1:0]                   htrans,\n    output  logic                           hmastlock,\n    output  logic   [SCR1_AHB_WIDTH-1:0]    haddr,\n    input   logic                           hready,\n    input   logic   [SCR1_AHB_WIDTH-1:0]    hrdata,\n    input   logic                           hresp\n\n);\n\n//-------------------------------------------------------------------------------\n// Local parameters declaration\n//-------------------------------------------------------------------------------\n`ifndef SCR1_IMEM_AHB_OUT_BP\nlocalparam  SCR1_FIFO_WIDTH = 2;\nlocalparam  SCR1_FIFO_CNT_WIDTH = $clog2(SCR1_FIFO_WIDTH+1);\n`endif // SCR1_IMEM_AHB_OUT_BP\n\n//-------------------------------------------------------------------------------\n// Local types declaration\n//-------------------------------------------------------------------------------\ntypedef enum logic {\n    SCR1_FSM_ADDR = 1'b0,\n    SCR1_FSM_DATA = 1'b1,\n    SCR1_FSM_ERR  = 1'bx\n} type_scr1_fsm_e;\n\ntypedef struct packed {\n    logic   [SCR1_AHB_WIDTH-1:0]    haddr;\n} type_scr1_req_fifo_s;\n\ntypedef struct packed {\n    logic                           hresp;\n    logic   [SCR1_AHB_WIDTH-1:0]    hrdata;\n} type_scr1_resp_fifo_s;\n\n//-------------------------------------------------------------------------------\n// Local signal declaration\n//-------------------------------------------------------------------------------\ntype_scr1_fsm_e                             fsm;\nlogic                                       req_fifo_rd;\nlogic                                       req_fifo_wr;\nlogic                                       req_fifo_up;\n`ifdef SCR1_IMEM_AHB_OUT_BP\ntype_scr1_req_fifo_s                        req_fifo_r;\ntype_scr1_req_fifo_s [0:0]                  req_fifo;\n`else // SCR1_IMEM_AHB_OUT_BP\ntype_scr1_req_fifo_s [0:SCR1_FIFO_WIDTH-1]  req_fifo;\ntype_scr1_req_fifo_s [0:SCR1_FIFO_WIDTH-1]  req_fifo_new;\nlogic       [SCR1_FIFO_CNT_WIDTH-1:0]       req_fifo_cnt;\nlogic       [SCR1_FIFO_CNT_WIDTH-1:0]       req_fifo_cnt_new;\n`endif // SCR1_IMEM_AHB_OUT_BP\nlogic                                       req_fifo_empty;\nlogic                                       req_fifo_full;\n\ntype_scr1_resp_fifo_s                       resp_fifo;\nlogic                                       resp_fifo_hready;\n\n//-------------------------------------------------------------------------------\n// Interface to Core\n//-------------------------------------------------------------------------------\nassign imem_req_ack = ~req_fifo_full;\nassign req_fifo_wr  = ~req_fifo_full & imem_req;\n\nassign imem_rdata = resp_fifo.hrdata;\n\nassign imem_resp = (resp_fifo_hready)\n                    ? (resp_fifo.hresp == SCR1_HRESP_OKAY)\n                        ? SCR1_MEM_RESP_RDY_OK\n                        : SCR1_MEM_RESP_RDY_ER\n                    : SCR1_MEM_RESP_NOTRDY;\n\n//-------------------------------------------------------------------------------\n// REQ_FIFO\n//-------------------------------------------------------------------------------\n`ifdef SCR1_IMEM_AHB_OUT_BP\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        req_fifo_full <= 1'b0;\n    end else begin\n        if (~req_fifo_full) begin\n            req_fifo_full <= imem_req & ~req_fifo_rd;\n        end else begin\n            req_fifo_full <= ~req_fifo_rd;\n        end\n    end\nend\nassign req_fifo_empty = ~(req_fifo_full | imem_req);\n\nassign req_fifo_up    = ~req_fifo_rd & req_fifo_wr;\nalways_ff @(posedge clk) begin\n    if (req_fifo_up) begin\n        req_fifo_r.haddr <= imem_addr;\n    end\nend\n\nassign req_fifo[0] = (req_fifo_full) ? req_fifo_r : imem_addr;\n\n`else // SCR1_IMEM_AHB_OUT_BP\nalways_comb begin\n    req_fifo_up      = 1'b0;\n    req_fifo_cnt_new = req_fifo_cnt;\n    req_fifo_new     = req_fifo;\n    case ({req_fifo_rd, req_fifo_wr})\n        2'b00 : begin\n            // nothing todo\n        end\n        2'b01: begin\n            // FIFO write\n            req_fifo_up = 1'b1;\n            req_fifo_new[req_fifo_cnt].haddr  = imem_addr;\n            req_fifo_cnt_new = req_fifo_cnt + 1'b1;\n        end\n        2'b10 : begin\n            // FIFO read\n            req_fifo_up     = 1'b1;\n            req_fifo_new[0] = req_fifo_new[1];\n            req_fifo_new[1].haddr  = 'x;\n            req_fifo_cnt_new = req_fifo_cnt - 1'b1;\n        end\n        2'b11 : begin\n            // Read and Write FIFO. It is possible only when fifo_cnt = 1\n            req_fifo_up           = 1'b1;\n            req_fifo_new[0].haddr = imem_addr;\n        end\n        default : begin\n            req_fifo_up      = 'x;\n            req_fifo_cnt_new = 'x;\n            req_fifo_new     = 'x;\n        end\n    endcase\nend\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        req_fifo_cnt <= '0;\n    end else begin\n        if (req_fifo_up) begin\n            req_fifo_cnt <= req_fifo_cnt_new;\n        end\n    end\nend\nassign req_fifo_full  = (req_fifo_cnt == SCR1_FIFO_WIDTH);\nassign req_fifo_empty = ~(|req_fifo_cnt);\n\nalways_ff @(posedge clk) begin\n    if (req_fifo_up) begin\n        req_fifo <= req_fifo_new;\n    end\nend\n`endif // SCR1_IMEM_AHB_OUT_BP\n\n//-------------------------------------------------------------------------------\n// FSM\n//-------------------------------------------------------------------------------\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        fsm <= SCR1_FSM_ADDR;\n    end else begin\n        case (fsm)\n            SCR1_FSM_ADDR : begin\n                if (hready) begin\n                    fsm <= (req_fifo_empty) ? SCR1_FSM_ADDR : SCR1_FSM_DATA;\n                end\n            end\n            SCR1_FSM_DATA : begin\n                if (hready) begin\n                    if (hresp == SCR1_HRESP_OKAY) begin\n                        fsm <= (req_fifo_empty) ? SCR1_FSM_ADDR : SCR1_FSM_DATA;\n                    end else begin\n                        fsm <= SCR1_FSM_ADDR;\n                    end\n                end\n            end\n            default : begin\n                fsm <= SCR1_FSM_ERR;\n            end\n        endcase\n    end\nend\n\nalways_comb begin\n    req_fifo_rd = 1'b0;\n    case (fsm)\n        SCR1_FSM_ADDR : begin\n            if (hready) begin\n                req_fifo_rd = ~req_fifo_empty;\n            end\n        end\n        SCR1_FSM_DATA : begin\n            if (hready) begin\n                req_fifo_rd = ~req_fifo_empty & (hresp == SCR1_HRESP_OKAY);\n            end\n        end\n        default : begin\n            req_fifo_rd = 1'bx;\n        end\n    endcase\nend\n\n//-------------------------------------------------------------------------------\n// FIFO response\n//-------------------------------------------------------------------------------\n`ifdef SCR1_IMEM_AHB_IN_BP\nassign resp_fifo_hready = (fsm == SCR1_FSM_DATA) ? hready : 1'b0;\nassign resp_fifo.hresp  = hresp;\nassign resp_fifo.hrdata = hrdata;\n`else // SCR1_IMEM_AHB_IN_BP\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        resp_fifo_hready <= 1'b0;\n    end else begin\n        resp_fifo_hready <= (fsm == SCR1_FSM_DATA) ? hready : 1'b0;\n    end\nend\n\nalways_ff @(posedge clk) begin\n    if (hready & (fsm == SCR1_FSM_DATA)) begin\n        resp_fifo.hresp  <= hresp;\n        resp_fifo.hrdata <= hrdata;\n    end\nend\n`endif // SCR1_IMEM_AHB_IN_BP\n\n//-------------------------------------------------------------------------------\n// Interface to AHB\n//-------------------------------------------------------------------------------\nassign hprot[SCR1_HPROT_DATA]  = 1'b0;\nassign hprot[SCR1_HPROT_PRV]   = 1'b0;\nassign hprot[SCR1_HPROT_BUF]   = 1'b0;\nassign hprot[SCR1_HPROT_CACHE] = 1'b0;\n\nassign hburst       = SCR1_HBURST_SINGLE;\nassign hsize        = SCR1_HSIZE_32B;\nassign hmastlock    = 1'b0;\n\nalways_comb begin\n    htrans = SCR1_HTRANS_IDLE;\n    case (fsm)\n        SCR1_FSM_ADDR : begin\n            if (~req_fifo_empty) begin\n                htrans = SCR1_HTRANS_NONSEQ;\n            end\n        end\n        SCR1_FSM_DATA : begin\n            if (hready) begin\n                if (hresp == SCR1_HRESP_OKAY) begin\n                    if (~req_fifo_empty) begin\n                        htrans = SCR1_HTRANS_NONSEQ;\n                    end\n                end\n            end\n        end\n        default : begin\n            htrans = SCR1_HTRANS_ERR;\n        end\n    endcase\nend\n\nassign haddr  = req_fifo[0].haddr;\n\n`ifdef SCR1_TRGT_SIMULATION\n//-------------------------------------------------------------------------------\n// Assertion\n//-------------------------------------------------------------------------------\n\n// Check Core interface\nSCR1_SVA_IMEM_AHB_BRIDGE_REQ_XCHECK : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    !$isunknown(imem_req)\n    ) else $error(\"IMEM AHB bridge Error: imem_req has unknown values\");\n\nSCR1_IMEM_AHB_BRIDGE_ADDR_XCHECK : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    imem_req |-> !$isunknown(imem_addr)\n    ) else $error(\"IMEM AHB bridge Error: imem_addr has unknown values\");\n\nSCR1_IMEM_AHB_BRIDGE_ADDR_ALLIGN : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    imem_req |-> (imem_addr[1:0] == '0)\n    ) else $error(\"IMEM AHB bridge Error: imem_addr has unalign values\");\n\n// Check AHB interface\nSCR1_IMEM_AHB_BRIDGE_HREADY_XCHECK : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    !$isunknown(hready)\n    ) else $error(\"IMEM AHB bridge Error: hready has unknown values\");\n\nSCR1_IMEM_AHB_BRIDGE_HRESP_XCHECK : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    !$isunknown(hresp)\n    ) else $error(\"IMEM AHB bridge Error: hresp has unknown values\");\n\n`endif // SCR1_TRGT_SIMULATION\n\nendmodule : scr1_imem_ahb\n"}
{"text": "/// Copyright by Syntacore LLC \u00a9 2016-2021. See LICENSE for details\n/// @file       <scr1_imem_router.sv>\n/// @brief      Instruction memory router\n///\n`include \"scr1_memif.svh\"\n`include \"scr1_arch_description.svh\"\n\nmodule scr1_imem_router\n#(\n    parameter SCR1_ADDR_MASK    = `SCR1_IMEM_AWIDTH'hFFFF0000,\n    parameter SCR1_ADDR_PATTERN = `SCR1_IMEM_AWIDTH'h00010000\n)\n(\n    // Control signals\n    input   logic                           rst_n,\n    input   logic                           clk,\n\n    // Core interface\n    output  logic                           imem_req_ack,\n    input   logic                           imem_req,\n    input   type_scr1_mem_cmd_e             imem_cmd,\n    input   logic [`SCR1_IMEM_AWIDTH-1:0]   imem_addr,\n    output  logic [`SCR1_IMEM_DWIDTH-1:0]   imem_rdata,\n    output  type_scr1_mem_resp_e            imem_resp,\n\n    // PORT0 interface\n    input   logic                           port0_req_ack,\n    output  logic                           port0_req,\n    output  type_scr1_mem_cmd_e             port0_cmd,\n    output  logic [`SCR1_IMEM_AWIDTH-1:0]   port0_addr,\n    input   logic [`SCR1_IMEM_DWIDTH-1:0]   port0_rdata,\n    input   type_scr1_mem_resp_e            port0_resp,\n\n    // PORT1 interface\n    input   logic                           port1_req_ack,\n    output  logic                           port1_req,\n    output  type_scr1_mem_cmd_e             port1_cmd,\n    output  logic [`SCR1_IMEM_AWIDTH-1:0]   port1_addr,\n    input   logic [`SCR1_IMEM_DWIDTH-1:0]   port1_rdata,\n    input   type_scr1_mem_resp_e            port1_resp\n);\n\n//-------------------------------------------------------------------------------\n// Local types declaration\n//-------------------------------------------------------------------------------\ntypedef enum logic {\n    SCR1_FSM_ADDR,\n    SCR1_FSM_DATA\n} type_scr1_fsm_e;\n\n//-------------------------------------------------------------------------------\n// Local signal declaration\n//-------------------------------------------------------------------------------\ntype_scr1_fsm_e                 fsm;\nlogic                           port_sel;\nlogic                           port_sel_r;\nlogic [`SCR1_IMEM_DWIDTH-1:0]   sel_rdata;\ntype_scr1_mem_resp_e            sel_resp;\nlogic                           sel_req_ack;\n\n//-------------------------------------------------------------------------------\n// FSM\n//-------------------------------------------------------------------------------\nassign port_sel = ((imem_addr & SCR1_ADDR_MASK) == SCR1_ADDR_PATTERN);\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        fsm        <= SCR1_FSM_ADDR;\n        port_sel_r <= 1'b0;\n    end else begin\n        case (fsm)\n            SCR1_FSM_ADDR : begin\n                if (imem_req & sel_req_ack) begin\n                    fsm <= SCR1_FSM_DATA;\n                    port_sel_r <= port_sel;\n                end\n            end\n            SCR1_FSM_DATA : begin\n                case (sel_resp)\n                    SCR1_MEM_RESP_RDY_OK : begin\n                        if (imem_req & sel_req_ack) begin\n                            fsm <= SCR1_FSM_DATA;\n                            port_sel_r <= port_sel;\n                        end else begin\n                            fsm <= SCR1_FSM_ADDR;\n                        end\n                    end\n                    SCR1_MEM_RESP_RDY_ER : begin\n                        fsm <= SCR1_FSM_ADDR;\n                    end\n                    default : begin\n                    end\n                endcase\n            end\n            default : begin\n            end\n        endcase\n    end\nend\n\nalways_comb begin\n    if ((fsm == SCR1_FSM_ADDR) | ((fsm == SCR1_FSM_DATA) & (sel_resp == SCR1_MEM_RESP_RDY_OK))) begin\n        sel_req_ack = (port_sel) ? port1_req_ack : port0_req_ack;\n    end else begin\n        sel_req_ack = 1'b0;\n    end\nend\n\nassign sel_rdata = (port_sel_r) ? port1_rdata : port0_rdata;\nassign sel_resp  = (port_sel_r) ? port1_resp  : port0_resp;\n\n//-------------------------------------------------------------------------------\n// Interface to core\n//-------------------------------------------------------------------------------\nassign imem_req_ack = sel_req_ack;\nassign imem_rdata   = sel_rdata;\nassign imem_resp    = sel_resp;\n\n//-------------------------------------------------------------------------------\n// Interface to PORT0\n//-------------------------------------------------------------------------------\nalways_comb begin\n    port0_req = 1'b0;\n    case (fsm)\n        SCR1_FSM_ADDR : begin\n            port0_req = imem_req & ~port_sel;\n        end\n        SCR1_FSM_DATA : begin\n            if (sel_resp == SCR1_MEM_RESP_RDY_OK) begin\n                port0_req = imem_req & ~port_sel;\n            end\n        end\n        default : begin\n        end\n    endcase\nend\n\n`ifdef SCR1_XPROP_EN\nassign port0_cmd   = (~port_sel) ? imem_cmd  : SCR1_MEM_CMD_ERROR;\nassign port0_addr  = (~port_sel) ? imem_addr : 'x;\n`else // SCR1_XPROP_EN\nassign port0_cmd   = imem_cmd ;\nassign port0_addr  = imem_addr;\n`endif // SCR1_XPROP_EN\n\n//-------------------------------------------------------------------------------\n// Interface to PORT1\n//-------------------------------------------------------------------------------\nalways_comb begin\n    port1_req = 1'b0;\n    case (fsm)\n        SCR1_FSM_ADDR : begin\n            port1_req = imem_req & port_sel;\n        end\n        SCR1_FSM_DATA : begin\n            if (sel_resp == SCR1_MEM_RESP_RDY_OK) begin\n                port1_req = imem_req & port_sel;\n            end\n        end\n        default : begin\n        end\n    endcase\nend\n\n`ifdef SCR1_XPROP_EN\nassign port1_cmd   = (port_sel) ? imem_cmd  : SCR1_MEM_CMD_ERROR;\nassign port1_addr  = (port_sel) ? imem_addr : 'x;\n`else // SCR1_XPROP_EN\nassign port1_cmd   = imem_cmd ;\nassign port1_addr  = imem_addr;\n`endif // SCR1_XPROP_EN\n\n`ifdef SCR1_TRGT_SIMULATION\n//-------------------------------------------------------------------------------\n// Assertion\n//-------------------------------------------------------------------------------\n\nSCR1_SVA_IMEM_RT_XCHECK : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    imem_req |-> !$isunknown({port_sel, imem_cmd})\n    ) else $error(\"IMEM router Error: unknown values\");\n\n`endif // SCR1_TRGT_SIMULATION\n\nendmodule : scr1_imem_router\n"}
{"text": "/// Copyright by Syntacore LLC \u00a9 2016-2021. See LICENSE for details\n/// @file       <scr1_ipic.sv>\n/// @brief      Integrated Programmable Interrupt Controller (IPIC)\n///\n\n//------------------------------------------------------------------------------\n //\n // Functionality:\n // - Synchronizes IRQ lines (optional)\n // - Detects level and edge (with optional lines inversion) of IRQ lines\n // - Setups interrupts handling (mode, inversion, enable)\n // - Provides information about pending interrupts and interrupts currently in\n //   service\n // - Generates interrupt request to CSR\n //\n // Structure:\n // - IRQ lines handling (synchronization, level and edge detection) logic\n // - IPIC registers:\n //   - CISV\n //   - CICSR\n //   - EOI\n //   - SOI\n //   - IDX\n //   - IPR\n //   - ISVR\n //   - IER\n //   - IMR\n //   - IINVR\n //   - ICSR\n // - Priority interrupt generation logic\n //\n//------------------------------------------------------------------------------\n\n`include \"scr1_arch_description.svh\"\n\n`ifdef SCR1_IPIC_EN\n\n`include \"scr1_ipic.svh\"\n\nmodule scr1_ipic\n(\n    // Common\n    input   logic                                   rst_n,                  // IPIC reset\n    input   logic                                   clk,                    // IPIC clock\n\n    // External Interrupt lines\n    input   logic [SCR1_IRQ_LINES_NUM-1:0]          soc2ipic_irq_lines_i,   // External IRQ lines\n\n    // CSR <-> IPIC interface\n    input   logic                                   csr2ipic_r_req_i,       // IPIC read request\n    input   logic                                   csr2ipic_w_req_i,       // IPIC write request\n    input   logic [2:0]                             csr2ipic_addr_i,        // IPIC address\n    input   logic [`SCR1_XLEN-1:0]                  csr2ipic_wdata_i,       // IPIC write data\n    output  logic [`SCR1_XLEN-1:0]                  ipic2csr_rdata_o,       // IPIC read data\n    output  logic                                   ipic2csr_irq_m_req_o    // IRQ request from IPIC\n);\n\n//-------------------------------------------------------------------------------\n// Local types declaration\n//-------------------------------------------------------------------------------\ntypedef struct {\n    logic                                   vd;\n    logic                                   idx;\n} type_scr1_search_one_2_s;\n\ntypedef struct {\n    logic                                   vd;\n    logic   [SCR1_IRQ_IDX_WIDTH-1:0]        idx;\n} type_scr1_search_one_16_s;\n\ntypedef struct packed {\n    logic                                   ip;\n    logic                                   ie;\n    logic                                   im;\n    logic                                   inv;\n    logic                                   isv;\n    logic   [SCR1_IRQ_LINES_WIDTH-1:0]      line;\n} type_scr1_icsr_m_s;\n\ntypedef struct packed {\n    logic                                   ip;\n    logic                                   ie;\n} type_scr1_cicsr_s;\n\n//-------------------------------------------------------------------------------\n// Local functions declaration\n//-------------------------------------------------------------------------------\n\nfunction automatic type_scr1_search_one_2_s scr1_search_one_2(\n    input   logic   [1:0] din\n);\n    type_scr1_search_one_2_s tmp;\nbegin\n    tmp.vd  = |din;\n    tmp.idx = ~din[0];\n    return  tmp;\nend\nendfunction : scr1_search_one_2\n\nfunction automatic type_scr1_search_one_16_s scr1_search_one_16(\n    input   logic [15:0]    din\n);\nbegin\n    logic [7:0]         stage1_vd;\n    logic [3:0]         stage2_vd;\n    logic [1:0]         stage3_vd;\n\n    logic               stage1_idx [7:0];\n    logic [1:0]         stage2_idx [3:0];\n    logic [2:0]         stage3_idx [1:0];\n    type_scr1_search_one_16_s result;\n\n    // Stage 1\n    for (int unsigned i=0; i<8; ++i) begin\n        type_scr1_search_one_2_s tmp;\n        tmp = scr1_search_one_2(din[(i+1)*2-1-:2]);\n        stage1_vd[i]  = tmp.vd;\n        stage1_idx[i] = tmp.idx;\n    end\n\n    // Stage 2\n    for (int unsigned i=0; i<4; ++i) begin\n        type_scr1_search_one_2_s tmp;\n        tmp = scr1_search_one_2(stage1_vd[(i+1)*2-1-:2]);\n        stage2_vd[i]  = tmp.vd;\n        stage2_idx[i] = (~tmp.idx) ? {tmp.idx, stage1_idx[2*i]} : {tmp.idx, stage1_idx[2*i+1]};\n    end\n\n    // Stage 3\n    for (int unsigned i=0; i<2; ++i) begin\n        type_scr1_search_one_2_s tmp;\n        tmp = scr1_search_one_2(stage2_vd[(i+1)*2-1-:2]);\n        stage3_vd[i]  = tmp.vd;\n        stage3_idx[i] = (~tmp.idx) ? {tmp.idx, stage2_idx[2*i]} : {tmp.idx, stage2_idx[2*i+1]};\n    end\n\n    // Stage 4\n    result.vd = |stage3_vd;\n    result.idx = (stage3_vd[0]) ? {1'b0, stage3_idx[0]} : {1'b1, stage3_idx[1]};\n\n    return result;\nend\nendfunction : scr1_search_one_16\n\n//------------------------------------------------------------------------------\n// Local signals declaration\n//------------------------------------------------------------------------------\n\n// IRQ lines handling signals\n//------------------------------------------------------------------------------\n\nlogic [SCR1_IRQ_VECT_NUM-1:0]           irq_lines;              // Internal IRQ lines\n`ifdef SCR1_IPIC_SYNC_EN\nlogic [SCR1_IRQ_VECT_NUM-1:0]           irq_lines_sync;\n`endif // SCR1_IPIC_SYNC_EN\nlogic [SCR1_IRQ_VECT_NUM-1:0]           irq_lines_dly;          // Internal IRQ lines delayed for 1 cycle\nlogic [SCR1_IRQ_VECT_NUM-1:0]           irq_edge_detected;      // IRQ lines edge detected flags\nlogic [SCR1_IRQ_VECT_NUM-1:0]           irq_lvl;                // IRQ lines level\n\n// IPIC registers\n//------------------------------------------------------------------------------\n\n// CISV register\nlogic                                   ipic_cisv_upd;          // Current Interrupt Vecotr in Service register update\nlogic [SCR1_IRQ_VECT_WIDTH-1:0]         ipic_cisv_ff;           // Current Interrupt Vector in Service register\nlogic [SCR1_IRQ_VECT_WIDTH-1:0]         ipic_cisv_next;         // Current Interrupt Vector in Service register next value\n\n// CICS register (CICSR)\nlogic                                   cicsr_wr_req;           // Write request to Current Interrupt Control Status register\ntype_scr1_cicsr_s                       ipic_cicsr;             // Current Interrupt Control Status register\n\n// EOI register\nlogic                                   eoi_wr_req;             // Write request to End of Interrupt register\nlogic                                   ipic_eoi_req;           // Request to end the interrupt that is currently in service\n\n// SOI register\nlogic                                   soi_wr_req;             // Write request to Start of Interrupt register\nlogic                                   ipic_soi_req;           // Request to start the interrupt\n\n// IDX register (IDXR)\nlogic                                   idxr_wr_req;            // Write request to Index register\nlogic [SCR1_IRQ_IDX_WIDTH-1:0]          ipic_idxr_ff;           // Index register\n\n// IP register (IPR)\nlogic                                   ipic_ipr_upd;           // Interrupt pending register update\nlogic [SCR1_IRQ_VECT_NUM-1:0]           ipic_ipr_ff;            // Interrupt pending register\nlogic [SCR1_IRQ_VECT_NUM-1:0]           ipic_ipr_next;          // Interrupt pending register next value\nlogic [SCR1_IRQ_VECT_NUM-1:0]           ipic_ipr_clr_cond;      // Interrupt pending clear condition\nlogic [SCR1_IRQ_VECT_NUM-1:0]           ipic_ipr_clr_req;       // Interrupt pending clear request\nlogic [SCR1_IRQ_VECT_NUM-1:0]           ipic_ipr_clr;           // Interrupt pending clear operation\n\n// ISV register (ISVR)\nlogic                                   ipic_isvr_upd;          // Interrupt Serviced register update\nlogic [SCR1_IRQ_VECT_NUM-1:0]           ipic_isvr_ff;           // Interrupt Serviced register\nlogic [SCR1_IRQ_VECT_NUM-1:0]           ipic_isvr_next;         // Interrupt Serviced register next value\n\n// IE register (IER)\nlogic                                   ipic_ier_upd;           // Interrupt enable register update\nlogic [SCR1_IRQ_VECT_NUM-1:0]           ipic_ier_ff;            // Interrupt enable register\nlogic [SCR1_IRQ_VECT_NUM-1:0]           ipic_ier_next;          // Interrupt enable register next value\n\n// IM register (IMR)\nlogic [SCR1_IRQ_VECT_NUM-1:0]           ipic_imr_ff;            // Interrupt mode register\nlogic [SCR1_IRQ_VECT_NUM-1:0]           ipic_imr_next;          // Interrupt mode register next value\n\n// IINV register (IINVR)\nlogic [SCR1_IRQ_VECT_NUM-1:0]           ipic_iinvr_ff;          // Interrupt Inversion register\nlogic [SCR1_IRQ_VECT_NUM-1:0]           ipic_iinvr_next;        // Interrupt Inversion register next value\n\n// ICS register (ICSR)\nlogic                                   icsr_wr_req;            // Write request to Interrupt Control Status register\ntype_scr1_icsr_m_s                      ipic_icsr;              // Interrupt Control Status register\n\n// Priority interrupt generation signals\n//------------------------------------------------------------------------------\n\n// Serviced interrupt signals\nlogic                                   irq_serv_vd;            // There is an interrupt in service\nlogic [SCR1_IRQ_IDX_WIDTH-1:0]          irq_serv_idx;           // Index of an interrupt that is currently in service\n\n// Requested interrupt signals\nlogic                                   irq_req_vd;             // There is a requested interrupt\nlogic [SCR1_IRQ_IDX_WIDTH-1:0]          irq_req_idx;            // Index of a requested interrupt\n\n// Interrupt requested on \"end of the previous interrupt\" signals\nlogic                                   irq_eoi_req_vd;         // There is a requested interrupt when the previous one has ended\nlogic [SCR1_IRQ_IDX_WIDTH-1:0]          irq_eoi_req_idx;        // Index of an interrupt requested when the previous one has ended\n\nlogic [SCR1_IRQ_VECT_NUM-1:0]           irq_req_v;              // Vector of interrupts that are pending and enabled\n\nlogic                                   irq_start_vd;           // Request to start an interrupt is valid\nlogic                                   irq_hi_prior_pnd;       // There is a pending IRQ with a priority higher than of the interrupt that is currently in service\n\ntype_scr1_search_one_16_s               irr_priority;           // Structure for vd and idx of the requested interrupt\ntype_scr1_search_one_16_s               isvr_priority_eoi;      // Structure for vd and idx of the interrupt requested when the previous interrupt has ended\nlogic [SCR1_IRQ_VECT_NUM-1:0]           ipic_isvr_eoi;          // Interrupt Serviced register when the previous interrupt has ended\n\n//------------------------------------------------------------------------------\n// IRQ lines handling\n//------------------------------------------------------------------------------\n\n`ifdef SCR1_IPIC_SYNC_EN\n// IRQ lines synchronization\n//------------------------------------------------------------------------------\n\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        irq_lines_sync <= '0;\n        irq_lines      <= '0;\n    end else begin\n        irq_lines_sync <= soc2ipic_irq_lines_i;\n        irq_lines      <= irq_lines_sync;\n    end\nend\n`else // SCR1_IPIC_SYNC_EN\nassign irq_lines = soc2ipic_irq_lines_i;\n`endif // SCR1_IPIC_SYNC_EN\n\n// IRQ lines level detection\n//------------------------------------------------------------------------------\n\nassign irq_lvl = irq_lines ^ ipic_iinvr_next;\n\n// IRQ lines edge detection\n//------------------------------------------------------------------------------\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        irq_lines_dly <= '0;\n    end else begin\n        irq_lines_dly <= irq_lines;\n    end\nend\n\nassign irq_edge_detected = (irq_lines_dly ^ irq_lines) & irq_lvl;\n\n//------------------------------------------------------------------------------\n// IPIC registers read/write interface\n//------------------------------------------------------------------------------\n\n// Read Logic\n//------------------------------------------------------------------------------\n\n// Read data multiplexer\nalways_comb begin\n    ipic2csr_rdata_o  = '0;\n\n    if (csr2ipic_r_req_i) begin\n        case (csr2ipic_addr_i)\n            SCR1_IPIC_CISV : begin\n                ipic2csr_rdata_o[SCR1_IRQ_VECT_WIDTH-1:0] = irq_serv_vd\n                                                          ? ipic_cisv_ff\n                                                          : SCR1_IRQ_VOID_VECT_NUM;\n            end\n            SCR1_IPIC_CICSR : begin\n                ipic2csr_rdata_o[SCR1_IPIC_ICSR_IP]  = ipic_cicsr.ip;\n                ipic2csr_rdata_o[SCR1_IPIC_ICSR_IE]  = ipic_cicsr.ie;\n            end\n            SCR1_IPIC_IPR : begin\n                ipic2csr_rdata_o = `SCR1_XLEN'(ipic_ipr_ff);\n            end\n            SCR1_IPIC_ISVR : begin\n                ipic2csr_rdata_o = `SCR1_XLEN'(ipic_isvr_ff);\n            end\n            SCR1_IPIC_EOI,\n            SCR1_IPIC_SOI : begin\n                ipic2csr_rdata_o = '0;\n            end\n            SCR1_IPIC_IDX : begin\n                ipic2csr_rdata_o = `SCR1_XLEN'(ipic_idxr_ff);\n            end\n            SCR1_IPIC_ICSR : begin\n                ipic2csr_rdata_o[SCR1_IPIC_ICSR_IP]      = ipic_icsr.ip;\n                ipic2csr_rdata_o[SCR1_IPIC_ICSR_IE]      = ipic_icsr.ie;\n                ipic2csr_rdata_o[SCR1_IPIC_ICSR_IM]      = ipic_icsr.im;\n                ipic2csr_rdata_o[SCR1_IPIC_ICSR_INV]     = ipic_icsr.inv;\n                ipic2csr_rdata_o[SCR1_IPIC_ICSR_PRV_MSB:\n                                 SCR1_IPIC_ICSR_PRV_LSB] = SCR1_IPIC_PRV_M;\n                ipic2csr_rdata_o[SCR1_IPIC_ICSR_IS]      = ipic_icsr.isv;\n                ipic2csr_rdata_o[SCR1_IPIC_ICSR_LN_MSB-1:\n                                 SCR1_IPIC_ICSR_LN_LSB]  = ipic_icsr.line;\n            end\n            default : begin\n                ipic2csr_rdata_o = 'x;\n            end\n        endcase\n    end\nend\n\n// Write logic\n//------------------------------------------------------------------------------\n\n// Register selection\nalways_comb begin\n    cicsr_wr_req = 1'b0;\n    eoi_wr_req   = 1'b0;\n    soi_wr_req   = 1'b0;\n    idxr_wr_req  = 1'b0;\n    icsr_wr_req  = 1'b0;\n    if (csr2ipic_w_req_i) begin\n        case (csr2ipic_addr_i)\n            SCR1_IPIC_CISV : begin end // Quiet Read-Only\n            SCR1_IPIC_CICSR: cicsr_wr_req = 1'b1;\n            SCR1_IPIC_IPR  : begin end\n            SCR1_IPIC_ISVR : begin end // Quiet Read-Only\n            SCR1_IPIC_EOI  : eoi_wr_req   = 1'b1;\n            SCR1_IPIC_SOI  : soi_wr_req   = 1'b1;\n            SCR1_IPIC_IDX  : idxr_wr_req  = 1'b1;\n            SCR1_IPIC_ICSR : icsr_wr_req  = 1'b1;\n            default : begin // Illegal IPIC register address\n                cicsr_wr_req = 'x;\n                eoi_wr_req   = 'x;\n                soi_wr_req   = 'x;\n                idxr_wr_req  = 'x;\n                icsr_wr_req  = 'x;\n            end\n        endcase\n    end\nend\n\n//------------------------------------------------------------------------------\n// IPIC registers\n//------------------------------------------------------------------------------\n//\n // Registers:\n // - Current Interrupt Vector in Service (CISV) register\n // - Current Interrupt Control Status (CICSR) register\n // - End of Interrupt (EOI) register\n // - Start of Interrupt (SOI) register\n // - Index (IDX) register\n // - Interrupt Pending Register (IPR)\n // - Interrupt Serviced Register (ISVR)\n // - Interrupt Enable Register (IER)\n // - Interrupt Mode Register (IMR)\n // - Interrupt Inversion Register (IINVR)\n // - Interrupt Control Status Register (ICSR)\n//\n\n// CISV register\n//------------------------------------------------------------------------------\n// Contains number of the interrupt vector currently in service. When no\n// interrupts are in service, contains number of the void interrupt vector (0x10).\n// The register cannot contain all 0's\n\nassign ipic_cisv_upd = irq_start_vd | ipic_eoi_req;\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        ipic_cisv_ff <= SCR1_IRQ_VOID_VECT_NUM;\n    end else if (ipic_cisv_upd) begin\n        ipic_cisv_ff <= ipic_cisv_next;\n    end\nend\n\nassign ipic_cisv_next = irq_start_vd ? {1'b0, irq_req_idx}\n                      : ipic_eoi_req ? irq_eoi_req_vd ? {1'b0, irq_eoi_req_idx}\n                                                      : SCR1_IRQ_VOID_VECT_NUM\n                                     : 1'b0;\n\nassign irq_serv_idx = ipic_cisv_ff[SCR1_IRQ_VECT_WIDTH-2:0];\nassign irq_serv_vd  = ~ipic_cisv_ff[SCR1_IRQ_VECT_WIDTH-1];\n\n// CICSR register\n//------------------------------------------------------------------------------\n// Shows whether the interrupt currently in service is pending and enabled\n\nassign ipic_cicsr.ip = ipic_ipr_ff[irq_serv_idx] & irq_serv_vd;\nassign ipic_cicsr.ie = ipic_ier_ff[irq_serv_idx] & irq_serv_vd;\n\n// EOI register\n//------------------------------------------------------------------------------\n// Writing any value to EOI register ends the interrupt which is currently in service\n\nassign ipic_eoi_req = eoi_wr_req & irq_serv_vd;\n\n// SOI register\n//------------------------------------------------------------------------------\n// Writing any value to SOI activates start of interrupt if one of the following\n// conditions is true:\n// - There is at least one pending interrupt with IE and ISR is zero\n// - There is at least one pending interrupt with IE and higher priority than the\n// interrupts currently in service\n\nassign ipic_soi_req = soi_wr_req & irq_req_vd;\n\n// IDX register\n//------------------------------------------------------------------------------\n// Defines the number of interrupt vector which is accessed through the IPIC_ICSR\n// register\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        ipic_idxr_ff <= '0;\n    end else if (idxr_wr_req) begin\n        ipic_idxr_ff <= csr2ipic_wdata_i[SCR1_IRQ_IDX_WIDTH-1:0];\n    end\nend\n\n// IPR\n//------------------------------------------------------------------------------\n// For every IRQ line shows whether there is a pending interrupt\n\nassign ipic_ipr_upd = (ipic_ipr_next != ipic_ipr_ff);\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        ipic_ipr_ff <= '0;\n    end else if (ipic_ipr_upd) begin\n        ipic_ipr_ff <= ipic_ipr_next;\n    end\nend\n\nalways_comb begin\n    ipic_ipr_clr_req = '0;\n    if (csr2ipic_w_req_i) begin\n        case (csr2ipic_addr_i)\n            SCR1_IPIC_CICSR: ipic_ipr_clr_req[irq_serv_idx] = csr2ipic_wdata_i[SCR1_IPIC_ICSR_IP]\n                                                            & irq_serv_vd;\n            SCR1_IPIC_IPR  : ipic_ipr_clr_req               = csr2ipic_wdata_i[SCR1_IRQ_VECT_NUM-1:0];\n            SCR1_IPIC_SOI  : ipic_ipr_clr_req[irq_req_idx]  = irq_req_vd;\n            SCR1_IPIC_ICSR : ipic_ipr_clr_req[ipic_idxr_ff] = csr2ipic_wdata_i[SCR1_IPIC_ICSR_IP];\n            default        : begin end\n        endcase\n    end\nend\n\nassign ipic_ipr_clr_cond = ~irq_lvl | ipic_imr_next;\nassign ipic_ipr_clr      = ipic_ipr_clr_req & ipic_ipr_clr_cond;\n\nalways_comb begin\n    ipic_ipr_next = '0;\n    for (int unsigned i=0; i<SCR1_IRQ_VECT_NUM; ++i) begin\n        ipic_ipr_next[i] = ipic_ipr_clr[i] ? 1'b0\n                         : ~ipic_imr_ff[i] ? irq_lvl[i]\n                                           : ipic_ipr_ff[i] | irq_edge_detected[i];\n    end\nend\n\n// ISVR\n//------------------------------------------------------------------------------\n// For every IRQ line shows whether the interrupt is in service or not\n\nassign ipic_isvr_upd = irq_start_vd | ipic_eoi_req;\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        ipic_isvr_ff <= '0;\n    end else if (ipic_isvr_upd) begin\n        ipic_isvr_ff <= ipic_isvr_next;\n    end\nend\n\nalways_comb begin\n    ipic_isvr_eoi = ipic_isvr_ff;\n    if (irq_serv_vd) begin\n        ipic_isvr_eoi[irq_serv_idx] = 1'b0;\n    end\nend\n\nalways_comb begin\n    ipic_isvr_next = ipic_isvr_ff;\n    if (irq_s"}
{"text": "tart_vd) begin\n        ipic_isvr_next[irq_req_idx] = 1'b1;\n    end else if (ipic_eoi_req) begin\n        ipic_isvr_next = ipic_isvr_eoi;\n    end\nend\n\n// IER\n//------------------------------------------------------------------------------\n// Enables/disables interrupt for every IRQ line\n\nassign ipic_ier_upd = cicsr_wr_req | icsr_wr_req;\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        ipic_ier_ff <= '0;\n    end else if (ipic_ier_upd) begin\n        ipic_ier_ff <= ipic_ier_next;\n    end\nend\n\nalways_comb begin\n    ipic_ier_next = ipic_ier_ff;\n    if (cicsr_wr_req) begin\n        ipic_ier_next[irq_serv_idx] = irq_serv_vd\n                                    ? csr2ipic_wdata_i[SCR1_IPIC_ICSR_IE]\n                                    : ipic_ier_ff[irq_serv_idx];\n    end else if (icsr_wr_req) begin\n        ipic_ier_next[ipic_idxr_ff] = csr2ipic_wdata_i[SCR1_IPIC_ICSR_IE];\n    end\nend\n\n// IMR\n//------------------------------------------------------------------------------\n// For every IRQ line sets either Level (0) or Edge (1) detection\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        ipic_imr_ff <= '0;\n    end else if (icsr_wr_req) begin\n        ipic_imr_ff <= ipic_imr_next;\n    end\nend\n\nalways_comb begin\n    ipic_imr_next = ipic_imr_ff;\n    if (icsr_wr_req) begin\n        ipic_imr_next[ipic_idxr_ff] = csr2ipic_wdata_i[SCR1_IPIC_ICSR_IM];\n    end\nend\n\n// IINVR\n//------------------------------------------------------------------------------\n// For every IRQ line defines whether it should be inverted or not\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        ipic_iinvr_ff <= '0;\n    end else if (icsr_wr_req) begin\n        ipic_iinvr_ff <= ipic_iinvr_next;\n    end\nend\n\nalways_comb begin\n    ipic_iinvr_next = ipic_iinvr_ff;\n    if (icsr_wr_req) begin\n        ipic_iinvr_next[ipic_idxr_ff] = csr2ipic_wdata_i[SCR1_IPIC_ICSR_INV];\n    end\nend\n\n// ICSR\n//------------------------------------------------------------------------------\n// Holds control and status information about the interrupt defined by Index Register\n\nassign ipic_icsr.ip    = ipic_ipr_ff  [ipic_idxr_ff];\nassign ipic_icsr.ie    = ipic_ier_ff  [ipic_idxr_ff];\nassign ipic_icsr.im    = ipic_imr_ff  [ipic_idxr_ff];\nassign ipic_icsr.inv   = ipic_iinvr_ff[ipic_idxr_ff];\nassign ipic_icsr.isv   = ipic_isvr_ff [ipic_idxr_ff];\nassign ipic_icsr.line  = SCR1_IRQ_LINES_WIDTH'(ipic_idxr_ff);\n\n//------------------------------------------------------------------------------\n// Priority IRQ generation logic\n//------------------------------------------------------------------------------\n\nassign irq_req_v = ipic_ipr_ff & ipic_ier_ff;\n\nassign irr_priority        = scr1_search_one_16(irq_req_v);\nassign irq_req_vd          = irr_priority.vd;\nassign irq_req_idx         = irr_priority.idx;\n\nassign isvr_priority_eoi   = scr1_search_one_16(ipic_isvr_eoi);\nassign irq_eoi_req_vd      = isvr_priority_eoi.vd;\nassign irq_eoi_req_idx     = isvr_priority_eoi.idx;\n\nassign irq_hi_prior_pnd     = irq_req_idx < irq_serv_idx;\n\nassign ipic2csr_irq_m_req_o = irq_req_vd & (~irq_serv_vd | irq_hi_prior_pnd);\n\nassign irq_start_vd         = ipic2csr_irq_m_req_o & ipic_soi_req;\n\nendmodule : scr1_ipic\n\n`endif // SCR1_IPIC_EN\n"}
{"text": "/// Copyright by Syntacore LLC \u00a9 2016-2021. See LICENSE for details\n/// @file       <scr1_memory_tb_ahb.sv>\n/// @brief      AHB memory testbench\n///\n\n`include \"scr1_arch_description.svh\"\n`include \"scr1_ahb.svh\"\n`include \"scr1_ipic.svh\"\n\nmodule scr1_memory_tb_ahb #(\n    parameter SCR1_MEM_POWER_SIZE  = 16\n)\n(\n    // Control\n    input   logic                                   rst_n,\n    input   logic                                   clk,\n`ifdef SCR1_IPIC_EN\n    output  logic  [SCR1_IRQ_LINES_NUM-1:0]         irq_lines,\n`else // SCR1_IPIC_EN\n    output  logic                                   ext_irq,\n`endif // SCR1_IPIC_EN\n    output  logic                                   soft_irq,\n    input   integer                                 imem_req_ack_stall_in,\n    input   integer                                 dmem_req_ack_stall_in,\n\n    // Instruction Memory Interface\n    // input   logic   [3:0]                           imem_hprot,\n    // input   logic   [2:0]                           imem_hburst,\n    input   logic   [2:0]                           imem_hsize,\n    input   logic   [1:0]                           imem_htrans,\n    input   logic   [SCR1_AHB_WIDTH-1:0]            imem_haddr,\n    output  logic                                   imem_hready,\n    output  logic   [SCR1_AHB_WIDTH-1:0]            imem_hrdata,\n    output  logic                                   imem_hresp,\n\n    // Memory Interface\n    // input   logic   [3:0]                           dmem_hprot,\n    // input   logic   [2:0]                           dmem_hburst,\n    input   logic   [2:0]                           dmem_hsize,\n    input   logic   [1:0]                           dmem_htrans,\n    input   logic   [SCR1_AHB_WIDTH-1:0]            dmem_haddr,\n    input   logic                                   dmem_hwrite,\n    input   logic   [SCR1_AHB_WIDTH-1:0]            dmem_hwdata,\n    output  logic                                   dmem_hready,\n    output  logic   [SCR1_AHB_WIDTH-1:0]            dmem_hrdata,\n    output  logic                                   dmem_hresp\n);\n\n//-------------------------------------------------------------------------------\n// Local Types\n//-------------------------------------------------------------------------------\ntypedef enum logic {\n    SCR1_AHB_STATE_IDLE = 1'b0,\n    SCR1_AHB_STATE_DATA = 1'b1,\n    SCR1_AHB_STATE_ERR  = 1'bx\n} type_scr1_ahb_state_e;\n\n//-------------------------------------------------------------------------------\n// Memory definition\n//-------------------------------------------------------------------------------\nlogic [7:0]                             memory [0:2**SCR1_MEM_POWER_SIZE-1];\n`ifdef SCR1_IPIC_EN\nlogic [SCR1_IRQ_LINES_NUM-1:0]          irq_lines_reg;\n`else // SCR1_IPIC_EN\nlogic                                   ext_irq_reg;\n`endif // SCR1_IPIC_EN\nlogic                                   soft_irq_reg;\nlogic [7:0]                             mirage [0:2**SCR1_MEM_POWER_SIZE-1];\nbit                                     mirage_en;\nbit                                     mirage_rangeen;\nbit [SCR1_AHB_WIDTH-1:0]                mirage_adrlo = '1;\nbit [SCR1_AHB_WIDTH-1:0]                mirage_adrhi = '1;\n\n`ifdef VERILATOR\nlogic [255:0]                           test_file;\n`else // VERILATOR\nstring                                  test_file;\n`endif // VERILATOR\nbit                                     test_file_init;\n\n//-------------------------------------------------------------------------------\n// Local functions\n//-------------------------------------------------------------------------------\nfunction logic [SCR1_AHB_WIDTH-1:0] scr1_read_mem(\n    logic   [SCR1_AHB_WIDTH-1:0]    addr,\n    logic   [3:0]                   r_be,\n    logic   [3:0]                   w_hazard,\n    logic   [SCR1_AHB_WIDTH-1:0]    w_data,\n    bit                             mirage_en\n);\n    logic [SCR1_AHB_WIDTH-1:0]      tmp;\n    logic [SCR1_MEM_POWER_SIZE-1:0] addr_mirage;\nbegin\n    scr1_read_mem = 'x;\n\n    if(~mirage_en) begin\n        for (int unsigned i=0; i<4; ++i) begin\n            tmp[(8*(i+1)-1)-:8] = (r_be[i])\n                                        ? (w_hazard[i])\n                                            ? w_data[(8*(i+1)-1)-:8]\n                                            : memory[addr+i]\n                                        : 'x;\n        end\n    end\n    else begin\n        addr_mirage = addr;\n        for (int i = 0; i < 4; ++i) begin\n            tmp[ (i*8)+:8 ] = (r_be[i])\n                                        ? (w_hazard[i])\n                                            ? w_data[(i*8)+:8]\n                                            : mirage[addr_mirage+i]\n                                        : 'x;\n        end\n    end\n    return tmp;\nend\nendfunction : scr1_read_mem\n\nfunction void scr1_write_mem(\n    logic   [SCR1_AHB_WIDTH-1:0]    addr,\n    logic   [3:0]                   w_be,\n    logic   [SCR1_AHB_WIDTH-1:0]    data,\n    bit                             mirage_en\n);\n    logic [SCR1_MEM_POWER_SIZE-1:0] addr_mirage;\nbegin\n    for (int unsigned i=0; i<4; ++i) begin\n        if (w_be[i]) begin\n            if(~mirage_en)\n                memory[addr+i] <= data[(8*(i+1)-1)-:8];\n            else begin\n                addr_mirage = addr;\n                mirage[addr_mirage+i] <= data[(8*(i+1)-1)-:8];\n            end\n        end\n    end\nend\nendfunction : scr1_write_mem\n\nfunction logic [3:0] scr1_be_form(\n    input   logic [1:0]     offset,\n    input   logic [1:0]     hsize\n);\n    logic [3:0]     tmp;\nbegin\n    case (hsize)\n        SCR1_HSIZE_8B : begin\n            tmp = 4'b0001 << offset;\n        end\n        SCR1_HSIZE_16B : begin\n            tmp = 4'b0011 << offset;\n        end\n        SCR1_HSIZE_32B : begin\n            tmp = 4'b1111;\n        end\n    endcase\n    return tmp;\nend\nendfunction : scr1_be_form\n\n//-------------------------------------------------------------------------------\n// Local signal declaration\n//-------------------------------------------------------------------------------\n// IMEM access\ntype_scr1_ahb_state_e           imem_ahb_state;\nlogic   [SCR1_AHB_WIDTH-1:0]    imem_ahb_addr;\nlogic   [SCR1_AHB_WIDTH-1:0]    imem_req_ack_stall;\nbit                             imem_req_ack_rnd;\nlogic                           imem_req_ack;\nlogic                           imem_req_ack_nc;\nlogic   [3:0]                   imem_be;\nlogic   [SCR1_AHB_WIDTH-1:0]    imem_hrdata_l;\nlogic   [3:0]                   imem_wr_hazard;\n\n// DMEM access\nlogic   [SCR1_AHB_WIDTH-1:0]    dmem_req_ack_stall;\nbit                             dmem_req_ack_rnd;\nlogic                           dmem_req_ack;\nlogic                           dmem_req_ack_nc;\nlogic   [3:0]                   dmem_be;\ntype_scr1_ahb_state_e           dmem_ahb_state;\nlogic   [SCR1_AHB_WIDTH-1:0]    dmem_ahb_addr;\nlogic                           dmem_ahb_wr;\nlogic   [2:0]                   dmem_ahb_size;\nlogic   [3:0]                   dmem_ahb_be;\nlogic   [SCR1_AHB_WIDTH-1:0]    dmem_hrdata_l;\nlogic   [3:0]                   dmem_wr_hazard;\n\n//-------------------------------------------------------------------------------\n// Instruction memory ready\n//-------------------------------------------------------------------------------\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        imem_req_ack_stall <= imem_req_ack_stall_in;\n        imem_req_ack_rnd   <= 1'b0;\n    end else begin\n        if (imem_req_ack_stall == '0) begin\n            imem_req_ack_rnd <= $random;\n        end else begin\n            imem_req_ack_stall <= ((imem_ahb_state == SCR1_AHB_STATE_DATA) | ~imem_req_ack_stall[0]) ? {imem_req_ack_stall[0], imem_req_ack_stall[31:1]} : imem_req_ack_stall;\n        end\n    end\nend\n\nassign imem_req_ack = (imem_req_ack_stall == 32'd0) ?  imem_req_ack_rnd : imem_req_ack_stall[0];\n\n//-------------------------------------------------------------------------------\n// Instruction memory AHB FSM\n//-------------------------------------------------------------------------------\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        imem_ahb_state <= SCR1_AHB_STATE_IDLE;\n    end else begin\n        case (imem_ahb_state)\n            SCR1_AHB_STATE_IDLE : begin\n//                if (imem_req_ack) begin\n                    case (imem_htrans)\n                        SCR1_HTRANS_IDLE : begin\n                            imem_ahb_state <= SCR1_AHB_STATE_IDLE;\n                        end\n                        SCR1_HTRANS_NONSEQ : begin\n                            imem_ahb_state <= SCR1_AHB_STATE_DATA;\n                        end\n                        default : begin\n                            imem_ahb_state <= SCR1_AHB_STATE_ERR;\n                        end\n                    endcase\n //               end\n            end\n            SCR1_AHB_STATE_DATA : begin\n                if (imem_req_ack) begin\n                    case (imem_htrans)\n                        SCR1_HTRANS_IDLE : begin\n                            imem_ahb_state <= SCR1_AHB_STATE_IDLE;\n                        end\n                        SCR1_HTRANS_NONSEQ : begin\n                            imem_ahb_state <= SCR1_AHB_STATE_DATA;\n                        end\n                        default : begin\n                            imem_ahb_state <= SCR1_AHB_STATE_ERR;\n                        end\n                    endcase\n                end\n            end\n            default : begin\n                imem_ahb_state <= SCR1_AHB_STATE_ERR;\n            end\n        endcase\n    end\nend\n\n//-------------------------------------------------------------------------------\n// Address data generation\n//-------------------------------------------------------------------------------\nassign imem_be = scr1_be_form(2'b00, imem_hsize);\nassign imem_wr_hazard = (dmem_ahb_wr & (imem_haddr[SCR1_AHB_WIDTH-1:2] == dmem_ahb_addr[SCR1_AHB_WIDTH-1:2])) ? imem_be & dmem_ahb_be : '0;\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        imem_ahb_addr  <= 'x;\n        imem_hrdata_l  <= 'x;\n    end else begin\n        case (imem_ahb_state)\n            SCR1_AHB_STATE_IDLE : begin\n//                if (imem_req_ack) begin\n                    case (imem_htrans)\n                        SCR1_HTRANS_IDLE : begin\n                        end\n                        SCR1_HTRANS_NONSEQ : begin\n                            imem_ahb_addr  <= imem_haddr;\n                            if(mirage_rangeen & imem_haddr>=mirage_adrlo & imem_haddr<mirage_adrhi)\n                                imem_hrdata_l <= scr1_read_mem({imem_haddr[SCR1_AHB_WIDTH-1:2], 2'b00}, imem_be, imem_wr_hazard, dmem_hwdata, 1'b1);\n                            else\n                                imem_hrdata_l <= scr1_read_mem({imem_haddr[SCR1_AHB_WIDTH-1:2], 2'b00}, imem_be, imem_wr_hazard, dmem_hwdata, 1'b0);\n                        end\n                        default : begin\n                            imem_ahb_addr  <= 'x;\n                            imem_hrdata_l  <= 'x;\n                        end\n                    endcase\n //               end\n            end\n            SCR1_AHB_STATE_DATA : begin\n                if (imem_req_ack) begin\n                    case (imem_htrans)\n                        SCR1_HTRANS_IDLE : begin\n                            imem_ahb_addr  <= 'x;\n                            imem_hrdata_l  <= 'x;\n                        end\n                        SCR1_HTRANS_NONSEQ : begin\n                            imem_ahb_addr  <= imem_haddr;\n                            if(mirage_rangeen & imem_haddr>=mirage_adrlo & imem_haddr<mirage_adrhi)\n                                imem_hrdata_l <= scr1_read_mem({imem_haddr[SCR1_AHB_WIDTH-1:2], 2'b00}, imem_be, imem_wr_hazard, dmem_hwdata, 1'b1);\n                            else\n                                imem_hrdata_l <= scr1_read_mem({imem_haddr[SCR1_AHB_WIDTH-1:2], 2'b00}, imem_be, imem_wr_hazard, dmem_hwdata, 1'b0);\n                        end\n                        default : begin\n                            imem_ahb_addr  <= 'x;\n                            imem_hrdata_l  <= 'x;\n                        end\n                    endcase\n                end\n            end\n            default : begin\n                imem_ahb_addr  <= 'x;\n                imem_hrdata_l  <= 'x;\n            end\n        endcase\n    end\nend\n\n//-------------------------------------------------------------------------------\n// Instruction Memory response\n//-------------------------------------------------------------------------------\nalways_comb begin\n    imem_hready = 1'b1;\n    imem_hresp  = SCR1_HRESP_OKAY;\n    imem_hrdata = 'x;\n    case (imem_ahb_state)\n        SCR1_AHB_STATE_IDLE : begin\n        end\n        SCR1_AHB_STATE_DATA : begin\n            if (imem_req_ack) begin\n                imem_hready = 1'b1;\n\n                imem_hresp  = SCR1_HRESP_OKAY;\n                imem_hrdata = imem_hrdata_l;\n            end\n        end\n        default : begin\n        end\n    endcase\nend\n\n//-------------------------------------------------------------------------------\n// Data memory ready\n//-------------------------------------------------------------------------------\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        dmem_req_ack_stall <= dmem_req_ack_stall_in;\n        dmem_req_ack_rnd   <= 1'b0;\n    end else begin\n        if (dmem_req_ack_stall == 32'd0) begin\n            dmem_req_ack_rnd <= $random;\n        end else begin\n            dmem_req_ack_stall <= ((dmem_ahb_state == SCR1_AHB_STATE_DATA) | ~dmem_req_ack_stall[0]) ? {dmem_req_ack_stall[0], dmem_req_ack_stall[31:1]} : dmem_req_ack_stall;\n        end\n    end\nend\n\nassign dmem_req_ack = (dmem_req_ack_stall == 32'd0) ?  dmem_req_ack_rnd : dmem_req_ack_stall[0];\n\n//-------------------------------------------------------------------------------\n// Data memory AHB FSM\n//-------------------------------------------------------------------------------\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        dmem_ahb_state <= SCR1_AHB_STATE_IDLE;\n    end else begin\n        case (dmem_ahb_state)\n            SCR1_AHB_STATE_IDLE : begin\n//                if (dmem_req_ack) begin\n                    case (dmem_htrans)\n                        SCR1_HTRANS_IDLE : begin\n                            dmem_ahb_state <= SCR1_AHB_STATE_IDLE;\n                        end\n                        SCR1_HTRANS_NONSEQ : begin\n                            dmem_ahb_state    <= SCR1_AHB_STATE_DATA;\n                        end\n                        default : begin\n                            dmem_ahb_state    <= SCR1_AHB_STATE_ERR;\n                        end\n                    endcase\n//                end\n            end\n            SCR1_AHB_STATE_DATA : begin\n                if (dmem_req_ack) begin\n                    case (dmem_htrans)\n                        SCR1_HTRANS_IDLE : begin\n                            dmem_ahb_state    <= SCR1_AHB_STATE_IDLE;\n                        end\n                        SCR1_HTRANS_NONSEQ : begin\n                            if (~dmem_hwrite) begin\n                                case (dmem_haddr)\n                                    SCR1_SIM_SOFT_IRQ_ADDR,\n                                    SCR1_SIM_EXT_IRQ_ADDR\n                                    : begin\n                                        // Skip access, switch to SCR1_AHB_STATE_IDLE\n                                        dmem_ahb_state    <= SCR1_AHB_STATE_IDLE;\n                                    end\n                                    default : begin\n                                        dmem_ahb_state    <= SCR1_AHB_STATE_DATA;\n                                    end\n                                endcase\n                            end\n                        end\n                        default : begin\n                            dmem_ahb_state    <= SCR1_AHB_STATE_ERR;\n                        end\n                    endcase\n                end\n            end\n            default : begin\n                dmem_ahb_state    <= SCR1_AHB_STATE_ERR;\n            end\n        endcase\n    end\nend\n\n//-------------------------------------------------------------------------------\n// Address command latch\n//-------------------------------------------------------------------------------\nassign dmem_be = scr1_be_form(dmem_haddr[1:0], dmem_hsize);\nassign dmem_wr_hazard = (dmem_ahb_wr & (dmem_haddr[SCR1_AHB_WIDTH-1:2] == dmem_ahb_addr[SCR1_AHB_WIDTH-1:2])) ? dmem_be & dmem_ahb_be : '0;\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        dmem_ahb_addr  <= 'x;\n        dmem_ahb_wr    <= 1'b0;\n        dmem_ahb_size  <= SCR1_HSIZE_ERR;\n        dmem_ahb_be    <= '0;\n    end else begin\n        case (dmem_ahb_state)\n            SCR1_AHB_STATE_IDLE : begin\n//                if (dmem_req_ack) begin\n                    case (dmem_htrans)\n                        SCR1_HTRANS_IDLE : begin\n                        end\n                        SCR1_HTRANS_NONSEQ : begin\n                            dmem_ahb_addr <= dmem_haddr;\n                            dmem_ahb_wr   <= dmem_hwrite;\n                            dmem_ahb_size <= dmem_hsize;\n                            dmem_ahb_be   <= dmem_be;\n                            if (~dmem_hwrite) begin\n                                case (dmem_haddr)\n                                    // Reading Soft IRQ value\n                                    SCR1_SIM_SOFT_IRQ_ADDR : begin\n                                        dmem_hrdata_l <= '0;\n                                        dmem_hrdata_l[0] <= soft_irq_reg;\n                                    end\n`ifdef SCR1_IPIC_EN\n                                    // Reading IRQ Lines values\n                                    SCR1_SIM_EXT_IRQ_ADDR : begin\n                                        dmem_hrdata_l <= '0;\n                                        dmem_hrdata_l[SCR1_IRQ_LINES_NUM-1:0] <= irq_lines_reg;\n                                    end\n`else // SCR1_IPIC_EN\n                                    // Reading External IRQ value\n                                    SCR1_SIM_EXT_IRQ_ADDR : begin\n                                        dmem_hrdata_l <= '0;\n                                        dmem_hrdata_l[0] <= ext_irq_reg;\n                                    end\n`endif // SCR1_IPIC_EN\n                                    // Regular read operation\n                                    default : begin\n                                        if(mirage_rangeen & dmem_haddr>=mirage_adrlo & dmem_haddr<mirage_adrhi)\n                                            dmem_hrdata_l <= scr1_read_mem({dmem_haddr[SCR1_AHB_WIDTH-1:2], 2'b00}, dmem_be, dmem_wr_hazard, dmem_hwdata, 1'b1);\n                                        else\n                                            dmem_hrdata_l <= scr1_read_mem({dmem_haddr[SCR1_AHB_WIDTH-1:2], 2'b00}, dmem_be, dmem_wr_hazard, dmem_hwdata, 1'b0);\n                                    end\n                                endcase\n                            end\n                        end\n                        default : begin\n                            dmem_ahb_addr  <= 'x;\n                            dmem_ahb_wr    <= 'x;\n                            dmem_ahb_size  <= SCR1_HSIZE_ERR;\n                            dmem_hrdata_l  <= 'x;\n                        end\n                    endcase\n//                end\n            end\n            SCR1_AHB_STATE_DATA : begin\n                if (dmem_req_ack) begin\n                    case (dmem_htrans)\n                        SCR1_HTRANS_IDLE : begin\n                            dmem_ahb_addr     <= 'x;\n                            dmem_ahb_wr       <= 1'b0;\n                            dmem_ahb_size     <= SCR1_HSIZE_ERR;\n                        end\n                        SCR1_HTRANS_NONSEQ : begin\n                            dmem_ahb_addr <= dmem_haddr;\n                            dmem_ahb_wr   <= dmem_hwrite;\n                            dmem_ahb_size <= dmem_hsize"}
{"text": ";\n                            dmem_ahb_be   <= dmem_be;\n                            if (~dmem_hwrite) begin\n                                case (dmem_haddr)\n                                    SCR1_SIM_SOFT_IRQ_ADDR,\n                                    SCR1_SIM_EXT_IRQ_ADDR\n                                    : begin\n                                        // Skip access, switch to SCR1_AHB_STATE_IDLE\n                                    end\n                                    default : begin\n                                        if(mirage_rangeen & dmem_haddr>=mirage_adrlo & dmem_haddr<mirage_adrhi)\n                                            dmem_hrdata_l <= scr1_read_mem({dmem_haddr[SCR1_AHB_WIDTH-1:2], 2'b00}, dmem_be, dmem_wr_hazard, dmem_hwdata, 1'b1);\n                                        else\n                                            dmem_hrdata_l <= scr1_read_mem({dmem_haddr[SCR1_AHB_WIDTH-1:2], 2'b00}, dmem_be, dmem_wr_hazard, dmem_hwdata, 1'b0);\n                                    end\n                                endcase\n                            end\n                        end\n                        default : begin\n                            dmem_ahb_addr  <= 'x;\n                            dmem_ahb_wr    <= 'x;\n                            dmem_ahb_size  <= SCR1_HSIZE_ERR;\n                            dmem_ahb_be    <= 'x;\n                            dmem_hrdata_l  <= 'x;\n                        end\n                    endcase\n                end\n            end\n            default : begin\n                dmem_ahb_addr  <= 'x;\n                dmem_ahb_wr    <= 'x;\n                dmem_ahb_size  <= SCR1_HSIZE_ERR;\n                dmem_hrdata_l  <= 'x;\n            end\n        endcase\n    end\nend\n\n//-------------------------------------------------------------------------------\n// Data Memory response\n//-------------------------------------------------------------------------------\nalways_comb begin\n    dmem_hready = 1'b0;\n    dmem_hresp  = SCR1_HRESP_ERROR;\n    dmem_hrdata = 'x;\n    case (dmem_ahb_state)\n        SCR1_AHB_STATE_IDLE : begin\n            if (dmem_req_ack) begin\n                dmem_hready = 1'b1;\n            end\n        end\n        SCR1_AHB_STATE_DATA : begin\n            if (dmem_req_ack) begin\n                dmem_hready = 1'b1;\n                dmem_hresp  = SCR1_HRESP_OKAY;\n                if (~dmem_ahb_wr) begin\n                    dmem_hrdata = dmem_hrdata_l;\n                end\n            end\n        end\n        default : begin\n        end\n    endcase\nend\n\n//-------------------------------------------------------------------------------\n// Data Memory write\n//-------------------------------------------------------------------------------\nalways @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        soft_irq_reg   <= '0;\n`ifdef SCR1_IPIC_EN\n        irq_lines_reg  <= '0;\n`else // SCR1_IPIC_EN\n        ext_irq_reg    <= '0;\n`endif // SCR1_IPIC_EN\n        if (test_file_init) $readmemh(test_file, memory);\n    end else begin\n        if ((dmem_ahb_state == SCR1_AHB_STATE_DATA) & dmem_req_ack & dmem_ahb_wr) begin\n            case (dmem_ahb_addr)\n                // Printing character in the simulation console\n                SCR1_SIM_PRINT_ADDR : begin\n                    $write(\"%c\", dmem_hwdata[7:0]);\n                end\n                // Writing Soft IRQ value\n                SCR1_SIM_SOFT_IRQ_ADDR : begin\n                    soft_irq_reg <= dmem_hwdata[0];\n                end\n`ifdef SCR1_IPIC_EN\n                // Writing IRQ Lines values\n                SCR1_SIM_EXT_IRQ_ADDR : begin\n                    irq_lines_reg <= dmem_hwdata[SCR1_IRQ_LINES_NUM-1:0];\n                end\n`else // SCR1_IPIC_EN\n                // Writing External IRQ value\n                SCR1_SIM_EXT_IRQ_ADDR : begin\n                    ext_irq_reg <= dmem_hwdata[0];\n                end\n`endif // SCR1_IPIC_EN\n                // Regular write operation\n                default : begin\n                    if(mirage_rangeen & dmem_ahb_addr>=mirage_adrlo & dmem_ahb_addr<mirage_adrhi)\n                        scr1_write_mem({dmem_ahb_addr[SCR1_AHB_WIDTH-1:2], 2'b00}, dmem_ahb_be, dmem_hwdata, 1'b1);\n                    else\n                        scr1_write_mem({dmem_ahb_addr[SCR1_AHB_WIDTH-1:2], 2'b00}, dmem_ahb_be, dmem_hwdata, 1'b0);\n                end\n            endcase\n        end\n    end\nend\n\n`ifdef SCR1_IPIC_EN\nassign irq_lines = irq_lines_reg;\n`else // SCR1_IPIC_EN\nassign ext_irq = ext_irq_reg;\n`endif // SCR1_IPIC_EN\nassign soft_irq = soft_irq_reg;\n\nendmodule : scr1_memory_tb_ahb\n"}
{"text": "/// Copyright by Syntacore LLC \u00a9 2016-2020. See LICENSE for details\n/// @file       <scr1_memory_tb_axi.sv>\n/// @brief      AXI memory testbench\n///\n\n`include \"scr1_arch_description.svh\"\n`include \"scr1_ipic.svh\"\n\nmodule scr1_memory_tb_axi #(\n    parameter SIZE   = 1*1024*1024,\n    parameter N_IF   = 2,\n    parameter W_ID   = 4,\n    parameter W_ADR  = 32,\n    parameter W_DATA = 32\n)\n(\n    // System\n    input   logic                          rst_n,\n    input   logic                          clk,\n`ifdef SCR1_IPIC_EN\n    output  logic [SCR1_IRQ_LINES_NUM-1:0] irq_lines,\n`else // SCR1_IPIC_EN\n    output  logic                          ext_irq,\n`endif // SCR1_IPIC_EN\n    output  logic                          soft_irq,\n\n    // Write address channel\n    input  logic [N_IF-1:0]                awvalid,\n    input  logic [N_IF-1:0] [W_ID-1:0]     awid,\n    input  logic [N_IF-1:0] [W_ADR-1:0]    awaddr,\n    input  logic [N_IF-1:0] [2:0]          awsize,\n    input  logic [N_IF-1:0] [7:0]          awlen,\n    output logic [N_IF-1:0]                awready,\n\n    // Write data channel\n    input  logic [N_IF-1:0]                wvalid,\n    input  logic [N_IF-1:0] [W_DATA-1:0]   wdata,\n    input  logic [N_IF-1:0] [W_DATA/8-1:0] wstrb,\n    input  logic [N_IF-1:0]                wlast,\n    output logic [N_IF-1:0]                wready,\n\n    // Write response channel\n    input  logic [N_IF-1:0]                bready,\n    output logic [N_IF-1:0]                bvalid,\n    output logic [N_IF-1:0] [W_ID-1:0]     bid,\n    output logic [N_IF-1:0] [1:0]          bresp,\n\n    // Read address channel\n    input  logic [N_IF-1:0]                arvalid,\n    input  logic [N_IF-1:0] [W_ID-1:0]     arid,\n    input  logic [N_IF-1:0] [W_ADR-1:0]    araddr,\n    input  logic [N_IF-1:0] [1:0]          arburst,\n    input  logic [N_IF-1:0] [2:0]          arsize,\n    input  logic [N_IF-1:0] [7:0]          arlen,\n    output logic [N_IF-1:0]                arready,\n\n    // Read data channel\n    input  logic [N_IF-1:0]                rready,\n    output logic [N_IF-1:0]                rvalid,\n    output logic [N_IF-1:0] [W_ID-1:0]     rid,\n    output logic [N_IF-1:0] [W_DATA-1:0]   rdata,\n    output logic [N_IF-1:0]                rlast,\n    output logic [N_IF-1:0] [1:0]          rresp\n);\n\n//-------------------------------------------------------------------------------\n// Local signal declaration\n//-------------------------------------------------------------------------------\nlogic  [7:0]                                memory [0:SIZE-1];\nlogic  [N_IF-1:0] [W_ADR-1:0]               awaddr_hold;\nlogic  [N_IF-1:0] [2:0]                     awsize_hold;\ngenvar                                      gi;\ngenvar                                      gj;\n\n`ifdef SCR1_IPIC_EN\nlogic [SCR1_IRQ_LINES_NUM-1:0]              irq_lines_reg;\n`else // SCR1_IPIC_EN\nlogic                                       ext_irq_reg;\n`endif // SCR1_IPIC_EN\nlogic                                       soft_irq_reg;\n\n`ifdef VERILATOR\nlogic [255:0]                               test_file;\n`else // VERILATOR\nstring                                      test_file;\n`endif // VERILATOR\nbit                                         test_file_init;\n\n//-------------------------------------------------------------------------------\n// Local functions\n//-------------------------------------------------------------------------------\n\nfunction automatic logic [W_DATA-1:0] mem_read (\n    logic [W_ADR:0] adr,        // starting address of READ burst operation\n    int             bytes_num,  // number of bytes to read\n    int             bytes_max   // number of bytes in data width\n    );\n\n    logic [W_ADR:0] byte_lane;  // positional number of byte to read\n\n    mem_read  = 'x;\n    byte_lane = 0;\n\n    // Storing the positional number of byte to read\n    for(int i=0; i<$clog2(bytes_max); ++i) begin\n        byte_lane[i] = adr[i];\n    end\n\n    // READ burst operation\n    for(int i=byte_lane; i<bytes_max & bytes_num!=0; ++i) begin\n        // Reading Soft IRQ value\n        if (adr[W_ADR-1:1] == SCR1_SIM_SOFT_IRQ_ADDR[W_ADR-1:1]) begin\n            mem_read[0] = soft_irq_reg;\n`ifdef SCR1_IPIC_EN\n        // Reading IRQ Lines values\n        end else if (adr[W_ADR-1:1] == SCR1_SIM_EXT_IRQ_ADDR[W_ADR-1:1]) begin\n            if (i*8 < SCR1_IRQ_LINES_NUM) begin\n                if (SCR1_IRQ_LINES_NUM < 8) begin\n                    mem_read[(i*8)+:8] = irq_lines_reg;\n                end else begin\n                    mem_read[(i*8)+:8] = irq_lines_reg[(i*8)+:8];\n                end\n            end\n`else // SCR1_IPIC_EN\n        // Reading External IRQ value\n        end else if (adr[W_ADR-1:1] == SCR1_SIM_EXT_IRQ_ADDR[W_ADR-1:1]) begin\n            mem_read[0] = ext_irq_reg;\n`endif // SCR1_IPIC_EN\n        // Regular read operation\n        end else begin\n            mem_read[(i*8)+:8] = memory[adr];\n        end\n\n        adr = adr+1'b1;\n        bytes_num = bytes_num - 1'b1;\n    end\nendfunction : mem_read\n\nfunction automatic void mem_write (\n    logic [W_ADR-1:0]      adr,         // starting address of WRITE burst operation\n    logic [W_DATA-1:0]     data,        // data to write\n    logic [(W_DATA/8)-1:0] bytes_en,    // bytes write strobes\n    int                    bytes_num,   // number of bytes to write\n    int                    bytes_max    // number of bytes in data width\n    );\n\n    logic[W_ADR:0]         byte_lane;   // positional number of byte to write\n\n    byte_lane = 0;\n\n    // Storing the positional number of byte to write\n    for(int i=0; i<$clog2(bytes_max); ++i) begin\n        byte_lane[i] = adr[i];\n    end\n\n    // WRITE burst operation\n    for(int i=byte_lane; i<bytes_max & bytes_num!=0; ++i) begin\n        // Printing character in the simulation console\n        if(bytes_en[i] & adr == SCR1_SIM_PRINT_ADDR) begin\n            $write(\"%c\",data[(i*8)+:8]);\n        // Writing Soft IRQ value\n        end else if(bytes_en[0] & adr[W_ADR-1:1] == SCR1_SIM_SOFT_IRQ_ADDR[W_ADR-1:1]) begin\n            soft_irq_reg <= data[0];\n`ifdef SCR1_IPIC_EN\n        // Writing IRQ Lines values\n        end else if(bytes_en[i] & adr[W_ADR-1:1] == SCR1_SIM_EXT_IRQ_ADDR[W_ADR-1:1]) begin\n            if( i*8 < SCR1_IRQ_LINES_NUM ) begin\n                if( SCR1_IRQ_LINES_NUM < 8 ) begin\n                    irq_lines_reg <= data[SCR1_IRQ_LINES_NUM-1:0];\n                end else begin\n                    irq_lines_reg[(i*8)+:8] <= data[(i*8)+:8];\n                end\n            end\n`else\n        // Writing External IRQ value\n        end else if(bytes_en[0] & adr[W_ADR-1:1] == SCR1_SIM_EXT_IRQ_ADDR[W_ADR-1:1]) begin\n            ext_irq_reg <= data[0];\n`endif // SCR1_IPIC_EN\n        // Regular write operation\n        end else if (bytes_en[i]) begin\n            memory[adr] = data[(i*8)+:8];\n        end\n        adr       = adr+1'b1;\n        bytes_num = bytes_num-1'b1;\n    end\nendfunction : mem_write\n\n\n`ifdef SCR1_IPIC_EN\nassign irq_lines = irq_lines_reg;\n`else // SCR1_IPIC_EN\nassign ext_irq = ext_irq_reg;\n`endif // SCR1_IPIC_EN\nassign soft_irq = soft_irq_reg;\n\ngenerate for(gi=0; gi<N_IF; ++gi) begin : rw_if\n\n//-------------------------------------------------------------------------------\n// Read operation\n//-------------------------------------------------------------------------------\nalways @(posedge clk, negedge rst_n) begin\n    if(~rst_n) begin\n        arready[gi] <= 1'b1;\n        rvalid[gi]  <= 1'b0;\n        rresp[gi]   <= 2'd3;\n        rdata[gi]   <= 'x;\n        rlast[gi]   <= 1'b0;\n        rid[gi]     <= '0;\n    end else begin\n\n        // Read data: acked\n        if( rvalid[gi] & rready[gi] ) begin\n            arready[gi] <= 1'b1;\n            rvalid[gi]  <= 1'b0;\n        end else if( rvalid[gi] & !rready[gi] ) begin\n            arready[gi] <= 1'b0;\n        end\n\n        // Read data: valid\n        if( arvalid[gi] & arready[gi] & ~(rvalid[gi] & !rready[gi]) ) begin\n\n            rvalid[gi] <= 1'b1;\n            rresp[gi]  <= '0;\n            rlast[gi]  <= 1'b1;\n            rid[gi]    <= arid[gi];\n\n            rdata[gi]  <= mem_read( araddr[gi],\n                                    2**arsize[gi],\n                                    W_DATA/8 );\n        end\n    end\nend\n\n//-------------------------------------------------------------------------------\n// Write operation\n//-------------------------------------------------------------------------------\nalways @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        bvalid[gi]      <= '0;\n        bresp[gi]       <= 2'd3;\n        awready[gi]     <= 1'b1;\n        wready[gi]      <= 1'b1;\n\n        soft_irq_reg    <= '0;\n`ifdef SCR1_IPIC_EN\n        irq_lines_reg   <= '0;\n`else // SCR1_IPIC_EN\n        ext_irq_reg     <= '0;\n`endif // SCR1_IPIC_EN\n\n        if (test_file_init) $readmemh(test_file, memory);\n    end else begin\n\n        // Write data: response\n        if( bvalid[gi] & bready[gi] ) begin\n            bvalid[gi]  <= 1'b0;\n            awready[gi] <= 1'b1;\n            wready[gi]  <= 1'b1;\n        end else if( bvalid[gi] & !bready[gi] ) begin\n            awready[gi] <= 1'b0;\n            wready[gi]  <= 1'b0;\n        end\n\n        // Write data: get address\n        if( awvalid[gi] & awready[gi] & ~(bvalid[gi] & !bready[gi]) ) begin\n            bid <= awid[gi];\n            if( ~wvalid[gi] ) begin\n                awaddr_hold[gi] <= awaddr[gi];\n                awsize_hold[gi] <= awsize[gi];\n                awready[gi] <= 1'b0;\n            end\n        end\n\n        // Write data: get data\n        if( wvalid[gi] & wready[gi] & wlast[gi] ) begin\n            bvalid[gi] <= 1'b1;\n            bresp[gi]  <= '0;\n\n            mem_write( awready[gi] ? awaddr[gi] : awaddr_hold[gi],\n                       wdata[gi],\n                       wstrb[gi],\n                       2**(awready[gi] ? awsize[gi] : awsize_hold[gi]),\n                       W_DATA/8 );\n        end\n    end\nend\n\n//`ifndef VERILATOR\n//-------------------------------------------------------------------------------\n// Assertions\n//-------------------------------------------------------------------------------\nSVA_TBMEM_AWADDR_404 :\n    assert property (\n        @(negedge clk) disable iff (~rst_n)\n        awvalid[gi] |-> awaddr[gi]<SIZE | awaddr[gi]==SCR1_SIM_PRINT_ADDR\n                                        | awaddr[gi]==SCR1_SIM_SOFT_IRQ_ADDR\n                                        | awaddr[gi]==SCR1_SIM_EXT_IRQ_ADDR\n    )\n    else $error(\"TBMEM: awaddr[%0d] >= SIZE\",gi);\n\nSVA_TBMEM_X_AWVALID :\n    assert property (\n        @(negedge clk) disable iff (~rst_n)\n        !$isunknown(awvalid[gi])\n    )\n    else $error(\"TBMEM: X state on awvalid[%0d]\",gi);\n\nSVA_TBMEM_X_AWCHANNEL :\n    assert property (\n        @(negedge clk) disable iff (~rst_n)\n        awvalid[gi] |-> !$isunknown({awid[gi],awaddr[gi],awsize[gi],awlen[gi]})\n    )\n    else $error(\"TBMEM: X state on aw channel[%0d]\",gi);\n\nSVA_TBMEM_AWLEN :\n    assert property (\n        @(negedge clk) disable iff (~rst_n)\n        awvalid[gi] |-> awlen[gi]==0\n    )\n    else $error(\"TBMEM: awlen[%0d] = %0d is not supported\",gi,awlen[gi]);\n\nSVA_TBMEM_X_WVALID :\n    assert property (\n        @(negedge clk) disable iff (~rst_n)\n        !$isunknown(wvalid[gi])\n    )\n    else $error(\"TBMEM: X state on wvalid[%0d]\",gi);\n\nSVA_TBMEM_X_WCHANNEL :\n    assert property (\n        @(negedge clk) disable iff (~rst_n)\n        wvalid[gi] |-> !$isunknown({wstrb[gi],wlast[gi]})\n    )\n    else $error(\"TBMEM: X state on w channel[%0d]\",gi);\n\nfor(gj=0; gj<W_DATA/8; ++gj) begin : SVA_TBMEM_X_WSTRB\nWDATA :\n    assert property (\n        @(negedge clk) disable iff (~rst_n)\n        (wvalid[gi] & wstrb[gi][gj]) |-> !$isunknown(wdata[gi][(gj*8)+:8])\n    )\n    else $error(\"TBMEM: X state on wdata with wstrb[%0d][%0d]\",gi,gj);\nend\n\nSVA_TBMEM_X_BREADY :\n    assert property (\n        @(negedge clk) disable iff (~rst_n)\n        bvalid[gi] |-> !$isunknown(bready[gi])\n    )\n    else $error(\"TBMEM: X state on bready[%0d]\",gi);\n\nSVA_TBMEM_ARADDR_404 :\n    assert property (\n        @(negedge clk) disable iff (~rst_n)\n        arvalid[gi] |-> araddr[gi]<SIZE | araddr[gi]==SCR1_SIM_PRINT_ADDR\n                                        | awaddr[gi]==SCR1_SIM_SOFT_IRQ_ADDR\n                                        | awaddr[gi]==SCR1_SIM_EXT_IRQ_ADDR\n    )\n    else $error(\"TBMEM: awaddr[%0d] >= SIZE\",gi);\n\nSVA_TBMEM_X_ARVALID :\n    assert property (\n        @(negedge clk) disable iff (~rst_n)\n        !$isunknown(arvalid[gi])\n    )\n    else $error(\"TBMEM: X state on arvalid[%0d]\",gi);\n\nSVA_TBMEM_X_ARCHANNEL :\n    assert property (\n        @(negedge clk) disable iff (~rst_n)\n        arvalid[gi] |-> !$isunknown({arid[gi],araddr[gi],arsize[gi],arlen[gi]})\n    )\n    else $error(\"TBMEM: X state on ar channel[%0d]\",gi);\n\nSVA_TBMEM_ARLEN :\n    assert property (\n        @(negedge clk) disable iff (~rst_n)\n        arvalid[gi] |-> arlen[gi]==0\n    )\n    else $error(\"TBMEM: arlen[%0d] = %0d is not supported\",gi,arlen[gi]);\n\nSVA_TBMEM_X_RREADY :\n    assert property (\n        @(negedge clk) disable iff (~rst_n)\n        rvalid[gi] |-> !$isunknown(rready[gi])\n    )\n    else $error(\"TBMEM: X state on rready[%0d]\",gi);\n\n//`endif // VERILATOR\n\nend endgenerate\n\nendmodule : scr1_memory_tb_axi\n"}
{"text": "/// Copyright by Syntacore LLC \u00a9 2016-2020. See LICENSE for details\n/// @file       <scr1_mem_axi.sv>\n/// @brief      Memory AXI bridge\n///\n\n`include \"scr1_memif.svh\"\n`include \"scr1_arch_description.svh\"\n\nmodule scr1_mem_axi\n#(\n    parameter SCR1_REQ_BUF_SIZE     = 2,                    // Power of 2 value\n    parameter SCR1_AXI_IDWIDTH      = 4,\n    parameter SCR1_ADDR_WIDTH       = 32,\n    parameter SCR1_AXI_REQ_BP       = 1,\n    parameter SCR1_AXI_RESP_BP      = 1\n)\n(\n    // Clock and Reset\n    input   logic                           clk,\n    input   logic                           rst_n,\n    input   logic                           axi_reinit,\n    // Core Interface\n    output  logic                           core_idle,\n    output  logic                           core_req_ack,\n    input   logic                           core_req,\n    input   type_scr1_mem_cmd_e             core_cmd,\n    input   type_scr1_mem_width_e           core_width,\n    input   logic [SCR1_ADDR_WIDTH-1:0]     core_addr,\n    input   logic [31:0]                    core_wdata,\n    output  logic [31:0]                    core_rdata,\n    output  type_scr1_mem_resp_e            core_resp,\n\n    // AXI\n    output  logic [SCR1_AXI_IDWIDTH-1:0]    awid,\n    output  logic [SCR1_ADDR_WIDTH-1:0]     awaddr,\n    output  logic [ 7:0]                    awlen,\n    output  logic [ 2:0]                    awsize,\n    output  logic [ 1:0]                    awburst,\n    output  logic                           awlock,\n    output  logic [ 3:0]                    awcache,\n    output  logic [ 2:0]                    awprot,\n    output  logic [ 3:0]                    awregion,\n    output  logic [ 3:0]                    awuser,\n    output  logic [ 3:0]                    awqos,\n    output  logic                           awvalid,\n    input   logic                           awready,\n    output  logic [31:0]                    wdata,\n    output  logic [3:0]                     wstrb,\n    output  logic                           wlast,\n    output  logic [3:0]                     wuser,\n    output  logic                           wvalid,\n    input   logic                           wready,\n    input   logic [SCR1_AXI_IDWIDTH-1:0]    bid,\n    input   logic [ 1:0]                    bresp,\n    input   logic                           bvalid,\n    input   logic [ 3:0]                    buser,\n    output  logic                           bready,\n    output  logic [SCR1_AXI_IDWIDTH-1:0]    arid,\n    output  logic [SCR1_ADDR_WIDTH-1:0]     araddr,\n    output  logic [ 7:0]                    arlen,\n    output  logic [ 2:0]                    arsize,\n    output  logic [ 1:0]                    arburst,\n    output  logic                           arlock,\n    output  logic [ 3:0]                    arcache,\n    output  logic [ 2:0]                    arprot,\n    output  logic [ 3:0]                    arregion,\n    output  logic [ 3:0]                    aruser,\n    output  logic [ 3:0]                    arqos,\n    output  logic                           arvalid,\n    input   logic                           arready,\n    input   logic [SCR1_AXI_IDWIDTH-1:0]    rid,\n    input   logic [31:0]                    rdata,\n    input   logic [ 1:0]                    rresp,\n    input   logic                           rlast,\n    input   logic [ 3:0]                    ruser,\n    input   logic                           rvalid,\n    output  logic                           rready\n);\n\n\n// Local functions\nfunction automatic logic [2:0] width2axsize (\n    input   type_scr1_mem_width_e    width );\n    logic [2:0] axsize;\nbegin\n    case (width)\n        SCR1_MEM_WIDTH_BYTE :  axsize = 3'b000;\n        SCR1_MEM_WIDTH_HWORD:  axsize = 3'b001;\n        SCR1_MEM_WIDTH_WORD :  axsize = 3'b010;\n                     default:  axsize = 'x;\n    endcase\n\n    return axsize;\nend\nendfunction: width2axsize\n\ntypedef struct packed {\n    type_scr1_mem_width_e                               axi_width;\n    logic                    [SCR1_ADDR_WIDTH-1:0]      axi_addr;\n    logic                                   [31:0]      axi_wdata;\n} type_scr1_request_s;\n\ntypedef struct packed {\n    logic                                               req_write;\n    logic                                               req_addr;\n    logic                                               req_data;\n    logic                                               req_resp;\n} type_scr1_req_status_s;\n\n\ntype_scr1_request_s         [SCR1_REQ_BUF_SIZE-1:0]     req_fifo;\ntype_scr1_req_status_s      [SCR1_REQ_BUF_SIZE-1:0]     req_status;\ntype_scr1_req_status_s      [SCR1_REQ_BUF_SIZE-1:0]     req_status_new;\nlogic                       [SCR1_REQ_BUF_SIZE-1:0]     req_status_en;\nlogic               [$clog2(SCR1_REQ_BUF_SIZE)-1:0]     req_aval_ptr;\nlogic               [$clog2(SCR1_REQ_BUF_SIZE)-1:0]     req_proc_ptr;\nlogic               [$clog2(SCR1_REQ_BUF_SIZE)-1:0]     req_done_ptr;\nlogic                                                   rresp_err;\nlogic                                       [31:0]      rcvd_rdata;\ntype_scr1_mem_resp_e                                    rcvd_resp;\nlogic                                                   force_read;\nlogic                                                   force_write;\n\n\n\nassign core_req_ack =   ~axi_reinit                        &\n                        ~req_status[req_aval_ptr].req_resp &\n                         core_resp!=SCR1_MEM_RESP_RDY_ER;\n\n\nassign rready      = ~req_status[req_done_ptr].req_write;\nassign bready      =  req_status[req_done_ptr].req_write;\n\n\nassign force_read  = bit'(SCR1_AXI_REQ_BP) & core_req & core_req_ack & req_aval_ptr==req_proc_ptr & core_cmd==SCR1_MEM_CMD_RD;\nassign force_write = bit'(SCR1_AXI_REQ_BP) & core_req & core_req_ack & req_aval_ptr==req_proc_ptr & core_cmd==SCR1_MEM_CMD_WR;\n\n\nalways_comb begin: idle_status\n    core_idle = 1'b1;\n    for (int unsigned i=0; i<SCR1_REQ_BUF_SIZE; ++i) begin\n        core_idle &= req_status[i].req_resp==1'b0;\n    end\nend\n\nalways_ff @(posedge clk) begin\n    if (core_req & core_req_ack) begin\n        req_fifo[req_aval_ptr].axi_width <= core_width;\n        req_fifo[req_aval_ptr].axi_addr  <= core_addr;\n        req_fifo[req_aval_ptr].axi_wdata <= core_wdata;\n    end\nend\n\n// Request Status Queue\n// It is used for holding control info of processing requests\n\n// Combinational logic of Request Status Queue\nalways_comb begin\n    // Default\n    req_status_en  = '0; // No update\n    req_status_new = req_status; // Hold request info\n\n    // Update status on new core request\n    if( core_req & core_req_ack ) begin\n        req_status_en[req_aval_ptr]            = 1'd1;\n\n        req_status_new[req_aval_ptr].req_resp  = 1'd1;\n        req_status_new[req_aval_ptr].req_write = core_cmd == SCR1_MEM_CMD_WR;\n\n        req_status_new[req_aval_ptr].req_addr  = ~( (force_read & arready) |\n                                                    (force_write & awready) );\n\n        req_status_new[req_aval_ptr].req_data  = ~( (force_write & wready & awlen == 8'd0) |\n                                                    (~force_write & core_cmd == SCR1_MEM_CMD_RD) );\n    end\n\n    // Update status on AXI address phase\n    if ( (awvalid & awready) | (arvalid & arready) ) begin\n        req_status_en[req_proc_ptr]           = 1'd1;\n        req_status_new[req_proc_ptr].req_addr = 1'd0;\n    end\n\n    // Update status on AXI data phase\n    if ( wvalid & wready & wlast ) begin\n        req_status_en[req_proc_ptr]           = 1'd1;\n        req_status_new[req_proc_ptr].req_data = 1'd0;\n    end\n\n    // Update status when AXI finish transaction\n    if ( (bvalid & bready) | (rvalid & rready & rlast) ) begin\n        req_status_en[req_done_ptr]           = 1'd1;\n        req_status_new[req_done_ptr].req_resp = 1'd0;\n    end\nend\n\n// Request Status Queue register\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        req_status <= '0;\n    end else begin\n        for (int unsigned i = 0; i < SCR1_REQ_BUF_SIZE; ++i) begin\n            if ( req_status_en[i] ) begin\n                req_status[i] <= req_status_new[i];\n            end\n        end\n    end\nend\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n)                         req_aval_ptr <= '0;\n    else if (core_req & core_req_ack)   req_aval_ptr <= req_aval_ptr + 1'b1;\nend\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        req_proc_ptr <= '0;\n    end else begin\n        if ((                                                    awvalid & awready & wvalid & wready & wlast) |\n            (~force_write & ~req_status[req_proc_ptr].req_data & awvalid & awready                          ) |\n            (~force_write & ~req_status[req_proc_ptr].req_addr &                     wvalid & wready & wlast) |\n            (               ~req_status[req_proc_ptr].req_data & arvalid & arready                          )  ) begin\n\n            req_proc_ptr <= req_proc_ptr + 1'b1;\n        end\n    end\nend\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        req_done_ptr <= '0;\n    end else begin\n        if ((bvalid & bready | rvalid & rready & rlast) & req_status[req_done_ptr].req_resp) begin\n\n            req_done_ptr <= req_done_ptr + 1'b1;\n        end\n    end\nend\n\n\n\nassign arvalid = req_status[req_proc_ptr].req_addr & ~req_status[req_proc_ptr].req_write | force_read;\nassign awvalid = req_status[req_proc_ptr].req_addr &  req_status[req_proc_ptr].req_write | force_write;\nassign  wvalid = req_status[req_proc_ptr].req_data &  req_status[req_proc_ptr].req_write | force_write;\n\nassign araddr  = (~force_read )? req_fifo[req_proc_ptr].axi_addr : core_addr;\nassign awaddr  = (~force_write)? req_fifo[req_proc_ptr].axi_addr : core_addr;\n\nalways_comb begin\n    if (bvalid & bready & req_status[req_done_ptr].req_resp) begin\n        rcvd_resp = (bresp==2'b00)? SCR1_MEM_RESP_RDY_OK :\n                                    SCR1_MEM_RESP_RDY_ER;\n    end else begin\n        if (rvalid & rready & rlast & req_status[req_done_ptr].req_resp) begin\n            rcvd_resp = (rresp==2'b00)? SCR1_MEM_RESP_RDY_OK :\n                                        SCR1_MEM_RESP_RDY_ER;\n        end else begin\n            rcvd_resp = SCR1_MEM_RESP_NOTRDY;\n        end\n    end\nend\n\n\n\n\n// Write data signals adaptation\nalways_comb begin\n    if (force_write)\n        case (core_width)\n            SCR1_MEM_WIDTH_BYTE :  wstrb = 4'h1 << core_addr[1:0];\n            SCR1_MEM_WIDTH_HWORD:  wstrb = 4'h3 << core_addr[1:0];\n            SCR1_MEM_WIDTH_WORD :  wstrb = 4'hf << core_addr[1:0];\n                         default:  wstrb = 'x;\n        endcase\n    else\n        case (req_fifo[req_proc_ptr].axi_width)\n            SCR1_MEM_WIDTH_BYTE :  wstrb = 4'h1 << req_fifo[req_proc_ptr].axi_addr[1:0];\n            SCR1_MEM_WIDTH_HWORD:  wstrb = 4'h3 << req_fifo[req_proc_ptr].axi_addr[1:0];\n            SCR1_MEM_WIDTH_WORD :  wstrb = 4'hf << req_fifo[req_proc_ptr].axi_addr[1:0];\n                         default:  wstrb = 'x;\n        endcase\nend\n\n\n\nassign wdata = (force_write)?                       core_wdata << (8*                       core_addr[1:0]) :\n                              req_fifo[req_proc_ptr].axi_wdata << (8* req_fifo[req_proc_ptr].axi_addr[1:0]);\n\n\n// Read data adaptation\nalways_comb begin\n    case (req_fifo[req_done_ptr].axi_width)\n        SCR1_MEM_WIDTH_BYTE :  rcvd_rdata = rdata >> (8*req_fifo[req_done_ptr].axi_addr[1:0]);\n        SCR1_MEM_WIDTH_HWORD:  rcvd_rdata = rdata >> (8*req_fifo[req_done_ptr].axi_addr[1:0]);\n        SCR1_MEM_WIDTH_WORD :  rcvd_rdata = rdata >> (8*req_fifo[req_done_ptr].axi_addr[1:0]);\n                     default:  rcvd_rdata = 'x;\n    endcase\nend\n\n\ngenerate\n    if (SCR1_AXI_RESP_BP == 1) begin : axi_resp_bp\n        assign core_rdata = (rvalid & rready & rlast) ? rcvd_rdata : '0;\n        assign core_resp  = (axi_reinit) ? SCR1_MEM_RESP_NOTRDY : rcvd_resp;\n    end else begin : axi_resp_no_bp\n        always_ff @(negedge rst_n, posedge clk) begin\n            if (~rst_n)              core_resp  <= SCR1_MEM_RESP_NOTRDY;\n            else                     core_resp  <= (axi_reinit) ? SCR1_MEM_RESP_NOTRDY : rcvd_resp;\n        end\n        always_ff @(posedge clk) begin\n            if (rvalid & rready & rlast) core_rdata <= rcvd_rdata;\n        end\n    end\nendgenerate\n\n\n\n// AXI interface assignments\nassign awid     = SCR1_AXI_IDWIDTH'(1);\nassign awlen    = 8'd0;\nassign awsize   = (force_write) ? width2axsize(core_width) : width2axsize(req_fifo[req_proc_ptr].axi_width);\nassign awburst  = 2'd1;\nassign awcache  = 4'd2;\nassign awlock   = '0;\nassign awprot   = '0;\nassign awregion = '0;\nassign awuser   = '0;\nassign awqos    = '0;\n\nassign arid     = SCR1_AXI_IDWIDTH'(0);\nassign arlen    = 8'd0;\nassign arsize   = (force_read) ? width2axsize(core_width) : width2axsize(req_fifo[req_proc_ptr].axi_width);\nassign arburst  = 2'd1;\nassign arcache  = 4'd2;\nassign arprot   = '0;\nassign arregion = '0;\nassign arlock   = '0;\nassign arqos    = '0;\nassign aruser   = '0;\n\nassign wlast    = 1'd1;\nassign wuser    = '0;\n\n\n`ifdef SCR1_TRGT_SIMULATION\n//-------------------------------------------------------------------------------\n// Assertion\n//-------------------------------------------------------------------------------\n\n// X checks\nSCR1_SVA_AXI_X_CHECK0  : assert property (@(negedge clk) disable iff (~rst_n)   !$isunknown({core_req, awready, wready, bvalid, arready, rvalid}) )\n                                                                                                        else $error(\"AXI bridge: X state on input\");\nSCR1_SVA_AXI_X_CHECK1  : assert property (@(negedge clk) disable iff (~rst_n)   core_req |->\n                                                                                    !$isunknown({core_cmd, core_width, core_addr}) )\n                                                                                                        else $error(\"AXI bridge: X state on input\");\nSCR1_SVA_AXI_X_CHECK2  : assert property (@(negedge clk) disable iff (~rst_n)   bvalid |->\n                                                                                    !$isunknown({bid, bresp}) )\n                                                                                                        else $error(\"AXI bridge: X state on input\");\nSCR1_SVA_AXI_X_CHECK3  : assert property (@(negedge clk) disable iff (~rst_n)   rvalid |->\n                                                                                    !$isunknown({rid, rresp}) )\n                                                                                                        else $error(\"AXI bridge: X state on input\");\n`endif // SCR1_TRGT_SIMULATION\n\nendmodule : scr1_mem_axi\n"}
{"text": "/// Copyright by Syntacore LLC \u00a9 2016-2021. See LICENSE for details\n/// @file       <scr1_pipe_csr.sv>\n/// @brief      Control Status Registers (CSR)\n///\n\n//------------------------------------------------------------------------------\n //\n // Functionality:\n // - Provides access to RISC-V CSR Machine registers\n // - Handles events (EXC, IRQ and MRET):\n //   - Setups handling configuration\n //   - Displays events statuses and information\n //   - Generates new PC\n // - Provides information about the number of executed instructions and elapsed\n //   cycles\n // - Provides interfaces for IPIC, HDU and TDU registers access\n //\n // Structure:\n // - Events (EXC, IRQ, MRET) logic\n // - CSR read/write interface\n // - CSR registers:\n //   - Machine Trap Setup registers\n //   - Machine Trap Handling registers\n //   - Machine Counters/Timers registers\n //   - Non-standard CSRs (MCOUNTEN)\n // - CSR <-> EXU i/f\n // - CSR <-> IPIC i/f\n // - CSR <-> HDU i/f\n // - CSR <-> TDU i/f\n //\n//------------------------------------------------------------------------------\n\n`include \"scr1_arch_description.svh\"\n`include \"scr1_csr.svh\"\n`include \"scr1_arch_types.svh\"\n`include \"scr1_riscv_isa_decoding.svh\"\n`ifdef SCR1_IPIC_EN\n`include \"scr1_ipic.svh\"\n`endif // SCR1_IPIC_EN\n`ifdef SCR1_DBG_EN\n`include \"scr1_hdu.svh\"\n`endif // SCR1_DBG_EN\n`ifdef SCR1_TDU_EN\n`include \"scr1_tdu.svh\"\n`endif // SCR1_TDU_EN\n\nmodule scr1_pipe_csr (\n    // Common\n    input   logic                                       rst_n,                      // CSR reset\n    input   logic                                       clk,                        // Gated CSR clock\n`ifndef SCR1_CSR_REDUCED_CNT\n `ifdef SCR1_CLKCTRL_EN\n    input   logic                                       clk_alw_on,                 // Not-gated CSR clock\n `endif // SCR1_CLKCTRL_EN\n`endif // SCR1_CSR_REDUCED_CNT\n\n    // SOC signals\n    // IRQ\n    input   logic                                       soc2csr_irq_ext_i,          // External interrupt request\n    input   logic                                       soc2csr_irq_soft_i,         // Software interrupt request\n    input   logic                                       soc2csr_irq_mtimer_i,       // External timer interrupt request\n\n    // Memory-mapped external timer\n    input   logic [63:0]                                soc2csr_mtimer_val_i,       // External timer value\n\n    // MHARTID fuse\n    input   logic [`SCR1_XLEN-1:0]                      soc2csr_fuse_mhartid_i,     // MHARTID fuse\n\n    // CSR <-> EXU read/write interface\n    input   logic                                       exu2csr_r_req_i,            // CSR read request\n    input   logic [SCR1_CSR_ADDR_WIDTH-1:0]             exu2csr_rw_addr_i,          // CSR read/write address\n    output  logic [`SCR1_XLEN-1:0]                      csr2exu_r_data_o,           // CSR read data\n    input   logic                                       exu2csr_w_req_i,            // CSR write request\n    input   type_scr1_csr_cmd_sel_e                     exu2csr_w_cmd_i,            // CSR write command\n    input   logic [`SCR1_XLEN-1:0]                      exu2csr_w_data_i,           // CSR write data\n    output  logic                                       csr2exu_rw_exc_o,           // CSR read/write access exception\n\n    // CSR <-> EXU event interface\n    input   logic                                       exu2csr_take_irq_i,         // Take IRQ trap\n    input   logic                                       exu2csr_take_exc_i,         // Take exception trap\n    input   logic                                       exu2csr_mret_update_i,      // MRET update CSR\n    input   logic                                       exu2csr_mret_instr_i,       // MRET instruction\n    input   type_scr1_exc_code_e                        exu2csr_exc_code_i,         // Exception code (see scr1_arch_types.svh)\n    input   logic [`SCR1_XLEN-1:0]                      exu2csr_trap_val_i,         // Trap value\n    output  logic                                       csr2exu_irq_o,              // IRQ request\n    output  logic                                       csr2exu_ip_ie_o,            // Some IRQ pending and locally enabled\n    output  logic                                       csr2exu_mstatus_mie_up_o,   // MSTATUS or MIE update in the current cycle\n\n`ifdef SCR1_IPIC_EN\n    // CSR <-> IPIC interface\n    output  logic                                       csr2ipic_r_req_o,           // IPIC read request\n    output  logic                                       csr2ipic_w_req_o,           // IPIC write request\n    output  logic [2:0]                                 csr2ipic_addr_o,            // IPIC address\n    output  logic [`SCR1_XLEN-1:0]                      csr2ipic_wdata_o,           // IPIC write data\n    input   logic [`SCR1_XLEN-1:0]                      ipic2csr_rdata_i,           // IPIC read data\n`endif // SCR1_IPIC_EN\n\n`ifdef SCR1_DBG_EN\n    // CSR <-> HDU interface\n    output  logic                                       csr2hdu_req_o,              // Request to HDU\n    output  type_scr1_csr_cmd_sel_e                     csr2hdu_cmd_o,              // HDU command\n    output  logic [SCR1_HDU_DEBUGCSR_ADDR_WIDTH-1:0]    csr2hdu_addr_o,             // HDU address\n    output  logic [`SCR1_XLEN-1:0]                      csr2hdu_wdata_o,            // HDU write data\n    input   logic [`SCR1_XLEN-1:0]                      hdu2csr_rdata_i,            // HDU read data\n    input   type_scr1_csr_resp_e                        hdu2csr_resp_i,             // HDU response\n    input   logic                                       hdu2csr_no_commit_i,        // Forbid instruction commitment\n`endif // SCR1_DBG_EN\n\n`ifdef SCR1_TDU_EN\n    // CSR <-> TDU interface\n    output  logic                                       csr2tdu_req_o,              // Request to TDU\n    output  type_scr1_csr_cmd_sel_e                     csr2tdu_cmd_o,              // TDU command\n    output  logic [SCR1_CSR_ADDR_TDU_OFFS_W-1:0]        csr2tdu_addr_o,             // TDU address\n    output  logic [`SCR1_XLEN-1:0]                      csr2tdu_wdata_o,            // TDU write data\n    input   logic [`SCR1_XLEN-1:0]                      tdu2csr_rdata_i,            // TDU read data\n    input   type_scr1_csr_resp_e                        tdu2csr_resp_i,             // TDU response\n`endif // SCR1_TDU_EN\n\n    // CSR <-> EXU PC interface\n`ifndef SCR1_CSR_REDUCED_CNT\n    input   logic                                       exu2csr_instret_no_exc_i,   // Instruction retired (without exception)\n`endif // SCR1_CSR_REDUCED_CNT\n    input   logic [`SCR1_XLEN-1:0]                      exu2csr_pc_curr_i,          // Current PC\n    input   logic [`SCR1_XLEN-1:0]                      exu2csr_pc_next_i,          // Next PC\n    output  logic [`SCR1_XLEN-1:0]                      csr2exu_new_pc_o            // Exception/IRQ/MRET new PC\n);\n\n//------------------------------------------------------------------------------\n// Local parameters\n//------------------------------------------------------------------------------\n\n`ifdef SCR1_RVC_EXT\n    localparam PC_LSB = 1;\n`else\n    localparam PC_LSB = 2;\n`endif\n\n//------------------------------------------------------------------------------\n// Local signals declaration\n//------------------------------------------------------------------------------\n\n// Machine Trap Setup registers\n//------------------------------------------------------------------------------\n\n// MSTATUS register\nlogic                                               csr_mstatus_upd;        // MSTATUS update enable\nlogic [`SCR1_XLEN-1:0]                              csr_mstatus;            // Aggregated MSTATUS\nlogic                                               csr_mstatus_mie_ff;     // MSTATUS: Global interrupt enable\nlogic                                               csr_mstatus_mie_next;   // MSTATUS: Global interrupt enable next value\nlogic                                               csr_mstatus_mpie_ff;    // MSTATUS: Global interrupt enable prior to the trap\nlogic                                               csr_mstatus_mpie_next;  // MSTATUS: Global interrupt enable prior to the trap next value\n\n// MIE register\nlogic                                               csr_mie_upd;            // MIE update enable\nlogic [`SCR1_XLEN-1:0]                              csr_mie;                // Aggregated MIE\nlogic                                               csr_mie_mtie_ff;        // MIE: Machine timer interrupt enable\nlogic                                               csr_mie_meie_ff;        // MIE: Machine external interrupt enable\nlogic                                               csr_mie_msie_ff;        // MIE: Machine software interrupt enable\n\n// MTVEC register\nlogic                                               csr_mtvec_upd;          // MTVEC update enable\nlogic [`SCR1_XLEN-1:SCR1_CSR_MTVEC_BASE_ZERO_BITS]  csr_mtvec_base;         // MTVEC: Base (upper 26 bits)\nlogic                                               csr_mtvec_mode;         // MTVEC: Mode (0-direct, 1-vectored) (wired)\n`ifdef SCR1_MTVEC_MODE_EN\nlogic                                               csr_mtvec_mode_ff;      // MTVEC: Mode (0-direct, 1-vectored) (registered)\nlogic                                               csr_mtvec_mode_vect;\n`endif\n\n// Machine Trap Handling registers\n//------------------------------------------------------------------------------\n\n// MSCRATCH register\nlogic                                               csr_mscratch_upd;       // MSCRATCH update enable\nlogic [`SCR1_XLEN-1:0]                              csr_mscratch_ff;        // MSCRATCH\n\n// MEPC register\nlogic                                               csr_mepc_upd;           // MEPC update enable\nlogic [`SCR1_XLEN-1:PC_LSB]                         csr_mepc_ff;            // MEPC registered value\nlogic [`SCR1_XLEN-1:PC_LSB]                         csr_mepc_next;          // MEPC next value\nlogic [`SCR1_XLEN-1:0]                              csr_mepc;               // MEPC registered value extended to XLEN\n\n// MCAUSE register\nlogic                                               csr_mcause_upd;         // MCAUSE update enable\nlogic                                               csr_mcause_i_ff;        // MCAUSE: Interrupt\nlogic                                               csr_mcause_i_next;      // MCAUSE: Interrupt next value\ntype_scr1_exc_code_e                                csr_mcause_ec_ff;       // MCAUSE: Exception code\ntype_scr1_exc_code_e                                csr_mcause_ec_next;     // MCAUSE: Exception code next value\ntype_scr1_exc_code_e                                csr_mcause_ec_new;      // MCAUSE: Exception code new value (IRQs)\n\n// MTVAL register\nlogic                                               csr_mtval_upd;          // MTVAL update enable\nlogic [`SCR1_XLEN-1:0]                              csr_mtval_ff;           // MTVAL registered value\nlogic [`SCR1_XLEN-1:0]                              csr_mtval_next;         // MTVAL next value\n\n// MIP register\nlogic [`SCR1_XLEN-1:0]                              csr_mip;                // Aggregated MIP\nlogic                                               csr_mip_mtip;           // MIP: Machine timer interrupt pending\nlogic                                               csr_mip_meip;           // MIP: Machine external interrupt pending\nlogic                                               csr_mip_msip;           // MIP: Machine software interrupt pending\n\n// Machine Counters/Timers registers\n//------------------------------------------------------------------------------\n\n`ifndef SCR1_CSR_REDUCED_CNT\n// MINSTRET register\nlogic [1:0]                                         csr_minstret_upd;\nlogic [SCR1_CSR_COUNTERS_WIDTH-1:0]                 csr_minstret;\nlogic                                               csr_minstret_lo_inc;\nlogic                                               csr_minstret_lo_upd;\nlogic [7:0]                                         csr_minstret_lo_ff;\nlogic [7:0]                                         csr_minstret_lo_next;\nlogic                                               csr_minstret_hi_inc;\nlogic                                               csr_minstret_hi_upd;\nlogic [SCR1_CSR_COUNTERS_WIDTH-1:8]                 csr_minstret_hi_ff;\nlogic [SCR1_CSR_COUNTERS_WIDTH-1:8]                 csr_minstret_hi_next;\nlogic [SCR1_CSR_COUNTERS_WIDTH-1:8]                 csr_minstret_hi_new;\n\n// MCYCLE register\nlogic [1:0]                                         csr_mcycle_upd;\nlogic [SCR1_CSR_COUNTERS_WIDTH-1:0]                 csr_mcycle;\nlogic                                               csr_mcycle_lo_inc;\nlogic                                               csr_mcycle_lo_upd;\nlogic [7:0]                                         csr_mcycle_lo_ff;\nlogic [7:0]                                         csr_mcycle_lo_next;\nlogic                                               csr_mcycle_hi_inc;\nlogic                                               csr_mcycle_hi_upd;\nlogic [SCR1_CSR_COUNTERS_WIDTH-1:8]                 csr_mcycle_hi_ff;\nlogic [SCR1_CSR_COUNTERS_WIDTH-1:8]                 csr_mcycle_hi_next;\nlogic [SCR1_CSR_COUNTERS_WIDTH-1:8]                 csr_mcycle_hi_new;\n`endif // ~SCR1_CSR_REDUCED_CNT\n\n// Non-standard CSRs\n//------------------------------------------------------------------------------\n\n// MCOUNTEN register\n`ifdef SCR1_MCOUNTEN_EN\nlogic                                               csr_mcounten_upd;       // MCOUNTEN update enable\nlogic [`SCR1_XLEN-1:0]                              csr_mcounten;           // Aggregated MCOUNTEN\nlogic                                               csr_mcounten_cy_ff;     // Cycle count enable\nlogic                                               csr_mcounten_ir_ff;     // Instret count enable\n`endif // SCR1_MCOUNTEN_EN\n\n// CSR read/write i/f\n//------------------------------------------------------------------------------\n\nlogic [`SCR1_XLEN-1:0]                              csr_r_data;\nlogic [`SCR1_XLEN-1:0]                              csr_w_data;\n\n// Events (exceptions, interrupts, mret) signals\n//------------------------------------------------------------------------------\n\n// Event flags\nlogic                                               e_exc;              // Successful exception trap\nlogic                                               e_irq;              // Successful IRQ trap\nlogic                                               e_mret;             // MRET instruction\nlogic                                               e_irq_nmret;        // IRQ trap without MRET instruction\n\n// Interrupt pending & enable signals\nlogic                                               csr_eirq_pnd_en;    // External IRQ pending and locally enabled\nlogic                                               csr_sirq_pnd_en;    // Software IRQ pending and locally enabled\nlogic                                               csr_tirq_pnd_en;    // Timer IRQ pending and locally enabled\n\n// Exception flags\nlogic                                               csr_w_exc;\nlogic                                               csr_r_exc;\nlogic                                               exu_req_no_exc;\n\n// Requests to other modules\nlogic                                               csr_ipic_req;\n`ifdef SCR1_DBG_EN\nlogic                                               csr_hdu_req;\n`endif // SCR1_DBG_EN\n`ifdef SCR1_TDU_EN\nlogic                                               csr_brkm_req;\n`endif // SCR1_TDU_EN\n\n//------------------------------------------------------------------------------\n// Events (IRQ, EXC, MRET)\n//------------------------------------------------------------------------------\n\n// Events priority\nassign e_exc    = exu2csr_take_exc_i\n`ifdef SCR1_DBG_EN\n                & ~hdu2csr_no_commit_i\n`endif // SCR1_DBG_EN\n                ;\nassign e_irq    = exu2csr_take_irq_i & ~exu2csr_take_exc_i\n`ifdef SCR1_DBG_EN\n                & ~hdu2csr_no_commit_i\n`endif // SCR1_DBG_EN\n                ;\nassign e_mret   = exu2csr_mret_update_i\n`ifdef SCR1_DBG_EN\n                & ~hdu2csr_no_commit_i\n`endif // SCR1_DBG_EN\n                ;\nassign e_irq_nmret = e_irq & ~exu2csr_mret_instr_i;\n\n// IRQ pending & enable signals\nassign csr_eirq_pnd_en = csr_mip_meip & csr_mie_meie_ff;\nassign csr_sirq_pnd_en = csr_mip_msip & csr_mie_msie_ff;\nassign csr_tirq_pnd_en = csr_mip_mtip & csr_mie_mtie_ff;\n\n// IRQ exception codes priority\nalways_comb begin\n    case (1'b1)\n        csr_eirq_pnd_en: csr_mcause_ec_new = type_scr1_exc_code_e'(SCR1_EXC_CODE_IRQ_M_EXTERNAL);\n        csr_sirq_pnd_en: csr_mcause_ec_new = type_scr1_exc_code_e'(SCR1_EXC_CODE_IRQ_M_SOFTWARE);\n        csr_tirq_pnd_en: csr_mcause_ec_new = type_scr1_exc_code_e'(SCR1_EXC_CODE_IRQ_M_TIMER);\n        default        : csr_mcause_ec_new = type_scr1_exc_code_e'(SCR1_EXC_CODE_IRQ_M_EXTERNAL);\n    endcase\nend\n\nassign exu_req_no_exc = ((exu2csr_r_req_i & ~csr_r_exc)\n                      |  (exu2csr_w_req_i & ~csr_w_exc));\n\n//------------------------------------------------------------------------------\n// CSR read/write interface\n//------------------------------------------------------------------------------\n\n// CSR read logic\n//------------------------------------------------------------------------------\n\nalways_comb begin\n    csr_r_data     = '0;\n    csr_r_exc      = 1'b0;\n`ifdef SCR1_DBG_EN\n    csr_hdu_req    = 1'b0;\n`endif // SCR1_DBG_EN\n`ifdef SCR1_TDU_EN\n    csr_brkm_req   = 1'b0;\n`endif // SCR1_TDU_EN\n`ifdef SCR1_IPIC_EN\n    csr2ipic_r_req_o = 1'b0;\n`endif // SCR1_IPIC_EN\n\n    casez (exu2csr_rw_addr_i)\n        // Machine Information Registers (read-only)\n        SCR1_CSR_ADDR_MVENDORID : csr_r_data    = SCR1_CSR_MVENDORID;\n        SCR1_CSR_ADDR_MARCHID   : csr_r_data    = SCR1_CSR_MARCHID;\n        SCR1_CSR_ADDR_MIMPID    : csr_r_data    = SCR1_CSR_MIMPID;\n        SCR1_CSR_ADDR_MHARTID   : csr_r_data    = soc2csr_fuse_mhartid_i;\n\n        // Machine Trap Setup (read-write)\n        SCR1_CSR_ADDR_MSTATUS   : csr_r_data    = csr_mstatus;\n        SCR1_CSR_ADDR_MISA      : csr_r_data    = SCR1_CSR_MISA;\n        SCR1_CSR_ADDR_MIE       : csr_r_data    = csr_mie;\n        SCR1_CSR_ADDR_MTVEC     : csr_r_data    = {csr_mtvec_base, 4'd0, 2'(csr_mtvec_mode)};\n\n        // Machine Trap Handling (read-write)\n        SCR1_CSR_ADDR_MSCRATCH  : csr_r_data    = csr_mscratch_ff;\n        SCR1_CSR_ADDR_MEPC      : csr_r_data    = csr_mepc;\n        SCR1_CSR_ADDR_MCAUSE    : csr_r_data    = {csr_mcause_i_ff, type_scr1_csr_mcause_ec_v'(csr_mcause_ec_ff)};\n        SCR1_CSR_ADDR_MTVAL     : csr_r_data    = csr_mtval_ff;\n        SCR1_CSR_ADDR_MIP       : csr_r_data    = csr_mip;\n\n        // User Counters/Timers (read-only)\n        {SCR1_CSR_ADDR_HPMCOUNTER_MASK, 5'b?????}   : begin\n            case (exu2csr_rw_addr_i[4:0])\n                5'd1        : csr_r_data    = soc2csr_mtimer_val_i[31:0];\n`ifndef SCR1_CSR_REDUCED_CNT\n                5'd0        : csr_r_data    = csr_mcycle[31:0];\n                5'd2        : csr_r_data    = csr_minstret[31:0];\n`endif // SCR1_CSR_REDUCED_CNT\n                default     : begin\n                    // return 0\n                end\n            endcase\n        end\n\n        {SCR1_CSR_ADDR_HPMCOUNTERH_MASK, 5'b?????}  : begin\n            case (exu2csr_rw_addr_i[4:0])\n                5'd1        : csr_r_data    = soc2csr_mtimer_val_i[63:32];\n`ifndef SCR1_CSR_REDUCED_CNT\n                5'd0        : csr_r_data    = csr_mcycle[63:32];\n                5'd2        : csr_r_data    = csr_minstret[63:32];\n`endif // SCR1_CSR_REDUCED_CNT\n                default     : begin\n                    // return 0\n                end\n            endcase\n        end\n\n        // Machine Counters/Timers (read-write)\n        {SCR1_CSR_ADDR_MHPMCOUNTER_MASK, 5'b?????}  : begin\n            case (exu2csr_rw_addr_i[4:0])\n                5'd1        : csr_r_exc     = exu2csr_r_req_i;\n`ifndef SCR1_CSR_REDUCED_CNT\n  "}
{"text": "              5'd0        : csr_r_data    = csr_mcycle[31:0];\n                5'd2        : csr_r_data    = csr_minstret[31:0];\n`endif // SCR1_CSR_REDUCED_CNT\n                default     : begin\n                    // return 0\n                end\n            endcase\n        end\n\n        {SCR1_CSR_ADDR_MHPMCOUNTERH_MASK, 5'b?????} : begin\n            case (exu2csr_rw_addr_i[4:0])\n                5'd1        : csr_r_exc     = exu2csr_r_req_i;\n`ifndef SCR1_CSR_REDUCED_CNT\n                5'd0        : csr_r_data    = csr_mcycle[63:32];\n                5'd2        : csr_r_data    = csr_minstret[63:32];\n`endif // SCR1_CSR_REDUCED_CNT\n                default     : begin\n                    // return 0\n                end\n            endcase\n        end\n\n        {SCR1_CSR_ADDR_MHPMEVENT_MASK, 5'b?????}    : begin\n            case (exu2csr_rw_addr_i[4:0])\n                5'd0,\n                5'd1,\n                5'd2        : csr_r_exc = exu2csr_r_req_i;\n                default     : begin\n                    // return 0\n                end\n            endcase\n        end\n\n`ifdef SCR1_MCOUNTEN_EN\n        SCR1_CSR_ADDR_MCOUNTEN      : csr_r_data    = csr_mcounten;\n`endif // SCR1_MCOUNTEN_EN\n\n`ifdef SCR1_IPIC_EN\n        // IPIC registers\n        SCR1_CSR_ADDR_IPIC_CISV,\n        SCR1_CSR_ADDR_IPIC_CICSR,\n        SCR1_CSR_ADDR_IPIC_IPR,\n        SCR1_CSR_ADDR_IPIC_ISVR,\n        SCR1_CSR_ADDR_IPIC_EOI,\n        SCR1_CSR_ADDR_IPIC_SOI,\n        SCR1_CSR_ADDR_IPIC_IDX,\n        SCR1_CSR_ADDR_IPIC_ICSR     : begin\n            csr_r_data       = ipic2csr_rdata_i;\n            csr2ipic_r_req_o = exu2csr_r_req_i;\n        end\n`endif // SCR1_IPIC_EN\n\n`ifdef SCR1_DBG_EN\n        // HDU registers\n        SCR1_HDU_DBGCSR_ADDR_DCSR,\n        SCR1_HDU_DBGCSR_ADDR_DPC,\n        SCR1_HDU_DBGCSR_ADDR_DSCRATCH0,\n        SCR1_HDU_DBGCSR_ADDR_DSCRATCH1 : begin\n            csr_hdu_req = 1'b1;\n            csr_r_data  = hdu2csr_rdata_i;\n        end\n`endif // SCR1_DBG_EN\n\n`ifdef SCR1_TDU_EN\n        // TDU registers\n        SCR1_CSR_ADDR_TDU_TSELECT,\n        SCR1_CSR_ADDR_TDU_TDATA1,\n        SCR1_CSR_ADDR_TDU_TDATA2,\n        SCR1_CSR_ADDR_TDU_TINFO: begin\n            csr_brkm_req    = 1'b1;\n            csr_r_data      = tdu2csr_rdata_i;\n        end\n`endif // SCR1_TDU_EN\n\n        default     : begin\n            csr_r_exc   = exu2csr_r_req_i;\n        end\n    endcase // exu2csr_rw_addr_i\nend\n\nassign csr2exu_r_data_o = csr_r_data;\n\n// CSR write logic\n//------------------------------------------------------------------------------\n\nalways_comb begin\n    case (exu2csr_w_cmd_i)\n        SCR1_CSR_CMD_WRITE  : csr_w_data =  exu2csr_w_data_i;\n        SCR1_CSR_CMD_SET    : csr_w_data =  exu2csr_w_data_i | csr_r_data;\n        SCR1_CSR_CMD_CLEAR  : csr_w_data = ~exu2csr_w_data_i & csr_r_data;\n        default             : csr_w_data = '0;\n    endcase\nend\n\nalways_comb begin\n    csr_mstatus_upd     = 1'b0;\n    csr_mie_upd         = 1'b0;\n    csr_mscratch_upd    = 1'b0;\n    csr_mepc_upd        = 1'b0;\n    csr_mcause_upd      = 1'b0;\n    csr_mtval_upd       = 1'b0;\n    csr_mtvec_upd       = 1'b0;\n\n`ifndef SCR1_CSR_REDUCED_CNT\n    csr_mcycle_upd      = 2'b00;\n    csr_minstret_upd    = 2'b00;\n`endif // SCR1_CSR_REDUCED_CNT\n\n`ifdef SCR1_MCOUNTEN_EN\n    csr_mcounten_upd    = 1'b0;\n`endif // SCR1_MCOUNTEN_EN\n    csr_w_exc           = 1'b0;\n`ifdef SCR1_IPIC_EN\n    csr2ipic_w_req_o    = 1'b0;\n`endif // SCR1_IPIC_EN\n\n    if (exu2csr_w_req_i) begin\n        casez (exu2csr_rw_addr_i)\n            // Machine Trap Setup (read-write)\n            SCR1_CSR_ADDR_MSTATUS   : csr_mstatus_upd   = 1'b1;\n            SCR1_CSR_ADDR_MISA      : begin end\n            SCR1_CSR_ADDR_MIE       : csr_mie_upd       = 1'b1;\n            SCR1_CSR_ADDR_MTVEC     : csr_mtvec_upd     = 1'b1;\n\n            // Machine Trap Handling (read-write)\n            SCR1_CSR_ADDR_MSCRATCH  : csr_mscratch_upd  = 1'b1;\n            SCR1_CSR_ADDR_MEPC      : csr_mepc_upd      = 1'b1;\n            SCR1_CSR_ADDR_MCAUSE    : csr_mcause_upd    = 1'b1;\n            SCR1_CSR_ADDR_MTVAL     : csr_mtval_upd     = 1'b1;\n            SCR1_CSR_ADDR_MIP       : begin end\n\n            // Machine Counters/Timers (read-write)\n            {SCR1_CSR_ADDR_MHPMCOUNTER_MASK, 5'b?????}  : begin\n                case (exu2csr_rw_addr_i[4:0])\n                    5'd1        : csr_w_exc           = 1'b1;\n`ifndef SCR1_CSR_REDUCED_CNT\n                    5'd0        : csr_mcycle_upd[0]   = 1'b1;\n                    5'd2        : csr_minstret_upd[0] = 1'b1;\n`endif // SCR1_CSR_REDUCED_CNT\n                    default     : begin\n                        // no exception\n                    end\n                endcase\n            end\n\n            {SCR1_CSR_ADDR_MHPMCOUNTERH_MASK, 5'b?????} : begin\n                case (exu2csr_rw_addr_i[4:0])\n                    5'd1        : csr_w_exc           = 1'b1;\n`ifndef SCR1_CSR_REDUCED_CNT\n                    5'd0        : csr_mcycle_upd[1]   = 1'b1;\n                    5'd2        : csr_minstret_upd[1] = 1'b1;\n`endif // SCR1_CSR_REDUCED_CNT\n                    default     : begin\n                        // no exception\n                    end\n                endcase\n            end\n\n            {SCR1_CSR_ADDR_MHPMEVENT_MASK, 5'b?????}    : begin\n                case (exu2csr_rw_addr_i[4:0])\n                    5'd0,\n                    5'd1,\n                    5'd2        : csr_w_exc = 1'b1;\n                    default     : begin\n                        // no exception\n                    end\n                endcase\n            end\n\n`ifdef SCR1_MCOUNTEN_EN\n            SCR1_CSR_ADDR_MCOUNTEN      : csr_mcounten_upd = 1'b1;\n`endif // SCR1_MCOUNTEN_EN\n\n`ifdef SCR1_IPIC_EN\n            // IPIC registers\n            SCR1_CSR_ADDR_IPIC_CICSR,\n            SCR1_CSR_ADDR_IPIC_IPR,\n            SCR1_CSR_ADDR_IPIC_EOI,\n            SCR1_CSR_ADDR_IPIC_SOI,\n            SCR1_CSR_ADDR_IPIC_IDX,\n            SCR1_CSR_ADDR_IPIC_ICSR     : begin\n                csr2ipic_w_req_o  = 1'b1;\n            end\n            SCR1_CSR_ADDR_IPIC_CISV,\n            SCR1_CSR_ADDR_IPIC_ISVR     : begin\n                // no exception on write\n            end\n`endif // SCR1_IPIC_EN\n\n`ifdef SCR1_DBG_EN\n            SCR1_HDU_DBGCSR_ADDR_DCSR,\n            SCR1_HDU_DBGCSR_ADDR_DPC,\n            SCR1_HDU_DBGCSR_ADDR_DSCRATCH0,\n            SCR1_HDU_DBGCSR_ADDR_DSCRATCH1 : begin\n            end\n`endif // SCR1_DBG_EN\n\n`ifdef SCR1_TDU_EN\n            // TDU registers\n            SCR1_CSR_ADDR_TDU_TSELECT,\n            SCR1_CSR_ADDR_TDU_TDATA1,\n            SCR1_CSR_ADDR_TDU_TDATA2,\n            SCR1_CSR_ADDR_TDU_TINFO: begin\n            end\n`endif // SCR1_TDU_EN\n\n            default : begin\n                csr_w_exc   = 1'b1;\n            end\n        endcase\n    end\nend\n\n//------------------------------------------------------------------------------\n// Machine Trap Setup registers\n//------------------------------------------------------------------------------\n//\n // Registers:\n // - MSTATUS\n // - MIE\n // - MTVEC\n//\n\n// MSTATUS register\n//------------------------------------------------------------------------------\n// Consists of 2 bits - current and previous (before trap) global interrupt\n// enable bits (MIE & MPIE)\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        csr_mstatus_mie_ff  <= SCR1_CSR_MSTATUS_MIE_RST_VAL;\n        csr_mstatus_mpie_ff <= SCR1_CSR_MSTATUS_MPIE_RST_VAL;\n    end else begin\n        csr_mstatus_mie_ff  <= csr_mstatus_mie_next;\n        csr_mstatus_mpie_ff <= csr_mstatus_mpie_next;\n    end\nend\n\nalways_comb begin\n    case (1'b1)\n        e_exc, e_irq  : begin\n            csr_mstatus_mie_next  = 1'b0;\n            csr_mstatus_mpie_next = csr_mstatus_mie_ff;\n        end\n        e_mret        : begin\n            csr_mstatus_mie_next  = csr_mstatus_mpie_ff;\n            csr_mstatus_mpie_next = 1'b1;\n        end\n        csr_mstatus_upd: begin\n            csr_mstatus_mie_next  = csr_w_data[SCR1_CSR_MSTATUS_MIE_OFFSET];\n            csr_mstatus_mpie_next = csr_w_data[SCR1_CSR_MSTATUS_MPIE_OFFSET];\n        end\n        default       : begin\n            csr_mstatus_mie_next  = csr_mstatus_mie_ff;\n            csr_mstatus_mpie_next = csr_mstatus_mpie_ff;\n        end\n    endcase\nend\n\nalways_comb begin\n    csr_mstatus                                                            = '0;\n    csr_mstatus[SCR1_CSR_MSTATUS_MIE_OFFSET]                               = csr_mstatus_mie_ff;\n    csr_mstatus[SCR1_CSR_MSTATUS_MPIE_OFFSET]                              = csr_mstatus_mpie_ff;\n    csr_mstatus[SCR1_CSR_MSTATUS_MPP_OFFSET+1:SCR1_CSR_MSTATUS_MPP_OFFSET] = SCR1_CSR_MSTATUS_MPP;\nend\n\n// MIE register\n//------------------------------------------------------------------------------\n// Contains interrupt enable bits (external, software, timer IRQs)\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        csr_mie_mtie_ff <= SCR1_CSR_MIE_MTIE_RST_VAL;\n        csr_mie_meie_ff <= SCR1_CSR_MIE_MEIE_RST_VAL;\n        csr_mie_msie_ff <= SCR1_CSR_MIE_MSIE_RST_VAL;\n    end else if (csr_mie_upd) begin\n        csr_mie_mtie_ff <= csr_w_data[SCR1_CSR_MIE_MTIE_OFFSET];\n        csr_mie_meie_ff <= csr_w_data[SCR1_CSR_MIE_MEIE_OFFSET];\n        csr_mie_msie_ff <= csr_w_data[SCR1_CSR_MIE_MSIE_OFFSET];\n    end\nend\n\nalways_comb begin\n    csr_mie                           = '0;\n    csr_mie[SCR1_CSR_MIE_MSIE_OFFSET] = csr_mie_msie_ff;\n    csr_mie[SCR1_CSR_MIE_MTIE_OFFSET] = csr_mie_mtie_ff;\n    csr_mie[SCR1_CSR_MIE_MEIE_OFFSET] = csr_mie_meie_ff;\nend\n\n// MTVEC register\n//------------------------------------------------------------------------------\n// Holds trap vector configuation. Consists of base and mode parts\n\n// MTVEC BASE part\n//------------------------------------------------------------------------------\n// Holds trap vector base address\ngenerate\n    // All bits of MTVEC base are Read-Only and hardwired to 0's\n    if (SCR1_MTVEC_BASE_WR_BITS == 0) begin : mtvec_base_ro\n\n        assign csr_mtvec_base   = SCR1_CSR_MTVEC_BASE_RST_VAL;\n\n    // All bits of MTVEC base are RW\n    end else if (SCR1_MTVEC_BASE_WR_BITS == SCR1_CSR_MTVEC_BASE_VAL_BITS) begin : mtvec_base_rw\n\n        always_ff @(negedge rst_n, posedge clk) begin\n            if (~rst_n) begin\n                csr_mtvec_base  <= SCR1_CSR_MTVEC_BASE_RST_VAL;\n            end else if (csr_mtvec_upd) begin\n                csr_mtvec_base  <= csr_w_data[`SCR1_XLEN-1:SCR1_CSR_MTVEC_BASE_ZERO_BITS];\n            end\n        end\n\n    // Lower bits of MTVEC base are RO, higher - RW\n    end else begin : mtvec_base_ro_rw\n\n        logic [(`SCR1_XLEN-1):(`SCR1_XLEN-SCR1_MTVEC_BASE_WR_BITS)]   csr_mtvec_base_reg;\n\n        always_ff @(negedge rst_n, posedge clk) begin\n            if (~rst_n) begin\n                csr_mtvec_base_reg <= SCR1_CSR_MTVEC_BASE_RST_VAL[(`SCR1_XLEN-1)-:SCR1_MTVEC_BASE_WR_BITS] ;\n            end else if (csr_mtvec_upd) begin\n                csr_mtvec_base_reg <= csr_w_data[(`SCR1_XLEN-1)-:SCR1_MTVEC_BASE_WR_BITS];\n            end\n        end\n\n        assign csr_mtvec_base = {csr_mtvec_base_reg, SCR1_CSR_MTVEC_BASE_RST_VAL[SCR1_CSR_MTVEC_BASE_ZERO_BITS+:SCR1_CSR_MTVEC_BASE_RO_BITS]};\n    end\nendgenerate\n\n// MTVEC MODE part\n//------------------------------------------------------------------------------\n// Chooses between direct (all exceptions set PC to BASE) or vectored\n// (asynchronous interrupts set PC to BASE+4xcause) interrupt modes\n\n`ifdef SCR1_MTVEC_MODE_EN\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        csr_mtvec_mode_ff <= SCR1_CSR_MTVEC_MODE_DIRECT;\n    end else if (csr_mtvec_upd) begin\n        csr_mtvec_mode_ff <= csr_w_data[0];\n    end\nend\n\nassign csr_mtvec_mode      = csr_mtvec_mode_ff;\nassign csr_mtvec_mode_vect = (csr_mtvec_mode_ff == SCR1_CSR_MTVEC_MODE_VECTORED);\n`else // SCR1_MTVEC_MODE_EN\nassign csr_mtvec_mode = SCR1_CSR_MTVEC_MODE_DIRECT;\n`endif // SCR1_MTVEC_MODE_EN\n\n//------------------------------------------------------------------------------\n// Machine Trap Handling registers\n//------------------------------------------------------------------------------\n//\n // Registers:\n // - MSCRATCH\n // - MEPC\n // - MCAUSE\n // - MTVAL\n // - MIP\n//\n\n// MSCRATCH register\n//------------------------------------------------------------------------------\n// Holds a pointer to a machine-mode hart-local context space\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        csr_mscratch_ff <= '0;\n    end else if (csr_mscratch_upd) begin\n        csr_mscratch_ff <= csr_w_data;\n    end\nend\n\n// MEPC register\n//------------------------------------------------------------------------------\n// When a trap is taken into M-mode saves the virtual address of instruction that\n// was interrupted or that encountered the exception\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        csr_mepc_ff <= '0;\n    end else begin\n        csr_mepc_ff <= csr_mepc_next;\n    end\nend\n\nalways_comb begin\n    case (1'b1)\n        e_exc       : csr_mepc_next = exu2csr_pc_curr_i[`SCR1_XLEN-1:PC_LSB];\n        e_irq_nmret : csr_mepc_next = exu2csr_pc_next_i[`SCR1_XLEN-1:PC_LSB];\n        csr_mepc_upd: csr_mepc_next = csr_w_data[`SCR1_XLEN-1:PC_LSB];\n        default     : csr_mepc_next = csr_mepc_ff;\n    endcase\nend\n\n`ifdef SCR1_RVC_EXT\n    assign csr_mepc = {csr_mepc_ff, 1'b0};\n`else\n    assign csr_mepc = {csr_mepc_ff, 2'b00};\n`endif\n\n// MCAUSE register\n//------------------------------------------------------------------------------\n// When a trap is taken into M-mode saves a code indicating the event that caused\n// the trap\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        csr_mcause_i_ff  <= 1'b0;\n        csr_mcause_ec_ff <= type_scr1_exc_code_e'(SCR1_EXC_CODE_RESET);\n    end else begin\n        csr_mcause_i_ff  <= csr_mcause_i_next;\n        csr_mcause_ec_ff <= csr_mcause_ec_next;\n    end\nend\n\nalways_comb begin\n    case (1'b1)\n        e_exc         : begin\n            csr_mcause_i_next  = 1'b0;\n            csr_mcause_ec_next = exu2csr_exc_code_i;\n        end\n        e_irq         : begin\n            csr_mcause_i_next  = 1'b1;\n            csr_mcause_ec_next = csr_mcause_ec_new;\n        end\n        csr_mcause_upd: begin\n            csr_mcause_i_next  = csr_w_data[`SCR1_XLEN-1];\n            csr_mcause_ec_next = type_scr1_exc_code_e'(csr_w_data[SCR1_EXC_CODE_WIDTH_E-1:0]);\n        end\n        default       : begin\n            csr_mcause_i_next  = csr_mcause_i_ff;\n            csr_mcause_ec_next = csr_mcause_ec_ff;\n        end\n    endcase\nend\n\n// MTVAL register\n//------------------------------------------------------------------------------\n// When a trap is taken into M-mode is either set to zero or written with exception-\n// specific information\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        csr_mtval_ff <= '0;\n    end else begin\n        csr_mtval_ff <= csr_mtval_next;\n    end\nend\n\nalways_comb begin\n    case (1'b1)\n        e_exc        : csr_mtval_next = exu2csr_trap_val_i;\n        e_irq        : csr_mtval_next = '0;\n        csr_mtval_upd: csr_mtval_next = csr_w_data;\n        default      : csr_mtval_next = csr_mtval_ff;\n    endcase\nend\n\n// MIP register\n//------------------------------------------------------------------------------\n// Contains information on pending interrupts (external, software, timer IRQs)\n\nassign csr_mip_mtip = soc2csr_irq_mtimer_i;\nassign csr_mip_meip = soc2csr_irq_ext_i;\nassign csr_mip_msip = soc2csr_irq_soft_i;\n\nalways_comb begin\n    csr_mip                           = '0;\n    csr_mip[SCR1_CSR_MIE_MSIE_OFFSET] = csr_mip_msip;\n    csr_mip[SCR1_CSR_MIE_MTIE_OFFSET] = csr_mip_mtip;\n    csr_mip[SCR1_CSR_MIE_MEIE_OFFSET] = csr_mip_meip;\nend\n\n//------------------------------------------------------------------------------\n// Machine Counters/Timers registers\n//------------------------------------------------------------------------------\n//\n // Registers:\n // - MCYCLE\n // - MINSTRET\n//\n\n`ifndef SCR1_CSR_REDUCED_CNT\n// MCYCLE register\n//------------------------------------------------------------------------------\n// Holds the number of clock cycles since some arbitrary point of time in the\n// past at which MCYCLE was zero\n\nassign csr_mcycle_lo_inc = 1'b1\n `ifdef SCR1_MCOUNTEN_EN\n                         & csr_mcounten_cy_ff\n `endif // SCR1_MCOUNTEN_EN\n                         ;\nassign csr_mcycle_hi_inc = csr_mcycle_lo_inc & (&csr_mcycle_lo_ff);\n\nassign csr_mcycle_lo_upd = csr_mcycle_lo_inc | csr_mcycle_upd[0];\nassign csr_mcycle_hi_upd = csr_mcycle_hi_inc | (|csr_mcycle_upd);\n\n `ifndef SCR1_CLKCTRL_EN\nalways_ff @(negedge rst_n, posedge clk) begin\n `else // SCR1_CLKCTRL_EN\nalways_ff @(negedge rst_n, posedge clk_alw_on) begin\n `endif // SCR1_CLKCTRL_EN\n    if (~rst_n) begin\n        csr_mcycle_lo_ff <= '0;\n        csr_mcycle_hi_ff <= '0;\n    end else begin\n        if (csr_mcycle_lo_upd) csr_mcycle_lo_ff <= csr_mcycle_lo_next;\n        if (csr_mcycle_hi_upd) csr_mcycle_hi_ff <= csr_mcycle_hi_next;\n    end\nend\n\nassign csr_mcycle_hi_new  = csr_mcycle_hi_ff + 1'b1;\n\nassign csr_mcycle_lo_next = csr_mcycle_upd[0] ? csr_w_data[7:0]\n                          : csr_mcycle_lo_inc ? csr_mcycle_lo_ff + 1'b1\n                                              : csr_mcycle_lo_ff;\nassign csr_mcycle_hi_next = csr_mcycle_upd[0] ? {csr_mcycle_hi_new[63:32], csr_w_data[31:8]}\n                          : csr_mcycle_upd[1] ? {csr_w_data, csr_mcycle_hi_new[31:8]}\n                          : csr_mcycle_hi_inc ? csr_mcycle_hi_new\n                                              : csr_mcycle_hi_ff;\n\nassign csr_mcycle = {csr_mcycle_hi_ff, csr_mcycle_lo_ff};\n\n// MINSTRET register\n//------------------------------------------------------------------------------\n// Holds the number of instructions executed by the core from some arbitrary time\n// in the past at which MINSTRET was equal to zero\n\nassign csr_minstret_lo_inc = exu2csr_instret_no_exc_i\n `ifdef SCR1_MCOUNTEN_EN\n                           & csr_mcounten_ir_ff\n `endif // SCR1_MCOUNTEN_EN\n                           ;\nassign csr_minstret_hi_inc = csr_minstret_lo_inc & (&csr_minstret_lo_ff);\n\nassign csr_minstret_lo_upd = csr_minstret_lo_inc | csr_minstret_upd[0];\nassign csr_minstret_hi_upd = csr_minstret_hi_inc | (|csr_minstret_upd);\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        csr_minstret_lo_ff <= '0;\n        csr_minstret_hi_ff <= '0;\n    end else begin\n        if (csr_minstret_lo_upd) csr_minstret_lo_ff <= csr_minstret_lo_next;\n        if (csr_minstret_hi_upd) csr_minstret_hi_ff <= csr_minstret_hi_next;\n    end\nend\n\nassign csr_minstret_hi_new  = csr_minstret_hi_ff + 1'b1;\n\nassign csr_minstret_lo_next = csr_minstret_upd[0] ? csr_w_data[7:0]\n                            : csr_minstret_lo_inc ? csr_minstret_lo_ff + 1'b1\n                                                  : csr_minstret_lo_ff;\nassign csr_minstret_hi_next = csr_minstret_upd[0] ? {csr_minstret_hi_new[63:32], csr_w_data[31:8]}\n                            : csr_minstret_upd[1] ? {csr_w_data, csr_minstret_hi_new[31:8]}\n                            : csr_minstret_hi_inc ? csr_minstret_hi_new\n                                                  : csr_minstret_hi_ff;\n\nassign csr_minstret = {csr_minstret_hi_ff, csr_minstret_lo_ff};\n`endif // SCR1_CSR_REDUCED_CNT\n\n//------------------------------------------------------------------------------\n// Non-standard CSR\n//------------------------------------------------------------------------------\n\n`ifdef SCR1_MCOUNTEN_EN\n// MCOUNTEN register\n//------------------------------------------------------------------------------\n// Holds Counters enable bits (CY - MCYCLE counter; IR - MINSTRET counter)\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        csr_mcounten_cy_ff <= 1'b1;\n        csr_mcounten_ir_ff <= 1'b1;\n    end else if (csr_mcounten_upd) begin\n        csr_mcounten_cy_ff <= csr_w_data[SCR1_CSR_MCOUNTEN_CY_OFFSET];\n        csr_mcounten_ir_ff <= csr_w_data[SCR1_CSR_MCOUNTEN_IR_OFFSET];\n    end\nend\n\nalways_comb begin\n"}
{"text": "    csr_mcounten    = '0;\n    csr_mcounten[SCR1_CSR_MCOUNTEN_CY_OFFSET]   = csr_mcounten_cy_ff;\n    csr_mcounten[SCR1_CSR_MCOUNTEN_IR_OFFSET]   = csr_mcounten_ir_ff;\nend\n`endif // SCR1_MCOUNTEN_EN\n\n//------------------------------------------------------------------------------\n// CSR <-> EXU interface\n//------------------------------------------------------------------------------\n\n// CSR exception\nassign csr2exu_rw_exc_o = csr_r_exc | csr_w_exc\n`ifdef SCR1_DBG_EN\n                        | (csr2hdu_req_o & (hdu2csr_resp_i != SCR1_CSR_RESP_OK))\n`endif // SCR1_DBG_EN\n`ifdef SCR1_TDU_EN\n                        | (csr2tdu_req_o & (tdu2csr_resp_i != SCR1_CSR_RESP_OK))\n`endif // SCR1_TDU_EN\n                        ;\nassign csr2exu_ip_ie_o  = csr_eirq_pnd_en | csr_sirq_pnd_en | csr_tirq_pnd_en;\nassign csr2exu_irq_o    = csr2exu_ip_ie_o & csr_mstatus_mie_ff;\n\nassign csr2exu_mstatus_mie_up_o = csr_mstatus_upd | csr_mie_upd | e_mret;\n\n// New PC multiplexer\n`ifndef SCR1_MTVEC_MODE_EN\nassign csr2exu_new_pc_o = (exu2csr_mret_instr_i & ~exu2csr_take_irq_i)\n                        ? csr_mepc\n                        : {csr_mtvec_base, SCR1_CSR_MTVEC_BASE_ZERO_BITS'(0)};\n`else // SCR1_MTVEC_MODE_EN\nalways_comb begin\n    if (exu2csr_mret_instr_i & ~exu2csr_take_irq_i) begin\n        csr2exu_new_pc_o  = csr_mepc;\n    end else begin\n        if (csr_mtvec_mode_vect) begin\n            case (1'b1)\n                exu2csr_take_exc_i: csr2exu_new_pc_o = {csr_mtvec_base, SCR1_CSR_MTVEC_BASE_ZERO_BITS'(0)};\n                csr_eirq_pnd_en   : csr2exu_new_pc_o = {csr_mtvec_base, SCR1_EXC_CODE_IRQ_M_EXTERNAL, 2'd0};\n                csr_sirq_pnd_en   : csr2exu_new_pc_o = {csr_mtvec_base, SCR1_EXC_CODE_IRQ_M_SOFTWARE, 2'd0};\n                csr_tirq_pnd_en   : csr2exu_new_pc_o = {csr_mtvec_base, SCR1_EXC_CODE_IRQ_M_TIMER, 2'd0};\n                default           : csr2exu_new_pc_o = {csr_mtvec_base, SCR1_CSR_MTVEC_BASE_ZERO_BITS'(0)};\n            endcase\n        end else begin // direct mode\n            csr2exu_new_pc_o = {csr_mtvec_base, SCR1_CSR_MTVEC_BASE_ZERO_BITS'(0)};\n        end\n    end\nend\n`endif // SCR1_MTVEC_MODE_EN\n\n`ifdef SCR1_IPIC_EN\n//------------------------------------------------------------------------------\n// CSR <-> IPIC interface\n//------------------------------------------------------------------------------\n\nassign csr_ipic_req     = csr2ipic_r_req_o | csr2ipic_w_req_o;\nassign csr2ipic_addr_o  = csr_ipic_req     ? exu2csr_rw_addr_i[2:0] : '0;\nassign csr2ipic_wdata_o = csr2ipic_w_req_o ? exu2csr_w_data_i       : '0;\n`endif // SCR1_IPIC_EN\n\n`ifdef SCR1_DBG_EN\n//------------------------------------------------------------------------------\n// CSR <-> HDU interface\n//------------------------------------------------------------------------------\n\nassign csr2hdu_req_o   = csr_hdu_req & exu_req_no_exc;\nassign csr2hdu_cmd_o   = exu2csr_w_cmd_i;\nassign csr2hdu_addr_o  = exu2csr_rw_addr_i[SCR1_HDU_DEBUGCSR_ADDR_WIDTH-1:0];\nassign csr2hdu_wdata_o = exu2csr_w_data_i;\n`endif // SCR1_DBG_EN\n\n`ifdef SCR1_TDU_EN\n//------------------------------------------------------------------------------\n// CSR <-> TDU interface\n//------------------------------------------------------------------------------\n\nassign csr2tdu_req_o   = csr_brkm_req & exu_req_no_exc;\nassign csr2tdu_cmd_o   = exu2csr_w_cmd_i;\nassign csr2tdu_addr_o  = exu2csr_rw_addr_i[SCR1_CSR_ADDR_TDU_OFFS_W-1:0];\nassign csr2tdu_wdata_o = exu2csr_w_data_i;\n`endif // SCR1_TDU_EN\n\n`ifdef SCR1_TRGT_SIMULATION\n//------------------------------------------------------------------------------\n// Assertions\n//------------------------------------------------------------------------------\n\n// X checks\n\nSCR1_SVA_CSR_XCHECK_CTRL : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    !$isunknown({exu2csr_r_req_i, exu2csr_w_req_i, exu2csr_take_irq_i, exu2csr_take_exc_i, exu2csr_mret_update_i\n`ifndef SCR1_CSR_REDUCED_CNT\n    , exu2csr_instret_no_exc_i\n`endif // SCR1_CSR_REDUCED_CNT\n    })\n    ) else $error(\"CSR Error: unknown control values\");\n\nSCR1_SVA_CSR_XCHECK_READ : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    exu2csr_r_req_i |-> !$isunknown({exu2csr_rw_addr_i, csr2exu_r_data_o, csr2exu_rw_exc_o})\n    ) else $error(\"CSR Error: unknown control values\");\n\nSCR1_SVA_CSR_XCHECK_WRITE : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    exu2csr_w_req_i |-> !$isunknown({exu2csr_rw_addr_i, exu2csr_w_cmd_i, exu2csr_w_data_i, csr2exu_rw_exc_o})\n    ) else $error(\"CSR Error: unknown control values\");\n\n`ifdef SCR1_IPIC_EN\nSCR1_SVA_CSR_XCHECK_READ_IPIC : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    csr2ipic_r_req_o |-> !$isunknown({csr2ipic_addr_o, ipic2csr_rdata_i})\n    ) else $error(\"CSR Error: unknown control values\");\n\nSCR1_SVA_CSR_XCHECK_WRITE_IPIC : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    csr2ipic_w_req_o |-> !$isunknown({csr2ipic_addr_o, csr2ipic_wdata_o})\n    ) else $error(\"CSR Error: unknown control values\");\n`endif // SCR1_IPIC_EN\n\n// Behavior checks\n\nSCR1_SVA_CSR_MRET : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    e_mret |=> ($stable(csr_mepc_ff) & $stable(csr_mtval_ff))\n    ) else $error(\"CSR Error: MRET wrong behavior\");\n\nSCR1_SVA_CSR_MRET_IRQ : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    (exu2csr_mret_instr_i & e_irq)\n    |=> ($stable(csr_mepc_ff) & (exu2csr_pc_curr_i != csr_mepc))\n    ) else $error(\"CSR Error: MRET+IRQ wrong behavior\");\n\nSCR1_SVA_CSR_EXC_IRQ : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    (exu2csr_take_exc_i & exu2csr_take_irq_i\n`ifdef SCR1_DBG_EN\n    & ~hdu2csr_no_commit_i\n`endif\n    ) |=>\n    (~csr_mstatus_mie_ff & (~csr_mcause_i_ff)\n    & (exu2csr_pc_curr_i=={csr_mtvec_base, SCR1_CSR_MTVEC_BASE_ZERO_BITS'(0)}))\n    ) else $error(\"CSR Error: wrong EXC+IRQ\");\n\nSCR1_SVA_CSR_EVENTS : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    $onehot0({e_irq, e_exc, e_mret})\n    ) else $error(\"CSR Error: more than one event at a time\");\n\nSCR1_SVA_CSR_RW_EXC : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    csr2exu_rw_exc_o |-> (exu2csr_w_req_i | exu2csr_r_req_i)\n    ) else $error(\"CSR Error: impossible exception\");\n\nSCR1_SVA_CSR_MSTATUS_MIE_UP : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    csr2exu_mstatus_mie_up_o |=> ~csr2exu_mstatus_mie_up_o\n    ) else $error(\"CSR Error: csr2exu_mstatus_mie_up_o can only be high for one mcycle\");\n\n\n`ifndef SCR1_CSR_REDUCED_CNT\n\nSCR1_SVA_CSR_CYCLE_INC : assert property (\n    @(\n`ifndef SCR1_CLKCTRL_EN\nnegedge clk\n`else // SCR1_CLKCTRL_EN\nnegedge clk_alw_on\n`endif // SCR1_CLKCTRL_EN\n    ) disable iff (~rst_n)\n    (~|csr_mcycle_upd) |=>\n`ifdef SCR1_MCOUNTEN_EN\n    ($past(csr_mcounten_cy_ff) ? (csr_mcycle == $past(csr_mcycle + 1'b1)) : $stable(csr_mcycle))\n`else //SCR1_MCOUNTEN_EN\n    (csr_mcycle == $past(csr_mcycle + 1'b1))\n`endif // SCR1_MCOUNTEN_EN\n    ) else $error(\"CSR Error: CYCLE increment wrong behavior\");\n\nSCR1_SVA_CSR_INSTRET_INC : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    (exu2csr_instret_no_exc_i & ~|csr_minstret_upd) |=>\n`ifdef SCR1_MCOUNTEN_EN\n    ($past(csr_mcounten_ir_ff) ? (csr_minstret == $past(csr_minstret + 1'b1)) : $stable(csr_minstret))\n`else //SCR1_MCOUNTEN_EN\n    (csr_minstret == $past(csr_minstret + 1'b1))\n`endif // SCR1_MCOUNTEN_EN\n    ) else $error(\"CSR Error: INSTRET increment wrong behavior\");\n\nSCR1_SVA_CSR_CYCLE_INSTRET_UP : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    ~(&csr_minstret_upd | &csr_mcycle_upd)\n    ) else $error(\"CSR Error: INSTRET/CYCLE up illegal value\");\n\n`endif // SCR1_CSR_REDUCED_CNT\n\n`endif // SCR1_TRGT_SIMULATION\n\nendmodule : scr1_pipe_csr\n"}
{"text": "/// Copyright by Syntacore LLC \u00a9 2016-2021. See LICENSE for details\n/// @file       <scr1_pipe_exu.sv>\n/// @brief      Execution Unit (EXU)\n///\n\n//------------------------------------------------------------------------------\n //\n // Functionality:\n // - Performs instructions execution:\n //   - Prevents instructions from execution if the HART is in WFI or Debug Halted\n //     state\n //   - Fetches operands for IALU\n //   - Calculates operation results via IALU\n //   - Stores IALU results in MPRF\n //   - Performs LOAD/STORE operations via LSU\n // - Handles exceptions:\n //   - Generates exception request\n //   - Encodes exception code\n //   - Calculates exception trap value\n // - Controls WFI instruction execution\n // - Calculates PC value:\n //   - Initializes PC on reset\n //   - Stores the current PC value\n //   - Calculates a New PC value and generates a New PC request to IFU\n //\n // Structure:\n // - Instruction queue\n // - Integer Arithmetic Logic Unit (IALU)\n // - Exceptions logic\n // - WFI logic\n // - Program Counter logic\n // - Load-Store Unit (LSU)\n // - EXU status logic\n // - EXU <-> MPRF i/f\n // - EXU <-> CSR i/f\n // - EXU <-> TDU i/f\n //\n//------------------------------------------------------------------------------\n\n`include \"scr1_arch_description.svh\"\n`include \"scr1_arch_types.svh\"\n`include \"scr1_memif.svh\"\n`include \"scr1_riscv_isa_decoding.svh\"\n`include \"scr1_csr.svh\"\n\n`ifdef SCR1_DBG_EN\n `include \"scr1_hdu.svh\"\n`endif // SCR1_DBG_EN\n\n`ifdef SCR1_TDU_EN\n `include \"scr1_tdu.svh\"\n`endif // SCR1_TDU_EN\n\nmodule scr1_pipe_exu (\n    // Common\n    input   logic                               rst_n,                      // EXU reset\n    input   logic                               clk,                        // Gated EXU clock\n`ifdef SCR1_CLKCTRL_EN\n    input   logic                               clk_alw_on,                 // Not-gated EXU clock\n    input   logic                               clk_pipe_en,                // EXU clock enabled flag\n`endif // SCR1_CLKCTRL_EN\n\n    // EXU <-> IDU interface\n    input   logic                               idu2exu_req_i,              // Request form IDU to EXU\n    output  logic                               exu2idu_rdy_o,              // EXU ready for new data from IDU\n    input   type_scr1_exu_cmd_s                 idu2exu_cmd_i,              // EXU command\n    input   logic                               idu2exu_use_rs1_i,          // Clock gating on rs1_addr field\n    input   logic                               idu2exu_use_rs2_i,          // Clock gating on rs2_addr field\n`ifndef SCR1_NO_EXE_STAGE\n    input   logic                               idu2exu_use_rd_i,           // Clock gating on rd_addr field\n    input   logic                               idu2exu_use_imm_i,          // Clock gating on imm field\n`endif // SCR1_NO_EXE_STAGE\n\n    // EXU <-> MPRF interface\n    output  logic [`SCR1_MPRF_AWIDTH-1:0]       exu2mprf_rs1_addr_o,        // MPRF rs1 read address\n    input   logic [`SCR1_XLEN-1:0]              mprf2exu_rs1_data_i,        // MPRF rs1 read data\n    output  logic [`SCR1_MPRF_AWIDTH-1:0]       exu2mprf_rs2_addr_o,        // MPRF rs2 read address\n    input   logic [`SCR1_XLEN-1:0]              mprf2exu_rs2_data_i,        // MPRF rs2 read data\n    output  logic                               exu2mprf_w_req_o,           // MPRF write request\n    output  logic [`SCR1_MPRF_AWIDTH-1:0]       exu2mprf_rd_addr_o,         // MPRF rd write address\n    output  logic [`SCR1_XLEN-1:0]              exu2mprf_rd_data_o,         // MPRF rd write data\n\n    // EXU <-> CSR read/write interface\n    output  logic [SCR1_CSR_ADDR_WIDTH-1:0]     exu2csr_rw_addr_o,          // CSR read/write address\n    output  logic                               exu2csr_r_req_o,            // CSR read request\n    input   logic [`SCR1_XLEN-1:0]              csr2exu_r_data_i,           // CSR read data\n    output  logic                               exu2csr_w_req_o,            // CSR write request\n    output  type_scr1_csr_cmd_sel_e             exu2csr_w_cmd_o,            // CSR write command\n    output  logic [`SCR1_XLEN-1:0]              exu2csr_w_data_o,           // CSR write data\n    input   logic                               csr2exu_rw_exc_i,           // CSR read/write access exception\n\n    // EXU <-> CSR events interface\n    output  logic                               exu2csr_take_irq_o,         // Take IRQ trap\n    output  logic                               exu2csr_take_exc_o,         // Take exception trap\n    output  logic                               exu2csr_mret_update_o,      // MRET update CSR\n    output  logic                               exu2csr_mret_instr_o,       // MRET instruction\n    output  type_scr1_exc_code_e                exu2csr_exc_code_o,         // Exception code (see scr1_arch_types.svh)\n    output  logic [`SCR1_XLEN-1:0]              exu2csr_trap_val_o,         // Trap value\n    input   logic [`SCR1_XLEN-1:0]              csr2exu_new_pc_i,           // Exception/IRQ/MRET new PC\n    input   logic                               csr2exu_irq_i,              // IRQ request\n    input   logic                               csr2exu_ip_ie_i,            // Some IRQ pending and locally enabled\n    input   logic                               csr2exu_mstatus_mie_up_i,   // MSTATUS or MIE update in the current cycle\n\n    // EXU <-> DMEM interface\n    output  logic                               exu2dmem_req_o,             // Data memory request\n    output  type_scr1_mem_cmd_e                 exu2dmem_cmd_o,             // Data memory command\n    output  type_scr1_mem_width_e               exu2dmem_width_o,           // Data memory width\n    output  logic [`SCR1_DMEM_AWIDTH-1:0]       exu2dmem_addr_o,            // Data memory address\n    output  logic [`SCR1_DMEM_DWIDTH-1:0]       exu2dmem_wdata_o,           // Data memory write data\n    input   logic                               dmem2exu_req_ack_i,         // Data memory request acknowledge\n    input   logic [`SCR1_DMEM_DWIDTH-1:0]       dmem2exu_rdata_i,           // Data memory read data\n    input   type_scr1_mem_resp_e                dmem2exu_resp_i,            // Data memory response\n\n    // EXU control\n    output  logic                               exu2pipe_exc_req_o,         // Exception on last instruction\n    output  logic                               exu2pipe_brkpt_o,           // Software Breakpoint (EBREAK)\n    output  logic                               exu2pipe_init_pc_o,         // Reset exit\n    output  logic                               exu2pipe_wfi_run2halt_o,    // Transition to WFI halted state\n    output  logic                               exu2pipe_instret_o,         // Instruction retired (with or without exception)\n`ifndef SCR1_CSR_REDUCED_CNT\n    output  logic                               exu2csr_instret_no_exc_o,   // Instruction retired (without exception)\n`endif // SCR1_CSR_REDUCED_CNT\n    output  logic                               exu2pipe_exu_busy_o,        // EXU busy\n\n`ifdef SCR1_DBG_EN\n    // EXU <-> HDU interface\n    input   logic                               hdu2exu_no_commit_i,        // Forbid instruction commitment\n    input   logic                               hdu2exu_irq_dsbl_i,         // Disable IRQ\n    input   logic                               hdu2exu_pc_advmt_dsbl_i,    // Forbid PC advancement\n    input   logic                               hdu2exu_dmode_sstep_en_i,   // Enable single-step\n    input   logic                               hdu2exu_pbuf_fetch_i,       // Take instructions from Program Buffer\n    input   logic                               hdu2exu_dbg_halted_i,       // Debug halted state\n    input   logic                               hdu2exu_dbg_run2halt_i,     // Transition to debug halted state\n    input   logic                               hdu2exu_dbg_halt2run_i,     // Transition to run state\n    input   logic                               hdu2exu_dbg_run_start_i,    // First cycle of run state\n    input   logic [`SCR1_XLEN-1:0]              hdu2exu_dbg_new_pc_i,       // New PC as starting point for HART Resume\n`endif // SCR1_DBG_EN\n\n`ifdef SCR1_TDU_EN\n    // EXU <-> TDU interface\n    output type_scr1_brkm_instr_mon_s           exu2tdu_imon_o,             // Instruction monitor\n    input  logic [SCR1_TDU_ALLTRIG_NUM-1:0]     tdu2exu_ibrkpt_match_i,     // Instruction breakpoint(s) match\n    input  logic                                tdu2exu_ibrkpt_exc_req_i,   // Instruction breakpoint exception\n    output type_scr1_brkm_lsu_mon_s             lsu2tdu_dmon_o,             // Data monitor\n    input  logic                                tdu2lsu_ibrkpt_exc_req_i,   // Instruction breakpoint exception\n    input  logic [SCR1_TDU_MTRIG_NUM-1:0]       tdu2lsu_dbrkpt_match_i,     // Data breakpoint(s) match\n    input  logic                                tdu2lsu_dbrkpt_exc_req_i,   // Data breakpoint exception\n    output logic [SCR1_TDU_ALLTRIG_NUM-1:0]     exu2tdu_ibrkpt_ret_o,       // Instruction with breakpoint flag retire\n  `ifdef SCR1_DBG_EN\n    output logic                                exu2hdu_ibrkpt_hw_o,        // Hardware breakpoint on current instruction\n  `endif // SCR1_DBG_EN\n`endif // SCR1_TDU_EN\n\n    // PC interface\n`ifdef SCR1_CLKCTRL_EN\n    output  logic                               exu2pipe_wfi_halted_o,      // WFI halted state\n`endif // SCR1_CLKCTRL_EN\n    output  logic [`SCR1_XLEN-1:0]              exu2pipe_pc_curr_o,         // Current PC\n    output  logic [`SCR1_XLEN-1:0]              exu2csr_pc_next_o,          // Next PC\n    output  logic                               exu2ifu_pc_new_req_o,       // New PC request\n    output  logic [`SCR1_XLEN-1:0]              exu2ifu_pc_new_o            // New PC data\n);\n\n//------------------------------------------------------------------------------\n// Local parameters declaration\n//------------------------------------------------------------------------------\n\nlocalparam SCR1_JUMP_MASK = `SCR1_XLEN'hFFFF_FFFE;\n\n//------------------------------------------------------------------------------\n// Local types declaration\n//------------------------------------------------------------------------------\n\ntypedef enum logic {\n    SCR1_CSR_INIT,\n    SCR1_CSR_RDY\n} scr1_csr_access_e;\n\n//------------------------------------------------------------------------------\n// Local signals declaration\n//------------------------------------------------------------------------------\n\n// Instruction queue signals\n//------------------------------------------------------------------------------\nlogic                               exu_queue_vd;\ntype_scr1_exu_cmd_s                 exu_queue;\nlogic                               exu_queue_barrier;\n\n`ifdef SCR1_DBG_EN\nlogic                               dbg_run_start_npbuf;\n`endif // SCR1_DBG_EN\nlogic                               exu_queue_en;\nlogic [`SCR1_XLEN-1:0]              exu_illegal_instr;\n\n`ifndef SCR1_NO_EXE_STAGE\nlogic                               idu2exu_use_rs1_ff;\nlogic                               idu2exu_use_rs2_ff;\n\n// EXU queue valid flag register signals\nlogic                               exu_queue_vd_upd;\nlogic                               exu_queue_vd_ff;\nlogic                               exu_queue_vd_next;\n`endif // SCR1_NO_EXE_STAGE\n\n// IALU signals\n//------------------------------------------------------------------------------\n`ifdef SCR1_RVM_EXT\nlogic                               ialu_rdy;\nlogic                               ialu_vd;\n`endif // SCR1_RVM_EXT\nlogic [`SCR1_XLEN-1:0]              ialu_main_op1;\nlogic [`SCR1_XLEN-1:0]              ialu_main_op2;\nlogic [`SCR1_XLEN-1:0]              ialu_main_res;\nlogic [`SCR1_XLEN-1:0]              ialu_addr_op1;\nlogic [`SCR1_XLEN-1:0]              ialu_addr_op2;\nlogic [`SCR1_XLEN-1:0]              ialu_addr_res;\nlogic                               ialu_cmp;\n\n// Exceptions signals\n//------------------------------------------------------------------------------\nlogic                               exu_exc_req;\n`ifdef SCR1_DBG_EN\nlogic                               exu_exc_req_ff;\nlogic                               exu_exc_req_next;\n`endif // SCR1_DBG_EN\ntype_scr1_exc_code_e                exc_code;\nlogic [`SCR1_XLEN-1:0]              exc_trap_val;\nlogic                               instr_fault_rvi_hi;\n\n// WFI signals\n//------------------------------------------------------------------------------\n// WFI control signals\nlogic                               wfi_halt_cond;\nlogic                               wfi_run_req;\nlogic                               wfi_halt_req;\n\n// WFI Run Start register\nlogic                               wfi_run_start_ff;\nlogic                               wfi_run_start_next;\n\n// WFI halted register\nlogic                               wfi_halted_upd;\nlogic                               wfi_halted_ff;\nlogic                               wfi_halted_next;\n\n// PC signals\n//------------------------------------------------------------------------------\nlogic [3:0]                         init_pc_v;\nlogic                               init_pc;\nlogic [`SCR1_XLEN-1:0]              inc_pc;\n\nlogic                               branch_taken;\nlogic                               jb_taken;\nlogic [`SCR1_XLEN-1:0]              jb_new_pc;\n`ifndef SCR1_RVC_EXT\nlogic                               jb_misalign;\n`endif\n\n// Current PC register\nlogic                               pc_curr_upd;\nlogic [`SCR1_XLEN-1:0]              pc_curr_ff;\nlogic [`SCR1_XLEN-1:0]              pc_curr_next;\n\n// LSU signals\n//------------------------------------------------------------------------------\nlogic                               lsu_req;\nlogic                               lsu_rdy;\nlogic [`SCR1_XLEN-1:0]              lsu_l_data;\nlogic                               lsu_exc_req;\ntype_scr1_exc_code_e                lsu_exc_code;\n\n// EXU status signals\n//------------------------------------------------------------------------------\nlogic                               exu_rdy;\n\n// MPRF signals\n//------------------------------------------------------------------------------\nlogic                               mprf_rs1_req;\nlogic                               mprf_rs2_req;\n\nlogic   [`SCR1_MPRF_AWIDTH-1:0]     mprf_rs1_addr;\nlogic   [`SCR1_MPRF_AWIDTH-1:0]     mprf_rs2_addr;\n\n// CSR signals\n//------------------------------------------------------------------------------\n// CSR access register\nscr1_csr_access_e                   csr_access_ff;\nscr1_csr_access_e                   csr_access_next;\nlogic                               csr_access_init;\n\n//------------------------------------------------------------------------------\n// Instruction execution queue\n//------------------------------------------------------------------------------\n//\n // Instruction execution queue consists of the following functional units:\n // - EXU queue control logic\n // - EXU queue valid flag register\n // - EXU queue register\n // - EXU queue status logic\n//\n\n`ifdef SCR1_DBG_EN\nassign dbg_run_start_npbuf = hdu2exu_dbg_run_start_i & ~hdu2exu_pbuf_fetch_i;\n`endif // SCR1_DBG_EN\n\n`ifndef SCR1_NO_EXE_STAGE\n\n// EXU queue control logic\n//------------------------------------------------------------------------------\n\nassign exu_queue_barrier = wfi_halted_ff | wfi_halt_req | wfi_run_start_ff\n`ifdef SCR1_DBG_EN\n                         | hdu2exu_dbg_halted_i  | hdu2exu_dbg_run2halt_i\n                         | dbg_run_start_npbuf\n`endif // SCR1_DBG_EN\n;\n\nassign exu_queue_en = exu2idu_rdy_o & idu2exu_req_i;\n\n// EXU queue valid flag register\n//------------------------------------------------------------------------------\n\nassign exu_queue_vd_upd = exu_queue_barrier | exu_rdy;\n\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        exu_queue_vd_ff <= 1'b0;\n    end else if (exu_queue_vd_upd) begin\n        exu_queue_vd_ff <= exu_queue_vd_next;\n    end\nend\n\nassign exu_queue_vd_next = ~exu_queue_barrier & idu2exu_req_i & ~exu2ifu_pc_new_req_o;\nassign exu_queue_vd      = exu_queue_vd_ff;\n\n// EXU queue register\n//------------------------------------------------------------------------------\n\nalways_ff @(posedge clk) begin\n    if (exu_queue_en) begin\n        exu_queue.instr_rvc      <= idu2exu_cmd_i.instr_rvc;\n        exu_queue.ialu_op        <= idu2exu_cmd_i.ialu_op;\n        exu_queue.ialu_cmd       <= idu2exu_cmd_i.ialu_cmd;\n        exu_queue.sum2_op        <= idu2exu_cmd_i.sum2_op;\n        exu_queue.lsu_cmd        <= idu2exu_cmd_i.lsu_cmd;\n        exu_queue.csr_op         <= idu2exu_cmd_i.csr_op;\n        exu_queue.csr_cmd        <= idu2exu_cmd_i.csr_cmd;\n        exu_queue.rd_wb_sel      <= idu2exu_cmd_i.rd_wb_sel;\n        exu_queue.jump_req       <= idu2exu_cmd_i.jump_req;\n        exu_queue.branch_req     <= idu2exu_cmd_i.branch_req;\n        exu_queue.mret_req       <= idu2exu_cmd_i.mret_req;\n        exu_queue.fencei_req     <= idu2exu_cmd_i.fencei_req;\n        exu_queue.wfi_req        <= idu2exu_cmd_i.wfi_req;\n        exu_queue.exc_req        <= idu2exu_cmd_i.exc_req;\n        exu_queue.exc_code       <= idu2exu_cmd_i.exc_code;\n        idu2exu_use_rs1_ff       <= idu2exu_use_rs1_i;\n        idu2exu_use_rs2_ff       <= idu2exu_use_rs2_i;\n        if (idu2exu_use_rs1_i) begin\n            exu_queue.rs1_addr   <= idu2exu_cmd_i.rs1_addr;\n        end\n        if (idu2exu_use_rs2_i) begin\n            exu_queue.rs2_addr   <= idu2exu_cmd_i.rs2_addr;\n        end\n        if (idu2exu_use_rd_i)  begin\n            exu_queue.rd_addr    <= idu2exu_cmd_i.rd_addr;\n        end\n        if (idu2exu_use_imm_i) begin\n            exu_queue.imm        <= idu2exu_cmd_i.imm;\n        end\n    end\nend\n\n`else // ~SCR1_NO_EXE_STAGE\n\nassign exu_queue_barrier = wfi_halted_ff | wfi_run_start_ff\n`ifdef SCR1_DBG_EN\n                         | hdu2exu_dbg_halted_i  | dbg_run_start_npbuf\n`endif // SCR1_DBG_EN\n;\nassign exu_queue_vd  = idu2exu_req_i & ~exu_queue_barrier;\nassign exu_queue     = idu2exu_cmd_i;\n\n`endif // ~SCR1_NO_EXE_STAGE\n\n//------------------------------------------------------------------------------\n// Integer Arithmetic Logic Unit (IALU)\n//------------------------------------------------------------------------------\n //\n // Functionality:\n // - Performs addition/subtraction and arithmetic and branch comparisons\n // - Performs logical operations (AND(I), OR(I), XOR(I))\n // - Performs address calculation for branch, jump, DMEM load and store and AUIPC\n //   instructions\n // - Performs shift operations\n // - Performs MUL/DIV operations\n //\n//------------------------------------------------------------------------------\n\n// IALU main operands fetch\n//------------------------------------------------------------------------------\n\n`ifdef SCR1_RVM_EXT\nassign ialu_vd  = exu_queue_vd & (exu_queue.ialu_cmd != SCR1_IALU_CMD_NONE)\n`ifdef SCR1_TDU_EN\n                & ~tdu2exu_ibrkpt_exc_req_i\n`endif // SCR1_TDU_EN\n                ;\n`endif // SCR1_RVM_EXT\n\nalways_comb begin\n`ifdef SCR1_RVM_EXT\n    if (~ialu_vd) begin\n        ialu_main_op1 = '0;\n        ialu_main_op2 = '0;\n    end else begin\n`endif // SCR1_RVM_EXT\n        if (exu_queue.ialu_op == SCR1_IALU_OP_REG_REG) begin\n            ialu_main_op1 = mprf2exu_rs1_data_i;\n            ialu_main_op2 = mprf2exu_rs2_data_i;\n        end else begin\n            ialu_main_op1 = mprf2exu_rs1_data_i;\n            ialu_main_op2 = exu_queue.imm;\n        end\n`ifdef SCR1_RVM_EXT\n    end\n`endif // SCR1_RVM_EXT\nend\n\n// IALU address operands fetch\n//------------------------------------------------------------------------------\n\nalways_comb begin\n    if (exu_queue.sum2_op == SCR1_SUM2_OP_REG_IMM) begin\n        ialu_addr_op1 = mprf2exu_rs1_data_i;\n        ialu_addr_op2 = exu_queue.imm;\n    end else begin\n        ialu_addr_op1 = pc_curr_ff;\n        ialu_addr_op2 = exu_queue.imm;\n    end\nend\n\n// IALU module instantiation\n//------------------------------------------------------------------------------\n\nscr1_pipe_ialu i_ialu(\n`ifdef SCR1_RVM_EXT\n "}
{"text": "   // Common\n    .clk                        (clk               ),\n    .rst_n                      (rst_n             ),\n    .exu2ialu_rvm_cmd_vd_i      (ialu_vd           ),\n    .ialu2exu_rvm_res_rdy_o     (ialu_rdy          ),\n`endif // SCR1_RVM_EXT\n\n    // IALU\n    .exu2ialu_main_op1_i        (ialu_main_op1     ),\n    .exu2ialu_main_op2_i        (ialu_main_op2     ),\n    .exu2ialu_cmd_i             (exu_queue.ialu_cmd),\n    .ialu2exu_main_res_o        (ialu_main_res     ),\n    .ialu2exu_cmp_res_o         (ialu_cmp          ),\n\n    // Address adder signals\n    .exu2ialu_addr_op1_i        (ialu_addr_op1     ),\n    .exu2ialu_addr_op2_i        (ialu_addr_op2     ),\n    .ialu2exu_addr_res_o        (ialu_addr_res     )\n);\n\n//------------------------------------------------------------------------------\n// Exceptions logic\n//------------------------------------------------------------------------------\n//\n // Exceptions logic consists of the following functional units:\n // - Exception request logic\n // - Exception code encoder\n // - Exception trap value multiplexer\n //\n//\n\n`ifndef SCR1_RVC_EXT\nassign jb_misalign  = exu_queue_vd  & jb_taken & |jb_new_pc[1:0];\n`endif // ~SCR1_RVC_EXT\n\n// Exception request\nassign exu_exc_req  = exu_queue_vd & (exu_queue.exc_req | lsu_exc_req\n                                                        | csr2exu_rw_exc_i\n`ifndef SCR1_RVC_EXT\n                                                        | jb_misalign\n`endif // ~SCR1_RVC_EXT\n`ifdef SCR1_TDU_EN\n  `ifdef SCR1_DBG_EN\n                                                        | exu2hdu_ibrkpt_hw_o\n  `endif // SCR1_DBG_EN\n`endif // SCR1_TDU_EN\n                                                        );\n\n// EXU exception request register\n//------------------------------------------------------------------------------\n\n`ifdef SCR1_DBG_EN\n\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        exu_exc_req_ff <= 1'b0;\n    end else begin\n        exu_exc_req_ff <= exu_exc_req_next;\n    end\nend\n\nassign exu_exc_req_next = hdu2exu_dbg_halt2run_i ? 1'b0 : exu_exc_req;\n`endif // SCR1_DBG_EN\n\n// Exception code encoder\n//------------------------------------------------------------------------------\n\nalways_comb begin\n    case (1'b1)\n`ifdef SCR1_TDU_EN\n  `ifdef SCR1_DBG_EN\n        exu2hdu_ibrkpt_hw_o: exc_code = SCR1_EXC_CODE_BREAKPOINT;\n  `endif // SCR1_DBG_EN\n`endif // SCR1_TDU_EN\n        exu_queue.exc_req  : exc_code = exu_queue.exc_code;\n        lsu_exc_req        : exc_code = lsu_exc_code;\n        csr2exu_rw_exc_i   : exc_code = SCR1_EXC_CODE_ILLEGAL_INSTR;\n`ifndef SCR1_RVC_EXT\n        jb_misalign        : exc_code = SCR1_EXC_CODE_INSTR_MISALIGN;\n`endif // ~SCR1_RVC_EXT\n        default            : exc_code = SCR1_EXC_CODE_ECALL_M;\n    endcase // 1'b1\nend\n\n// Exception trap value multiplexer\n//------------------------------------------------------------------------------\n\nassign instr_fault_rvi_hi = exu_queue.instr_rvc;\nassign exu_illegal_instr = {exu2csr_rw_addr_o,          // CSR address\n                            5'(exu_queue.rs1_addr),     // rs1 / zimm\n                            exu_queue.imm[14:12],       // funct3\n                            5'(exu_queue.rd_addr),      // rd\n                            SCR1_OPCODE_SYSTEM,\n                            SCR1_INSTR_RVI\n                           };\n\n// If Instruction Access Fault occurred on high part of RVI instruction trap\n// value is set to point on the high part of the instruction (inc_pc=pc+2)\nalways_comb begin\n    case (exc_code)\n`ifndef SCR1_RVC_EXT\n        SCR1_EXC_CODE_INSTR_MISALIGN    : exc_trap_val = jb_new_pc;\n`endif // SCR1_RVC_EXT\n        SCR1_EXC_CODE_INSTR_ACCESS_FAULT: exc_trap_val = instr_fault_rvi_hi\n                                                       ? inc_pc\n                                                       : pc_curr_ff;\n`ifdef SCR1_MTVAL_ILLEGAL_INSTR_EN\n        SCR1_EXC_CODE_ILLEGAL_INSTR     : exc_trap_val = exu_queue.exc_req\n                                                       ? exu_queue.imm\n                                                       : exu_illegal_instr;\n`else // SCR1_MTVAL_ILLEGAL_INSTR_EN\n        SCR1_EXC_CODE_ILLEGAL_INSTR     : exc_trap_val = '0;\n`endif // SCR1_MTVAL_ILLEGAL_INSTR_EN\n`ifdef SCR1_TDU_EN\n        SCR1_EXC_CODE_BREAKPOINT: begin\n            case (1'b1)\n                tdu2exu_ibrkpt_exc_req_i: exc_trap_val = pc_curr_ff;\n                tdu2lsu_dbrkpt_exc_req_i: exc_trap_val = ialu_addr_res;\n                default                 : exc_trap_val = '0;\n            endcase\n        end\n`endif // SCR1_TDU_EN\n        SCR1_EXC_CODE_LD_ADDR_MISALIGN,\n        SCR1_EXC_CODE_LD_ACCESS_FAULT,\n        SCR1_EXC_CODE_ST_ADDR_MISALIGN,\n        SCR1_EXC_CODE_ST_ACCESS_FAULT   : exc_trap_val = ialu_addr_res;\n        default                         : exc_trap_val = '0;\n    endcase // exc_code\nend\n\n//------------------------------------------------------------------------------\n// WFI logic\n//------------------------------------------------------------------------------\n//\n // Wait for interrupt (WFI) logic consists of the following functional units:\n // - WFI control logic\n // - WFI Run Start register\n // - WFI Halted flag register\n // - WFI status signals\n//\n\n// WFI control logic\n//------------------------------------------------------------------------------\n\nassign wfi_halt_cond = ~csr2exu_ip_ie_i\n                     & ((exu_queue_vd & exu_queue.wfi_req) | wfi_run_start_ff)\n`ifdef SCR1_DBG_EN\n                     & ~hdu2exu_no_commit_i & ~hdu2exu_dmode_sstep_en_i & ~hdu2exu_dbg_run2halt_i\n`endif // SCR1_DBG_EN\n                     ;\nassign wfi_halt_req  = ~wfi_halted_ff & wfi_halt_cond;\n\n// HART will exit WFI halted state if the event that causes the HART to resume\n// execution occurs even if it doesn't cause an interrupt to be taken\nassign wfi_run_req   = wfi_halted_ff  & (csr2exu_ip_ie_i\n`ifdef SCR1_DBG_EN\n                                      | hdu2exu_dbg_halt2run_i\n`endif // SCR1_DBG_EN\n                                      );\n\n// WFI Run Start register\n//------------------------------------------------------------------------------\n\n`ifndef SCR1_CLKCTRL_EN\nalways_ff @(negedge rst_n, posedge clk) begin\n`else // SCR1_CLKCTRL_EN\nalways_ff @(negedge rst_n, posedge clk_alw_on) begin\n`endif // SCR1_CLKCTRL_EN\n    if (~rst_n) begin\n        wfi_run_start_ff <= 1'b0;\n    end else begin\n        wfi_run_start_ff <= wfi_run_start_next;\n    end\nend\n\nassign wfi_run_start_next = wfi_halted_ff & csr2exu_ip_ie_i & ~exu2csr_take_irq_o;\n\n// WFI halted flag register\n//------------------------------------------------------------------------------\n\nassign wfi_halted_upd = wfi_halt_req | wfi_run_req;\n\n`ifndef SCR1_CLKCTRL_EN\nalways_ff @(negedge rst_n, posedge clk) begin\n`else // SCR1_CLKCTRL_EN\nalways_ff @(negedge rst_n, posedge clk_alw_on) begin\n`endif // SCR1_CLKCTRL_EN\n    if (~rst_n) begin\n        wfi_halted_ff <= 1'b0;\n    end else if (wfi_halted_upd) begin\n        wfi_halted_ff <= wfi_halted_next;\n    end\nend\n\nassign wfi_halted_next = wfi_halt_req | ~wfi_run_req;\n\n// WFI status signals\n//------------------------------------------------------------------------------\n\nassign exu2pipe_wfi_run2halt_o = wfi_halt_req;\n`ifdef SCR1_CLKCTRL_EN\nassign exu2pipe_wfi_halted_o   = wfi_halted_ff;\n`endif // SCR1_CLKCTRL_EN\n\n//------------------------------------------------------------------------------\n// Program Counter logic\n//------------------------------------------------------------------------------\n//\n // PC logic consists of the following functional units:\n // - PC initialization logic\n // - Current PC register\n // - New PC multiplexer\n\n// PC initialization logic\n//------------------------------------------------------------------------------\n// Generates a New PC request to set PC to reset value\n\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        init_pc_v <= '0;\n    end else begin\n        if (~&init_pc_v) begin\n            init_pc_v <= {init_pc_v[2:0], 1'b1};\n        end\n    end\nend\n\nassign init_pc = ~init_pc_v[3] & init_pc_v[2];\n\n// Current PC register\n//------------------------------------------------------------------------------\n\nassign pc_curr_upd = ((exu2pipe_instret_o | exu2csr_take_irq_o\n`ifdef SCR1_DBG_EN\n                   | dbg_run_start_npbuf) & ( ~hdu2exu_pc_advmt_dsbl_i\n                                            & ~hdu2exu_no_commit_i\n`endif // SCR1_DBG_EN\n                   ));\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        pc_curr_ff <= SCR1_RST_VECTOR;\n    end else if (pc_curr_upd) begin\n        pc_curr_ff <= pc_curr_next;\n    end\nend\n\n`ifdef SCR1_RVC_EXT\nassign inc_pc = pc_curr_ff + (exu_queue.instr_rvc ? `SCR1_XLEN'd2 : `SCR1_XLEN'd4);\n`else // ~SCR1_RVC_EXT\nassign inc_pc = pc_curr_ff + `SCR1_XLEN'd4;\n`endif // ~SCR1_RVC_EXT\n\nassign pc_curr_next = exu2ifu_pc_new_req_o        ? exu2ifu_pc_new_o\n                    : (inc_pc[6] ^ pc_curr_ff[6]) ? inc_pc\n                                                  : {pc_curr_ff[`SCR1_XLEN-1:6], inc_pc[5:0]};\n\n// New PC multiplexer\n//------------------------------------------------------------------------------\n\nalways_comb begin\n    case (1'b1)\n        init_pc             : exu2ifu_pc_new_o = SCR1_RST_VECTOR;\n        exu2csr_take_exc_o,\n        exu2csr_take_irq_o,\n        exu2csr_mret_instr_o: exu2ifu_pc_new_o = csr2exu_new_pc_i;\n`ifdef SCR1_DBG_EN\n        dbg_run_start_npbuf : exu2ifu_pc_new_o = hdu2exu_dbg_new_pc_i;\n`endif // SCR1_DBG_EN\n        wfi_run_start_ff    : exu2ifu_pc_new_o = pc_curr_ff;\n        exu_queue.fencei_req: exu2ifu_pc_new_o = inc_pc;\n        default             : exu2ifu_pc_new_o = ialu_addr_res & SCR1_JUMP_MASK;\n    endcase\nend\n\nassign exu2ifu_pc_new_req_o = init_pc                                        // reset\n                            | exu2csr_take_irq_o\n                            | exu2csr_take_exc_o\n                            | (exu2csr_mret_instr_o & ~csr2exu_mstatus_mie_up_i)\n                            | (exu_queue_vd & exu_queue.fencei_req)\n                            | (wfi_run_start_ff\n`ifdef SCR1_CLKCTRL_EN\n                            & clk_pipe_en\n`endif // SCR1_CLKCTRL_EN\n                            )\n`ifdef SCR1_DBG_EN\n                            | dbg_run_start_npbuf\n`endif // SCR1_DBG_EN\n                            | (exu_queue_vd & jb_taken);\n\n// Jump/branch signals\nassign branch_taken = exu_queue.branch_req & ialu_cmp;\nassign jb_taken     = exu_queue.jump_req | branch_taken;\nassign jb_new_pc    = ialu_addr_res & SCR1_JUMP_MASK;\n\n// PC to be loaded on MRET from interrupt trap\nassign exu2csr_pc_next_o  = ~exu_queue_vd ? pc_curr_ff\n                          : jb_taken      ? jb_new_pc\n                                          : inc_pc;\nassign exu2pipe_pc_curr_o = pc_curr_ff;\n\n//------------------------------------------------------------------------------\n// Load/Store Unit (LSU)\n//------------------------------------------------------------------------------\n //\n // Functionality:\n // - Performs load and store operations in Data Memory\n // - Generates DMEM address misalign and access fault exceptions\n // - Passes DMEM operations information to TDU and generates LSU breakpoint exception\n //\n//------------------------------------------------------------------------------\n\nassign lsu_req  = ((exu_queue.lsu_cmd != SCR1_LSU_CMD_NONE) & exu_queue_vd);\n\nscr1_pipe_lsu i_lsu(\n    .rst_n                      (rst_n                   ),\n    .clk                        (clk                     ),\n\n    // EXU <-> LSU interface\n    .exu2lsu_req_i              (lsu_req                 ),       // Request to LSU\n    .exu2lsu_cmd_i              (exu_queue.lsu_cmd       ),       // LSU command\n    .exu2lsu_addr_i             (ialu_addr_res           ),       // DMEM address\n    .exu2lsu_sdata_i            (mprf2exu_rs2_data_i     ),       // Data for store to DMEM\n    .lsu2exu_rdy_o              (lsu_rdy                 ),       // LSU ready\n    .lsu2exu_ldata_o            (lsu_l_data              ),       // Loaded data form DMEM\n    .lsu2exu_exc_o              (lsu_exc_req             ),       // LSU exception\n    .lsu2exu_exc_code_o         (lsu_exc_code            ),       // LSU exception code\n\n`ifdef SCR1_TDU_EN\n    // TDU <-> LSU interface\n    .lsu2tdu_dmon_o             (lsu2tdu_dmon_o          ),\n    .tdu2lsu_ibrkpt_exc_req_i   (tdu2lsu_ibrkpt_exc_req_i),\n    .tdu2lsu_dbrkpt_exc_req_i   (tdu2lsu_dbrkpt_exc_req_i),\n`endif // SCR1_TDU_EN\n\n    // Data memory interface\n    .lsu2dmem_req_o             (exu2dmem_req_o          ),       // DMEM request\n    .lsu2dmem_cmd_o             (exu2dmem_cmd_o          ),       // DMEM command\n    .lsu2dmem_width_o           (exu2dmem_width_o        ),       // DMEM width\n    .lsu2dmem_addr_o            (exu2dmem_addr_o         ),       // DMEM address\n    .lsu2dmem_wdata_o           (exu2dmem_wdata_o        ),       // DMEM write data\n    .dmem2lsu_req_ack_i         (dmem2exu_req_ack_i      ),       // DMEM request acknowledge\n    .dmem2lsu_rdata_i           (dmem2exu_rdata_i        ),       // DMEM read data\n    .dmem2lsu_resp_i            (dmem2exu_resp_i         )        // DMEM response\n);\n\n//------------------------------------------------------------------------------\n// EXU status logic\n//------------------------------------------------------------------------------\n\n// EXU ready flag\nalways_comb begin\n    case (1'b1)\n        lsu_req                 : exu_rdy = lsu_rdy | lsu_exc_req;\n`ifdef SCR1_RVM_EXT\n        ialu_vd                 : exu_rdy = ialu_rdy;\n`endif // SCR1_RVM_EXT\n        csr2exu_mstatus_mie_up_i: exu_rdy = 1'b0;\n        default                 : exu_rdy = 1'b1;\n    endcase\nend\n\nassign exu2pipe_init_pc_o       = init_pc;\nassign exu2idu_rdy_o            = exu_rdy & ~exu_queue_barrier;\nassign exu2pipe_exu_busy_o      = exu_queue_vd & ~exu_rdy;\nassign exu2pipe_instret_o       = exu_queue_vd & exu_rdy;\n`ifndef SCR1_CSR_REDUCED_CNT\nassign exu2csr_instret_no_exc_o = exu2pipe_instret_o & ~exu_exc_req;\n`endif // SCR1_CSR_REDUCED_CNT\n\n// Exceptions\n`ifdef SCR1_DBG_EN\nassign exu2pipe_exc_req_o  = exu_queue_vd ? exu_exc_req : exu_exc_req_ff;\n`else // SCR1_DBG_EN\nassign exu2pipe_exc_req_o  = exu_exc_req;\n`endif // SCR1_DBG_EN\n\n// Breakpoints\nassign exu2pipe_brkpt_o    = exu_queue_vd & (exu_queue.exc_code == SCR1_EXC_CODE_BREAKPOINT);\n`ifdef SCR1_TDU_EN\n  `ifdef SCR1_DBG_EN\nassign exu2hdu_ibrkpt_hw_o = tdu2exu_ibrkpt_exc_req_i | tdu2lsu_dbrkpt_exc_req_i;\n  `endif // SCR1_DBG_EN\n`endif // SCR1_TDU_EN\n\n//------------------------------------------------------------------------------\n// EXU <-> MPRF interface\n//------------------------------------------------------------------------------\n\n// Operands fetching stage\n//------------------------------------------------------------------------------\n\n`ifdef  SCR1_NO_EXE_STAGE\nassign mprf_rs1_req = exu_queue_vd & idu2exu_use_rs1_i;\nassign mprf_rs2_req = exu_queue_vd & idu2exu_use_rs2_i;\n`else // SCR1_NO_EXE_STAGE\n `ifdef  SCR1_MPRF_RAM\nassign mprf_rs1_req = exu_queue_en\n                    ? (exu_queue_vd_next & idu2exu_use_rs1_i)\n                    : (exu_queue_vd      & idu2exu_use_rs1_ff);\nassign mprf_rs2_req = exu_queue_en\n                    ? (exu_queue_vd_next & idu2exu_use_rs2_i)\n                    : (exu_queue_vd      & idu2exu_use_rs2_ff);\n `else // SCR1_MPRF_RAM\nassign mprf_rs1_req = exu_queue_vd & idu2exu_use_rs1_ff;\nassign mprf_rs2_req = exu_queue_vd & idu2exu_use_rs2_ff;\n `endif // SCR1_MPRF_RAM\n`endif // SCR1_NO_EXE_STAGE\n\n// If exu_queue isn't enabled we need previous addresses and usage flags because\n// RAM blocks read operation is SYNCHRONOUS\n`ifdef SCR1_MPRF_RAM\nassign mprf_rs1_addr = exu_queue_en ? idu2exu_cmd_i.rs1_addr[`SCR1_MPRF_AWIDTH-1:0] : exu_queue.rs1_addr[`SCR1_MPRF_AWIDTH-1:0];\nassign mprf_rs2_addr = exu_queue_en ? idu2exu_cmd_i.rs2_addr[`SCR1_MPRF_AWIDTH-1:0] : exu_queue.rs2_addr[`SCR1_MPRF_AWIDTH-1:0];\n`else // SCR1_MPRF_RAM\nassign mprf_rs1_addr = exu_queue.rs1_addr[`SCR1_MPRF_AWIDTH-1:0];\nassign mprf_rs2_addr = exu_queue.rs2_addr[`SCR1_MPRF_AWIDTH-1:0];\n`endif // SCR1_MPRF_RAM\n\nassign exu2mprf_rs1_addr_o = mprf_rs1_req ? mprf_rs1_addr[`SCR1_MPRF_AWIDTH-1:0] : '0;\nassign exu2mprf_rs2_addr_o = mprf_rs2_req ? mprf_rs2_addr[`SCR1_MPRF_AWIDTH-1:0] : '0;\n\n// Write back stage\n//------------------------------------------------------------------------------\n\nassign exu2mprf_w_req_o   = (exu_queue.rd_wb_sel != SCR1_RD_WB_NONE) & exu_queue_vd & ~exu_exc_req\n`ifdef SCR1_DBG_EN\n                          & ~hdu2exu_no_commit_i\n`endif // SCR1_DBG_EN\n                          & ((exu_queue.rd_wb_sel == SCR1_RD_WB_CSR) ? csr_access_init : exu_rdy);\n\nassign exu2mprf_rd_addr_o = `SCR1_MPRF_AWIDTH'(exu_queue.rd_addr);\n\n// MRPF RD data multiplexer\nalways_comb begin\n    case (exu_queue.rd_wb_sel)\n        SCR1_RD_WB_SUM2  : exu2mprf_rd_data_o = ialu_addr_res;\n        SCR1_RD_WB_IMM   : exu2mprf_rd_data_o = exu_queue.imm;\n        SCR1_RD_WB_INC_PC: exu2mprf_rd_data_o = inc_pc;\n        SCR1_RD_WB_LSU   : exu2mprf_rd_data_o = lsu_l_data;\n        SCR1_RD_WB_CSR   : exu2mprf_rd_data_o = csr2exu_r_data_i;\n        default          : exu2mprf_rd_data_o = ialu_main_res;\n    endcase\nend\n\n//------------------------------------------------------------------------------\n// EXU <-> CSR interface\n//------------------------------------------------------------------------------\n//\n // EXU <-> CSR interface consists of the following functional units:\n // - CSR write/read interface\n // - CSR access FSM\n // - CSR events interface:\n //   - Exceptions signals\n //   - Interrupts signals\n //   - MRET signals\n//\n\n// CSRs write/read interface\n//------------------------------------------------------------------------------\n\n// CSR write/read request signals calculation\nalways_comb begin\n    if (~exu_queue_vd\n`ifdef SCR1_TDU_EN\n       | tdu2exu_ibrkpt_exc_req_i\n`endif // SCR1_TDU_EN\n    ) begin\n        exu2csr_r_req_o = 1'b0;\n        exu2csr_w_req_o = 1'b0;\n    end else begin\n        case (exu_queue.csr_cmd)\n            SCR1_CSR_CMD_WRITE  : begin\n                exu2csr_r_req_o = |exu_queue.rd_addr;\n                exu2csr_w_req_o = csr_access_init;\n            end\n            SCR1_CSR_CMD_SET,\n            SCR1_CSR_CMD_CLEAR  : begin\n                exu2csr_r_req_o = 1'b1;\n                exu2csr_w_req_o = |exu_queue.rs1_addr & csr_access_init;\n            end\n            default : begin\n                exu2csr_r_req_o = 1'b0;\n                exu2csr_w_req_o = 1'b0;\n            end\n        endcase\n    end\nend\n\nassign exu2csr_w_cmd_o   = exu_queue.csr_cmd;\nassign exu2csr_rw_addr_o = exu_queue.imm[SCR1_CSR_ADDR_WIDTH-1:0];\nassign exu2csr_w_data_o  = (exu_queue.csr_op == SCR1_CSR_OP_REG)\n                         ? mprf2exu_rs1_data_i\n                         : {'0, exu_queue.rs1_addr}; // zimm\n\n\n// CSR access FSM\n//------------------------------------------------------------------------------\n\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        csr_access_ff <= SCR1_CSR_INIT;\n    end else begin\n        csr_access_ff <= csr_access_next;\n    end\nend\n\nassign csr_access_next = (csr_access_init & csr2exu_mstatus_mie_up_i)\n                       ? SCR1_CSR_RDY\n                       : SCR1_CSR_INIT;\n\nassign csr_access_init = (csr_access_ff == SCR1_CSR_INIT);\n\n// CSR events interface\n//------------------------------------------------------------------------------\n\n// Exceptions signals\nassign exu2csr_take_exc_o = exu_exc_req\n`ifdef SCR1_DBG_EN\n                          & ~hdu2exu_dbg_halted_i\n`endif // SCR1_DBG_EN\n                          ;\nassign exu2csr_exc_code_o = exc_code;\nassign exu2csr_trap_val_o = exc_trap_val;\n\n// Interrupts signals\nassign exu2csr_take_irq_o = csr2exu_irq_i & ~exu2pipe_exu_busy_o\n`ifdef SCR1_DBG_EN\n                          & ~hdu2exu_irq_dsbl_i\n                          & ~hdu2exu_dbg_halted_i\n`endif // SCR1_DBG_EN\n`ifdef SCR1_CLKCTRL_EN\n                          & clk_pipe_en\n`endif /"}
{"text": "/ SCR1_CLKCTRL_EN\n                          ;\n\n// MRET signals\n// MRET instruction flag\nassign exu2csr_mret_instr_o  = exu_queue_vd & exu_queue.mret_req\n`ifdef SCR1_TDU_EN\n                             & ~tdu2exu_ibrkpt_exc_req_i\n`endif // SCR1_TDU_EN\n`ifdef SCR1_DBG_EN\n                             & ~hdu2exu_dbg_halted_i\n`endif // SCR1_DBG_EN\n                             ;\nassign exu2csr_mret_update_o = exu2csr_mret_instr_o & csr_access_init;\n\n`ifdef SCR1_TDU_EN\n//------------------------------------------------------------------------------\n// EXU <-> TDU interface\n//------------------------------------------------------------------------------\n\n// Instruction monitor\nassign exu2tdu_imon_o.vd    = exu_queue_vd;\nassign exu2tdu_imon_o.req   = exu2pipe_instret_o;\nassign exu2tdu_imon_o.addr  = pc_curr_ff;\n\nalways_comb begin\n    exu2tdu_ibrkpt_ret_o = '0;\n    if (exu_queue_vd) begin\n        exu2tdu_ibrkpt_ret_o = tdu2exu_ibrkpt_match_i;\n        if (lsu_req) begin\n            exu2tdu_ibrkpt_ret_o[SCR1_TDU_MTRIG_NUM-1:0] |= tdu2lsu_dbrkpt_match_i;\n        end\n    end\nend\n`endif // SCR1_TDU_EN\n\n\n`ifdef SCR1_TRGT_SIMULATION\n//------------------------------------------------------------------------------\n// Tracelog signals\n//------------------------------------------------------------------------------\n\nlogic [`SCR1_XLEN-1:0]      update_pc;\nlogic                       update_pc_en;\n\nassign update_pc_en = (init_pc | exu2pipe_instret_o | exu2csr_take_irq_o)\n`ifdef SCR1_DBG_EN\n                    & ~hdu2exu_pc_advmt_dsbl_i & ~hdu2exu_no_commit_i\n`endif // SCR1_DBG_EN\n                    ;\nassign update_pc    = exu2ifu_pc_new_req_o ? exu2ifu_pc_new_o : inc_pc;\n\n\n//------------------------------------------------------------------------------\n// Assertion\n//------------------------------------------------------------------------------\n\n// X checks\n\nSCR1_SVA_EXU_XCHECK_CTRL : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    !$isunknown({idu2exu_req_i, csr2exu_irq_i, csr2exu_ip_ie_i, lsu_req, lsu_rdy, exu_exc_req})\n    ) else $error(\"EXU Error: unknown control values\");\n\nSCR1_SVA_EXU_XCHECK_QUEUE : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    (idu2exu_req_i & exu_queue_vd) |-> !$isunknown(idu2exu_cmd_i)\n    ) else $error(\"EXU Error: unknown values in queue\");\n\nSCR1_SVA_EXU_XCHECK_CSR_RDATA : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    exu2csr_r_req_o |-> !$isunknown({csr2exu_r_data_i, csr2exu_rw_exc_i})\n    ) else $error(\"EXU Error: unknown values from CSR\");\n\n// Behavior checks\n\nSCR1_SVA_EXU_ONEHOT : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    $onehot0({exu_queue.jump_req, exu_queue.branch_req, lsu_req})\n    ) else $error(\"EXU Error: illegal combination of control signals\");\n\nSCR1_SVA_EXU_ONEHOT_EXC : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    exu_queue_vd |->\n    $onehot0({exu_queue.exc_req, lsu_exc_req, csr2exu_rw_exc_i\n`ifndef SCR1_RVC_EXT\n    , jb_misalign\n`endif\n    })\n    ) else $error(\"EXU Error: exceptions $onehot0 failed\");\n\n// No event can request current PC update before initial reset sequence is done\nSCR1_SVA_EXU_CURR_PC_UPD_BEFORE_INIT : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    ~&init_pc_v |-> ~( pc_curr_upd & ~init_pc )\n    ) else $error(\"EXU Error: current PC updated before been initialized\");\n\n// No event can generate a new PC request to IFU before initial reset sequence\n// is done\nSCR1_SVA_EXU_NEW_PC_REQ_BEFORE_INIT : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    ~&init_pc_v |-> ~( exu2ifu_pc_new_req_o & ~init_pc )\n    ) else $error(\"EXU Error: new PC req generated before reset sequence is done\");\n\n`endif // SCR1_TRGT_SIMULATION\n\nendmodule : scr1_pipe_exu\n"}
{"text": "/// Copyright by Syntacore LLC  2016-2021. See LICENSE for details\n/// @file       <scr1_pipe_hdu.sv>\n/// @brief      HART Debug Unit (HDU)\n///\n\n//------------------------------------------------------------------------------\n //\n //\n // Functionality:\n // - Controls HART state (RUN, Debug RUN, Debug HALTED)\n // - Setups Debug Mode execution\n // - Provides status information about Debug Mode execution\n // - Provides Program Buffer functionality (a few instructions execution while\n //   in Debug Mode)\n // - Provides access to Debug CSRs\n //\n // Structure:\n // - Debug state FSM\n // - HART Control logic\n // - HART Status logic\n // - Program Buffer\n // - Debug CSRs\n // - HDU <-> DM interface\n // - HDU <-> EXU interface\n // - HDU <-> IFU interface\n // - HDU <-> CSR interface\n // - HDU <-> TDU interface\n //\n//------------------------------------------------------------------------------\n\n`include \"scr1_arch_description.svh\"\n\n`ifdef SCR1_DBG_EN\n`include \"scr1_arch_types.svh\"\n`include \"scr1_riscv_isa_decoding.svh\"\n`include \"scr1_hdu.svh\"\n\nmodule scr1_pipe_hdu #(parameter HART_PBUF_INSTR_REGOUT_EN = 1'b1) (\n    // Common signals\n    input  logic                                        rst_n,                      // HDU reset\n    input  logic                                        clk,                        // HDU clock\n    input  logic                                        clk_en,                     // HDU clock enable\n`ifdef SCR1_CLKCTRL_EN\n    input   logic                                       clk_pipe_en,                // Pipeline clock enable\n`endif // SCR1_CLKCTRL_EN\n    input  logic                                        pipe2hdu_rdc_qlfy_i,        // Pipeline RDC qualifier\n\n    // HDU <-> CSR i/f\n    input  logic                                        csr2hdu_req_i,              // CSR i/f request\n    input  type_scr1_csr_cmd_sel_e                      csr2hdu_cmd_i,              // CSR i/f command\n    input  logic [SCR1_HDU_DEBUGCSR_ADDR_WIDTH-1:0]     csr2hdu_addr_i,             // CSR i/f address\n    input  logic [`SCR1_XLEN-1:0]                       csr2hdu_wdata_i,            // CSR i/f write data\n    output type_scr1_csr_resp_e                         hdu2csr_resp_o,             // CSR i/f response\n    output logic [`SCR1_XLEN-1:0]                       hdu2csr_rdata_o,            // CSR i/f read data\n\n    // HDU <-> DM i/f\n    // HART Run Control i/f\n    input  logic                                        dm2hdu_cmd_req_i,           // DM-HART Command request\n    input  type_scr1_hdu_dbgstates_e                    dm2hdu_cmd_i,               // DM-HART Command\n    output logic                                        hdu2dm_cmd_resp_o,          // DM-HART Command response\n    output logic                                        hdu2dm_cmd_rcode_o,         // DM-HART Command return code: 0 - Ok; 1 - Error\n    output logic                                        hdu2dm_hart_event_o,        // DM-HART Event: 1 if HART debug state changed\n    output type_scr1_hdu_hartstatus_s                   hdu2dm_hart_status_o,       // DM-HART Status\n\n    // Program Buffer i/f\n    output logic [SCR1_HDU_PBUF_ADDR_WIDTH-1:0]         hdu2dm_pbuf_addr_o,         // Program Buffer address - so far request only for 1 instruction\n    input  logic [SCR1_HDU_CORE_INSTR_WIDTH-1:0]        dm2hdu_pbuf_instr_i,        // Program Buffer instruction\n\n    // HART Abstract Data regs i/f\n    output logic                                        hdu2dm_dreg_req_o,          // Abstract Data Register request\n    output logic                                        hdu2dm_dreg_wr_o,           // Abstract Data Register write\n    output logic [`SCR1_XLEN-1:0]                       hdu2dm_dreg_wdata_o,        // Abstract Data Register write data\n    input  logic                                        dm2hdu_dreg_resp_i,         // Abstract Data Register response\n    input  logic                                        dm2hdu_dreg_fail_i,         // Abstract Data Register fail\n    input  logic [`SCR1_XLEN-1:0]                       dm2hdu_dreg_rdata_i,        // Abstract Data Register read data\n\n`ifdef SCR1_TDU_EN\n    // HDU <-> TDU interface\n    output  logic                                       hdu2tdu_hwbrk_dsbl_o,       // Disables BRKM\n    input   logic                                       tdu2hdu_dmode_req_i,        // Trigger Module requests transition to debug mode\n    input   logic                                       exu2hdu_ibrkpt_hw_i,        // Hardware breakpoint on current instruction\n`endif // SCR1_TDU_EN\n\n    // HART Run Status\n    input   logic                                       pipe2hdu_exu_busy_i,        // EXU busy\n    input   logic                                       pipe2hdu_instret_i,         // Instruction retired (with or without exception)\n    input   logic                                       pipe2hdu_init_pc_i,         // Reset exit\n\n    // HART Halt Status\n    input   logic                                       pipe2hdu_exu_exc_req_i,     // Exception request\n    input   logic                                       pipe2hdu_brkpt_i,           // Software Breakpoint (EBREAK)\n\n    // HDU <-> EXU i/f\n    // HART Run Control\n    output  logic                                       hdu2exu_pbuf_fetch_o,       // Fetch instruction from Program Buffer\n    output  logic                                       hdu2exu_no_commit_o,        // Forbid instruction commitment\n    output  logic                                       hdu2exu_irq_dsbl_o,         // Disable IRQ\n    output  logic                                       hdu2exu_pc_advmt_dsbl_o,    // Forbid PC advancement\n    output  logic                                       hdu2exu_dmode_sstep_en_o,   // Enable single-step\n\n    // HART state\n    output  logic                                       hdu2exu_dbg_halted_o,       // Debug halted state\n    output  logic                                       hdu2exu_dbg_run2halt_o,     // Transition to debug halted state\n    output  logic                                       hdu2exu_dbg_halt2run_o,     // Transition to run state\n    output  logic                                       hdu2exu_dbg_run_start_o,    // First cycle of run state\n\n    // PC interface\n    input  logic [`SCR1_XLEN-1:0]                       pipe2hdu_pc_curr_i,         // Current PC\n    output logic [`SCR1_XLEN-1:0]                       hdu2exu_dbg_new_pc_o,       // New PC for resume\n\n    // HDU <-> IFU i/f\n    // Program Buffer Instruction interface\n    input   logic                                       ifu2hdu_pbuf_instr_rdy_i,   // Program Buffer Instruction i/f ready\n    output  logic                                       hdu2ifu_pbuf_instr_vd_o,    // Program Buffer Instruction valid\n    output  logic                                       hdu2ifu_pbuf_instr_err_o,   // Program Buffer Instruction i/f error\n    output  logic [SCR1_HDU_CORE_INSTR_WIDTH-1:0]       hdu2ifu_pbuf_instr_o        // Program Buffer Instruction itself\n);\n\n//------------------------------------------------------------------------------\n// Local Parameters\n//------------------------------------------------------------------------------\n\nlocalparam int unsigned SCR1_HDU_TIMEOUT       = 64;       // must be power of 2\nlocalparam int unsigned SCR1_HDU_TIMEOUT_WIDTH = $clog2(SCR1_HDU_TIMEOUT);\n\n//------------------------------------------------------------------------------\n// Local Signals\n//------------------------------------------------------------------------------\n\n// Debug FSM\n//------------------------------------------------------------------------------\n\n// FSM control signals\nlogic                                               dm_dhalt_req;\nlogic                                               dm_run_req;\n\nlogic                                               dm_cmd_run;\nlogic                                               dm_cmd_dhalted;\nlogic                                               dm_cmd_drun;\n\n// Debug state FSM signals\ntype_scr1_hdu_dbgstates_e                           dbg_state;\ntype_scr1_hdu_dbgstates_e                           dbg_state_next;\nlogic                                               dbg_state_dhalted;\nlogic                                               dbg_state_drun;\nlogic                                               dbg_state_run;\nlogic                                               dbg_state_reset;\n\n// FSM transition, update and event registers\nlogic                                               dfsm_trans;\nlogic                                               dfsm_trans_next;\nlogic                                               dfsm_update;\nlogic                                               dfsm_update_next;\nlogic                                               dfsm_event;\nlogic                                               dfsm_event_next;\n\n// HART Control signals\n//------------------------------------------------------------------------------\n\nlogic                                               hart_resume_req;\nlogic                                               hart_halt_req;\nlogic                                               hart_cmd_req;\n\n// HART Run Control register\nlogic                                               hart_runctrl_upd;\nlogic                                               hart_runctrl_clr;\ntype_scr1_hdu_runctrl_s                             hart_runctrl;\n\n// HART halt request timeout counter signals\nlogic [SCR1_HDU_TIMEOUT_WIDTH-1:0]                  halt_req_timeout_cnt;\nlogic [SCR1_HDU_TIMEOUT_WIDTH-1:0]                  halt_req_timeout_cnt_next;\nlogic                                               halt_req_timeout_cnt_en;\nlogic                                               halt_req_timeout_flag;\n\n// HART Status signals\n//------------------------------------------------------------------------------\n\ntype_scr1_hdu_haltstatus_s                          hart_haltstatus;\ntype_scr1_hdu_haltcause_e                           hart_haltcause;\n\nlogic                                               hart_halt_pnd;\nlogic                                               hart_halt_ack;\n\n// Debug mode cause decoder signals\nlogic                                               dmode_cause_sstep;\nlogic                                               dmode_cause_except;\nlogic                                               dmode_cause_ebreak;\nlogic                                               dmode_cause_any;\n`ifdef SCR1_TDU_EN\nlogic                                               dmode_cause_tmreq;\n`endif // SCR1_TDU_EN\n\n// Program Buffer FSM\n//------------------------------------------------------------------------------\n\n// PBUF FSM control signals\nlogic                                               ifu_handshake_done;\nlogic                                               pbuf_exc_inj_req;\nlogic                                               pbuf_exc_inj_end;\nlogic                                               pbuf_start_fetch;\n\n// PBUF FSM signals\ntype_scr1_hdu_pbufstates_e                          pbuf_fsm_curr;\ntype_scr1_hdu_pbufstates_e                          pbuf_fsm_next;\nlogic                                               pbuf_fsm_idle;\nlogic                                               pbuf_fsm_fetch;\nlogic                                               pbuf_fsm_excinj;\n\n// PBUF address signals\nlogic [SCR1_HDU_PBUF_ADDR_WIDTH-1:0]                pbuf_addr_ff;\nlogic [SCR1_HDU_PBUF_ADDR_WIDTH-1:0]                pbuf_addr_next;\nlogic                                               pbuf_addr_end;\nlogic                                               pbuf_addr_next_vd;\n\nlogic                                               pbuf_instr_wait_latching;\n\n// Debugs CSRs\n//------------------------------------------------------------------------------\n\n// CSRs write/read interface signals\nlogic                                               csr_upd_on_halt;\nlogic                                               csr_wr;\nlogic [`SCR1_XLEN-1:0]                              csr_wr_data;\nlogic [`SCR1_XLEN-1:0]                              csr_rd_data;\n\n// Debug Control and Status register (DCSR)\nlogic                                               csr_dcsr_sel;\nlogic                                               csr_dcsr_wr;\ntype_scr1_hdu_dcsr_s                                csr_dcsr_in;\ntype_scr1_hdu_dcsr_s                                csr_dcsr_out;\nlogic                                               csr_dcsr_ebreakm;\nlogic                                               csr_dcsr_stepie;\nlogic                                               csr_dcsr_step;\nlogic [SCR1_HDU_DCSR_CAUSE_BIT_L-\n       SCR1_HDU_DCSR_CAUSE_BIT_R:0]                 csr_dcsr_cause;\n\n// Debug Program Counter register (DPC)\nlogic                                               csr_dpc_sel;\nlogic                                               csr_dpc_wr;\nlogic [`SCR1_XLEN-1:0]                              csr_dpc_ff;\nlogic [`SCR1_XLEN-1:0]                              csr_dpc_next;\nlogic [`SCR1_XLEN-1:0]                              csr_dpc_out;\n\n// Debug Scratch register 0 (DSCRATCH0)\nlogic                                               csr_addr_dscratch0;\nlogic                                               csr_dscratch0_sel;\nlogic                                               csr_dscratch0_wr;\nlogic [`SCR1_XLEN-1:0]                              csr_dscratch0_out;\ntype_scr1_csr_resp_e                                csr_dscratch0_resp;\n\n//------------------------------------------------------------------------------\n// Debug state FSM logic\n//------------------------------------------------------------------------------\n//\n // Debug state FSM logic consists of the following functional units:\n // - FSM control logic\n // - Debug state FSM\n // - FSM transition, update and event registers\n//\n\n// FSM control logic\n//------------------------------------------------------------------------------\n\nassign dm_cmd_dhalted = (dm2hdu_cmd_i == SCR1_HDU_DBGSTATE_DHALTED);\nassign dm_cmd_run     = (dm2hdu_cmd_i == SCR1_HDU_DBGSTATE_RUN);\nassign dm_cmd_drun    = (dm2hdu_cmd_i == SCR1_HDU_DBGSTATE_DRUN);\n\nassign dm_dhalt_req   = dm2hdu_cmd_req_i & dm_cmd_dhalted;\nassign dm_run_req     = dm2hdu_cmd_req_i & (dm_cmd_run | dm_cmd_drun);\n\n// Debug state FSM\n//------------------------------------------------------------------------------\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        dbg_state <= SCR1_HDU_DBGSTATE_RESET;\n    end else begin\n        dbg_state <= dbg_state_next;\n    end\nend\n\nalways_comb begin\n    if (~pipe2hdu_rdc_qlfy_i) begin\n        dbg_state_next = SCR1_HDU_DBGSTATE_RESET;\n    end else begin\n        case (dbg_state)\n            SCR1_HDU_DBGSTATE_RESET: begin\n                dbg_state_next = ~pipe2hdu_init_pc_i ? SCR1_HDU_DBGSTATE_RESET\n                               : dm_dhalt_req        ? SCR1_HDU_DBGSTATE_DHALTED\n                                                     : SCR1_HDU_DBGSTATE_RUN;\n            end\n            SCR1_HDU_DBGSTATE_RUN: begin\n                dbg_state_next = dfsm_update         ? SCR1_HDU_DBGSTATE_DHALTED\n                                                     : SCR1_HDU_DBGSTATE_RUN;\n            end\n            SCR1_HDU_DBGSTATE_DHALTED: begin\n                dbg_state_next = ~dfsm_update        ? SCR1_HDU_DBGSTATE_DHALTED\n                               : dm_cmd_drun         ? SCR1_HDU_DBGSTATE_DRUN\n                                                     : SCR1_HDU_DBGSTATE_RUN;\n            end\n            SCR1_HDU_DBGSTATE_DRUN: begin\n                dbg_state_next = dfsm_update         ? SCR1_HDU_DBGSTATE_DHALTED\n                                                     : SCR1_HDU_DBGSTATE_DRUN;\n            end\n            default: begin\n`ifdef SCR1_XPROP_EN\n                dbg_state_next = SCR1_HDU_DBGSTATE_XXX;\n`else // SCR1_XPROP_EN\n                dbg_state_next = dbg_state;\n`endif // SCR1_XPROP_EN\n            end\n        endcase\n    end\nend\n\nassign dbg_state_dhalted = (dbg_state == SCR1_HDU_DBGSTATE_DHALTED);\nassign dbg_state_drun    = (dbg_state == SCR1_HDU_DBGSTATE_DRUN);\nassign dbg_state_run     = (dbg_state == SCR1_HDU_DBGSTATE_RUN);\nassign dbg_state_reset   = (dbg_state == SCR1_HDU_DBGSTATE_RESET);\n\n// FSM transition, update and event registers\n//------------------------------------------------------------------------------\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        dfsm_trans  <= 1'b0;\n        dfsm_update <= 1'b0;\n        dfsm_event  <= 1'b0;\n    end else begin\n        dfsm_trans  <= dfsm_trans_next;\n        dfsm_update <= dfsm_update_next;\n        dfsm_event  <= dfsm_event_next;\n    end\nend\n\nalways_comb begin\n    dfsm_trans_next  = 1'b0;\n    dfsm_update_next = 1'b0;\n    dfsm_event_next  = 1'b0;\n\n    if (~pipe2hdu_rdc_qlfy_i) begin\n        dfsm_trans_next  = 1'b0;\n        dfsm_update_next = 1'b0;\n        dfsm_event_next  = 1'b1;\n    end else begin\n        case (dbg_state)\n            SCR1_HDU_DBGSTATE_RESET: begin\n                dfsm_trans_next  = 1'b0;\n                dfsm_update_next = 1'b0;\n                dfsm_event_next  = pipe2hdu_init_pc_i & ~dm2hdu_cmd_req_i;\n            end\n\n            SCR1_HDU_DBGSTATE_RUN,\n            SCR1_HDU_DBGSTATE_DRUN: begin\n                dfsm_trans_next  = ~dfsm_update ? hart_halt_pnd : dfsm_trans;\n                dfsm_update_next = ~dfsm_update & hart_halt_ack;\n                dfsm_event_next  = dfsm_update;\n            end\n\n            SCR1_HDU_DBGSTATE_DHALTED: begin\n                dfsm_trans_next  = ~dfsm_update ? ~dfsm_trans & dm_run_req\n                                                : dfsm_trans;\n                dfsm_update_next = ~dfsm_update & dfsm_trans;\n                dfsm_event_next  = dfsm_update;\n            end\n\n            default : begin\n                dfsm_trans_next  = 'X;\n                dfsm_update_next = 'X;\n                dfsm_event_next  = 'X;\n            end\n        endcase\n    end\nend\n\n//------------------------------------------------------------------------------\n// HART Control logic\n//------------------------------------------------------------------------------\n//\n // HART Control logic consists of the following functional units:\n // - Control signals\n // - HART Run Control register\n // - HART Halt Request Time-Out counter\n//\n\n// Control logic\nalways_comb begin\n    hart_cmd_req = 1'b0;\n\n    if (~pipe2hdu_rdc_qlfy_i) begin\n        hart_cmd_req = 1'b0;\n    end else begin\n        case (dbg_state)\n            SCR1_HDU_DBGSTATE_RESET  : hart_cmd_req = dm2hdu_cmd_req_i;\n            SCR1_HDU_DBGSTATE_DHALTED: hart_cmd_req = (dfsm_update | dfsm_trans);\n            SCR1_HDU_DBGSTATE_RUN,\n            SCR1_HDU_DBGSTATE_DRUN   : hart_cmd_req = ~dfsm_update & dfsm_trans;\n            default                  : hart_cmd_req = 'X;\n        endcase\n    end\nend\n\nassign hart_halt_req   = dm_cmd_dhalted & hart_cmd_req;\nassign hart_resume_req = (dm_cmd_run | dm_cmd_drun) & hart_cmd_req;\n\n// HART Run Control register\n//------------------------------------------------------------------------------\n\nassign hart_runctrl_clr = (dbg_state_run | dbg_state_drun)\n                        & (dbg_state_next == SCR1_HDU_DBGSTATE_DHALTED);\nassign hart_runctrl_upd = dbg_state_dhalted & dfsm_trans_next;\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        hart_runctrl.irq_dsbl      <= 1'b0;\n        hart_runctrl.fetch_src     <= SCR1_HDU_FETCH_SRC_NORMAL;\n        hart_runctrl.pc_advmt_dsbl <= 1'b0;\n        hart_runctrl.hwbrkpt_dsbl  <= 1'b0;\n        hart_runctrl.redirect      <= '0;\n    end else if(clk_en) begin\n        if (hart_runctrl_clr) begin\n            hart_runctrl           <= '0;\n        end else begin\n            if (hart_runctrl_upd) begin\n                if (~dm_cmd_drun) begin\n                    // Case : resume to RUN state\n                    hart_runctrl.irq_dsbl        <= csr_dcsr_step ? ~csr_dcsr_stepie : 1'b0;\n                    hart_runctrl.fetch"}
{"text": "_src       <= SCR1_HDU_FETCH_SRC_NORMAL;\n                    hart_runctrl.pc_advmt_dsbl   <= 1'b0;\n                    hart_runctrl.hwbrkpt_dsbl    <= 1'b0;\n                    hart_runctrl.redirect.sstep  <= csr_dcsr_step;\n                    hart_runctrl.redirect.ebreak <= csr_dcsr_ebreakm;\n                end else begin\n                    // Case : resume to DRUN state\n                    hart_runctrl.irq_dsbl        <= 1'b1;\n                    hart_runctrl.fetch_src       <= SCR1_HDU_FETCH_SRC_PBUF;\n                    hart_runctrl.pc_advmt_dsbl   <= 1'b1;\n                    hart_runctrl.hwbrkpt_dsbl    <= 1'b1;\n                    hart_runctrl.redirect.sstep  <= 1'b0;\n                    hart_runctrl.redirect.ebreak <= 1'b1;\n                end\n            end\n        end\n    end\nend\n\n// HART Halt Request Time-Out counter\n//------------------------------------------------------------------------------\n// HART goes into halt state only if the halt request is present for timeout period\n// of time\n\nassign halt_req_timeout_cnt_en = hdu2exu_dbg_halt2run_o\n                               | (hart_halt_req & ~hdu2exu_dbg_run2halt_o);\n\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        halt_req_timeout_cnt <= '1;\n    end else if (halt_req_timeout_cnt_en) begin\n        halt_req_timeout_cnt <= halt_req_timeout_cnt_next;\n    end\nend\n\nassign halt_req_timeout_cnt_next = hdu2exu_dbg_halt2run_o                    ? '1\n                                 : (hart_halt_req & ~hdu2exu_dbg_run2halt_o) ? halt_req_timeout_cnt - 1'b1\n                                                                             : halt_req_timeout_cnt;\n\nassign halt_req_timeout_flag = ~|halt_req_timeout_cnt;\n\n//------------------------------------------------------------------------------\n// HART Status logic\n//------------------------------------------------------------------------------\n//\n // HART Status logic consists of the following functional units:\n // - Debug mode cause decoder\n // - Hart halt status cause encoder\n // - Hart halt status register\n//\n\n// Debug mode cause decoder\n//------------------------------------------------------------------------------\n\nassign dmode_cause_sstep  = hart_runctrl.redirect.sstep & pipe2hdu_instret_i;\nassign dmode_cause_except = dbg_state_drun & pipe2hdu_exu_exc_req_i\n                          & ~pipe2hdu_brkpt_i\n`ifdef SCR1_TDU_EN\n                          & ~exu2hdu_ibrkpt_hw_i\n`endif // SCR1_TDU_EN\n                          ;\nassign dmode_cause_ebreak = hart_runctrl.redirect.ebreak & pipe2hdu_brkpt_i;\n`ifdef SCR1_TDU_EN\nassign dmode_cause_tmreq  = tdu2hdu_dmode_req_i & exu2hdu_ibrkpt_hw_i;\n`endif // SCR1_TDU_EN\n\nassign dmode_cause_any = dmode_cause_sstep | dmode_cause_ebreak | dmode_cause_except\n                       | hart_halt_req\n`ifdef SCR1_TDU_EN\n                       | dmode_cause_tmreq\n`endif // SCR1_TDU_EN\n                       ;\n\n// HART halt cause encoder\n//------------------------------------------------------------------------------\n\nalways_comb begin\n    case (1'b1)\n`ifdef SCR1_TDU_EN\n        dmode_cause_tmreq   : hart_haltcause = SCR1_HDU_HALTCAUSE_TMREQ;\n`endif // SCR1_TDU_EN\n        dmode_cause_ebreak  : hart_haltcause = SCR1_HDU_HALTCAUSE_EBREAK;\n        hart_halt_req       : hart_haltcause = SCR1_HDU_HALTCAUSE_DMREQ;\n        dmode_cause_sstep   : hart_haltcause = SCR1_HDU_HALTCAUSE_SSTEP;\n        default             : hart_haltcause = SCR1_HDU_HALTCAUSE_NONE;\n    endcase\nend\n\n// HART halt status register\n//------------------------------------------------------------------------------\n\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        hart_haltstatus        <= '0;\n    end else if (hart_halt_ack) begin\n        hart_haltstatus.except <= dmode_cause_except;\n        hart_haltstatus.cause  <= hart_haltcause;\n    end\nend\n\nassign hart_halt_pnd = (dfsm_trans | dm_dhalt_req) & ~hart_halt_ack;\nassign hart_halt_ack = ~hdu2exu_dbg_halted_o\n                     & (halt_req_timeout_flag | (~pipe2hdu_exu_busy_i & dmode_cause_any));\n\n//------------------------------------------------------------------------------\n// Program Buffer (PBUF) logic\n//------------------------------------------------------------------------------\n//\n // Program Buffer allows to execute small programs in debug mode\n//\n\n// To terminate Program Buffer execution exception should be raised. There are 2\n// cases:\n// - One of PBUF instructions raise an exception\n// - No PBUF instruction raise an exception before the last PBUF instruction has\n// been issued. In this case FSM goes into EXCINJECT state and an \"Instruction\n// fetch access fault\" exception is injected\n\n// PBUF FSM\n//------------------------------------------------------------------------------\n\nassign ifu_handshake_done = hdu2ifu_pbuf_instr_vd_o & ifu2hdu_pbuf_instr_rdy_i;\nassign pbuf_addr_end      = (pbuf_addr_ff == (SCR1_HDU_PBUF_ADDR_SPAN-1));\n\nassign pbuf_start_fetch = dbg_state_dhalted      & (dbg_state_next == SCR1_HDU_DBGSTATE_DRUN);\nassign pbuf_exc_inj_req = ifu_handshake_done     & pbuf_addr_end;\nassign pbuf_exc_inj_end = pipe2hdu_exu_exc_req_i | ifu_handshake_done;\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        pbuf_fsm_curr <= SCR1_HDU_PBUFSTATE_IDLE;\n    end else if(clk_en) begin\n        pbuf_fsm_curr <= pbuf_fsm_next;\n    end\nend\n\nalways_comb begin\n    case (pbuf_fsm_curr)\n        SCR1_HDU_PBUFSTATE_IDLE: begin\n            pbuf_fsm_next = pbuf_start_fetch       ? SCR1_HDU_PBUFSTATE_FETCH\n                                                   : SCR1_HDU_PBUFSTATE_IDLE;\n        end\n        SCR1_HDU_PBUFSTATE_FETCH: begin\n            pbuf_fsm_next = pipe2hdu_exu_exc_req_i ? SCR1_HDU_PBUFSTATE_WAIT4END\n                          : pbuf_exc_inj_req       ? SCR1_HDU_PBUFSTATE_EXCINJECT\n                                                   : SCR1_HDU_PBUFSTATE_FETCH;\n        end\n        SCR1_HDU_PBUFSTATE_EXCINJECT: begin\n            pbuf_fsm_next = pbuf_exc_inj_end       ? SCR1_HDU_PBUFSTATE_WAIT4END\n                                                   : SCR1_HDU_PBUFSTATE_EXCINJECT;\n        end\n        SCR1_HDU_PBUFSTATE_WAIT4END: begin\n            pbuf_fsm_next = hdu2exu_dbg_halted_o   ? SCR1_HDU_PBUFSTATE_IDLE\n                                                   : SCR1_HDU_PBUFSTATE_WAIT4END;\n        end\n    endcase\nend\n\nassign pbuf_fsm_idle   = (pbuf_fsm_curr == SCR1_HDU_PBUFSTATE_IDLE);\nassign pbuf_fsm_fetch  = (pbuf_fsm_curr == SCR1_HDU_PBUFSTATE_FETCH);\nassign pbuf_fsm_excinj = (pbuf_fsm_curr == SCR1_HDU_PBUFSTATE_EXCINJECT);\n\n// Program Buffer address register\n//------------------------------------------------------------------------------\n\nassign pbuf_addr_next_vd = pbuf_fsm_fetch          & ifu_handshake_done\n                         & ~pipe2hdu_exu_exc_req_i & ~pbuf_addr_end;\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        pbuf_addr_ff <= '0;\n    end else if(clk_en) begin\n        pbuf_addr_ff <= pbuf_addr_next;\n    end\nend\n\nassign pbuf_addr_next = pbuf_fsm_idle     ? '0\n                      : pbuf_addr_next_vd ? pbuf_addr_ff + 1'b1\n                                          : pbuf_addr_ff;\n\n// Pass instruction from debug program buffer to cpu pipeline with two options:\n// - through register, better for frequency\n// - through wires, better for area\ngenerate if (HART_PBUF_INSTR_REGOUT_EN) begin\n    always_ff @(posedge clk, negedge rst_n) begin\n        if (~rst_n) begin\n            pbuf_instr_wait_latching <= 1'b0;\n        end else begin\n            pbuf_instr_wait_latching <= ifu_handshake_done;\n        end\n    end\nend else begin\n    assign pbuf_instr_wait_latching = 1'b0;\nend endgenerate\n\n//------------------------------------------------------------------------------\n// Debug CSRs\n//------------------------------------------------------------------------------\n\nassign csr_upd_on_halt = (dbg_state_reset | dbg_state_run)\n                       & (dbg_state_next == SCR1_HDU_DBGSTATE_DHALTED);\n\n// CSRs select logic\n//------------------------------------------------------------------------------\n\nalways_comb begin : csr_if_regsel\n    csr_dcsr_sel        = 1'b0;\n    csr_dpc_sel         = 1'b0;\n    csr_dscratch0_sel   = 1'b0;\n    //csr_dscratch1_sel   = 1'b0;\n\n    if (csr2hdu_req_i) begin\n        case (csr2hdu_addr_i)\n            SCR1_HDU_DBGCSR_OFFS_DCSR     : csr_dcsr_sel      = 1'b1;\n            SCR1_HDU_DBGCSR_OFFS_DPC      : csr_dpc_sel       = 1'b1;\n            SCR1_HDU_DBGCSR_OFFS_DSCRATCH0: csr_dscratch0_sel = 1'b1;\n            default : begin\n                                            csr_dcsr_sel      = 1'bX;\n                                            csr_dpc_sel       = 1'bX;\n                                            csr_dscratch0_sel = 1'bX;\n            end\n        endcase\n    end\nend : csr_if_regsel\n\n// CSRs read interface\n//------------------------------------------------------------------------------\n\nassign csr_rd_data = csr_dcsr_out | csr_dpc_out | csr_dscratch0_out;\n\n// CSRs write interface\n//------------------------------------------------------------------------------\n\nassign csr_wr = csr2hdu_req_i;\n\nalways_comb begin : csr_if_write\n    csr_wr_data     = '0;\n\n    if (csr2hdu_req_i) begin\n        case (csr2hdu_cmd_i)\n            SCR1_CSR_CMD_WRITE : csr_wr_data = csr2hdu_wdata_i;\n            SCR1_CSR_CMD_SET   : csr_wr_data = csr_rd_data | csr2hdu_wdata_i;\n            SCR1_CSR_CMD_CLEAR : csr_wr_data = csr_rd_data & (~csr2hdu_wdata_i);\n            default            : csr_wr_data = 'X;\n        endcase\n    end\nend : csr_if_write\n\n// Debug Control and Status register\n//------------------------------------------------------------------------------\n// Setups the HART behaviour in Debug Mode and holds Debug status information\n\nalways_comb begin\n    csr_dcsr_in                 = csr_wr_data;\n    csr_dcsr_wr                 = csr_wr & csr_dcsr_sel;\n\n    csr_dcsr_out                = '0;\n    if (csr_dcsr_sel) begin\n        csr_dcsr_out.xdebugver  = SCR1_HDU_DEBUGCSR_DCSR_XDEBUGVER;\n        csr_dcsr_out.ebreakm    = csr_dcsr_ebreakm;\n        csr_dcsr_out.stepie     = csr_dcsr_stepie;\n        csr_dcsr_out.step       = csr_dcsr_step;\n        csr_dcsr_out.prv        = 2'b11;\n        csr_dcsr_out.cause      = csr_dcsr_cause;\n    end\nend\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        csr_dcsr_ebreakm        <= 1'b0;\n        csr_dcsr_stepie         <= 1'b0;\n        csr_dcsr_step           <= 1'b0;\n    end else if(clk_en) begin\n        if (csr_dcsr_wr) begin\n            csr_dcsr_ebreakm    <= csr_dcsr_in.ebreakm;\n            csr_dcsr_stepie     <= csr_dcsr_in.stepie;\n            csr_dcsr_step       <= csr_dcsr_in.step;\n        end\n    end\nend\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        csr_dcsr_cause <= 1'b0;\n    end else if(clk_en) begin\n        if(csr_upd_on_halt) begin\n            csr_dcsr_cause <= hart_haltstatus.cause;\n        end\n    end\nend\n\n// Debug PC register\n//------------------------------------------------------------------------------\n// Saves the virtual address of the next instruction to be executed when Debug\n// Mode is entered. Could be changed by debugger\n\nassign csr_dpc_wr   = csr_wr & csr_dpc_sel;\n\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        csr_dpc_ff <= '0;\n    end else if(clk_en) begin\n        csr_dpc_ff <= csr_dpc_next;\n    end\nend\n\nassign csr_dpc_next = csr_upd_on_halt ? pipe2hdu_pc_curr_i\n                    : csr_dpc_wr      ? csr_wr_data\n                                      : csr_dpc_ff;\nassign csr_dpc_out  = csr_dpc_sel     ? csr_dpc_ff : '0;\n\n// Debug Scratch 0 register\n//------------------------------------------------------------------------------\n\nassign csr_dscratch0_resp = (~dm2hdu_dreg_resp_i | dm2hdu_dreg_fail_i)\n                          ? SCR1_CSR_RESP_ER\n                          : SCR1_CSR_RESP_OK;\nassign csr_dscratch0_out  = csr_dscratch0_sel ? dm2hdu_dreg_rdata_i : '0;\n\n//------------------------------------------------------------------------------\n// HDU <-> DM interface\n//------------------------------------------------------------------------------\n\nassign hdu2dm_hart_event_o = dfsm_event;\n\n// HART status\nalways_comb begin\n    hdu2dm_hart_status_o           = '0;\n    hdu2dm_hart_status_o.dbg_state = dbg_state;\n    hdu2dm_hart_status_o.except    = dbg_state_dhalted & hart_haltstatus.except;\n    hdu2dm_hart_status_o.ebreak    = dbg_state_dhalted & (hart_haltstatus.cause == SCR1_HDU_HALTCAUSE_EBREAK);\nend\n\nassign hdu2dm_cmd_rcode_o = dbg_state_reset\n                          ? ~pipe2hdu_rdc_qlfy_i | ~pipe2hdu_init_pc_i | ~dm2hdu_cmd_req_i\n                          : ~pipe2hdu_rdc_qlfy_i | ~dfsm_update;\n\nalways_comb begin\n    hdu2dm_cmd_resp_o   = 1'b0;\n\n    case (dbg_state)\n        SCR1_HDU_DBGSTATE_RESET: begin\n            hdu2dm_cmd_resp_o  = pipe2hdu_rdc_qlfy_i & pipe2hdu_init_pc_i & dm2hdu_cmd_req_i;\n        end\n\n        SCR1_HDU_DBGSTATE_RUN: begin\n            hdu2dm_cmd_resp_o  = pipe2hdu_rdc_qlfy_i & dfsm_update & dm2hdu_cmd_req_i;\n        end\n\n        SCR1_HDU_DBGSTATE_DHALTED: begin\n            hdu2dm_cmd_resp_o  = pipe2hdu_rdc_qlfy_i ? dfsm_update : dm2hdu_cmd_req_i;\n        end\n\n        SCR1_HDU_DBGSTATE_DRUN: begin\n            hdu2dm_cmd_resp_o  = (~pipe2hdu_rdc_qlfy_i | dfsm_update) & dm2hdu_cmd_req_i;\n        end\n\n        default: begin\n            hdu2dm_cmd_resp_o  = 'X;\n        end\n    endcase\nend\n\nassign hdu2dm_pbuf_addr_o  = pbuf_addr_ff;\nassign hdu2dm_dreg_req_o   = csr_dscratch0_sel;\nassign hdu2dm_dreg_wr_o    = csr_wr & csr_dscratch0_sel;\nassign hdu2dm_dreg_wdata_o = csr_wr_data;\n\n//------------------------------------------------------------------------------\n// HDU <-> EXU interface\n//------------------------------------------------------------------------------\n\nassign hdu2exu_dbg_halted_o    = (dbg_state_next == SCR1_HDU_DBGSTATE_DHALTED)\n                               | (~pipe2hdu_rdc_qlfy_i & ~dbg_state_run);\nassign hdu2exu_dbg_run_start_o = dbg_state_dhalted & pipe2hdu_rdc_qlfy_i & dfsm_update;\nassign hdu2exu_dbg_halt2run_o  = hdu2exu_dbg_halted_o & hart_resume_req\n`ifdef SCR1_CLKCTRL_EN\n                               & clk_pipe_en\n`endif // SCR1_CLKCTRL_EN\n                               ;\nassign hdu2exu_dbg_run2halt_o  = hart_halt_ack;\n\nassign hdu2exu_pbuf_fetch_o    = hart_runctrl.fetch_src;\nassign hdu2exu_irq_dsbl_o      = hart_runctrl.irq_dsbl;\nassign hdu2exu_pc_advmt_dsbl_o = hart_runctrl.pc_advmt_dsbl;\n// No change in arch. state if dmode caused by breakpoint\nassign hdu2exu_no_commit_o     = dmode_cause_ebreak\n`ifdef SCR1_TDU_EN\n                               | dmode_cause_tmreq\n`endif // SCR1_TDU_EN\n                               ;\nassign hdu2exu_dmode_sstep_en_o = hart_runctrl.redirect.sstep;\nassign hdu2exu_dbg_new_pc_o     = csr_dpc_ff;\n\n//------------------------------------------------------------------------------\n// HDU <-> IFU interface\n//------------------------------------------------------------------------------\n\nassign hdu2ifu_pbuf_instr_vd_o  = (pbuf_fsm_fetch | pbuf_fsm_excinj)\n                                & ~pbuf_instr_wait_latching;\nassign hdu2ifu_pbuf_instr_err_o = pbuf_fsm_excinj;\n\ngenerate if (HART_PBUF_INSTR_REGOUT_EN) begin\n    always_ff @(posedge clk) begin\n        hdu2ifu_pbuf_instr_o <= dm2hdu_pbuf_instr_i;\n    end\nend else begin\n    assign hdu2ifu_pbuf_instr_o = dm2hdu_pbuf_instr_i;\nend endgenerate\n\n//------------------------------------------------------------------------------\n// HDU <-> CSR interface\n//------------------------------------------------------------------------------\n\nassign csr_addr_dscratch0 = (csr2hdu_addr_i == SCR1_HDU_DBGCSR_OFFS_DSCRATCH0);\n\nassign hdu2csr_resp_o  = ~dbg_state_drun    ? SCR1_CSR_RESP_ER\n                       : csr_addr_dscratch0 ? csr_dscratch0_resp\n                       : csr2hdu_req_i      ? SCR1_CSR_RESP_OK\n                                            : SCR1_CSR_RESP_ER;\nassign hdu2csr_rdata_o = csr_rd_data;\n\n`ifdef SCR1_TDU_EN\n//------------------------------------------------------------------------------\n// HDU <-> TDU interface\n//------------------------------------------------------------------------------\n\nassign hdu2tdu_hwbrk_dsbl_o = hart_runctrl.hwbrkpt_dsbl;\n`endif // SCR1_TDU_EN\n\n`ifdef SCR1_TRGT_SIMULATION\n//-------------------------------------------------------------------------------\n// Assertion\n//-------------------------------------------------------------------------------\n\nSVA_HDU_XCHECK_COMMON :\n    assert property (\n        @(negedge clk) disable iff (~rst_n)\n        !$isunknown( {rst_n,clk,clk_en,csr2hdu_req_i,pipe2hdu_rdc_qlfy_i} )\n    )\n    else $error(\"HDU Error: common signals are in X state\");\n\nSVA_HDU_XCHECK_CSR_INTF :\n    assert property (\n        @(negedge clk) disable iff (~rst_n)\n        csr2hdu_req_i |-> !$isunknown( {csr2hdu_cmd_i,csr2hdu_addr_i,csr2hdu_wdata_i} )\n    )\n    else $error(\"HDU Error: CSR i/f is in X state\");\n\nSVA_HDU_XCHECK_DM_INTF :\n    assert property (\n        @(negedge clk) disable iff (~rst_n)\n        !$isunknown( {dm2hdu_cmd_req_i,dm2hdu_cmd_i,dm2hdu_dreg_resp_i,\n        dm2hdu_dreg_fail_i} )\n    )\n    else $error(\"HDU Error: DM i/f is in X state\");\n\nSVA_HDU_XCHECK_TDU_INTF :\n    assert property (\n        @(negedge clk) disable iff (~rst_n)\n        !$isunknown( {tdu2hdu_dmode_req_i,exu2hdu_ibrkpt_hw_i} )\n    )\n    else $error(\"HDU Error: TDU i/f is in X state\");\n\nSVA_HDU_XCHECK_HART_INTF :\n    assert property (\n        @(negedge clk) disable iff (~rst_n)\n        !$isunknown( {pipe2hdu_exu_busy_i,pipe2hdu_instret_i,pipe2hdu_init_pc_i,pipe2hdu_exu_exc_req_i,pipe2hdu_brkpt_i,\n        pipe2hdu_pc_curr_i,ifu2hdu_pbuf_instr_rdy_i} )\n    )\n    else $error(\"HDU Error: HART i/f is in X state\");\n\n`endif // SCR1_TRGT_SIMULATION\n\nendmodule : scr1_pipe_hdu\n\n`endif // SCR1_DBG_EN\n"}
{"text": "/// Copyright by Syntacore LLC \u00a9 2016-2021. See LICENSE for details\n/// @file       <scr1_pipe_ialu.sv>\n/// @brief      Integer Arithmetic Logic Unit (IALU)\n///\n\n//-------------------------------------------------------------------------------\n //\n // Functionality:\n // - Performs addition/subtraction and arithmetic and branch comparisons\n // - Performs logical operations (AND(I), OR(I), XOR(I))\n // - Performs address calculation for branch, jump, DMEM load and store and AUIPC\n //   instructions\n // - Performs shift operations\n // - Performs MUL/DIV operations\n //\n // Structure:\n // - Main adder\n // - Address adder\n // - Shift logic\n // - MUL/DIV logic\n // - Output result multiplexer\n //\n//-------------------------------------------------------------------------------\n\n`include \"scr1_arch_description.svh\"\n`include \"scr1_riscv_isa_decoding.svh\"\n`include \"scr1_search_ms1.svh\"\n\n\nmodule scr1_pipe_ialu (\n`ifdef SCR1_RVM_EXT\n    // Common\n    input   logic                           clk,                        // IALU clock\n    input   logic                           rst_n,                      // IALU reset\n    input   logic                           exu2ialu_rvm_cmd_vd_i,      // MUL/DIV command valid\n    output  logic                           ialu2exu_rvm_res_rdy_o,     // MUL/DIV result ready\n`endif // SCR1_RVM_EXT\n\n    // Main adder\n    input   logic [`SCR1_XLEN-1:0]          exu2ialu_main_op1_i,        // main ALU 1st operand\n    input   logic [`SCR1_XLEN-1:0]          exu2ialu_main_op2_i,        // main ALU 2nd operand\n    input   type_scr1_ialu_cmd_sel_e        exu2ialu_cmd_i,             // IALU command\n    output  logic [`SCR1_XLEN-1:0]          ialu2exu_main_res_o,        // main ALU result\n    output  logic                           ialu2exu_cmp_res_o,         // IALU comparison result\n\n    // Address adder\n    input   logic [`SCR1_XLEN-1:0]          exu2ialu_addr_op1_i,        // Address adder 1st operand\n    input   logic [`SCR1_XLEN-1:0]          exu2ialu_addr_op2_i,        // Address adder 2nd operand\n    output  logic [`SCR1_XLEN-1:0]          ialu2exu_addr_res_o         // Address adder result\n);\n\n//-------------------------------------------------------------------------------\n// Local parameters declaration\n//-------------------------------------------------------------------------------\n\n`ifdef SCR1_RVM_EXT\n `ifdef SCR1_FAST_MUL\nlocalparam SCR1_MUL_WIDTH     = `SCR1_XLEN;\nlocalparam SCR1_MUL_RES_WIDTH = 2 * `SCR1_XLEN;\nlocalparam SCR1_MDU_SUM_WIDTH = `SCR1_XLEN + 1;\n `else\nlocalparam SCR1_MUL_STG_NUM   = 32;\nlocalparam SCR1_MUL_WIDTH     = 32 / SCR1_MUL_STG_NUM;\nlocalparam SCR1_MUL_CNT_INIT  = 32'b1 << (`SCR1_XLEN/SCR1_MUL_WIDTH - 2);\nlocalparam SCR1_MDU_SUM_WIDTH = `SCR1_XLEN + SCR1_MUL_WIDTH;\n `endif // ~SCR1_FAST_MUL\nlocalparam SCR1_DIV_WIDTH     = 1;\nlocalparam SCR1_DIV_CNT_INIT  = 32'b1 << (`SCR1_XLEN/SCR1_DIV_WIDTH - 2);\n`endif // SCR1_RVM_EXT\n\n//-------------------------------------------------------------------------------\n// Local types declaration\n//-------------------------------------------------------------------------------\n\ntypedef struct packed {\n    logic       z;      // Zero\n    logic       s;      // Sign\n    logic       o;      // Overflow\n    logic       c;      // Carry\n} type_scr1_ialu_flags_s;\n\n `ifdef SCR1_RVM_EXT\ntypedef enum logic [1:0] {\n    SCR1_IALU_MDU_FSM_IDLE,\n    SCR1_IALU_MDU_FSM_ITER,\n    SCR1_IALU_MDU_FSM_CORR\n} type_scr1_ialu_fsm_state;\n\ntypedef enum logic [1:0] {\n   SCR1_IALU_MDU_NONE,\n   SCR1_IALU_MDU_MUL,\n   SCR1_IALU_MDU_DIV\n} type_scr1_ialu_mdu_cmd;\n `endif // SCR1_RVM_EXT\n\n//-------------------------------------------------------------------------------\n// Local signals declaration\n//-------------------------------------------------------------------------------\n\n// Main adder signals\nlogic        [`SCR1_XLEN:0]                 main_sum_res;       // Main adder result\ntype_scr1_ialu_flags_s                      main_sum_flags;     // Main adder flags\nlogic                                       main_sum_pos_ovflw; // Main adder positive overflow\nlogic                                       main_sum_neg_ovflw; // Main adder negative overflow\nlogic                                       main_ops_diff_sgn;  // Main adder operands have different signs\nlogic                                       main_ops_non_zero;  // Both main adder operands are NOT 0\n\n// Shifter signals\nlogic                                       ialu_cmd_shft;      // IALU command is shift\nlogic signed [`SCR1_XLEN-1:0]               shft_op1;           // SHIFT operand 1\nlogic        [4:0]                          shft_op2;           // SHIFT operand 2\nlogic        [1:0]                          shft_cmd;           // SHIFT command: 00 - logical left, 10 - logical right, 11 - arithmetical right\nlogic        [`SCR1_XLEN-1:0]               shft_res;           // SHIFT result\n\n// MUL/DIV signals\n`ifdef SCR1_RVM_EXT\n// MUL/DIV FSM control signals\nlogic                                       mdu_cmd_is_iter;    // MDU Command is iterative\nlogic                                       mdu_iter_req;       // Request iterative stage\nlogic                                       mdu_iter_rdy;       // Iteration is ready\nlogic                                       mdu_corr_req;       // DIV/REM(U) correction request\nlogic                                       div_corr_req;       // Correction request for DIV operation\nlogic                                       rem_corr_req;       // Correction request for REM(U) operations\n\n// MUL/DIV FSM signals\ntype_scr1_ialu_fsm_state                    mdu_fsm_ff;         // Current FSM state\ntype_scr1_ialu_fsm_state                    mdu_fsm_next;       // Next FSM state\nlogic                                       mdu_fsm_idle;       // MDU FSM is in IDLE state\n`ifdef SCR1_TRGT_SIMULATION\nlogic                                       mdu_fsm_iter;       // MDU FSM is in ITER state\n`endif // SCR1_TRGT_SIMULATION\nlogic                                       mdu_fsm_corr;       // MDU FSM is in CORR state\n\n// MDU command signals\ntype_scr1_ialu_mdu_cmd                      mdu_cmd;            // MDU command: 00 - NONE, 01 - MUL,  10 - DIV\nlogic                                       mdu_cmd_mul;        // MDU command is MUL(HSU)\nlogic                                       mdu_cmd_div;        // MDU command is DIV(U)/REM(U)\nlogic        [1:0]                          mul_cmd;            // MUL command: 00 - MUL,  01 - MULH, 10 - MULHSU, 11 - MULHU\nlogic                                       mul_cmd_hi;         // High part of MUL result is requested\nlogic        [1:0]                          div_cmd;            // DIV command: 00 - DIV,  01 - DIVU, 10 - REM,    11 - REMU\nlogic                                       div_cmd_div;        // DIV command is DIV\nlogic                                       div_cmd_rem;        // DIV command is REM(U)\n\n// Multiplier signals\nlogic                                       mul_op1_is_sgn;     // First MUL operand is signed\nlogic                                       mul_op2_is_sgn;     // Second MUL operand is signed\nlogic                                       mul_op1_sgn;        // First MUL operand is negative\nlogic                                       mul_op2_sgn;        // Second MUL operand is negative\nlogic signed [`SCR1_XLEN:0]                 mul_op1;            // MUL operand 1\nlogic signed [SCR1_MUL_WIDTH:0]             mul_op2;            // MUL operand 1\n `ifdef SCR1_FAST_MUL\nlogic signed [SCR1_MUL_RES_WIDTH-1:0]       mul_res;            // MUL result\n `else // ~SCR1_FAST_MUL\nlogic signed [SCR1_MDU_SUM_WIDTH:0]         mul_part_prod;\nlogic        [`SCR1_XLEN-1:0]               mul_res_hi;\nlogic        [`SCR1_XLEN-1:0]               mul_res_lo;\n `endif // ~SCR1_FAST_MUL\n\n// Divisor signals\nlogic                                       div_ops_are_sgn;\nlogic                                       div_op1_is_neg;\nlogic                                       div_op2_is_neg;\nlogic                                       div_res_rem_c;\nlogic        [`SCR1_XLEN-1:0]               div_res_rem;\nlogic        [`SCR1_XLEN-1:0]               div_res_quo;\nlogic                                       div_quo_bit;\nlogic                                       div_dvdnd_lo_upd;\nlogic        [`SCR1_XLEN-1:0]               div_dvdnd_lo_ff;\nlogic        [`SCR1_XLEN-1:0]               div_dvdnd_lo_next;\n\n// MDU adder signals\nlogic                                       mdu_sum_sub;        // MDU adder operation: 0 - add, 1 - sub\nlogic signed [SCR1_MDU_SUM_WIDTH-1:0]       mdu_sum_op1;        // MDU adder operand 1\nlogic signed [SCR1_MDU_SUM_WIDTH-1:0]       mdu_sum_op2;        // MDU adder operand 2\nlogic signed [SCR1_MDU_SUM_WIDTH-1:0]       mdu_sum_res;        // MDU adder result\n\n// MDU iteration counter signals\nlogic                                       mdu_iter_cnt_en;\nlogic        [`SCR1_XLEN-1:0]               mdu_iter_cnt;\nlogic        [`SCR1_XLEN-1:0]               mdu_iter_cnt_next;\n\n// Intermediate results registers\nlogic                                       mdu_res_upd;\nlogic                                       mdu_res_c_ff;\nlogic                                       mdu_res_c_next;\nlogic        [`SCR1_XLEN-1:0]               mdu_res_hi_ff;\nlogic        [`SCR1_XLEN-1:0]               mdu_res_hi_next;\nlogic        [`SCR1_XLEN-1:0]               mdu_res_lo_ff;\nlogic        [`SCR1_XLEN-1:0]               mdu_res_lo_next;\n`endif // SCR1_RVM_EXT\n\n//-------------------------------------------------------------------------------\n// Main adder\n//-------------------------------------------------------------------------------\n//\n // Main adder is used for the following types of operations:\n // - Addition/subtraction          (ADD/ADDI/SUB)\n // - Branch comparisons            (BEQ/BNE/BLT(U)/BGE(U))\n // - Arithmetic comparisons        (SLT(U)/SLTI(U))\n//\n\n// Carry out (MSB of main_sum_res) is evaluated correctly because the result\n// width equals to the maximum width of both the right-hand and left-hand side variables\nalways_comb begin\n    main_sum_res = (exu2ialu_cmd_i != SCR1_IALU_CMD_ADD)\n                 ? ({1'b0, exu2ialu_main_op1_i} - {1'b0, exu2ialu_main_op2_i})   // Subtraction and comparison\n                 : ({1'b0, exu2ialu_main_op1_i} + {1'b0, exu2ialu_main_op2_i});  // Addition\n\n    main_sum_pos_ovflw = ~exu2ialu_main_op1_i[`SCR1_XLEN-1]\n                       &  exu2ialu_main_op2_i[`SCR1_XLEN-1]\n                       &  main_sum_res[`SCR1_XLEN-1];\n    main_sum_neg_ovflw =  exu2ialu_main_op1_i[`SCR1_XLEN-1]\n                       & ~exu2ialu_main_op2_i[`SCR1_XLEN-1]\n                       & ~main_sum_res[`SCR1_XLEN-1];\n\n    // FLAGS1 - flags for comparison (result of subtraction)\n    main_sum_flags.c = main_sum_res[`SCR1_XLEN];\n    main_sum_flags.z = ~|main_sum_res[`SCR1_XLEN-1:0];\n    main_sum_flags.s = main_sum_res[`SCR1_XLEN-1];\n    main_sum_flags.o = main_sum_pos_ovflw | main_sum_neg_ovflw;\nend\n\n//-------------------------------------------------------------------------------\n// Address adder\n//-------------------------------------------------------------------------------\n//\n // Additional adder is used for the following types of operations:\n // - PC-based address calculation          (AUIPC)\n // - IMEM branch address calculation       (BEQ/BNE/BLT(U)/BGE(U))\n // - IMEM jump address calculation         (JAL/JALR)\n // - DMEM load address calculation         (LB(U)/LH(U)/LW)\n // - DMEM store address calculation        (SB/SH/SW)\n//\n\nassign ialu2exu_addr_res_o = exu2ialu_addr_op1_i + exu2ialu_addr_op2_i;\n\n//-------------------------------------------------------------------------------\n// Shift logic\n//-------------------------------------------------------------------------------\n //\n // Shift logic supports the following types of shift operations:\n // - Logical left shift      (SLLI/SLL)\n // - Logical right shift     (SRLI/SRL)\n // - Arithmetic right shift  (SRAI/SRA)\n//\n\nassign ialu_cmd_shft = (exu2ialu_cmd_i == SCR1_IALU_CMD_SLL)\n                     | (exu2ialu_cmd_i == SCR1_IALU_CMD_SRL)\n                     | (exu2ialu_cmd_i == SCR1_IALU_CMD_SRA);\nassign shft_cmd      = ialu_cmd_shft\n                     ? {(exu2ialu_cmd_i != SCR1_IALU_CMD_SLL),\n                        (exu2ialu_cmd_i == SCR1_IALU_CMD_SRA)}\n                     : 2'b00;\n\nalways_comb begin\n    shft_op1 = exu2ialu_main_op1_i;\n    shft_op2 = exu2ialu_main_op2_i[4:0];\n    case (shft_cmd)\n        2'b10   : shft_res = shft_op1  >> shft_op2;\n        2'b11   : shft_res = shft_op1 >>> shft_op2;\n        default : shft_res = shft_op1  << shft_op2;\n    endcase\nend\n\n`ifdef SCR1_RVM_EXT\n//-------------------------------------------------------------------------------\n// MUL/DIV logic\n//-------------------------------------------------------------------------------\n//\n // MUL/DIV instructions use the following functional units:\n // - MUL/DIV FSM control logic, including iteration number counter\n // - MUL/DIV FSM\n // - MUL logic\n // - DIV logic\n // - MDU adder to produce an intermediate result\n // - 2 registers to save the intermediate result (shared between MUL and DIV\n //   operations)\n//\n\n//-------------------------------------------------------------------------------\n// MUL/DIV FSM Control logic\n//-------------------------------------------------------------------------------\n\nassign mdu_cmd_div = (exu2ialu_cmd_i == SCR1_IALU_CMD_DIV)\n                   | (exu2ialu_cmd_i == SCR1_IALU_CMD_DIVU)\n                   | (exu2ialu_cmd_i == SCR1_IALU_CMD_REM)\n                   | (exu2ialu_cmd_i == SCR1_IALU_CMD_REMU);\nassign mdu_cmd_mul = (exu2ialu_cmd_i == SCR1_IALU_CMD_MUL)\n                   | (exu2ialu_cmd_i == SCR1_IALU_CMD_MULH)\n                   | (exu2ialu_cmd_i == SCR1_IALU_CMD_MULHU)\n                   | (exu2ialu_cmd_i == SCR1_IALU_CMD_MULHSU);\n\nassign mdu_cmd     = mdu_cmd_div ? SCR1_IALU_MDU_DIV\n                   : mdu_cmd_mul ? SCR1_IALU_MDU_MUL\n                                 : SCR1_IALU_MDU_NONE;\n\nassign main_ops_non_zero = |exu2ialu_main_op1_i & |exu2ialu_main_op2_i;\nassign main_ops_diff_sgn = exu2ialu_main_op1_i[`SCR1_XLEN-1]\n                         ^ exu2ialu_main_op2_i[`SCR1_XLEN-1];\n\n `ifdef SCR1_FAST_MUL\n    assign mdu_cmd_is_iter = mdu_cmd_div;\n `else // ~SCR1_FAST_MUL\n    assign mdu_cmd_is_iter = mdu_cmd_mul | mdu_cmd_div;\n `endif // ~SCR1_FAST_MUL\n\nassign mdu_iter_req = mdu_cmd_is_iter ? (main_ops_non_zero & mdu_fsm_idle) : 1'b0;\nassign mdu_iter_rdy = mdu_iter_cnt[0];\n\nassign div_cmd_div = (div_cmd == 2'b00);\nassign div_cmd_rem = div_cmd[1];\n\n// Correction request signals\nassign div_corr_req = div_cmd_div & main_ops_diff_sgn;\nassign rem_corr_req = div_cmd_rem & |div_res_rem & (div_op1_is_neg ^ div_res_rem_c);\nassign mdu_corr_req = mdu_cmd_div & (div_corr_req | rem_corr_req);\n\n// MDU iteration counter\n//------------------------------------------------------------------------------\n\nassign mdu_iter_cnt_en = exu2ialu_rvm_cmd_vd_i & ~ialu2exu_rvm_res_rdy_o;\n\nalways_ff @(posedge clk) begin\n    if (mdu_iter_cnt_en) begin\n        mdu_iter_cnt <= mdu_iter_cnt_next;\n    end\nend\n\nassign mdu_iter_cnt_next = ~mdu_fsm_idle ? mdu_iter_cnt >> 1\n                         : mdu_cmd_div   ? SCR1_DIV_CNT_INIT\n `ifndef SCR1_FAST_MUL\n                         : mdu_cmd_mul   ? SCR1_MUL_CNT_INIT\n `endif // ~SCR1_FAST_MUL\n                                         : mdu_iter_cnt;\n\n//-------------------------------------------------------------------------------\n// MUL/DIV FSM\n//-------------------------------------------------------------------------------\n\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        mdu_fsm_ff <= SCR1_IALU_MDU_FSM_IDLE;\n    end else begin\n        mdu_fsm_ff <= mdu_fsm_next;\n    end\nend\n\nalways_comb begin\n    mdu_fsm_next = SCR1_IALU_MDU_FSM_IDLE;\n\n    if (exu2ialu_rvm_cmd_vd_i) begin\n        case (mdu_fsm_ff)\n            SCR1_IALU_MDU_FSM_IDLE : begin\n                mdu_fsm_next = mdu_iter_req  ? SCR1_IALU_MDU_FSM_ITER\n                                             : SCR1_IALU_MDU_FSM_IDLE;\n            end\n            SCR1_IALU_MDU_FSM_ITER : begin\n                mdu_fsm_next = ~mdu_iter_rdy ? SCR1_IALU_MDU_FSM_ITER\n                             : mdu_corr_req  ? SCR1_IALU_MDU_FSM_CORR\n                                             : SCR1_IALU_MDU_FSM_IDLE;\n            end\n            SCR1_IALU_MDU_FSM_CORR : begin\n                mdu_fsm_next = SCR1_IALU_MDU_FSM_IDLE;\n            end\n        endcase\n    end\nend\n\nassign mdu_fsm_idle = (mdu_fsm_ff == SCR1_IALU_MDU_FSM_IDLE);\n`ifdef SCR1_TRGT_SIMULATION\nassign mdu_fsm_iter = (mdu_fsm_ff == SCR1_IALU_MDU_FSM_ITER);\n`endif // SCR1_TRGT_SIMULATION\nassign mdu_fsm_corr = (mdu_fsm_ff == SCR1_IALU_MDU_FSM_CORR);\n\n//-------------------------------------------------------------------------------\n// Multiplier logic\n//-------------------------------------------------------------------------------\n//\n // Multiplication has 2 options: fast (1 cycle) and Radix-2 (32 cycles) multiplication.\n //\n // 1. Fast multiplication uses the straightforward approach when 2 operands are\n // multiplied in one cycle\n //\n // 2. Radix-2 multiplication uses 2 registers (high and low part of multiplication)\n //\n // Radix-2 algorithm:\n // 1. Initialize registers\n // 2. Create a partial product by multiplying multiplicand by the LSB of multiplier\n // 3. Add the partial product to the previous (intermediate) value of multiplication\n //    result (stored into high and low parts of multiplication result register)\n // 4. Shift the low part of multiplication result register right\n // 4. Store the addition result into the high part of multiplication result register\n // 6. If iteration is not ready, go to step 2. Otherwise multiplication is done\n //\n//\n\nassign mul_cmd  = {((exu2ialu_cmd_i == SCR1_IALU_CMD_MULHU) | (exu2ialu_cmd_i == SCR1_IALU_CMD_MULHSU)),\n                   ((exu2ialu_cmd_i == SCR1_IALU_CMD_MULHU) | (exu2ialu_cmd_i == SCR1_IALU_CMD_MULH))};\n\nassign mul_cmd_hi     = |mul_cmd;\nassign mul_op1_is_sgn = ~&mul_cmd;\nassign mul_op2_is_sgn = ~mul_cmd[1];\nassign mul_op1_sgn    = mul_op1_is_sgn & exu2ialu_main_op1_i[`SCR1_XLEN-1];\nassign mul_op2_sgn    = mul_op2_is_sgn & exu2ialu_main_op2_i[`SCR1_XLEN-1];\n\n`ifdef SCR1_FAST_MUL\nassign mul_op1 = mdu_cmd_mul ? $signed({mul_op1_sgn, exu2ialu_main_op1_i}) : '0;\nassign mul_op2 = mdu_cmd_mul ? $signed({mul_op2_sgn, exu2ialu_main_op2_i}) : '0;\nassign mul_res = mdu_cmd_mul ? mul_op1 * mul_op2                           : $signed('0);\n`else // ~SCR1_FAST_MUL\nassign mul_op1 = mdu_cmd_mul  ? $signed({mul_op1_sgn, exu2ialu_main_op1_i}) : '0;\nassign mul_op2 = ~mdu_cmd_mul ? '0\n               : mdu_fsm_idle ? $signed({1'b0, exu2ialu_main_op2_i[SCR1_MUL_WIDTH-1:0]})\n                              : $signed({(mdu_iter_cnt[0] & mul_op2_is_sgn & mdu_res_lo_ff[SCR1_MUL_WIDTH-1]),\n                                          mdu_res_lo_ff[SCR1_MUL_WIDTH-1:0]});\n\nassign mul_part_prod            = mdu_cmd_mul  ? mul_op1 * mul_op2 : $signed('0);\nassign {mul_res_hi, mul_res_lo} = ~mdu_cmd_mul ? '0\n                                : mdu_fsm_idle ? ({mdu_sum_res, exu2ialu_main_op2_i[`SCR1_XLEN-1:SCR1_MUL_WIDTH]})\n                                               : ({mdu_sum_res, mdu_res_lo_ff[`SCR1_XLEN-1:SCR1_MUL_WIDTH]});\n`endif // ~SCR1_FAST_MUL\n\n//-------------------------------------------------------------------------------\n// Divider logic\n//-------------------------------------------------------------------------------\n//\n // Division uses a non-restoring algorithm. 3 registers are used:\n // - Remainder register\n // - Quotient register\n // - Dividend low part register (for corner case quotient bit calculation)\n //\n // Algorithm:\n // 1. Initialize registers\n // 2. Shift remainder and dividend low part registers left\n // 3. Compare remainder register with the divisor (taking previous quotient bit\n //    and operands signs into account) and calculate quotient bit based on the\n //    comparison re"}
{"text": "sults\n // 4. Shift quotient register left, append quotient bit to the quotient register\n // 5. If iteration is not ready, go to step 2. Otherwise go to step 6\n // 6. Do correction if necessary, otherwise division is done\n //\n // Quotient bit calculation has a corner case:\n // When dividend is negative result carry bit check takes into account only\n // the case of remainder register been greater than divisor. To handle\n // equality case we should check if both the comparison result and the\n // lower part of dividend are zero\n//\n\nassign div_cmd  = {((exu2ialu_cmd_i == SCR1_IALU_CMD_REM)   | (exu2ialu_cmd_i == SCR1_IALU_CMD_REMU)),\n                   ((exu2ialu_cmd_i == SCR1_IALU_CMD_REMU)  | (exu2ialu_cmd_i == SCR1_IALU_CMD_DIVU))};\n\nassign div_ops_are_sgn = ~div_cmd[0];\nassign div_op1_is_neg  = div_ops_are_sgn & exu2ialu_main_op1_i[`SCR1_XLEN-1];\nassign div_op2_is_neg  = div_ops_are_sgn & exu2ialu_main_op2_i[`SCR1_XLEN-1];\n\nalways_comb begin\n    div_res_rem_c = '0;\n    div_res_rem   = '0;\n    div_res_quo   = '0;\n    div_quo_bit   = 1'b0;\n    if (mdu_cmd_div & ~mdu_fsm_corr) begin\n        div_res_rem_c = mdu_sum_res[SCR1_MDU_SUM_WIDTH-1];\n        div_res_rem   = mdu_sum_res[SCR1_MDU_SUM_WIDTH-2:0];\n        div_quo_bit   = ~(div_op1_is_neg ^ div_res_rem_c)\n                      | (div_op1_is_neg & ({mdu_sum_res, div_dvdnd_lo_next} == '0));\n        div_res_quo   = mdu_fsm_idle\n                      ? {'0, div_quo_bit}\n                      : {mdu_res_lo_ff[`SCR1_XLEN-2:0], div_quo_bit};\n    end\nend\n\n// Dividend low part register\n//------------------------------------------------------------------------------\n\nassign div_dvdnd_lo_upd = exu2ialu_rvm_cmd_vd_i & ~ialu2exu_rvm_res_rdy_o;\n\nalways_ff @(posedge clk) begin\n    if (div_dvdnd_lo_upd) begin\n        div_dvdnd_lo_ff <= div_dvdnd_lo_next;\n    end\nend\n\nassign div_dvdnd_lo_next = (~mdu_cmd_div | mdu_fsm_corr) ? '0\n                         : mdu_fsm_idle                  ? exu2ialu_main_op1_i << 1\n                                                         : div_dvdnd_lo_ff     << 1;\n\n//-------------------------------------------------------------------------------\n// MDU adder\n//-------------------------------------------------------------------------------\n\nalways_comb begin\n    mdu_sum_sub    = 1'b0;\n    mdu_sum_op1    = '0;\n    mdu_sum_op2    = '0;\n    case (mdu_cmd)\n        SCR1_IALU_MDU_DIV : begin\n            logic           sgn;\n            logic           inv;\n\n            sgn         = mdu_fsm_corr ? div_op1_is_neg ^ mdu_res_c_ff\n                        : mdu_fsm_idle ? 1'b0\n                                       : ~mdu_res_lo_ff[0];\n            inv         = div_ops_are_sgn & main_ops_diff_sgn;\n            mdu_sum_sub = ~inv ^ sgn;\n            mdu_sum_op1 = mdu_fsm_corr ? $signed({1'b0, mdu_res_hi_ff})\n                        : mdu_fsm_idle ? $signed({div_op1_is_neg, exu2ialu_main_op1_i[`SCR1_XLEN-1]})\n                                       : $signed({mdu_res_hi_ff, div_dvdnd_lo_ff[`SCR1_XLEN-1]});\n            mdu_sum_op2 = $signed({div_op2_is_neg, exu2ialu_main_op2_i});\n        end\n`ifndef SCR1_FAST_MUL\n        SCR1_IALU_MDU_MUL : begin\n            mdu_sum_op1 = mdu_fsm_idle\n                        ? '0\n                        : $signed({(mul_op1_is_sgn & mdu_res_hi_ff[`SCR1_XLEN-1]), mdu_res_hi_ff});\n            mdu_sum_op2 = mul_part_prod;\n        end\n`endif // SCR1_FAST_MUL\n        default : begin end\n    endcase\n    mdu_sum_res = mdu_sum_sub\n                ? (mdu_sum_op1 - mdu_sum_op2)\n                : (mdu_sum_op1 + mdu_sum_op2);\nend\n\n//-------------------------------------------------------------------------------\n// MUL/DIV intermediate results registers\n//-------------------------------------------------------------------------------\n\nassign mdu_res_upd = exu2ialu_rvm_cmd_vd_i & ~ialu2exu_rvm_res_rdy_o;\n\nalways_ff @(posedge clk) begin\n    if (mdu_res_upd) begin\n        mdu_res_c_ff  <= mdu_res_c_next;\n        mdu_res_hi_ff <= mdu_res_hi_next;\n        mdu_res_lo_ff <= mdu_res_lo_next;\n    end\nend\n\nassign mdu_res_c_next  = mdu_cmd_div ? div_res_rem_c : mdu_res_c_ff;\nassign mdu_res_hi_next = mdu_cmd_div ? div_res_rem\n `ifndef SCR1_FAST_MUL\n                       : mdu_cmd_mul ? mul_res_hi\n `endif // SCR1_FAST_MUL\n                                     : mdu_res_hi_ff;\nassign mdu_res_lo_next = mdu_cmd_div ? div_res_quo\n `ifndef SCR1_FAST_MUL\n                       : mdu_cmd_mul ? mul_res_lo\n `endif // SCR1_FAST_MUL\n                                     : mdu_res_lo_ff;\n`endif // SCR1_RVM_EXT\n\n//-------------------------------------------------------------------------------\n// Operation result forming\n//-------------------------------------------------------------------------------\n\nalways_comb begin\n    ialu2exu_main_res_o    = '0;\n    ialu2exu_cmp_res_o     = 1'b0;\n`ifdef SCR1_RVM_EXT\n    ialu2exu_rvm_res_rdy_o = 1'b1;\n`endif // SCR1_RVM_EXT\n\n    case (exu2ialu_cmd_i)\n        SCR1_IALU_CMD_AND : begin\n            ialu2exu_main_res_o = exu2ialu_main_op1_i & exu2ialu_main_op2_i;\n        end\n        SCR1_IALU_CMD_OR : begin\n            ialu2exu_main_res_o = exu2ialu_main_op1_i | exu2ialu_main_op2_i;\n        end\n        SCR1_IALU_CMD_XOR : begin\n            ialu2exu_main_res_o = exu2ialu_main_op1_i ^ exu2ialu_main_op2_i;\n        end\n        SCR1_IALU_CMD_ADD : begin\n            ialu2exu_main_res_o = main_sum_res[`SCR1_XLEN-1:0];\n        end\n        SCR1_IALU_CMD_SUB : begin\n            ialu2exu_main_res_o = main_sum_res[`SCR1_XLEN-1:0];\n        end\n        SCR1_IALU_CMD_SUB_LT : begin\n            ialu2exu_main_res_o = `SCR1_XLEN'(main_sum_flags.s ^ main_sum_flags.o);\n            ialu2exu_cmp_res_o  = main_sum_flags.s ^ main_sum_flags.o;\n        end\n        SCR1_IALU_CMD_SUB_LTU : begin\n            ialu2exu_main_res_o = `SCR1_XLEN'(main_sum_flags.c);\n            ialu2exu_cmp_res_o  = main_sum_flags.c;\n        end\n        SCR1_IALU_CMD_SUB_EQ : begin\n            ialu2exu_main_res_o = `SCR1_XLEN'(main_sum_flags.z);\n            ialu2exu_cmp_res_o  = main_sum_flags.z;\n        end\n        SCR1_IALU_CMD_SUB_NE : begin\n            ialu2exu_main_res_o = `SCR1_XLEN'(~main_sum_flags.z);\n            ialu2exu_cmp_res_o  = ~main_sum_flags.z;\n        end\n        SCR1_IALU_CMD_SUB_GE : begin\n            ialu2exu_main_res_o = `SCR1_XLEN'(~(main_sum_flags.s ^ main_sum_flags.o));\n            ialu2exu_cmp_res_o  = ~(main_sum_flags.s ^ main_sum_flags.o);\n        end\n        SCR1_IALU_CMD_SUB_GEU : begin\n            ialu2exu_main_res_o = `SCR1_XLEN'(~main_sum_flags.c);\n            ialu2exu_cmp_res_o  = ~main_sum_flags.c;\n        end\n        SCR1_IALU_CMD_SLL,\n        SCR1_IALU_CMD_SRL,\n        SCR1_IALU_CMD_SRA: begin\n            ialu2exu_main_res_o = shft_res;\n        end\n`ifdef SCR1_RVM_EXT\n        SCR1_IALU_CMD_MUL,\n        SCR1_IALU_CMD_MULHU,\n        SCR1_IALU_CMD_MULHSU,\n        SCR1_IALU_CMD_MULH : begin\n `ifdef SCR1_FAST_MUL\n            ialu2exu_main_res_o = mul_cmd_hi\n                                ? mul_res[SCR1_MUL_RES_WIDTH-1:`SCR1_XLEN]\n                                : mul_res[`SCR1_XLEN-1:0];\n `else // ~SCR1_FAST_MUL\n            case (mdu_fsm_ff)\n                SCR1_IALU_MDU_FSM_IDLE : begin\n                    ialu2exu_main_res_o    = '0;\n                    ialu2exu_rvm_res_rdy_o = ~mdu_iter_req;\n                end\n                SCR1_IALU_MDU_FSM_ITER : begin\n                    ialu2exu_main_res_o    = mul_cmd_hi ? mul_res_hi : mul_res_lo;\n                    ialu2exu_rvm_res_rdy_o = mdu_iter_rdy;\n                end\n            endcase\n `endif // ~SCR1_FAST_MUL\n        end\n        SCR1_IALU_CMD_DIV,\n        SCR1_IALU_CMD_DIVU,\n        SCR1_IALU_CMD_REM,\n        SCR1_IALU_CMD_REMU : begin\n            case (mdu_fsm_ff)\n                SCR1_IALU_MDU_FSM_IDLE : begin\n                    ialu2exu_main_res_o    = (|exu2ialu_main_op2_i | div_cmd_rem)\n                                           ? exu2ialu_main_op1_i\n                                           : '1;\n                    ialu2exu_rvm_res_rdy_o = ~mdu_iter_req;\n                end\n                SCR1_IALU_MDU_FSM_ITER : begin\n                    ialu2exu_main_res_o    = div_cmd_rem ? div_res_rem : div_res_quo;\n                    ialu2exu_rvm_res_rdy_o = mdu_iter_rdy & ~mdu_corr_req;\n                end\n                SCR1_IALU_MDU_FSM_CORR : begin\n                    ialu2exu_main_res_o    = div_cmd_rem\n                                           ? mdu_sum_res[`SCR1_XLEN-1:0]\n                                           : -mdu_res_lo_ff[`SCR1_XLEN-1:0];\n                    ialu2exu_rvm_res_rdy_o = 1'b1;\n                end\n            endcase\n        end\n`endif // SCR1_RVM_EXT\n        default : begin end\n    endcase\nend\n\n\n`ifdef SCR1_TRGT_SIMULATION\n//-------------------------------------------------------------------------------\n// Assertion\n//-------------------------------------------------------------------------------\n\n`ifdef SCR1_RVM_EXT\n\n// X checks\n\nSCR1_SVA_IALU_XCHECK : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    !$isunknown({exu2ialu_rvm_cmd_vd_i, mdu_fsm_ff})\n    ) else $error(\"IALU Error: unknown values\");\n\nSCR1_SVA_IALU_XCHECK_QUEUE : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    exu2ialu_rvm_cmd_vd_i |->\n    !$isunknown({exu2ialu_main_op1_i, exu2ialu_main_op2_i, exu2ialu_cmd_i})\n    ) else $error(\"IALU Error: unknown values in queue\");\n\n// Behavior checks\n\nSCR1_SVA_IALU_ILL_STATE : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    $onehot0({~exu2ialu_rvm_cmd_vd_i, mdu_fsm_iter, mdu_fsm_corr})\n    ) else $error(\"IALU Error: illegal state\");\n\nSCR1_SVA_IALU_JUMP_FROM_IDLE : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    (mdu_fsm_idle & (~exu2ialu_rvm_cmd_vd_i | ~mdu_iter_req)) |=> mdu_fsm_idle\n    ) else $error(\"EXU Error: illegal jump from IDLE state\");\n\nSCR1_SVA_IALU_IDLE_TO_ITER : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    (mdu_fsm_idle & exu2ialu_rvm_cmd_vd_i & mdu_iter_req) |=> mdu_fsm_iter\n    ) else $error(\"EXU Error: illegal change state form IDLE to ITER\");\n\nSCR1_SVA_IALU_JUMP_FROM_ITER : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    (mdu_fsm_iter & ~mdu_iter_rdy) |=> mdu_fsm_iter\n    ) else $error(\"EXU Error: illegal jump from ITER state\");\n\nSCR1_SVA_IALU_ITER_TO_IDLE : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    (mdu_fsm_iter & mdu_iter_rdy & ~mdu_corr_req) |=> mdu_fsm_idle\n    ) else $error(\"EXU Error: illegal state change ITER to IDLE\");\n\nSCR1_SVA_IALU_ITER_TO_CORR : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    (mdu_fsm_iter & mdu_iter_rdy & mdu_corr_req) |=> mdu_fsm_corr\n    ) else $error(\"EXU Error: illegal state change ITER to CORR\");\n\nSCR1_SVA_IALU_CORR_TO_IDLE : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    mdu_fsm_corr |=> mdu_fsm_idle\n    ) else $error(\"EXU Error: illegal state stay in CORR\");\n\n`endif // SCR1_RVM_EXT\n\n`endif // SCR1_TRGT_SIMULATION\n\nendmodule : scr1_pipe_ialu\n"}
{"text": "/// Copyright by Syntacore LLC \u00a9 2016-2021. See LICENSE for details\n/// @file       <scr1_pipe_idu.sv>\n/// @brief      Instruction Decoder Unit (IDU)\n///\n\n//------------------------------------------------------------------------------\n //\n // Functionality:\n // - Decodes the instruction and creates the appropriate control signals for EXU\n //\n // Structure:\n // - Instruction decoder\n // - IDU <-> IFU i/f\n // - IDU <-> EXU i/f\n //\n//------------------------------------------------------------------------------\n\n`include \"scr1_memif.svh\"\n`include \"scr1_arch_types.svh\"\n`include \"scr1_riscv_isa_decoding.svh\"\n`include \"scr1_arch_description.svh\"\n\nmodule scr1_pipe_idu\n(\n`ifdef SCR1_TRGT_SIMULATION\n    input   logic                           rst_n,                  // IDU reset\n    input   logic                           clk,                    // IDU clock\n`endif // SCR1_TRGT_SIMULATION\n\n    // IFU <-> IDU interface\n    output  logic                           idu2ifu_rdy_o,          // IDU ready for new data\n    input   logic [`SCR1_IMEM_DWIDTH-1:0]   ifu2idu_instr_i,        // IFU instruction\n    input   logic                           ifu2idu_imem_err_i,     // Instruction access fault exception\n    input   logic                           ifu2idu_err_rvi_hi_i,   // 1 - imem fault when trying to fetch second half of an unaligned RVI instruction\n    input   logic                           ifu2idu_vd_i,           // IFU request\n\n    // IDU <-> EXU interface\n    output  logic                           idu2exu_req_o,          // IDU request\n    output  type_scr1_exu_cmd_s             idu2exu_cmd_o,          // IDU command\n    output  logic                           idu2exu_use_rs1_o,      // Instruction uses rs1\n    output  logic                           idu2exu_use_rs2_o,      // Instruction uses rs2\n`ifndef SCR1_NO_EXE_STAGE\n    output  logic                           idu2exu_use_rd_o,       // Instruction uses rd\n    output  logic                           idu2exu_use_imm_o,      // Instruction uses immediate\n`endif // SCR1_NO_EXE_STAGE\n    input   logic                           exu2idu_rdy_i           // EXU ready for new data\n);\n\n//-------------------------------------------------------------------------------\n// Local parameters declaration\n//-------------------------------------------------------------------------------\n\nlocalparam [SCR1_GPR_FIELD_WIDTH-1:0] SCR1_MPRF_ZERO_ADDR   = 5'd0;\nlocalparam [SCR1_GPR_FIELD_WIDTH-1:0] SCR1_MPRF_RA_ADDR     = 5'd1;\nlocalparam [SCR1_GPR_FIELD_WIDTH-1:0] SCR1_MPRF_SP_ADDR     = 5'd2;\n\n//-------------------------------------------------------------------------------\n// Local signals declaration\n//-------------------------------------------------------------------------------\n\nlogic [`SCR1_IMEM_DWIDTH-1:0]       instr;\ntype_scr1_instr_type_e              instr_type;\ntype_scr1_rvi_opcode_e              rvi_opcode;\nlogic                               rvi_illegal;\nlogic [2:0]                         funct3;\nlogic [6:0]                         funct7;\nlogic [11:0]                        funct12;\nlogic [4:0]                         shamt;\n`ifdef SCR1_RVC_EXT\nlogic                               rvc_illegal;\n`endif  // SCR1_RVC_EXT\n`ifdef SCR1_RVE_EXT\nlogic                               rve_illegal;\n`endif  // SCR1_RVE_EXT\n\n//-------------------------------------------------------------------------------\n// Instruction decoding\n//-------------------------------------------------------------------------------\n\nassign idu2ifu_rdy_o  = exu2idu_rdy_i;\nassign idu2exu_req_o  = ifu2idu_vd_i;\nassign instr          = ifu2idu_instr_i;\n\n// RVI / RVC\nassign instr_type   = type_scr1_instr_type_e'(instr[1:0]);\n\n// RVI / RVC fields\nassign rvi_opcode   = type_scr1_rvi_opcode_e'(instr[6:2]);                          // RVI\nassign funct3       = (instr_type == SCR1_INSTR_RVI) ? instr[14:12] : instr[15:13]; // RVI / RVC\nassign funct7       = instr[31:25];                                                 // RVI\nassign funct12      = instr[31:20];                                                 // RVI (SYSTEM)\nassign shamt        = instr[24:20];                                                 // RVI\n\n// RV32I(MC) decode\nalways_comb begin\n    // Defaults\n    idu2exu_cmd_o.instr_rvc   = 1'b0;\n    idu2exu_cmd_o.ialu_op     = SCR1_IALU_OP_REG_REG;\n    idu2exu_cmd_o.ialu_cmd    = SCR1_IALU_CMD_NONE;\n    idu2exu_cmd_o.sum2_op     = SCR1_SUM2_OP_PC_IMM;\n    idu2exu_cmd_o.lsu_cmd     = SCR1_LSU_CMD_NONE;\n    idu2exu_cmd_o.csr_op      = SCR1_CSR_OP_REG;\n    idu2exu_cmd_o.csr_cmd     = SCR1_CSR_CMD_NONE;\n    idu2exu_cmd_o.rd_wb_sel   = SCR1_RD_WB_NONE;\n    idu2exu_cmd_o.jump_req    = 1'b0;\n    idu2exu_cmd_o.branch_req  = 1'b0;\n    idu2exu_cmd_o.mret_req    = 1'b0;\n    idu2exu_cmd_o.fencei_req  = 1'b0;\n    idu2exu_cmd_o.wfi_req     = 1'b0;\n    idu2exu_cmd_o.rs1_addr    = '0;\n    idu2exu_cmd_o.rs2_addr    = '0;\n    idu2exu_cmd_o.rd_addr     = '0;\n    idu2exu_cmd_o.imm         = '0;\n    idu2exu_cmd_o.exc_req     = 1'b0;\n    idu2exu_cmd_o.exc_code    = SCR1_EXC_CODE_INSTR_MISALIGN;\n\n    // Clock gating\n    idu2exu_use_rs1_o         = 1'b0;\n    idu2exu_use_rs2_o         = 1'b0;\n`ifndef SCR1_NO_EXE_STAGE\n    idu2exu_use_rd_o          = 1'b0;\n    idu2exu_use_imm_o         = 1'b0;\n`endif // SCR1_NO_EXE_STAGE\n\n    rvi_illegal             = 1'b0;\n`ifdef SCR1_RVE_EXT\n    rve_illegal             = 1'b0;\n`endif  // SCR1_RVE_EXT\n`ifdef SCR1_RVC_EXT\n    rvc_illegal             = 1'b0;\n`endif  // SCR1_RVC_EXT\n\n    // Check for IMEM access fault\n    if (ifu2idu_imem_err_i) begin\n        idu2exu_cmd_o.exc_req     = 1'b1;\n        idu2exu_cmd_o.exc_code    = SCR1_EXC_CODE_INSTR_ACCESS_FAULT;\n        idu2exu_cmd_o.instr_rvc   = ifu2idu_err_rvi_hi_i;\n    end else begin  // no imem fault\n        case (instr_type)\n            SCR1_INSTR_RVI  : begin\n                idu2exu_cmd_o.rs1_addr    = instr[19:15];\n                idu2exu_cmd_o.rs2_addr    = instr[24:20];\n                idu2exu_cmd_o.rd_addr     = instr[11:7];\n                case (rvi_opcode)\n                    SCR1_OPCODE_AUIPC           : begin\n`ifndef SCR1_NO_EXE_STAGE\n                        idu2exu_use_rd_o          = 1'b1;\n                        idu2exu_use_imm_o         = 1'b1;\n`endif // SCR1_NO_EXE_STAGE\n                        idu2exu_cmd_o.sum2_op     = SCR1_SUM2_OP_PC_IMM;\n                        idu2exu_cmd_o.rd_wb_sel   = SCR1_RD_WB_SUM2;\n                        idu2exu_cmd_o.imm         = {instr[31:12], 12'b0};\n`ifdef SCR1_RVE_EXT\n                        if (instr[11])          rve_illegal = 1'b1;\n`endif  // SCR1_RVE_EXT\n                    end // SCR1_OPCODE_AUIPC\n\n                    SCR1_OPCODE_LUI             : begin\n`ifndef SCR1_NO_EXE_STAGE\n                        idu2exu_use_rd_o          = 1'b1;\n                        idu2exu_use_imm_o         = 1'b1;\n`endif // SCR1_NO_EXE_STAGE\n                        idu2exu_cmd_o.rd_wb_sel   = SCR1_RD_WB_IMM;\n                        idu2exu_cmd_o.imm         = {instr[31:12], 12'b0};\n`ifdef SCR1_RVE_EXT\n                        if (instr[11])          rve_illegal = 1'b1;\n`endif  // SCR1_RVE_EXT\n                    end // SCR1_OPCODE_LUI\n\n                    SCR1_OPCODE_JAL             : begin\n`ifndef SCR1_NO_EXE_STAGE\n                        idu2exu_use_rd_o          = 1'b1;\n                        idu2exu_use_imm_o         = 1'b1;\n`endif // SCR1_NO_EXE_STAGE\n                        idu2exu_cmd_o.sum2_op     = SCR1_SUM2_OP_PC_IMM;\n                        idu2exu_cmd_o.rd_wb_sel   = SCR1_RD_WB_INC_PC;\n                        idu2exu_cmd_o.jump_req    = 1'b1;\n                        idu2exu_cmd_o.imm         = {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0};\n`ifdef SCR1_RVE_EXT\n                        if (instr[11])          rve_illegal = 1'b1;\n`endif  // SCR1_RVE_EXT\n                    end // SCR1_OPCODE_JAL\n\n                    SCR1_OPCODE_LOAD            : begin\n                        idu2exu_use_rs1_o         = 1'b1;\n`ifndef SCR1_NO_EXE_STAGE\n                        idu2exu_use_rd_o          = 1'b1;\n                        idu2exu_use_imm_o         = 1'b1;\n`endif // SCR1_NO_EXE_STAGE\n                        idu2exu_cmd_o.sum2_op     = SCR1_SUM2_OP_REG_IMM;\n                        idu2exu_cmd_o.rd_wb_sel   = SCR1_RD_WB_LSU;\n                        idu2exu_cmd_o.imm         = {{21{instr[31]}}, instr[30:20]};\n                        case (funct3)\n                            3'b000  : idu2exu_cmd_o.lsu_cmd = SCR1_LSU_CMD_LB;\n                            3'b001  : idu2exu_cmd_o.lsu_cmd = SCR1_LSU_CMD_LH;\n                            3'b010  : idu2exu_cmd_o.lsu_cmd = SCR1_LSU_CMD_LW;\n                            3'b100  : idu2exu_cmd_o.lsu_cmd = SCR1_LSU_CMD_LBU;\n                            3'b101  : idu2exu_cmd_o.lsu_cmd = SCR1_LSU_CMD_LHU;\n                            default : rvi_illegal = 1'b1;\n                        endcase // funct3\n`ifdef SCR1_RVE_EXT\n                        if (instr[11] | instr[19])  rve_illegal = 1'b1;\n`endif  // SCR1_RVE_EXT\n                    end // SCR1_OPCODE_LOAD\n\n                    SCR1_OPCODE_STORE           : begin\n                        idu2exu_use_rs1_o         = 1'b1;\n                        idu2exu_use_rs2_o         = 1'b1;\n`ifndef SCR1_NO_EXE_STAGE\n                        idu2exu_use_imm_o         = 1'b1;\n`endif // SCR1_NO_EXE_STAGE\n                        idu2exu_cmd_o.sum2_op     = SCR1_SUM2_OP_REG_IMM;\n                        idu2exu_cmd_o.imm         = {{21{instr[31]}}, instr[30:25], instr[11:7]};\n                        case (funct3)\n                            3'b000  : idu2exu_cmd_o.lsu_cmd = SCR1_LSU_CMD_SB;\n                            3'b001  : idu2exu_cmd_o.lsu_cmd = SCR1_LSU_CMD_SH;\n                            3'b010  : idu2exu_cmd_o.lsu_cmd = SCR1_LSU_CMD_SW;\n                            default : rvi_illegal = 1'b1;\n                        endcase // funct3\n`ifdef SCR1_RVE_EXT\n                        if (instr[19] | instr[24])  rve_illegal = 1'b1;\n`endif  // SCR1_RVE_EXT\n                    end // SCR1_OPCODE_STORE\n\n                    SCR1_OPCODE_OP              : begin\n                        idu2exu_use_rs1_o         = 1'b1;\n                        idu2exu_use_rs2_o         = 1'b1;\n`ifndef SCR1_NO_EXE_STAGE\n                        idu2exu_use_rd_o          = 1'b1;\n`endif // SCR1_NO_EXE_STAGE\n                        idu2exu_cmd_o.ialu_op     = SCR1_IALU_OP_REG_REG;\n                        idu2exu_cmd_o.rd_wb_sel   = SCR1_RD_WB_IALU;\n                        case (funct7)\n                            7'b0000000 : begin\n                                case (funct3)\n                                    3'b000  : idu2exu_cmd_o.ialu_cmd  = SCR1_IALU_CMD_ADD;\n                                    3'b001  : idu2exu_cmd_o.ialu_cmd  = SCR1_IALU_CMD_SLL;\n                                    3'b010  : idu2exu_cmd_o.ialu_cmd  = SCR1_IALU_CMD_SUB_LT;\n                                    3'b011  : idu2exu_cmd_o.ialu_cmd  = SCR1_IALU_CMD_SUB_LTU;\n                                    3'b100  : idu2exu_cmd_o.ialu_cmd  = SCR1_IALU_CMD_XOR;\n                                    3'b101  : idu2exu_cmd_o.ialu_cmd  = SCR1_IALU_CMD_SRL;\n                                    3'b110  : idu2exu_cmd_o.ialu_cmd  = SCR1_IALU_CMD_OR;\n                                    3'b111  : idu2exu_cmd_o.ialu_cmd  = SCR1_IALU_CMD_AND;\n                                endcase // funct3\n                            end // 7'b0000000\n\n                            7'b0100000 : begin\n                                case (funct3)\n                                    3'b000  : idu2exu_cmd_o.ialu_cmd  = SCR1_IALU_CMD_SUB;\n                                    3'b101  : idu2exu_cmd_o.ialu_cmd  = SCR1_IALU_CMD_SRA;\n                                    default : rvi_illegal = 1'b1;\n                                endcase // funct3\n                            end // 7'b0100000\n`ifdef SCR1_RVM_EXT\n                            7'b0000001 : begin\n                                case (funct3)\n                                    3'b000  : idu2exu_cmd_o.ialu_cmd  = SCR1_IALU_CMD_MUL;\n                                    3'b001  : idu2exu_cmd_o.ialu_cmd  = SCR1_IALU_CMD_MULH;\n                                    3'b010  : idu2exu_cmd_o.ialu_cmd  = SCR1_IALU_CMD_MULHSU;\n                                    3'b011  : idu2exu_cmd_o.ialu_cmd  = SCR1_IALU_CMD_MULHU;\n                                    3'b100  : idu2exu_cmd_o.ialu_cmd  = SCR1_IALU_CMD_DIV;\n                                    3'b101  : idu2exu_cmd_o.ialu_cmd  = SCR1_IALU_CMD_DIVU;\n                                    3'b110  : idu2exu_cmd_o.ialu_cmd  = SCR1_IALU_CMD_REM;\n                                    3'b111  : idu2exu_cmd_o.ialu_cmd  = SCR1_IALU_CMD_REMU;\n                                endcase // funct3\n                            end // 7'b0000001\n`endif  // SCR1_RVM_EXT\n                            default : rvi_illegal = 1'b1;\n                        endcase // funct7\n`ifdef SCR1_RVE_EXT\n                        if (instr[11] | instr[19] | instr[24])  rve_illegal = 1'b1;\n`endif  // SCR1_RVE_EXT\n                    end // SCR1_OPCODE_OP\n\n                    SCR1_OPCODE_OP_IMM          : begin\n                        idu2exu_use_rs1_o         = 1'b1;\n`ifndef SCR1_NO_EXE_STAGE\n                        idu2exu_use_rd_o          = 1'b1;\n                        idu2exu_use_imm_o         = 1'b1;\n`endif // SCR1_NO_EXE_STAGE\n                        idu2exu_cmd_o.imm         = {{21{instr[31]}}, instr[30:20]};\n                        idu2exu_cmd_o.ialu_op     = SCR1_IALU_OP_REG_IMM;\n                        idu2exu_cmd_o.rd_wb_sel   = SCR1_RD_WB_IALU;\n                        case (funct3)\n                            3'b000  : idu2exu_cmd_o.ialu_cmd  = SCR1_IALU_CMD_ADD;        // ADDI\n                            3'b010  : idu2exu_cmd_o.ialu_cmd  = SCR1_IALU_CMD_SUB_LT;     // SLTI\n                            3'b011  : idu2exu_cmd_o.ialu_cmd  = SCR1_IALU_CMD_SUB_LTU;    // SLTIU\n                            3'b100  : idu2exu_cmd_o.ialu_cmd  = SCR1_IALU_CMD_XOR;        // XORI\n                            3'b110  : idu2exu_cmd_o.ialu_cmd  = SCR1_IALU_CMD_OR;         // ORI\n                            3'b111  : idu2exu_cmd_o.ialu_cmd  = SCR1_IALU_CMD_AND;        // ANDI\n                            3'b001  : begin\n                                case (funct7)\n                                    7'b0000000  : begin\n                                        // SLLI\n                                        idu2exu_cmd_o.imm         = `SCR1_XLEN'(shamt);   // zero-extend\n                                        idu2exu_cmd_o.ialu_cmd    = SCR1_IALU_CMD_SLL;\n                                    end\n                                    default     : rvi_illegal   = 1'b1;\n                                endcase // funct7\n                            end\n                            3'b101  : begin\n                                case (funct7)\n                                    7'b0000000  : begin\n                                        // SRLI\n                                        idu2exu_cmd_o.imm         = `SCR1_XLEN'(shamt);   // zero-extend\n                                        idu2exu_cmd_o.ialu_cmd    = SCR1_IALU_CMD_SRL;\n                                    end\n                                    7'b0100000  : begin\n                                        // SRAI\n                                        idu2exu_cmd_o.imm         = `SCR1_XLEN'(shamt);   // zero-extend\n                                        idu2exu_cmd_o.ialu_cmd    = SCR1_IALU_CMD_SRA;\n                                    end\n                                    default     : rvi_illegal   = 1'b1;\n                                endcase // funct7\n                            end\n                        endcase // funct3\n`ifdef SCR1_RVE_EXT\n                        if (instr[11] | instr[19])  rve_illegal = 1'b1;\n`endif  // SCR1_RVE_EXT\n                    end // SCR1_OPCODE_OP_IMM\n\n                    SCR1_OPCODE_MISC_MEM    : begin\n                        case (funct3)\n                            3'b000  : begin\n                                if (~|{instr[31:28], instr[19:15], instr[11:7]}) begin\n                                    // FENCE = NOP\n                                end\n                                else rvi_illegal = 1'b1;\n                            end\n                            3'b001  : begin\n                                if (~|{instr[31:15], instr[11:7]}) begin\n                                    // FENCE.I\n                                    idu2exu_cmd_o.fencei_req    = 1'b1;\n                                end\n                                else rvi_illegal = 1'b1;\n                            end\n                            default : rvi_illegal = 1'b1;\n                        endcase // funct3\n                    end // SCR1_OPCODE_MISC_MEM\n\n                    SCR1_OPCODE_BRANCH          : begin\n                        idu2exu_use_rs1_o         = 1'b1;\n                        idu2exu_use_rs2_o         = 1'b1;\n`ifndef SCR1_NO_EXE_STAGE\n                        idu2exu_use_imm_o         = 1'b1;\n`endif // SCR1_NO_EXE_STAGE\n                        idu2exu_cmd_o.imm         = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};\n                        idu2exu_cmd_o.branch_req  = 1'b1;\n                        idu2exu_cmd_o.sum2_op     = SCR1_SUM2_OP_PC_IMM;\n                        idu2exu_cmd_o.ialu_op     = SCR1_IALU_OP_REG_REG;\n                        case (funct3)\n                            3'b000  : idu2exu_cmd_o.ialu_cmd = SCR1_IALU_CMD_SUB_EQ;\n                            3'b001  : idu2exu_cmd_o.ialu_cmd = SCR1_IALU_CMD_SUB_NE;\n                            3'b100  : idu2exu_cmd_o.ialu_cmd = SCR1_IALU_CMD_SUB_LT;\n                            3'b101  : idu2exu_cmd_o.ialu_cmd = SCR1_IALU_CMD_SUB_GE;\n                            3'b110  : idu2exu_cmd_o.ialu_cmd = SCR1_IALU_CMD_SUB_LTU;\n                            3'b111  : idu2exu_cmd_o.ialu_cmd = SCR1_IALU_CMD_SUB_GEU;\n                            default : rvi_illegal = 1'b1;\n                        endcase // funct3\n`ifdef SCR1_RVE_EXT\n                        if (instr[19] | instr[24])  rve_illegal = 1'b1;\n`endif  // SCR1_RVE_EXT\n                    end // SCR1_OPCODE_BRANCH\n\n                    SCR1_OPCODE_JALR        : begin\n                        idu2exu_use_rs1_o     = 1'b1;\n`ifndef SCR1_NO_EXE_STAGE\n                        idu2exu_use_rd_o      = 1'b1;\n                        idu2exu_use_imm_o     = 1'b1;\n`endif // SCR1_NO_EXE_STAGE\n                        case (funct3)\n                            3'b000  : begin\n                                // JALR\n                                idu2exu_cmd_o.sum2_op   = SCR1_SUM2_OP_REG_IMM;\n                                idu2exu_cmd_o.rd_wb_sel = SCR1_RD_WB_INC_PC;\n                                idu2exu_cmd_o.jump_req  = 1'b1;\n                                idu2exu_cmd_o.imm       = {{21{instr[31]}}, instr[30:20]};\n                            end\n                            default : rvi_illegal = 1'b1;\n                        endcase\n`ifdef SCR1_RVE_EXT\n                        if (instr[11] | instr[19])  rve_illegal = 1'b1;\n`endif  // SCR1_RVE_EXT\n                    end // SCR1_OPCODE_JALR\n\n                    SCR1_OPCODE_SYSTEM      : begin\n`ifndef SCR1_NO_EXE_STAGE\n                        idu2exu_use_rd_o      = 1'b1;\n                        idu2exu_use_imm_o     = 1'b1;\n`endif // SCR1_NO_EXE_STAGE\n                        idu2exu_cmd_o.imm     = `SCR1_XLEN'({funct3, instr[31:20]});      // {funct3, CSR address}\n                        case (funct3)\n                            3'b000  : begin\n`ifndef SCR1_NO_EXE_STAGE\n                                idu2exu_use_rd_o    = 1'b0;\n                                idu2exu_use_imm_o   = 1'b0;\n`endif // SCR1_NO_EXE_STAGE\n                                case ({instr[19:15], instr[11:7]})\n                                    10'd0 : begin\n                   "}
{"text": "                     case (funct12)\n                                            12'h000 : begin\n                                                // ECALL\n                                                idu2exu_cmd_o.exc_req     = 1'b1;\n                                                idu2exu_cmd_o.exc_code    = SCR1_EXC_CODE_ECALL_M;\n                                            end\n                                            12'h001 : begin\n                                                // EBREAK\n                                                idu2exu_cmd_o.exc_req     = 1'b1;\n                                                idu2exu_cmd_o.exc_code    = SCR1_EXC_CODE_BREAKPOINT;\n                                            end\n                                            12'h302 : begin\n                                                // MRET\n                                                idu2exu_cmd_o.mret_req    = 1'b1;\n                                            end\n                                            12'h105 : begin\n                                                // WFI\n                                                idu2exu_cmd_o.wfi_req     = 1'b1;\n                                            end\n                                            default : rvi_illegal = 1'b1;\n                                        endcase // funct12\n                                    end\n                                    default : rvi_illegal = 1'b1;\n                                endcase // {instr[19:15], instr[11:7]}\n                            end\n                            3'b001  : begin\n                                // CSRRW\n                                idu2exu_use_rs1_o             = 1'b1;\n                                idu2exu_cmd_o.rd_wb_sel       = SCR1_RD_WB_CSR;\n                                idu2exu_cmd_o.csr_cmd         = SCR1_CSR_CMD_WRITE;\n                                idu2exu_cmd_o.csr_op          = SCR1_CSR_OP_REG;\n`ifdef SCR1_RVE_EXT\n                                if (instr[11] | instr[19])  rve_illegal = 1'b1;\n`endif  // SCR1_RVE_EXT\n                            end\n                            3'b010  : begin\n                                // CSRRS\n                                idu2exu_use_rs1_o             = 1'b1;\n                                idu2exu_cmd_o.rd_wb_sel       = SCR1_RD_WB_CSR;\n                                idu2exu_cmd_o.csr_cmd         = SCR1_CSR_CMD_SET;\n                                idu2exu_cmd_o.csr_op          = SCR1_CSR_OP_REG;\n`ifdef SCR1_RVE_EXT\n                                if (instr[11] | instr[19])  rve_illegal = 1'b1;\n`endif  // SCR1_RVE_EXT\n                            end\n                            3'b011  : begin\n                                // CSRRC\n                                idu2exu_use_rs1_o             = 1'b1;\n                                idu2exu_cmd_o.rd_wb_sel       = SCR1_RD_WB_CSR;\n                                idu2exu_cmd_o.csr_cmd         = SCR1_CSR_CMD_CLEAR;\n                                idu2exu_cmd_o.csr_op          = SCR1_CSR_OP_REG;\n`ifdef SCR1_RVE_EXT\n                                if (instr[11] | instr[19])  rve_illegal = 1'b1;\n`endif  // SCR1_RVE_EXT\n                            end\n                            3'b101  : begin\n                                // CSRRWI\n                                idu2exu_use_rs1_o             = 1'b1;             // zimm\n                                idu2exu_cmd_o.rd_wb_sel       = SCR1_RD_WB_CSR;\n                                idu2exu_cmd_o.csr_cmd         = SCR1_CSR_CMD_WRITE;\n                                idu2exu_cmd_o.csr_op          = SCR1_CSR_OP_IMM;\n`ifdef SCR1_RVE_EXT\n                                if (instr[11])              rve_illegal = 1'b1;\n`endif  // SCR1_RVE_EXT\n                            end\n                            3'b110  : begin\n                                // CSRRSI\n                                idu2exu_use_rs1_o             = 1'b1;             // zimm\n                                idu2exu_cmd_o.rd_wb_sel       = SCR1_RD_WB_CSR;\n                                idu2exu_cmd_o.csr_cmd         = SCR1_CSR_CMD_SET;\n                                idu2exu_cmd_o.csr_op          = SCR1_CSR_OP_IMM;\n`ifdef SCR1_RVE_EXT\n                                if (instr[11])              rve_illegal = 1'b1;\n`endif  // SCR1_RVE_EXT\n                            end\n                            3'b111  : begin\n                                // CSRRCI\n                                idu2exu_use_rs1_o             = 1'b1;             // zimm\n                                idu2exu_cmd_o.rd_wb_sel       = SCR1_RD_WB_CSR;\n                                idu2exu_cmd_o.csr_cmd         = SCR1_CSR_CMD_CLEAR;\n                                idu2exu_cmd_o.csr_op          = SCR1_CSR_OP_IMM;\n`ifdef SCR1_RVE_EXT\n                                if (instr[11])              rve_illegal = 1'b1;\n`endif  // SCR1_RVE_EXT\n                            end\n                            default : rvi_illegal = 1'b1;\n                        endcase // funct3\n                    end // SCR1_OPCODE_SYSTEM\n\n                    default : begin\n                        rvi_illegal = 1'b1;\n                    end\n                endcase // rvi_opcode\n            end // SCR1_INSTR_RVI\n\n`ifdef SCR1_RVC_EXT\n\n            // Quadrant 0\n            SCR1_INSTR_RVC0 : begin\n                idu2exu_cmd_o.instr_rvc   = 1'b1;\n                idu2exu_use_rs1_o         = 1'b1;\n`ifndef SCR1_NO_EXE_STAGE\n                idu2exu_use_imm_o         = 1'b1;\n`endif // SCR1_NO_EXE_STAGE\n                case (funct3)\n                    3'b000  : begin\n                        if (~|instr[12:5])      rvc_illegal = 1'b1;\n                        // C.ADDI4SPN\n`ifndef SCR1_NO_EXE_STAGE\n                        idu2exu_use_rd_o          = 1'b1;\n`endif // SCR1_NO_EXE_STAGE\n                        idu2exu_cmd_o.ialu_cmd    = SCR1_IALU_CMD_ADD;\n                        idu2exu_cmd_o.ialu_op     = SCR1_IALU_OP_REG_IMM;\n                        idu2exu_cmd_o.rd_wb_sel   = SCR1_RD_WB_IALU;\n                        idu2exu_cmd_o.rs1_addr    = SCR1_MPRF_SP_ADDR;\n                        idu2exu_cmd_o.rd_addr     = {2'b01, instr[4:2]};\n                        idu2exu_cmd_o.imm         = {22'd0, instr[10:7], instr[12:11], instr[5], instr[6], 2'b00};\n                    end\n                    3'b010  : begin\n                        // C.LW\n`ifndef SCR1_NO_EXE_STAGE\n                        idu2exu_use_rd_o          = 1'b1;\n`endif // SCR1_NO_EXE_STAGE\n                        idu2exu_cmd_o.sum2_op     = SCR1_SUM2_OP_REG_IMM;\n                        idu2exu_cmd_o.lsu_cmd     = SCR1_LSU_CMD_LW;\n                        idu2exu_cmd_o.rd_wb_sel   = SCR1_RD_WB_LSU;\n                        idu2exu_cmd_o.rs1_addr    = {2'b01, instr[9:7]};\n                        idu2exu_cmd_o.rd_addr     = {2'b01, instr[4:2]};\n                        idu2exu_cmd_o.imm         = {25'd0, instr[5], instr[12:10], instr[6], 2'b00};\n                    end\n                    3'b110  : begin\n                        // C.SW\n                        idu2exu_use_rs2_o         = 1'b1;\n                        idu2exu_cmd_o.sum2_op     = SCR1_SUM2_OP_REG_IMM;\n                        idu2exu_cmd_o.lsu_cmd     = SCR1_LSU_CMD_SW;\n                        idu2exu_cmd_o.rs1_addr    = {2'b01, instr[9:7]};\n                        idu2exu_cmd_o.rs2_addr    = {2'b01, instr[4:2]};\n                        idu2exu_cmd_o.imm         = {25'd0, instr[5], instr[12:10], instr[6], 2'b00};\n                    end\n                    default : begin\n                        rvc_illegal = 1'b1;\n                    end\n                endcase // funct3\n            end // Quadrant 0\n\n            // Quadrant 1\n            SCR1_INSTR_RVC1 : begin\n                idu2exu_cmd_o.instr_rvc   = 1'b1;\n`ifndef SCR1_NO_EXE_STAGE\n                idu2exu_use_rd_o          = 1'b1;\n                idu2exu_use_imm_o         = 1'b1;\n`endif // SCR1_NO_EXE_STAGE\n                case (funct3)\n                    3'b000  : begin\n                        // C.ADDI / C.NOP\n                        idu2exu_use_rs1_o         = 1'b1;\n                        idu2exu_cmd_o.ialu_cmd    = SCR1_IALU_CMD_ADD;\n                        idu2exu_cmd_o.ialu_op     = SCR1_IALU_OP_REG_IMM;\n                        idu2exu_cmd_o.rd_wb_sel   = SCR1_RD_WB_IALU;\n                        idu2exu_cmd_o.rs1_addr    = instr[11:7];\n                        idu2exu_cmd_o.rd_addr     = instr[11:7];\n                        idu2exu_cmd_o.imm         = {{27{instr[12]}}, instr[6:2]};\n`ifdef SCR1_RVE_EXT\n                        if (instr[11])          rve_illegal = 1'b1;\n`endif  // SCR1_RVE_EXT\n                    end\n                    3'b001  : begin\n                        // C.JAL\n                        idu2exu_cmd_o.sum2_op     = SCR1_SUM2_OP_PC_IMM;\n                        idu2exu_cmd_o.rd_wb_sel   = SCR1_RD_WB_INC_PC;\n                        idu2exu_cmd_o.jump_req    = 1'b1;\n                        idu2exu_cmd_o.rd_addr     = SCR1_MPRF_RA_ADDR;\n                        idu2exu_cmd_o.imm         = {{21{instr[12]}}, instr[8], instr[10:9], instr[6], instr[7], instr[2], instr[11], instr[5:3], 1'b0};\n                    end\n                    3'b010  : begin\n                        // C.LI\n                        idu2exu_cmd_o.rd_wb_sel   = SCR1_RD_WB_IMM;\n                        idu2exu_cmd_o.rd_addr     = instr[11:7];\n                        idu2exu_cmd_o.imm         = {{27{instr[12]}}, instr[6:2]};\n`ifdef SCR1_RVE_EXT\n                        if (instr[11])          rve_illegal = 1'b1;\n`endif  // SCR1_RVE_EXT\n                    end\n                    3'b011  : begin\n                        if (~|{instr[12], instr[6:2]}) rvc_illegal = 1'b1;\n                        if (instr[11:7] == SCR1_MPRF_SP_ADDR) begin\n                            // C.ADDI16SP\n                            idu2exu_use_rs1_o         = 1'b1;\n                            idu2exu_cmd_o.ialu_cmd    = SCR1_IALU_CMD_ADD;\n                            idu2exu_cmd_o.ialu_op     = SCR1_IALU_OP_REG_IMM;\n                            idu2exu_cmd_o.rd_wb_sel   = SCR1_RD_WB_IALU;\n                            idu2exu_cmd_o.rs1_addr    = SCR1_MPRF_SP_ADDR;\n                            idu2exu_cmd_o.rd_addr     = SCR1_MPRF_SP_ADDR;\n                            idu2exu_cmd_o.imm         = {{23{instr[12]}}, instr[4:3], instr[5], instr[2], instr[6], 4'd0};\n                        end else begin\n                            // C.LUI\n                            idu2exu_cmd_o.rd_wb_sel   = SCR1_RD_WB_IMM;\n                            idu2exu_cmd_o.rd_addr     = instr[11:7];\n                            idu2exu_cmd_o.imm         = {{15{instr[12]}}, instr[6:2], 12'd0};\n`ifdef SCR1_RVE_EXT\n                            if (instr[11])          rve_illegal = 1'b1;\n`endif  // SCR1_RVE_EXT\n                        end\n                    end\n                    3'b100  : begin\n                        idu2exu_cmd_o.rs1_addr    = {2'b01, instr[9:7]};\n                        idu2exu_cmd_o.rd_addr     = {2'b01, instr[9:7]};\n                        idu2exu_cmd_o.rs2_addr    = {2'b01, instr[4:2]};\n                        idu2exu_use_rs1_o         = 1'b1;\n`ifndef SCR1_NO_EXE_STAGE\n                        idu2exu_use_rd_o          = 1'b1;\n`endif // SCR1_NO_EXE_STAGE\n                        case (instr[11:10])\n                            2'b00   : begin\n                                if (instr[12])          rvc_illegal = 1'b1;\n                                // C.SRLI\n`ifndef SCR1_NO_EXE_STAGE\n                                idu2exu_use_imm_o         = 1'b1;\n`endif // SCR1_NO_EXE_STAGE\n                                idu2exu_cmd_o.imm         = {27'd0, instr[6:2]};\n                                idu2exu_cmd_o.ialu_cmd    = SCR1_IALU_CMD_SRL;\n                                idu2exu_cmd_o.ialu_op     = SCR1_IALU_OP_REG_IMM;\n                                idu2exu_cmd_o.rd_wb_sel   = SCR1_RD_WB_IALU;\n                            end\n                            2'b01   : begin\n                                if (instr[12])          rvc_illegal = 1'b1;\n                                // C.SRAI\n`ifndef SCR1_NO_EXE_STAGE\n                                idu2exu_use_imm_o         = 1'b1;\n`endif // SCR1_NO_EXE_STAGE\n                                idu2exu_cmd_o.imm         = {27'd0, instr[6:2]};\n                                idu2exu_cmd_o.ialu_cmd    = SCR1_IALU_CMD_SRA;\n                                idu2exu_cmd_o.ialu_op     = SCR1_IALU_OP_REG_IMM;\n                                idu2exu_cmd_o.rd_wb_sel   = SCR1_RD_WB_IALU;\n                            end\n                            2'b10   : begin\n                                // C.ANDI\n`ifndef SCR1_NO_EXE_STAGE\n                                idu2exu_use_imm_o         = 1'b1;\n`endif // SCR1_NO_EXE_STAGE\n                                idu2exu_cmd_o.ialu_cmd    = SCR1_IALU_CMD_AND;\n                                idu2exu_cmd_o.ialu_op     = SCR1_IALU_OP_REG_IMM;\n                                idu2exu_cmd_o.rd_wb_sel   = SCR1_RD_WB_IALU;\n                                idu2exu_cmd_o.imm         = {{27{instr[12]}}, instr[6:2]};\n                            end\n                            2'b11   : begin\n                                idu2exu_use_rs2_o         = 1'b1;\n                                case ({instr[12], instr[6:5]})\n                                    3'b000  : begin\n                                        // C.SUB\n                                        idu2exu_cmd_o.ialu_cmd    = SCR1_IALU_CMD_SUB;\n                                        idu2exu_cmd_o.ialu_op     = SCR1_IALU_OP_REG_REG;\n                                        idu2exu_cmd_o.rd_wb_sel   = SCR1_RD_WB_IALU;\n                                    end\n                                    3'b001  : begin\n                                        // C.XOR\n                                        idu2exu_cmd_o.ialu_cmd    = SCR1_IALU_CMD_XOR;\n                                        idu2exu_cmd_o.ialu_op     = SCR1_IALU_OP_REG_REG;\n                                        idu2exu_cmd_o.rd_wb_sel   = SCR1_RD_WB_IALU;\n                                    end\n                                    3'b010  : begin\n                                        // C.OR\n                                        idu2exu_cmd_o.ialu_cmd    = SCR1_IALU_CMD_OR;\n                                        idu2exu_cmd_o.ialu_op     = SCR1_IALU_OP_REG_REG;\n                                        idu2exu_cmd_o.rd_wb_sel   = SCR1_RD_WB_IALU;\n                                    end\n                                    3'b011  : begin\n                                        // C.AND\n                                        idu2exu_cmd_o.ialu_cmd    = SCR1_IALU_CMD_AND;\n                                        idu2exu_cmd_o.ialu_op     = SCR1_IALU_OP_REG_REG;\n                                        idu2exu_cmd_o.rd_wb_sel   = SCR1_RD_WB_IALU;\n                                    end\n                                    default : begin\n                                        rvc_illegal = 1'b1;\n                                    end\n                                endcase // {instr[12], instr[6:5]}\n                            end\n                        endcase // instr[11:10]\n                    end // funct3 == 3'b100\n                    3'b101  : begin\n                        // C.J\n`ifndef SCR1_NO_EXE_STAGE\n                        idu2exu_use_imm_o         = 1'b1;\n`endif // SCR1_NO_EXE_STAGE\n                        idu2exu_cmd_o.sum2_op     = SCR1_SUM2_OP_PC_IMM;\n                        idu2exu_cmd_o.jump_req    = 1'b1;\n                        idu2exu_cmd_o.imm         = {{21{instr[12]}}, instr[8], instr[10:9], instr[6], instr[7], instr[2], instr[11], instr[5:3], 1'b0};\n                    end\n                    3'b110  : begin\n                        // C.BEQZ\n                        idu2exu_use_rs1_o         = 1'b1;\n                        idu2exu_use_rs2_o         = 1'b1;\n`ifndef SCR1_NO_EXE_STAGE\n                        idu2exu_use_imm_o         = 1'b1;\n`endif // SCR1_NO_EXE_STAGE\n                        idu2exu_cmd_o.ialu_cmd    = SCR1_IALU_CMD_SUB_EQ;\n                        idu2exu_cmd_o.ialu_op     = SCR1_IALU_OP_REG_REG;\n                        idu2exu_cmd_o.sum2_op     = SCR1_SUM2_OP_PC_IMM;\n                        idu2exu_cmd_o.branch_req  = 1'b1;\n                        idu2exu_cmd_o.rs1_addr    = {2'b01, instr[9:7]};\n                        idu2exu_cmd_o.rs2_addr    = SCR1_MPRF_ZERO_ADDR;\n                        idu2exu_cmd_o.imm         = {{24{instr[12]}}, instr[6:5], instr[2], instr[11:10], instr[4:3], 1'b0};\n                    end\n                    3'b111  : begin\n                        // C.BNEZ\n                        idu2exu_use_rs1_o         = 1'b1;\n                        idu2exu_use_rs2_o         = 1'b1;\n`ifndef SCR1_NO_EXE_STAGE\n                        idu2exu_use_imm_o         = 1'b1;\n`endif // SCR1_NO_EXE_STAGE\n                        idu2exu_cmd_o.ialu_cmd    = SCR1_IALU_CMD_SUB_NE;\n                        idu2exu_cmd_o.ialu_op     = SCR1_IALU_OP_REG_REG;\n                        idu2exu_cmd_o.sum2_op     = SCR1_SUM2_OP_PC_IMM;\n                        idu2exu_cmd_o.branch_req  = 1'b1;\n                        idu2exu_cmd_o.rs1_addr    = {2'b01, instr[9:7]};\n                        idu2exu_cmd_o.rs2_addr    = SCR1_MPRF_ZERO_ADDR;\n                        idu2exu_cmd_o.imm         = {{24{instr[12]}}, instr[6:5], instr[2], instr[11:10], instr[4:3], 1'b0};\n                    end\n                endcase // funct3\n            end // Quadrant 1\n\n            // Quadrant 2\n            SCR1_INSTR_RVC2 : begin\n                idu2exu_cmd_o.instr_rvc   = 1'b1;\n                idu2exu_use_rs1_o         = 1'b1;\n                case (funct3)\n                    3'b000  : begin\n                        if (instr[12])          rvc_illegal = 1'b1;\n                        // C.SLLI\n`ifndef SCR1_NO_EXE_STAGE\n                        idu2exu_use_rd_o          = 1'b1;\n                        idu2exu_use_imm_o         = 1'b1;\n`endif // SCR1_NO_EXE_STAGE\n                        idu2exu_cmd_o.rs1_addr    = instr[11:7];\n                        idu2exu_cmd_o.rd_addr     = instr[11:7];\n                        idu2exu_cmd_o.imm         = {27'd0, instr[6:2]};\n                        idu2exu_cmd_o.ialu_cmd    = SCR1_IALU_CMD_SLL;\n                        idu2exu_cmd_o.ialu_op     = SCR1_IALU_OP_REG_IMM;\n                        idu2exu_cmd_o.rd_wb_sel   = SCR1_RD_WB_IALU;\n`ifdef SCR1_RVE_EXT\n                        if (instr[11])          rve_illegal = 1'b1;\n`endif  // SCR1_RVE_EXT\n                    end\n                    3'b010  : begin\n                        if (~|instr[11:7])      rvc_illegal = 1'b1;\n                        // C.LWSP\n`ifndef SCR1_NO_EXE_STAGE\n                        idu2exu_use_rd_o          = 1'b1;\n                        idu2exu_use_imm_o         = 1'b1;\n`endif // SCR1_NO_EXE_STAGE\n                        idu2exu_cmd_o.sum2_op     = SCR1_SUM2_OP_REG_IMM;\n                        idu2exu_cmd_o.lsu_cmd     = SCR1_LSU_CMD_LW;\n                        idu2exu_cmd_o.rd_wb_sel   = SCR1_RD_WB_LSU;\n                        idu2exu_cmd_o.rs1_addr    = SCR1_MPRF_SP_ADDR;\n                        idu2exu_cmd_o.rd_addr     = instr[11:7];\n                        idu2exu_cmd_o.imm         = {24'd0, instr[3:2], instr[12], instr[6:4], 2'b00};\n`ifdef SCR1_RVE_EXT\n                        if (instr[11])          rve_illegal = 1'b1;\n`endif  // SCR1_RVE_EXT\n                    end\n                    3'b100  : begin\n                        if (~instr[12]) begin\n                            if (|instr[6:2]) begin\n                                // C.MV\n                                idu2exu_use_rs2_o         = 1'b1;\n`ifndef SCR1_NO_EXE_STAGE\n                                idu2exu_use_rd_o          = 1'b1;\n`endif // SCR1_NO_EXE_STAGE\n                                idu2exu_cmd_o.ialu"}
{"text": "_cmd    = SCR1_IALU_CMD_ADD;\n                                idu2exu_cmd_o.ialu_op     = SCR1_IALU_OP_REG_REG;\n                                idu2exu_cmd_o.rd_wb_sel   = SCR1_RD_WB_IALU;\n                                idu2exu_cmd_o.rs1_addr    = SCR1_MPRF_ZERO_ADDR;\n                                idu2exu_cmd_o.rs2_addr    = instr[6:2];\n                                idu2exu_cmd_o.rd_addr     = instr[11:7];\n`ifdef SCR1_RVE_EXT\n                                if (instr[11]|instr[6]) rve_illegal = 1'b1;\n`endif  // SCR1_RVE_EXT\n                            end else begin\n                                if (~|instr[11:7])      rvc_illegal = 1'b1;\n                                // C.JR\n`ifndef SCR1_NO_EXE_STAGE\n                                idu2exu_use_imm_o         = 1'b1;\n`endif // SCR1_NO_EXE_STAGE\n                                idu2exu_cmd_o.sum2_op     = SCR1_SUM2_OP_REG_IMM;\n                                idu2exu_cmd_o.jump_req    = 1'b1;\n                                idu2exu_cmd_o.rs1_addr    = instr[11:7];\n                                idu2exu_cmd_o.imm         = 0;\n`ifdef SCR1_RVE_EXT\n                                if (instr[11])          rve_illegal = 1'b1;\n`endif  // SCR1_RVE_EXT\n                            end\n                        end else begin  // instr[12] == 1\n                            if (~|instr[11:2]) begin\n                                // C.EBREAK\n                                idu2exu_cmd_o.exc_req     = 1'b1;\n                                idu2exu_cmd_o.exc_code    = SCR1_EXC_CODE_BREAKPOINT;\n                            end else if (~|instr[6:2]) begin\n                                // C.JALR\n                                idu2exu_use_rs1_o         = 1'b1;\n`ifndef SCR1_NO_EXE_STAGE\n                                idu2exu_use_rd_o          = 1'b1;\n                                idu2exu_use_imm_o         = 1'b1;\n`endif // SCR1_NO_EXE_STAGE\n                                idu2exu_cmd_o.sum2_op     = SCR1_SUM2_OP_REG_IMM;\n                                idu2exu_cmd_o.rd_wb_sel   = SCR1_RD_WB_INC_PC;\n                                idu2exu_cmd_o.jump_req    = 1'b1;\n                                idu2exu_cmd_o.rs1_addr    = instr[11:7];\n                                idu2exu_cmd_o.rd_addr     = SCR1_MPRF_RA_ADDR;\n                                idu2exu_cmd_o.imm         = 0;\n`ifdef SCR1_RVE_EXT\n                                if (instr[11])          rve_illegal = 1'b1;\n`endif  // SCR1_RVE_EXT\n                            end else begin\n                                // C.ADD\n                                idu2exu_use_rs1_o         = 1'b1;\n                                idu2exu_use_rs2_o         = 1'b1;\n`ifndef SCR1_NO_EXE_STAGE\n                                idu2exu_use_rd_o          = 1'b1;\n`endif // SCR1_NO_EXE_STAGE\n                                idu2exu_cmd_o.ialu_cmd    = SCR1_IALU_CMD_ADD;\n                                idu2exu_cmd_o.ialu_op     = SCR1_IALU_OP_REG_REG;\n                                idu2exu_cmd_o.rd_wb_sel   = SCR1_RD_WB_IALU;\n                                idu2exu_cmd_o.rs1_addr    = instr[11:7];\n                                idu2exu_cmd_o.rs2_addr    = instr[6:2];\n                                idu2exu_cmd_o.rd_addr     = instr[11:7];\n`ifdef SCR1_RVE_EXT\n                                if (instr[11]|instr[6]) rve_illegal = 1'b1;\n`endif  // SCR1_RVE_EXT\n                            end\n                        end // instr[12] == 1\n                    end\n                    3'b110  : begin\n                        // C.SWSP\n                        idu2exu_use_rs1_o         = 1'b1;\n                        idu2exu_use_rs2_o         = 1'b1;\n`ifndef SCR1_NO_EXE_STAGE\n                        idu2exu_use_imm_o         = 1'b1;\n`endif // SCR1_NO_EXE_STAGE\n                        idu2exu_cmd_o.sum2_op     = SCR1_SUM2_OP_REG_IMM;\n                        idu2exu_cmd_o.lsu_cmd     = SCR1_LSU_CMD_SW;\n                        idu2exu_cmd_o.rs1_addr    = SCR1_MPRF_SP_ADDR;\n                        idu2exu_cmd_o.rs2_addr    = instr[6:2];\n                        idu2exu_cmd_o.imm         = {24'd0, instr[8:7], instr[12:9], 2'b00};\n`ifdef SCR1_RVE_EXT\n                        if (instr[6])           rve_illegal = 1'b1;\n`endif  // SCR1_RVE_EXT\n                    end\n                    default : begin\n                        rvc_illegal = 1'b1;\n                    end\n                endcase // funct3\n            end // Quadrant 2\n\n            default         : begin\n`ifdef SCR1_XPROP_EN\n                rvi_illegal             = 1'b1;\n`endif // SCR1_XPROP_EN\n            end\n`else   // SCR1_RVC_EXT\n            default         : begin\n                idu2exu_cmd_o.instr_rvc = 1'b1;\n                rvi_illegal             = 1'b1;\n            end\n`endif  // SCR1_RVC_EXT\n        endcase // instr_type\n    end // no imem fault\n\n    // At this point the instruction is fully decoded\n    // given that no imem fault has happened\n\n    // Check illegal instruction\n    if (\n    rvi_illegal\n`ifdef SCR1_RVC_EXT\n    | rvc_illegal\n`endif\n`ifdef SCR1_RVE_EXT\n    | rve_illegal\n`endif\n    ) begin\n        idu2exu_cmd_o.ialu_cmd        = SCR1_IALU_CMD_NONE;\n        idu2exu_cmd_o.lsu_cmd         = SCR1_LSU_CMD_NONE;\n        idu2exu_cmd_o.csr_cmd         = SCR1_CSR_CMD_NONE;\n        idu2exu_cmd_o.rd_wb_sel       = SCR1_RD_WB_NONE;\n        idu2exu_cmd_o.jump_req        = 1'b0;\n        idu2exu_cmd_o.branch_req      = 1'b0;\n        idu2exu_cmd_o.mret_req        = 1'b0;\n        idu2exu_cmd_o.fencei_req      = 1'b0;\n        idu2exu_cmd_o.wfi_req         = 1'b0;\n\n        idu2exu_use_rs1_o             = 1'b0;\n        idu2exu_use_rs2_o             = 1'b0;\n`ifndef SCR1_NO_EXE_STAGE\n        idu2exu_use_rd_o              = 1'b0;\n`endif // SCR1_NO_EXE_STAGE\n\n`ifndef SCR1_MTVAL_ILLEGAL_INSTR_EN\n        idu2exu_use_imm_o             = 1'b0;\n`else // SCR1_MTVAL_ILLEGAL_INSTR_EN\n`ifndef SCR1_NO_EXE_STAGE\n        idu2exu_use_imm_o             = 1'b1;\n`endif // SCR1_NO_EXE_STAGE\n        idu2exu_cmd_o.imm             = instr;\n`endif // SCR1_MTVAL_ILLEGAL_INSTR_EN\n\n        idu2exu_cmd_o.exc_req         = 1'b1;\n        idu2exu_cmd_o.exc_code        = SCR1_EXC_CODE_ILLEGAL_INSTR;\n    end\n\nend // RV32I(MC) decode\n\n`ifdef SCR1_TRGT_SIMULATION\n//-------------------------------------------------------------------------------\n// Assertion\n//-------------------------------------------------------------------------------\n\n// X checks\n\nSCR1_SVA_IDU_XCHECK : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    !$isunknown({ifu2idu_vd_i, exu2idu_rdy_i})\n    ) else $error(\"IDU Error: unknown values\");\n\n// Behavior checks\n\nSCR1_SVA_IDU_IALU_CMD_RANGE : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    (ifu2idu_vd_i & ~ifu2idu_imem_err_i) |->\n    ((idu2exu_cmd_o.ialu_cmd >= SCR1_IALU_CMD_NONE) &\n    (idu2exu_cmd_o.ialu_cmd <=\n`ifdef SCR1_RVM_EXT\n                            SCR1_IALU_CMD_REMU\n`else\n                            SCR1_IALU_CMD_SRA\n`endif // SCR1_RVM_EXT\n        ))\n    ) else $error(\"IDU Error: IALU_CMD out of range\");\n\n`endif // SCR1_TRGT_SIMULATION\n\nendmodule : scr1_pipe_idu\n"}
{"text": "/// Copyright by Syntacore LLC \u00a9 2016-2021. See LICENSE for details\n/// @file       <scr1_pipe_ifu.sv>\n/// @brief      Instruction Fetch Unit (IFU)\n///\n\n//------------------------------------------------------------------------------\n //\n // Functionality:\n // - Controls instruction fetching process:\n //   - Fetches instructions either from IMEM or from Program Buffer, supporting\n //     pending IMEM instructions handling\n //   - Handles new PC misalignment and constructs the correct instruction (supports\n //     RVI and RVC instructions)\n //   - Either stores instructions in the instruction queue or bypasses to the\n //     IDU if the corresponding option is used\n //   - Flushes instruction queue if requested\n //\n // Structure:\n // - Instruction queue\n // - IFU FSM\n // - IFU <-> IMEM i/f\n // - IFU <-> IDU i/f\n // - IFU <-> HDU i/f\n //\n//------------------------------------------------------------------------------\n\n`include \"scr1_memif.svh\"\n`include \"scr1_arch_description.svh\"\n`ifdef SCR1_DBG_EN\n`include \"scr1_hdu.svh\"\n`endif // SCR1_DBG_EN\n\nmodule scr1_pipe_ifu\n(\n    // Control signals\n    input   logic                                   rst_n,                      // IFU reset\n    input   logic                                   clk,                        // IFU clock\n    input   logic                                   pipe2ifu_stop_fetch_i,      // Stop instruction fetch\n\n    // IFU <-> IMEM interface\n    input   logic                                   imem2ifu_req_ack_i,         // Instruction memory request acknowledgement\n    output  logic                                   ifu2imem_req_o,             // Instruction memory request\n    output  type_scr1_mem_cmd_e                     ifu2imem_cmd_o,             // Instruction memory command (READ/WRITE)\n    output  logic [`SCR1_IMEM_AWIDTH-1:0]           ifu2imem_addr_o,            // Instruction memory address\n    input   logic [`SCR1_IMEM_DWIDTH-1:0]           imem2ifu_rdata_i,           // Instruction memory read data\n    input   type_scr1_mem_resp_e                    imem2ifu_resp_i,            // Instruction memory response\n\n    // IFU <-> EXU New PC interface\n    input   logic                                   exu2ifu_pc_new_req_i,       // New PC request (jumps, branches, traps etc)\n    input   logic [`SCR1_XLEN-1:0]                  exu2ifu_pc_new_i,           // New PC\n\n`ifdef SCR1_DBG_EN\n    // IFU <-> HDU Program Buffer interface\n    input   logic                                   hdu2ifu_pbuf_fetch_i,       // Fetch instructions provided by Program Buffer\n    output  logic                                   ifu2hdu_pbuf_rdy_o,         // Program Buffer Instruction i/f ready\n    input   logic                                   hdu2ifu_pbuf_vd_i,          // Program Buffer Instruction valid\n    input   logic                                   hdu2ifu_pbuf_err_i,         // Program Buffer Instruction i/f error\n    input   logic [SCR1_HDU_CORE_INSTR_WIDTH-1:0]   hdu2ifu_pbuf_instr_i,       // Program Buffer Instruction itself\n`endif // SCR1_DBG_EN\n\n`ifdef SCR1_CLKCTRL_EN\n    output  logic                                   ifu2pipe_imem_txns_pnd_o,   // There are pending imem transactions\n`endif // SCR1_CLKCTRL_EN\n\n    // IFU <-> IDU interface\n    input   logic                                   idu2ifu_rdy_i,              // IDU ready for new data\n    output  logic [`SCR1_IMEM_DWIDTH-1:0]           ifu2idu_instr_o,            // IFU instruction\n    output  logic                                   ifu2idu_imem_err_o,         // Instruction access fault exception\n    output  logic                                   ifu2idu_err_rvi_hi_o,       // 1 - imem fault when trying to fetch second half of an unaligned RVI instruction\n    output  logic                                   ifu2idu_vd_o                // IFU request\n);\n\n//------------------------------------------------------------------------------\n// Local parameters declaration\n//------------------------------------------------------------------------------\n\nlocalparam SCR1_IFU_Q_SIZE_WORD     = 2;\nlocalparam SCR1_IFU_Q_SIZE_HALF     = SCR1_IFU_Q_SIZE_WORD * 2;\nlocalparam SCR1_TXN_CNT_W           = 3;\n\nlocalparam SCR1_IFU_QUEUE_ADR_W     = $clog2(SCR1_IFU_Q_SIZE_HALF);\nlocalparam SCR1_IFU_QUEUE_PTR_W     = SCR1_IFU_QUEUE_ADR_W + 1;\n\nlocalparam SCR1_IFU_Q_FREE_H_W      = $clog2(SCR1_IFU_Q_SIZE_HALF + 1);\nlocalparam SCR1_IFU_Q_FREE_W_W      = $clog2(SCR1_IFU_Q_SIZE_WORD + 1);\n\n//------------------------------------------------------------------------------\n// Local types declaration\n//------------------------------------------------------------------------------\n\ntypedef enum logic {\n    SCR1_IFU_FSM_IDLE,\n    SCR1_IFU_FSM_FETCH\n} type_scr1_ifu_fsm_e;\n\ntypedef enum logic[1:0] {\n    SCR1_IFU_QUEUE_WR_NONE,      // No write to queue\n    SCR1_IFU_QUEUE_WR_FULL,      // Write 32 rdata bits to queue\n    SCR1_IFU_QUEUE_WR_HI         // Write 16 upper rdata bits to queue\n} type_scr1_ifu_queue_wr_e;\n\ntypedef enum logic[1:0] {\n    SCR1_IFU_QUEUE_RD_NONE,      // No queue read\n    SCR1_IFU_QUEUE_RD_HWORD,     // Read halfword\n    SCR1_IFU_QUEUE_RD_WORD       // Read word\n} type_scr1_ifu_queue_rd_e;\n\n`ifdef SCR1_NO_DEC_STAGE\ntypedef enum logic[1:0] {\n    SCR1_BYPASS_NONE,               // No bypass\n    SCR1_BYPASS_RVC,                // Bypass RVC\n    SCR1_BYPASS_RVI_RDATA_QUEUE,    // Bypass RVI, rdata+queue\n    SCR1_BYPASS_RVI_RDATA           // Bypass RVI, rdata only\n} type_scr1_bypass_e;\n`endif // SCR1_NO_DEC_STAGE\n\ntypedef enum logic [2:0] {\n    // SCR1_IFU_INSTR_<UPPER_16_BITS>_<LOWER_16_BITS>\n    SCR1_IFU_INSTR_NONE,                // No valid instruction\n    SCR1_IFU_INSTR_RVI_HI_RVI_LO,       // Full RV32I instruction\n    SCR1_IFU_INSTR_RVC_RVC,\n    SCR1_IFU_INSTR_RVI_LO_RVC,\n    SCR1_IFU_INSTR_RVC_RVI_HI,\n    SCR1_IFU_INSTR_RVI_LO_RVI_HI,\n    SCR1_IFU_INSTR_RVC_NV,              // Instruction after unaligned new_pc\n    SCR1_IFU_INSTR_RVI_LO_NV            // Instruction after unaligned new_pc\n} type_scr1_ifu_instr_e;\n\n//------------------------------------------------------------------------------\n// Local signals declaration\n//------------------------------------------------------------------------------\n\n// Instruction queue signals\n//------------------------------------------------------------------------------\n\n// New PC unaligned flag register\nlogic                               new_pc_unaligned_ff;\nlogic                               new_pc_unaligned_next;\nlogic                               new_pc_unaligned_upd;\n\n// IMEM instruction type decoder\nlogic                               instr_hi_is_rvi;\nlogic                               instr_lo_is_rvi;\ntype_scr1_ifu_instr_e               instr_type;\n\n// Register to store if the previous IMEM instruction had low part of RVI instruction\n// in its high part\nlogic                               instr_hi_rvi_lo_ff;\nlogic                               instr_hi_rvi_lo_next;\n\n// Queue read/write size decoders\ntype_scr1_ifu_queue_rd_e            q_rd_size;\nlogic                               q_rd_vd;\nlogic                               q_rd_none;\nlogic                               q_rd_hword;\ntype_scr1_ifu_queue_wr_e            q_wr_size;\nlogic                               q_wr_none;\nlogic                               q_wr_full;\n\n// Write/read pointer registers\nlogic [SCR1_IFU_QUEUE_PTR_W-1:0]    q_rptr;\nlogic [SCR1_IFU_QUEUE_PTR_W-1:0]    q_rptr_next;\nlogic                               q_rptr_upd;\nlogic [SCR1_IFU_QUEUE_PTR_W-1:0]    q_wptr;\nlogic [SCR1_IFU_QUEUE_PTR_W-1:0]    q_wptr_next;\nlogic                               q_wptr_upd;\n\n// Instruction queue control signals\nlogic                               q_wr_en;\nlogic                               q_flush_req;\n\n// Queue data registers\nlogic [`SCR1_IMEM_DWIDTH/2-1:0]     q_data  [SCR1_IFU_Q_SIZE_HALF];\nlogic [`SCR1_IMEM_DWIDTH/2-1:0]     q_data_head;\nlogic [`SCR1_IMEM_DWIDTH/2-1:0]     q_data_next;\n\n// Queue error flags registers\nlogic                               q_err   [SCR1_IFU_Q_SIZE_HALF];\nlogic                               q_err_head;\nlogic                               q_err_next;\n\n// Instruction queue status signals\nlogic                               q_is_empty;\nlogic                               q_has_free_slots;\nlogic                               q_has_1_ocpd_hw;\nlogic                               q_head_is_rvc;\nlogic                               q_head_is_rvi;\nlogic [SCR1_IFU_Q_FREE_H_W-1:0]     q_ocpd_h;\nlogic [SCR1_IFU_Q_FREE_H_W-1:0]     q_free_h_next;\nlogic [SCR1_IFU_Q_FREE_W_W-1:0]     q_free_w_next;\n\n// IFU FSM signals\n//------------------------------------------------------------------------------\n\n// IFU FSM control signals\nlogic                               ifu_fetch_req;\nlogic                               ifu_stop_req;\n\ntype_scr1_ifu_fsm_e                 ifu_fsm_curr;\ntype_scr1_ifu_fsm_e                 ifu_fsm_next;\nlogic                               ifu_fsm_fetch;\n\n// IMEM signals\n//------------------------------------------------------------------------------\n\n// IMEM response signals\nlogic                               imem_resp_ok;\nlogic                               imem_resp_er;\nlogic                               imem_resp_er_discard_pnd;\nlogic                               imem_resp_discard_req;\nlogic                               imem_resp_received;\nlogic                               imem_resp_vd;\nlogic                               imem_handshake_done;\n\nlogic [15:0]                        imem_rdata_lo;\nlogic [31:16]                       imem_rdata_hi;\n\n// IMEM address signals\nlogic                               imem_addr_upd;\nlogic [`SCR1_XLEN-1:2]              imem_addr_ff;\nlogic [`SCR1_XLEN-1:2]              imem_addr_next;\n\n// IMEM pending transactions counter\nlogic                               imem_pnd_txns_cnt_upd;\nlogic [SCR1_TXN_CNT_W-1:0]          imem_pnd_txns_cnt;\nlogic [SCR1_TXN_CNT_W-1:0]          imem_pnd_txns_cnt_next;\nlogic [SCR1_TXN_CNT_W-1:0]          imem_vd_pnd_txns_cnt;\nlogic                               imem_pnd_txns_q_full;\n\n// IMEM responses discard counter\nlogic                               imem_resp_discard_cnt_upd;\nlogic [SCR1_TXN_CNT_W-1:0]          imem_resp_discard_cnt;\nlogic [SCR1_TXN_CNT_W-1:0]          imem_resp_discard_cnt_next;\n\n`ifdef SCR1_NEW_PC_REG\nlogic                               new_pc_req_ff;\n`endif // SCR1_NEW_PC_REG\n\n// Instruction bypass signals\n`ifdef SCR1_NO_DEC_STAGE\ntype_scr1_bypass_e                  instr_bypass_type;\nlogic                               instr_bypass_vd;\n`endif // SCR1_NO_DEC_STAGE\n\n//------------------------------------------------------------------------------\n// Instruction queue\n//------------------------------------------------------------------------------\n//\n // Instruction queue consists of the following functional units:\n // - New PC unaligned flag register\n // - Instruction type decoder, including register to store if the previous\n //   IMEM instruction had low part of RVI instruction in its high part\n // - Read/write size decoders\n // - Read/write pointer registers\n // - Data and error flag registers\n // - Status logic\n//\n\n// New PC unaligned flag register\n//------------------------------------------------------------------------------\n\nassign new_pc_unaligned_upd = exu2ifu_pc_new_req_i | imem_resp_vd;\n\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        new_pc_unaligned_ff <= 1'b0;\n    end else if (new_pc_unaligned_upd) begin\n        new_pc_unaligned_ff <= new_pc_unaligned_next;\n    end\nend\n\nassign new_pc_unaligned_next = exu2ifu_pc_new_req_i ? exu2ifu_pc_new_i[1]\n                             : ~imem_resp_vd        ? new_pc_unaligned_ff\n                                                    : 1'b0;\n\n// Instruction type decoder\n//------------------------------------------------------------------------------\n\nassign instr_hi_is_rvi = &imem2ifu_rdata_i[17:16];\nassign instr_lo_is_rvi = &imem2ifu_rdata_i[1:0];\n\nalways_comb begin\n    instr_type = SCR1_IFU_INSTR_NONE;\n\n    if (imem_resp_ok & ~imem_resp_discard_req) begin\n        if (new_pc_unaligned_ff) begin\n            instr_type = instr_hi_is_rvi ? SCR1_IFU_INSTR_RVI_LO_NV\n                                         : SCR1_IFU_INSTR_RVC_NV;\n        end else begin // ~new_pc_unaligned_ff\n            if (instr_hi_rvi_lo_ff) begin\n                instr_type = instr_hi_is_rvi ? SCR1_IFU_INSTR_RVI_LO_RVI_HI\n                                             : SCR1_IFU_INSTR_RVC_RVI_HI;\n            end else begin // SCR1_OTHER\n                case ({instr_hi_is_rvi, instr_lo_is_rvi})\n                    2'b00   : instr_type   = SCR1_IFU_INSTR_RVC_RVC;\n                    2'b10   : instr_type   = SCR1_IFU_INSTR_RVI_LO_RVC;\n                    default : instr_type   = SCR1_IFU_INSTR_RVI_HI_RVI_LO;\n                endcase\n            end\n        end\n    end\nend\n\n// Register to store if the previous IMEM instruction had low part of RVI\n// instruction in its high part\n//------------------------------------------------------------------------------\n\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        instr_hi_rvi_lo_ff <= 1'b0;\n    end else begin\n        if (exu2ifu_pc_new_req_i) begin\n            instr_hi_rvi_lo_ff <= 1'b0;\n        end else if (imem_resp_vd) begin\n            instr_hi_rvi_lo_ff <= instr_hi_rvi_lo_next;\n        end\n    end\nend\n\nassign instr_hi_rvi_lo_next = (instr_type == SCR1_IFU_INSTR_RVI_LO_NV)\n                            | (instr_type == SCR1_IFU_INSTR_RVI_LO_RVI_HI)\n                            | (instr_type == SCR1_IFU_INSTR_RVI_LO_RVC);\n\n// Queue write/read size decoders\n//------------------------------------------------------------------------------\n\n// Queue read size decoder\nassign q_rd_vd    = ~q_is_empty & ifu2idu_vd_o & idu2ifu_rdy_i;\nassign q_rd_hword = q_head_is_rvc | q_err_head\n`ifdef SCR1_NO_DEC_STAGE\n                  | (q_head_is_rvi & instr_bypass_vd)\n`endif // SCR1_NO_DEC_STAGE\n                  ;\nassign q_rd_size  = ~q_rd_vd   ? SCR1_IFU_QUEUE_RD_NONE\n                  : q_rd_hword ? SCR1_IFU_QUEUE_RD_HWORD\n                               : SCR1_IFU_QUEUE_RD_WORD;\nassign q_rd_none  = (q_rd_size == SCR1_IFU_QUEUE_RD_NONE);\n\n// Queue write size decoder\nalways_comb begin\n    q_wr_size = SCR1_IFU_QUEUE_WR_NONE;\n    if (~imem_resp_discard_req) begin\n        if (imem_resp_ok) begin\n`ifdef SCR1_NO_DEC_STAGE\n            case (instr_type)\n                SCR1_IFU_INSTR_NONE         : q_wr_size = SCR1_IFU_QUEUE_WR_NONE;\n                SCR1_IFU_INSTR_RVI_LO_NV    : q_wr_size = SCR1_IFU_QUEUE_WR_HI;\n                SCR1_IFU_INSTR_RVC_NV       : q_wr_size = (instr_bypass_vd & idu2ifu_rdy_i)\n                                                        ? SCR1_IFU_QUEUE_WR_NONE\n                                                        : SCR1_IFU_QUEUE_WR_HI;\n                SCR1_IFU_INSTR_RVI_HI_RVI_LO: q_wr_size = (instr_bypass_vd & idu2ifu_rdy_i)\n                                                        ? SCR1_IFU_QUEUE_WR_NONE\n                                                        : SCR1_IFU_QUEUE_WR_FULL;\n                SCR1_IFU_INSTR_RVC_RVC,\n                SCR1_IFU_INSTR_RVI_LO_RVC,\n                SCR1_IFU_INSTR_RVC_RVI_HI,\n                SCR1_IFU_INSTR_RVI_LO_RVI_HI: q_wr_size = (instr_bypass_vd & idu2ifu_rdy_i)\n                                                        ? SCR1_IFU_QUEUE_WR_HI\n                                                        : SCR1_IFU_QUEUE_WR_FULL;\n            endcase // instr_type\n`else // SCR1_NO_DEC_STAGE\n            case (instr_type)\n                SCR1_IFU_INSTR_NONE         : q_wr_size = SCR1_IFU_QUEUE_WR_NONE;\n                SCR1_IFU_INSTR_RVC_NV,\n                SCR1_IFU_INSTR_RVI_LO_NV    : q_wr_size = SCR1_IFU_QUEUE_WR_HI;\n                default                     : q_wr_size = SCR1_IFU_QUEUE_WR_FULL;\n            endcase // instr_type\n`endif // SCR1_NO_DEC_STAGE\n        end else if (imem_resp_er) begin\n            q_wr_size = SCR1_IFU_QUEUE_WR_FULL;\n        end // imem_resp_er\n    end // ~imem_resp_discard_req\nend\n\nassign q_wr_none   = (q_wr_size == SCR1_IFU_QUEUE_WR_NONE);\nassign q_wr_full   = (q_wr_size == SCR1_IFU_QUEUE_WR_FULL);\n\n// Write/read pointer registers\n//------------------------------------------------------------------------------\n\nassign q_flush_req = exu2ifu_pc_new_req_i | pipe2ifu_stop_fetch_i;\n\n// Queue write pointer register\nassign q_wptr_upd  = q_flush_req | ~q_wr_none;\n\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        q_wptr <= '0;\n    end else if (q_wptr_upd) begin\n        q_wptr <= q_wptr_next;\n    end\nend\n\nassign q_wptr_next = q_flush_req ? '0\n                   : ~q_wr_none  ? q_wptr + (q_wr_full ? SCR1_IFU_QUEUE_PTR_W'('b010) : SCR1_IFU_QUEUE_PTR_W'('b001))\n                                 : q_wptr;\n\n// Queue read pointer register\nassign q_rptr_upd  = q_flush_req | ~q_rd_none;\n\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        q_rptr <= '0;\n    end else if (q_rptr_upd) begin\n        q_rptr <= q_rptr_next;\n    end\nend\n\nassign q_rptr_next = q_flush_req ? '0\n                   : ~q_rd_none  ? q_rptr + (q_rd_hword ? SCR1_IFU_QUEUE_PTR_W'('b001) : SCR1_IFU_QUEUE_PTR_W'('b010))\n                                 : q_rptr;\n\n// Queue data and error flag registers\n//------------------------------------------------------------------------------\n\nassign imem_rdata_hi = imem2ifu_rdata_i[31:16];\nassign imem_rdata_lo = imem2ifu_rdata_i[15:0];\n\nassign q_wr_en = imem_resp_vd & ~q_flush_req;\n\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        q_data  <= '{SCR1_IFU_Q_SIZE_HALF{'0}};\n        q_err   <= '{SCR1_IFU_Q_SIZE_HALF{1'b0}};\n    end else if (q_wr_en) begin\n        case (q_wr_size)\n            SCR1_IFU_QUEUE_WR_HI    : begin\n                q_data[SCR1_IFU_QUEUE_ADR_W'(q_wptr)]         <= imem_rdata_hi;\n                q_err [SCR1_IFU_QUEUE_ADR_W'(q_wptr)]         <= imem_resp_er;\n            end\n            SCR1_IFU_QUEUE_WR_FULL  : begin\n                q_data[SCR1_IFU_QUEUE_ADR_W'(q_wptr)]         <= imem_rdata_lo;\n                q_err [SCR1_IFU_QUEUE_ADR_W'(q_wptr)]         <= imem_resp_er;\n                q_data[SCR1_IFU_QUEUE_ADR_W'(q_wptr + 1'b1)]  <= imem_rdata_hi;\n                q_err [SCR1_IFU_QUEUE_ADR_W'(q_wptr + 1'b1)]  <= imem_resp_er;\n            end\n        endcase\n    end\nend\n\nassign q_data_head = q_data [SCR1_IFU_QUEUE_ADR_W'(q_rptr)];\nassign q_data_next = q_data [SCR1_IFU_QUEUE_ADR_W'(q_rptr + 1'b1)];\nassign q_err_head  = q_err  [SCR1_IFU_QUEUE_ADR_W'(q_rptr)];\nassign q_err_next  = q_err  [SCR1_IFU_QUEUE_ADR_W'(q_rptr + 1'b1)];\n\n// Queue status logic\n//------------------------------------------------------------------------------\n\nassign q_ocpd_h         = SCR1_IFU_Q_FREE_H_W'(q_wptr - q_rptr);\nassign q_free_h_next    = SCR1_IFU_Q_FREE_H_W'(SCR1_IFU_Q_SIZE_HALF - (q_wptr - q_rptr_next));\nassign q_free_w_next    = SCR1_IFU_Q_FREE_W_W'(q_free_h_next >> 1'b1);\n\nassign q_is_empty       = (q_rptr == q_wptr);\nassign q_has_free_slots = (SCR1_TXN_CNT_W'(q_free_w_next) > imem_vd_pnd_txns_cnt);\nassign q_has_1_ocpd_hw  = (q_ocpd_h == SCR1_IFU_Q_FREE_H_W'(1));\n\nassign q_head_is_rvi    = &(q_data_head[1:0]);\nassign q_head_is_rvc    = ~q_head_is_rvi;\n\n//------------------------------------------------------------------------------\n// IFU FSM\n//------------------------------------------------------------------------------\n\n// IFU FSM control signals\nassign ifu_fetch_req = exu2ifu_pc_new_req_i & ~pipe2ifu_stop_fetch_i;\nassign ifu_stop_req  = pipe2ifu_stop_fetch_i\n                     | (imem_resp_er_discard_pnd & ~exu2ifu_pc_new_req_i);\n\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        ifu_fsm_curr <= SCR1_IFU_FSM_IDLE;\n    end else begin\n        ifu_fsm_curr <= ifu_fsm_next;\n    end\nend\n\nalways_comb begin\n    case (ifu_fsm_curr)\n        SCR1_IFU_FSM_IDLE   : begin\n            ifu_fsm_next = ifu_fetch_req ? SCR1_IFU_FSM_FETCH\n    "}
{"text": "                                     : SCR1_IFU_FSM_IDLE;\n        end\n        SCR1_IFU_FSM_FETCH  : begin\n            ifu_fsm_next = ifu_stop_req  ? SCR1_IFU_FSM_IDLE\n                                         : SCR1_IFU_FSM_FETCH;\n        end\n    endcase\nend\n\nassign ifu_fsm_fetch = (ifu_fsm_curr == SCR1_IFU_FSM_FETCH);\n\n//------------------------------------------------------------------------------\n// IFU <-> IMEM interface\n//------------------------------------------------------------------------------\n//\n // IFU <-> IMEM interface consists of the following functional units:\n // - IMEM response logic\n // - IMEM address register\n // - Pending IMEM transactions counter\n // - IMEM discard responses counter\n // - IFU <-> IMEM interface output signals\n//\n\n// IMEM response logic\n//------------------------------------------------------------------------------\n\nassign imem_resp_er             = (imem2ifu_resp_i == SCR1_MEM_RESP_RDY_ER);\nassign imem_resp_ok             = (imem2ifu_resp_i == SCR1_MEM_RESP_RDY_OK);\nassign imem_resp_received       = imem_resp_ok | imem_resp_er;\nassign imem_resp_vd             = imem_resp_received & ~imem_resp_discard_req;\nassign imem_resp_er_discard_pnd = imem_resp_er & ~imem_resp_discard_req;\n\nassign imem_handshake_done = ifu2imem_req_o & imem2ifu_req_ack_i;\n\n// IMEM address register\n//------------------------------------------------------------------------------\n\nassign imem_addr_upd = imem_handshake_done | exu2ifu_pc_new_req_i;\n\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        imem_addr_ff <= '0;\n    end else if (imem_addr_upd) begin\n        imem_addr_ff <= imem_addr_next;\n    end\nend\n\n`ifndef SCR1_NEW_PC_REG\nassign imem_addr_next = exu2ifu_pc_new_req_i ? exu2ifu_pc_new_i[`SCR1_XLEN-1:2]                 + imem_handshake_done\n                      : &imem_addr_ff[5:2]   ? imem_addr_ff                                     + imem_handshake_done\n                                             : {imem_addr_ff[`SCR1_XLEN-1:6], imem_addr_ff[5:2] + imem_handshake_done};\n`else // SCR1_NEW_PC_REG\nassign imem_addr_next = exu2ifu_pc_new_req_i ? exu2ifu_pc_new_i[`SCR1_XLEN-1:2]\n                      : &imem_addr_ff[5:2]   ? imem_addr_ff                                     + imem_handshake_done\n                                             : {imem_addr_ff[`SCR1_XLEN-1:6], imem_addr_ff[5:2] + imem_handshake_done};\n`endif // SCR1_NEW_PC_REG\n\n// Pending IMEM transactions counter\n//------------------------------------------------------------------------------\n// Pending IMEM transactions occur if IFU request has been acknowledged, but\n// response comes in the next cycle or later\n\nassign imem_pnd_txns_cnt_upd  = imem_handshake_done ^ imem_resp_received;\n\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        imem_pnd_txns_cnt <= '0;\n    end else if (imem_pnd_txns_cnt_upd) begin\n        imem_pnd_txns_cnt <= imem_pnd_txns_cnt_next;\n    end\nend\n\nassign imem_pnd_txns_cnt_next = imem_pnd_txns_cnt + (imem_handshake_done - imem_resp_received);\nassign imem_pnd_txns_q_full   = &imem_pnd_txns_cnt;\n\n// IMEM discard responses counter\n//------------------------------------------------------------------------------\n// IMEM instructions should be discarded in the following 2 cases:\n// 1. New PC is requested by jump, branch, mret or other instruction\n// 2. IMEM response was erroneous and not discarded\n//\n// In both cases the number of instructions to be discarded equals to the number\n// of pending instructions.\n// In the 1st case we don't need all the instructions that haven't been fetched\n// yet, since the PC has changed.\n// In the 2nd case, since the IMEM responce was erroneous there is no guarantee\n// that subsequent IMEM instructions would be valid.\n\nassign imem_resp_discard_cnt_upd = exu2ifu_pc_new_req_i | imem_resp_er\n                                 | (imem_resp_ok & imem_resp_discard_req);\n\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        imem_resp_discard_cnt <= '0;\n    end else if (imem_resp_discard_cnt_upd) begin\n        imem_resp_discard_cnt <= imem_resp_discard_cnt_next;\n    end\nend\n\n`ifndef SCR1_NEW_PC_REG\nassign imem_resp_discard_cnt_next = exu2ifu_pc_new_req_i     ? imem_pnd_txns_cnt_next - imem_handshake_done\n                                  : imem_resp_er_discard_pnd ? imem_pnd_txns_cnt_next\n                                                             : imem_resp_discard_cnt - 1'b1;\n`else // SCR1_NEW_PC_REG\nassign imem_resp_discard_cnt_next = exu2ifu_pc_new_req_i | imem_resp_er_discard_pnd\n                                  ? imem_pnd_txns_cnt_next\n                                  : imem_resp_discard_cnt - 1'b1;\n`endif // SCR1_NEW_PC_REG\n\nassign imem_vd_pnd_txns_cnt  = imem_pnd_txns_cnt - imem_resp_discard_cnt;\nassign imem_resp_discard_req = |imem_resp_discard_cnt;\n\n// IFU <-> IMEM interface output signals\n//------------------------------------------------------------------------------\n\n`ifndef SCR1_NEW_PC_REG\nassign ifu2imem_req_o  = (exu2ifu_pc_new_req_i & ~imem_pnd_txns_q_full & ~pipe2ifu_stop_fetch_i)\n                       | (ifu_fsm_fetch        & ~imem_pnd_txns_q_full & q_has_free_slots);\nassign ifu2imem_addr_o = exu2ifu_pc_new_req_i\n                       ? {exu2ifu_pc_new_i[`SCR1_XLEN-1:2], 2'b00}\n                       : {imem_addr_ff, 2'b00};\n`else // SCR1_NEW_PC_REG\nassign ifu2imem_req_o  = ifu_fsm_fetch & ~imem_pnd_txns_q_full & q_has_free_slots;\nassign ifu2imem_addr_o = {imem_addr_ff, 2'b00};\n`endif // SCR1_NEW_PC_REG\n\nassign ifu2imem_cmd_o  = SCR1_MEM_CMD_RD;\n\n`ifdef SCR1_CLKCTRL_EN\nassign ifu2pipe_imem_txns_pnd_o = |imem_pnd_txns_cnt;\n`endif // SCR1_CLKCTRL_EN\n\n//------------------------------------------------------------------------------\n// IFU <-> IDU interface\n//------------------------------------------------------------------------------\n//\n // IFU <-> IDU interface consists of the following functional units:\n // - Instruction bypass type decoder\n // - IFU <-> IDU status signals\n // - Output instruction multiplexer\n//\n\n`ifdef SCR1_NO_DEC_STAGE\n\n// Instruction bypass type decoder\n//------------------------------------------------------------------------------\n\nassign instr_bypass_vd  = (instr_bypass_type != SCR1_BYPASS_NONE);\n\nalways_comb begin\n    instr_bypass_type    = SCR1_BYPASS_NONE;\n\n    if (imem_resp_vd) begin\n        if (q_is_empty) begin\n            case (instr_type)\n                SCR1_IFU_INSTR_RVC_NV,\n                SCR1_IFU_INSTR_RVC_RVC,\n                SCR1_IFU_INSTR_RVI_LO_RVC       : begin\n                    instr_bypass_type = SCR1_BYPASS_RVC;\n                end\n                SCR1_IFU_INSTR_RVI_HI_RVI_LO    : begin\n                    instr_bypass_type = SCR1_BYPASS_RVI_RDATA;\n                end\n                default : begin end\n            endcase // instr_type\n        end else if (q_has_1_ocpd_hw & q_head_is_rvi) begin\n            if (instr_hi_rvi_lo_ff) begin\n                instr_bypass_type = SCR1_BYPASS_RVI_RDATA_QUEUE;\n            end\n        end\n    end // imem_resp_vd\nend\n\n// IFU <-> IDU interface status signals\n//------------------------------------------------------------------------------\n\nalways_comb begin\n    ifu2idu_vd_o         = 1'b0;\n    ifu2idu_imem_err_o   = 1'b0;\n    ifu2idu_err_rvi_hi_o = 1'b0;\n\n    if (ifu_fsm_fetch | ~q_is_empty) begin\n        if (instr_bypass_vd) begin\n            ifu2idu_vd_o          = 1'b1;\n            ifu2idu_imem_err_o    = (instr_bypass_type == SCR1_BYPASS_RVI_RDATA_QUEUE)\n                                  ? (imem_resp_er | q_err_head)\n                                  : imem_resp_er;\n            ifu2idu_err_rvi_hi_o  = (instr_bypass_type == SCR1_BYPASS_RVI_RDATA_QUEUE) & imem_resp_er;\n        end else if (~q_is_empty) begin\n            if (q_has_1_ocpd_hw) begin\n                ifu2idu_vd_o         = q_head_is_rvc | q_err_head;\n                ifu2idu_imem_err_o   = q_err_head;\n                ifu2idu_err_rvi_hi_o = ~q_err_head & q_head_is_rvi & q_err_next;\n            end else begin\n                ifu2idu_vd_o         = 1'b1;\n                ifu2idu_imem_err_o   = q_err_head ? 1'b1 : (q_head_is_rvi & q_err_next);\n            end\n        end // ~q_is_empty\n    end\n`ifdef SCR1_DBG_EN\n    if (hdu2ifu_pbuf_fetch_i) begin\n        ifu2idu_vd_o          = hdu2ifu_pbuf_vd_i;\n        ifu2idu_imem_err_o    = hdu2ifu_pbuf_err_i;\n    end\n`endif // SCR1_DBG_EN\nend\n\n// Output instruction multiplexer\n//------------------------------------------------------------------------------\n\nalways_comb begin\n    case (instr_bypass_type)\n        SCR1_BYPASS_RVC            : begin\n            ifu2idu_instr_o = `SCR1_IMEM_DWIDTH'(new_pc_unaligned_ff ? imem_rdata_hi\n                                                                     : imem_rdata_lo);\n        end\n        SCR1_BYPASS_RVI_RDATA      : begin\n            ifu2idu_instr_o = imem2ifu_rdata_i;\n        end\n        SCR1_BYPASS_RVI_RDATA_QUEUE: begin\n            ifu2idu_instr_o = {imem_rdata_lo, q_data_head};\n        end\n        default                    : begin\n            ifu2idu_instr_o = `SCR1_IMEM_DWIDTH'(q_head_is_rvc ? q_data_head\n                                                               : {q_data_next, q_data_head});\n        end\n    endcase // instr_bypass_type\n`ifdef SCR1_DBG_EN\n    if (hdu2ifu_pbuf_fetch_i) begin\n        ifu2idu_instr_o = `SCR1_IMEM_DWIDTH'({'0, hdu2ifu_pbuf_instr_i});\n    end\n`endif // SCR1_DBG_EN\nend\n\n`else   // SCR1_NO_DEC_STAGE\n\n// IFU <-> IDU interface status signals\n//------------------------------------------------------------------------------\n\nalways_comb begin\n    ifu2idu_vd_o          = 1'b0;\n    ifu2idu_imem_err_o    = 1'b0;\n    ifu2idu_err_rvi_hi_o  = 1'b0;\n    if (~q_is_empty) begin\n        if (q_has_1_ocpd_hw) begin\n            ifu2idu_vd_o          = q_head_is_rvc | q_err_head;\n            ifu2idu_imem_err_o    = q_err_head;\n        end else begin\n            ifu2idu_vd_o          = 1'b1;\n            ifu2idu_imem_err_o    = q_err_head ? 1'b1 : (q_head_is_rvi & q_err_next);\n            ifu2idu_err_rvi_hi_o  = ~q_err_head & q_head_is_rvi & q_err_next;\n        end\n    end // ~q_is_empty\n`ifdef SCR1_DBG_EN\n    if (hdu2ifu_pbuf_fetch_i) begin\n        ifu2idu_vd_o          = hdu2ifu_pbuf_vd_i;\n        ifu2idu_imem_err_o    = hdu2ifu_pbuf_err_i;\n    end\n`endif // SCR1_DBG_EN\nend\n\n// Output instruction multiplexer\n//------------------------------------------------------------------------------\n\nalways_comb begin\n    ifu2idu_instr_o = q_head_is_rvc ? `SCR1_IMEM_DWIDTH'(q_data_head)\n                                    : {q_data_next, q_data_head};\n`ifdef SCR1_DBG_EN\n    if (hdu2ifu_pbuf_fetch_i) begin\n        ifu2idu_instr_o = `SCR1_IMEM_DWIDTH'({'0, hdu2ifu_pbuf_instr_i});\n    end\n`endif // SCR1_DBG_EN\nend\n\n`endif  // SCR1_NO_DEC_STAGE\n\n`ifdef SCR1_DBG_EN\nassign ifu2hdu_pbuf_rdy_o = idu2ifu_rdy_i;\n`endif // SCR1_DBG_EN\n\n`ifdef SCR1_TRGT_SIMULATION\n\n//------------------------------------------------------------------------------\n// Assertions\n//------------------------------------------------------------------------------\n\n// X checks\n\nSCR1_SVA_IFU_XCHECK : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    !$isunknown({imem2ifu_req_ack_i, idu2ifu_rdy_i, exu2ifu_pc_new_req_i})\n    ) else $error(\"IFU Error: unknown values\");\n\nSCR1_SVA_IFU_XCHECK_REQ : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    ifu2imem_req_o |-> !$isunknown({ifu2imem_addr_o, ifu2imem_cmd_o})\n    ) else $error(\"IFU Error: unknown {ifu2imem_addr_o, ifu2imem_cmd_o}\");\n\n// Behavior checks\n\nSCR1_SVA_IFU_DRC_UNDERFLOW : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    ~imem_resp_discard_req |=> ~(imem_resp_discard_cnt == SCR1_TXN_CNT_W'('1))\n    ) else $error(\"IFU Error: imem_resp_discard_cnt underflow\");\n\nSCR1_SVA_IFU_DRC_RANGE : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    (imem_resp_discard_cnt >= 0) & (imem_resp_discard_cnt <= imem_pnd_txns_cnt)\n    ) else $error(\"IFU Error: imem_resp_discard_cnt out of range\");\n\nSCR1_SVA_IFU_QUEUE_OVF : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    (q_ocpd_h >= SCR1_IFU_Q_FREE_H_W'(SCR1_IFU_Q_SIZE_HALF-1)) |->\n    ((q_ocpd_h == SCR1_IFU_Q_FREE_H_W'(SCR1_IFU_Q_SIZE_HALF-1)) ? (q_wr_size != SCR1_IFU_QUEUE_WR_FULL)\n                                                                : (q_wr_size == SCR1_IFU_QUEUE_WR_NONE))\n    ) else $error(\"IFU Error: queue overflow\");\n\nSCR1_SVA_IFU_IMEM_ERR_BEH : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    (imem_resp_er & ~imem_resp_discard_req & ~exu2ifu_pc_new_req_i) |=>\n    (ifu_fsm_curr == SCR1_IFU_FSM_IDLE) & (imem_resp_discard_cnt == imem_pnd_txns_cnt)\n    ) else $error(\"IFU Error: incorrect behavior after memory error\");\n\nSCR1_SVA_IFU_NEW_PC_REQ_BEH : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    exu2ifu_pc_new_req_i |=> q_is_empty\n    ) else $error(\"IFU Error: incorrect behavior after exu2ifu_pc_new_req_i\");\n\nSCR1_SVA_IFU_IMEM_ADDR_ALIGNED : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    ifu2imem_req_o |-> ~|ifu2imem_addr_o[1:0]\n    ) else $error(\"IFU Error: unaligned IMEM access\");\n\nSCR1_SVA_IFU_STOP_FETCH : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    pipe2ifu_stop_fetch_i |=> (ifu_fsm_curr == SCR1_IFU_FSM_IDLE)\n    ) else $error(\"IFU Error: fetch not stopped\");\n\nSCR1_SVA_IFU_IMEM_FAULT_RVI_HI : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    ifu2idu_err_rvi_hi_o |-> ifu2idu_imem_err_o\n    ) else $error(\"IFU Error: ifu2idu_imem_err_o == 0\");\n\n`endif // SCR1_TRGT_SIMULATION\n\nendmodule : scr1_pipe_ifu\n"}
{"text": "/// Copyright by Syntacore LLC \u00a9 2016-2021. See LICENSE for details\n/// @file       <scr1_pipe_lsu.sv>\n/// @brief      Load/Store Unit (LSU)\n///\n\n//------------------------------------------------------------------------------\n //\n // Functionality:\n // - Performs load and store operations in Data Memory\n // - Generates DMEM address misalign and access fault exceptions\n // - Passes DMEM operations information to TDU and generates LSU breakpoint exception\n //\n // Structure:\n // - FSM\n // - Exceptions logic\n // - LSU <-> EXU interface\n // - LSU <-> DMEM interface\n // - LSU <-> TDU interface\n //\n//------------------------------------------------------------------------------\n\n`include \"scr1_arch_description.svh\"\n`include \"scr1_arch_types.svh\"\n`include \"scr1_memif.svh\"\n`include \"scr1_riscv_isa_decoding.svh\"\n`ifdef SCR1_TDU_EN\n`include \"scr1_tdu.svh\"\n`endif // SCR1_TDU_EN\n\nmodule scr1_pipe_lsu (\n    // Common\n    input   logic                               rst_n,                      // LSU reset\n    input   logic                               clk,                        // LSU clock\n\n    // LSU <-> EXU interface\n    input   logic                               exu2lsu_req_i,              // Request to LSU\n    input   type_scr1_lsu_cmd_sel_e             exu2lsu_cmd_i,              // LSU command\n    input   logic [`SCR1_XLEN-1:0]              exu2lsu_addr_i,             // Address of DMEM\n    input   logic [`SCR1_XLEN-1:0]              exu2lsu_sdata_i,            // Data for store\n    output  logic                               lsu2exu_rdy_o,              // LSU received DMEM response\n    output  logic [`SCR1_XLEN-1:0]              lsu2exu_ldata_o,            // Load data\n    output  logic                               lsu2exu_exc_o,              // Exception from LSU\n    output  type_scr1_exc_code_e                lsu2exu_exc_code_o,         // Exception code\n\n`ifdef SCR1_TDU_EN\n    // LSU <-> TDU interface\n    output  type_scr1_brkm_lsu_mon_s            lsu2tdu_dmon_o,             // Data address stream monitoring\n    input   logic                               tdu2lsu_ibrkpt_exc_req_i,   // Instruction BP exception request\n    input   logic                               tdu2lsu_dbrkpt_exc_req_i,   // Data BP exception request\n`endif // SCR1_TDU_EN\n\n    // LSU <-> DMEM interface\n    output  logic                               lsu2dmem_req_o,             // Data memory request\n    output  type_scr1_mem_cmd_e                 lsu2dmem_cmd_o,             // Data memory command (READ/WRITE)\n    output  type_scr1_mem_width_e               lsu2dmem_width_o,           // Data memory data width\n    output  logic [`SCR1_DMEM_AWIDTH-1:0]       lsu2dmem_addr_o,            // Data memory address\n    output  logic [`SCR1_DMEM_DWIDTH-1:0]       lsu2dmem_wdata_o,           // Data memory write data\n    input   logic                               dmem2lsu_req_ack_i,         // Data memory request acknowledge\n    input   logic [`SCR1_DMEM_DWIDTH-1:0]       dmem2lsu_rdata_i,           // Data memory read data\n    input   type_scr1_mem_resp_e                dmem2lsu_resp_i             // Data memory response\n);\n\n//------------------------------------------------------------------------------\n// Local types declaration\n//------------------------------------------------------------------------------\n\ntypedef enum logic {\n    SCR1_LSU_FSM_IDLE,\n    SCR1_LSU_FSM_BUSY\n} type_scr1_lsu_fsm_e;\n\n//------------------------------------------------------------------------------\n// Local signals declaration\n//------------------------------------------------------------------------------\n\n// LSU FSM signals\ntype_scr1_lsu_fsm_e         lsu_fsm_curr;       // LSU FSM current state\ntype_scr1_lsu_fsm_e         lsu_fsm_next;       // LSU FSM next state\nlogic                       lsu_fsm_idle;       // LSU FSM is in IDLE state\n\n// LSU Command register signals\nlogic                       lsu_cmd_upd;        // LSU Command register update\ntype_scr1_lsu_cmd_sel_e     lsu_cmd_ff;         // LSU Command register value\nlogic                       lsu_cmd_ff_load;    // Registered LSU Command is load\nlogic                       lsu_cmd_ff_store;   // Registered LSU Command is store\n\n// DMEM command and width flags\nlogic                       dmem_cmd_load;      // DMEM command is load\nlogic                       dmem_cmd_store;     // DMEM Command is store\nlogic                       dmem_wdth_word;     // DMEM data width is WORD\nlogic                       dmem_wdth_hword;    // DMEM data width is HALFWORD\nlogic                       dmem_wdth_byte;     // DMEM data width is BYTE\n\n// DMEM response and request control signals\nlogic                       dmem_resp_ok;       // DMEM response is OK\nlogic                       dmem_resp_er;       // DMEM response is erroneous\nlogic                       dmem_resp_received; // DMEM response is received\nlogic                       dmem_req_vd;        // DMEM request is valid (req_ack received)\n\n// Exceptions signals\nlogic                       lsu_exc_req;        // LSU exception request\nlogic                       dmem_addr_mslgn;    // DMEM address is misaligned\nlogic                       dmem_addr_mslgn_l;  // DMEM load address is misaligned\nlogic                       dmem_addr_mslgn_s;  // DMEM store address is misaligned\n`ifdef SCR1_TDU_EN\nlogic                       lsu_exc_hwbrk;      // LSU hardware breakpoint exception\n`endif // SCR1_TDU_EN\n\n//------------------------------------------------------------------------------\n// Control logic\n//------------------------------------------------------------------------------\n\n// DMEM response and request control signals\nassign dmem_resp_ok       = (dmem2lsu_resp_i == SCR1_MEM_RESP_RDY_OK);\nassign dmem_resp_er       = (dmem2lsu_resp_i == SCR1_MEM_RESP_RDY_ER);\nassign dmem_resp_received = dmem_resp_ok | dmem_resp_er;\nassign dmem_req_vd        = exu2lsu_req_i & dmem2lsu_req_ack_i & ~lsu_exc_req;\n\n// LSU load and store command flags\nassign dmem_cmd_load  = (exu2lsu_cmd_i == SCR1_LSU_CMD_LB )\n                      | (exu2lsu_cmd_i == SCR1_LSU_CMD_LBU)\n                      | (exu2lsu_cmd_i == SCR1_LSU_CMD_LH )\n                      | (exu2lsu_cmd_i == SCR1_LSU_CMD_LHU)\n                      | (exu2lsu_cmd_i == SCR1_LSU_CMD_LW );\nassign dmem_cmd_store = (exu2lsu_cmd_i == SCR1_LSU_CMD_SB )\n                      | (exu2lsu_cmd_i == SCR1_LSU_CMD_SH )\n                      | (exu2lsu_cmd_i == SCR1_LSU_CMD_SW );\n\n// LSU data width flags\nassign dmem_wdth_word  = (exu2lsu_cmd_i == SCR1_LSU_CMD_LW )\n                       | (exu2lsu_cmd_i == SCR1_LSU_CMD_SW );\nassign dmem_wdth_hword = (exu2lsu_cmd_i == SCR1_LSU_CMD_LH )\n                       | (exu2lsu_cmd_i == SCR1_LSU_CMD_LHU)\n                       | (exu2lsu_cmd_i == SCR1_LSU_CMD_SH );\nassign dmem_wdth_byte  = (exu2lsu_cmd_i == SCR1_LSU_CMD_LB )\n                       | (exu2lsu_cmd_i == SCR1_LSU_CMD_LBU)\n                       | (exu2lsu_cmd_i == SCR1_LSU_CMD_SB );\n\n// LSU command register\nassign lsu_cmd_upd = lsu_fsm_idle & dmem_req_vd;\n\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        lsu_cmd_ff <= SCR1_LSU_CMD_NONE;\n    end else if (lsu_cmd_upd) begin\n        lsu_cmd_ff <= exu2lsu_cmd_i;\n    end\nend\n\n// LSU registered load and store command flags\nassign lsu_cmd_ff_load  = (lsu_cmd_ff == SCR1_LSU_CMD_LB )\n                        | (lsu_cmd_ff == SCR1_LSU_CMD_LBU)\n                        | (lsu_cmd_ff == SCR1_LSU_CMD_LH )\n                        | (lsu_cmd_ff == SCR1_LSU_CMD_LHU)\n                        | (lsu_cmd_ff == SCR1_LSU_CMD_LW );\nassign lsu_cmd_ff_store = (lsu_cmd_ff == SCR1_LSU_CMD_SB )\n                        | (lsu_cmd_ff == SCR1_LSU_CMD_SH )\n                        | (lsu_cmd_ff == SCR1_LSU_CMD_SW );\n\n//------------------------------------------------------------------------------\n// LSU FSM\n//------------------------------------------------------------------------------\n //\n // LSU FSM is used to control the LSU <-> DMEM interface\n //\n//\n\n// Updating LSU FSM state\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        lsu_fsm_curr <= SCR1_LSU_FSM_IDLE;\n    end else begin\n        lsu_fsm_curr <= lsu_fsm_next;\n    end\nend\n\n// LSU FSM next state logic\nalways_comb begin\n    case (lsu_fsm_curr)\n        SCR1_LSU_FSM_IDLE: begin\n            lsu_fsm_next = dmem_req_vd        ? SCR1_LSU_FSM_BUSY\n                                              : SCR1_LSU_FSM_IDLE;\n        end\n        SCR1_LSU_FSM_BUSY: begin\n            lsu_fsm_next = dmem_resp_received ? SCR1_LSU_FSM_IDLE\n                                              : SCR1_LSU_FSM_BUSY;\n        end\n    endcase\nend\n\nassign lsu_fsm_idle = (lsu_fsm_curr == SCR1_LSU_FSM_IDLE);\n\n//------------------------------------------------------------------------------\n// Exceptions logic\n//------------------------------------------------------------------------------\n //\n // The following types of exceptions are supported:\n // - Load address misalign\n // - Load access fault\n // - Store address misalign\n // - Store access fault\n // - LSU breakpoint exception\n//\n\n// DMEM addr misalign logic\nassign dmem_addr_mslgn   = exu2lsu_req_i & ( (dmem_wdth_hword & exu2lsu_addr_i[0])\n                                           | (dmem_wdth_word  & |exu2lsu_addr_i[1:0]));\nassign dmem_addr_mslgn_l = dmem_addr_mslgn & dmem_cmd_load;\nassign dmem_addr_mslgn_s = dmem_addr_mslgn & dmem_cmd_store;\n\n// Exception code logic\nalways_comb begin\n    case (1'b1)\n        dmem_resp_er     : lsu2exu_exc_code_o = lsu_cmd_ff_load  ? SCR1_EXC_CODE_LD_ACCESS_FAULT\n                                              : lsu_cmd_ff_store ? SCR1_EXC_CODE_ST_ACCESS_FAULT\n                                                                 : SCR1_EXC_CODE_INSTR_MISALIGN;\n`ifdef SCR1_TDU_EN\n        lsu_exc_hwbrk    : lsu2exu_exc_code_o = SCR1_EXC_CODE_BREAKPOINT;\n`endif // SCR1_TDU_EN\n        dmem_addr_mslgn_l: lsu2exu_exc_code_o = SCR1_EXC_CODE_LD_ADDR_MISALIGN;\n        dmem_addr_mslgn_s: lsu2exu_exc_code_o = SCR1_EXC_CODE_ST_ADDR_MISALIGN;\n        default          : lsu2exu_exc_code_o = SCR1_EXC_CODE_INSTR_MISALIGN;\n    endcase // 1'b1\nend\n\nassign lsu_exc_req = dmem_addr_mslgn_l | dmem_addr_mslgn_s\n`ifdef SCR1_TDU_EN\n                   | lsu_exc_hwbrk\n`endif // SCR1_TDU_EN\n;\n\n//------------------------------------------------------------------------------\n// LSU <-> EXU interface\n//------------------------------------------------------------------------------\n\nassign lsu2exu_rdy_o = dmem_resp_received;\nassign lsu2exu_exc_o = dmem_resp_er | lsu_exc_req;\n\n// Sign- or zero-extending data received from DMEM\nalways_comb begin\n    case (lsu_cmd_ff)\n        SCR1_LSU_CMD_LH : lsu2exu_ldata_o = {{16{dmem2lsu_rdata_i[15]}}, dmem2lsu_rdata_i[15:0]};\n        SCR1_LSU_CMD_LHU: lsu2exu_ldata_o = { 16'b0,                     dmem2lsu_rdata_i[15:0]};\n        SCR1_LSU_CMD_LB : lsu2exu_ldata_o = {{24{dmem2lsu_rdata_i[7]}},  dmem2lsu_rdata_i[7:0]};\n        SCR1_LSU_CMD_LBU: lsu2exu_ldata_o = { 24'b0,                     dmem2lsu_rdata_i[7:0]};\n        default         : lsu2exu_ldata_o = dmem2lsu_rdata_i;\n    endcase // lsu_cmd_ff\nend\n\n//------------------------------------------------------------------------------\n// LSU <-> DMEM interface\n//------------------------------------------------------------------------------\n\nassign lsu2dmem_req_o   = exu2lsu_req_i & ~lsu_exc_req & lsu_fsm_idle;\nassign lsu2dmem_addr_o  = exu2lsu_addr_i;\nassign lsu2dmem_wdata_o = exu2lsu_sdata_i;\nassign lsu2dmem_cmd_o   = dmem_cmd_store  ? SCR1_MEM_CMD_WR : SCR1_MEM_CMD_RD;\nassign lsu2dmem_width_o = dmem_wdth_byte  ? SCR1_MEM_WIDTH_BYTE\n                        : dmem_wdth_hword ? SCR1_MEM_WIDTH_HWORD\n                                          : SCR1_MEM_WIDTH_WORD;\n\n`ifdef SCR1_TDU_EN\n//------------------------------------------------------------------------------\n// LSU <-> TDU interface\n//------------------------------------------------------------------------------\n\nassign lsu2tdu_dmon_o.vd    = exu2lsu_req_i & lsu_fsm_idle & ~tdu2lsu_ibrkpt_exc_req_i;\nassign lsu2tdu_dmon_o.addr  = exu2lsu_addr_i;\nassign lsu2tdu_dmon_o.load  = dmem_cmd_load;\nassign lsu2tdu_dmon_o.store = dmem_cmd_store;\n\nassign lsu_exc_hwbrk = (exu2lsu_req_i & tdu2lsu_ibrkpt_exc_req_i)\n                     | tdu2lsu_dbrkpt_exc_req_i;\n\n`endif // SCR1_TDU_EN\n\n`ifdef SCR1_TRGT_SIMULATION\n//------------------------------------------------------------------------------\n// Assertions\n//------------------------------------------------------------------------------\n\n// X checks\n\nSCR1_SVA_LSU_XCHECK_CTRL : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    !$isunknown({exu2lsu_req_i, lsu_fsm_curr\n`ifdef SCR1_TDU_EN\n        , tdu2lsu_ibrkpt_exc_req_i, tdu2lsu_dbrkpt_exc_req_i\n`endif // SCR1_TDU_EN\n    })\n    ) else $error(\"LSU Error: unknown control value\");\n\nSCR1_SVA_LSU_XCHECK_CMD : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    exu2lsu_req_i |-> !$isunknown({exu2lsu_cmd_i, exu2lsu_addr_i})\n    ) else $error(\"LSU Error: undefined CMD or address\");\n\nSCR1_SVA_LSU_XCHECK_SDATA : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    (exu2lsu_req_i & (lsu2dmem_cmd_o == SCR1_MEM_CMD_WR)) |-> !$isunknown({exu2lsu_sdata_i})\n    ) else $error(\"LSU Error: undefined store data\");\n\nSCR1_SVA_LSU_XCHECK_EXC : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    lsu2exu_exc_o |-> !$isunknown(lsu2exu_exc_code_o)\n    ) else $error(\"LSU Error: exception code undefined\");\n\nSCR1_SVA_LSU_IMEM_CTRL : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    lsu2dmem_req_o |-> !$isunknown({lsu2dmem_cmd_o, lsu2dmem_width_o, lsu2dmem_addr_o})\n    ) else $error(\"LSU Error: undefined dmem control\");\n\nSCR1_SVA_LSU_IMEM_ACK : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    lsu2dmem_req_o |-> !$isunknown(dmem2lsu_req_ack_i)\n    ) else $error(\"LSU Error: undefined dmem ack\");\n\nSCR1_SVA_LSU_IMEM_WDATA : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    lsu2dmem_req_o & (lsu2dmem_cmd_o == SCR1_MEM_CMD_WR)\n    |-> !$isunknown(lsu2dmem_wdata_o[8:0])\n    ) else $error(\"LSU Error: undefined dmem wdata\");\n\n// Behavior checks\n\nSCR1_SVA_LSU_EXC_ONEHOT : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    $onehot0({dmem_resp_er, dmem_addr_mslgn_l, dmem_addr_mslgn_s})\n    ) else $error(\"LSU Error: more than one exception at a time\");\n\nSCR1_SVA_LSU_UNEXPECTED_DMEM_RESP : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    lsu_fsm_idle |-> ~dmem_resp_received\n    ) else $error(\"LSU Error: not expecting memory response\");\n\nSCR1_SVA_LSU_REQ_EXC : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    lsu2exu_exc_o |-> exu2lsu_req_i\n    ) else $error(\"LSU Error: impossible exception\");\n\n`ifdef SCR1_TDU_EN\n\nSCR1_COV_LSU_MISALIGN_BRKPT : cover property (\n    @(negedge clk) disable iff (~rst_n)\n    (dmem_addr_mslgn_l | dmem_addr_mslgn_s) & lsu_exc_hwbrk\n);\n`endif // SCR1_TDU_EN\n\n`endif // SCR1_TRGT_SIMULATION\n\nendmodule : scr1_pipe_lsu\n"}
{"text": "/// Copyright by Syntacore LLC \u00a9 2016-2021. See LICENSE for details\n/// @file       <scr1_pipe_mprf.sv>\n/// @brief      Multi Port Register File (MPRF)\n///\n\n`include \"scr1_arch_description.svh\"\n`include \"scr1_arch_types.svh\"\n\nmodule scr1_pipe_mprf (\n    // Common\n`ifdef SCR1_MPRF_RST_EN\n    input   logic                               rst_n,                      // MPRF reset\n`endif // SCR1_MPRF_RST_EN\n    input   logic                               clk,                        // MPRF clock\n\n    // EXU <-> MPRF interface\n    input   logic [`SCR1_MPRF_AWIDTH-1:0]       exu2mprf_rs1_addr_i,        // MPRF rs1 read address\n    output  logic [`SCR1_XLEN-1:0]              mprf2exu_rs1_data_o,        // MPRF rs1 read data\n    input   logic [`SCR1_MPRF_AWIDTH-1:0]       exu2mprf_rs2_addr_i,        // MPRF rs2 read address\n    output  logic [`SCR1_XLEN-1:0]              mprf2exu_rs2_data_o,        // MPRF rs2 read data\n    input   logic                               exu2mprf_w_req_i,           // MPRF write request\n    input   logic [`SCR1_MPRF_AWIDTH-1:0]       exu2mprf_rd_addr_i,         // MPRF rd write address\n    input   logic [`SCR1_XLEN-1:0]              exu2mprf_rd_data_i          // MPRF rd write data\n);\n\n//-------------------------------------------------------------------------------\n// Local types declaration\n//-------------------------------------------------------------------------------\n\nlogic                        wr_req_vd;\n\nlogic                        rs1_addr_vd;\nlogic                        rs2_addr_vd;\n\n`ifdef  SCR1_MPRF_RAM\nlogic                        rs1_addr_vd_ff;\nlogic                        rs2_addr_vd_ff;\n\nlogic                        rs1_new_data_req;\nlogic                        rs2_new_data_req;\nlogic                        rs1_new_data_req_ff;\nlogic                        rs2_new_data_req_ff;\nlogic                        read_new_data_req;\n\nlogic    [`SCR1_XLEN-1:0]    rd_data_ff;\n\nlogic    [`SCR1_XLEN-1:0]    rs1_data_ff;\nlogic    [`SCR1_XLEN-1:0]    rs2_data_ff;\n\n// when using RAM, 2 memories are needed because 3 simultaneous independent\n// write/read operations can occur\n `ifdef SCR1_TRGT_FPGA_INTEL_MAX10\n(* ramstyle = \"M9K\" *)      logic   [`SCR1_XLEN-1:0]    mprf_int   [1:`SCR1_MPRF_SIZE-1];\n(* ramstyle = \"M9K\" *)      logic   [`SCR1_XLEN-1:0]    mprf_int2  [1:`SCR1_MPRF_SIZE-1];\n `elsif SCR1_TRGT_FPGA_INTEL_ARRIAV\n(* ramstyle = \"M10K\" *)     logic   [`SCR1_XLEN-1:0]    mprf_int   [1:`SCR1_MPRF_SIZE-1];\n(* ramstyle = \"M10K\" *)     logic   [`SCR1_XLEN-1:0]    mprf_int2  [1:`SCR1_MPRF_SIZE-1];\n `else\nlogic   [`SCR1_XLEN-1:0]    mprf_int   [1:`SCR1_MPRF_SIZE-1];\nlogic   [`SCR1_XLEN-1:0]    mprf_int2  [1:`SCR1_MPRF_SIZE-1];\n `endif\n`else  // distributed logic implementation\ntype_scr1_mprf_v [1:`SCR1_MPRF_SIZE-1]                  mprf_int;\n`endif\n\n//------------------------------------------------------------------------------\n// MPRF control logic\n//------------------------------------------------------------------------------\n\n// control signals common for distributed logic and RAM implementations\nassign  rs1_addr_vd  =   |exu2mprf_rs1_addr_i;\nassign  rs2_addr_vd  =   |exu2mprf_rs2_addr_i;\n\nassign  wr_req_vd  =   exu2mprf_w_req_i & |exu2mprf_rd_addr_i;\n\n// RAM implementation specific control signals\n`ifdef SCR1_MPRF_RAM\nassign  rs1_new_data_req    =   wr_req_vd & ( exu2mprf_rs1_addr_i == exu2mprf_rd_addr_i );\nassign  rs2_new_data_req    =   wr_req_vd & ( exu2mprf_rs2_addr_i == exu2mprf_rd_addr_i );\nassign  read_new_data_req   =   rs1_new_data_req | rs2_new_data_req;\n\nalways_ff @( posedge clk ) begin\n    rs1_addr_vd_ff          <=  rs1_addr_vd;\n    rs2_addr_vd_ff          <=  rs2_addr_vd;\n    rs1_new_data_req_ff     <=  rs1_new_data_req;\n    rs2_new_data_req_ff     <=  rs2_new_data_req;\nend\n`endif // SCR1_MPRF_RAM\n\n`ifdef  SCR1_MPRF_RAM\n//-------------------------------------------------------------------------------\n// RAM implementation\n//-------------------------------------------------------------------------------\n\n// RAM is implemented with 2 simple dual-port memories with sync read operation;\n// logic for \"write-first\" RDW behavior is implemented externally to the embedded\n// memory blocks\n\n// bypass new wr_data to the read output if write/read collision occurs\nassign  mprf2exu_rs1_data_o   =   ( rs1_new_data_req_ff ) ? rd_data_ff\n                                : (( rs1_addr_vd_ff )   ? rs1_data_ff\n                                                        : '0 );\n\nassign  mprf2exu_rs2_data_o   =   ( rs2_new_data_req_ff ) ? rd_data_ff\n                                : (( rs2_addr_vd_ff )   ? rs2_data_ff\n                                                        : '0 );\n\nalways_ff @( posedge clk ) begin\n    if ( read_new_data_req ) begin\n        rd_data_ff     <=  exu2mprf_rd_data_i;\n    end\nend\n\n// synchronous read operation\nalways_ff @( posedge clk ) begin\n    rs1_data_ff   <=   mprf_int[exu2mprf_rs1_addr_i];\n    rs2_data_ff   <=   mprf_int2[exu2mprf_rs2_addr_i];\nend\n\n// write operation\nalways_ff @( posedge clk ) begin\n    if ( wr_req_vd ) begin\n        mprf_int[exu2mprf_rd_addr_i]  <= exu2mprf_rd_data_i;\n        mprf_int2[exu2mprf_rd_addr_i] <= exu2mprf_rd_data_i;\n    end\nend\n`else   // distributed logic implementation\n//------------------------------------------------------------------------------\n// distributed logic implementation\n//------------------------------------------------------------------------------\n\n// asynchronous read operation\nassign  mprf2exu_rs1_data_o = ( rs1_addr_vd ) ? mprf_int[exu2mprf_rs1_addr_i] : '0;\nassign  mprf2exu_rs2_data_o = ( rs2_addr_vd ) ? mprf_int[exu2mprf_rs2_addr_i] : '0;\n\n// write operation\n `ifdef SCR1_MPRF_RST_EN\nalways_ff @( posedge clk, negedge rst_n ) begin\n    if ( ~rst_n ) begin\n        mprf_int <= '{default: '0};\n    end else if ( wr_req_vd ) begin\n        mprf_int[exu2mprf_rd_addr_i] <= exu2mprf_rd_data_i;\n    end\nend\n `else // ~SCR1_MPRF_RST_EN\nalways_ff @( posedge clk ) begin\n    if ( wr_req_vd ) begin\n        mprf_int[exu2mprf_rd_addr_i] <= exu2mprf_rd_data_i;\n    end\nend\n `endif // ~SCR1_MPRF_RST_EN\n`endif\n\n`ifdef SCR1_TRGT_SIMULATION\n//-------------------------------------------------------------------------------\n// Assertion\n//-------------------------------------------------------------------------------\n`ifdef SCR1_MPRF_RST_EN\nSCR1_SVA_MPRF_WRITEX : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    exu2mprf_w_req_i |-> !$isunknown({exu2mprf_rd_addr_i, (|exu2mprf_rd_addr_i ? exu2mprf_rd_data_i : `SCR1_XLEN'd0)})\n    ) else $error(\"MPRF error: unknown values\");\n`endif // SCR1_MPRF_RST_EN\n\n`endif // SCR1_TRGT_SIMULATION\n\nendmodule : scr1_pipe_mprf\n"}
{"text": "/// Copyright by Syntacore LLC \u00a9 2016-2021. See LICENSE for details\n/// @file       <scr1_pipe_tdu.sv>\n/// @brief      Trigger Debug Unit (TDU)\n///\n\n//------------------------------------------------------------------------------\n //\n // Functionality:\n // - Provides read/write interface for TDU CSRs\n // - Provides triggers functionality:\n //   - Supports triggers either in both Debug and M modes or in Debug mode only\n //   - Supports virtual address matching (load, store, exec) triggers\n //   - Supports instruction count triggers\n //   - Supports the following actions on trigger firing:\n //     - Breakpoint exception raising\n //     - Debug Mode entering\n //   - Supports triggers chaining\n //\n // Structure:\n // - CSR read/write i/f\n // - TDU CSRs:\n //   - TSELECT\n //   - TDATA1/MCONTROL/ICOUNT\n //   - TDATA2\n //   - TINFO\n // - TDU <-> EXU i/f\n // - TDU <-> LSU i/f\n // - TDU <-> HDU i/f\n//------------------------------------------------------------------------------\n\n`include \"scr1_arch_description.svh\"\n\n`ifdef SCR1_TDU_EN\n`include \"scr1_riscv_isa_decoding.svh\"\n`include \"scr1_tdu.svh\"\n\nmodule scr1_pipe_tdu (\n    // Common signals\n    input  logic                                            rst_n,                      // TDU reset\n    input  logic                                            clk,                        // TDU clock\n    input  logic                                            clk_en,                     // TDU clock enable\n    input  logic                                            tdu_dsbl_i,                 // TDU Disable\n\n    // TDU <-> CSR interface\n    input  logic                                            csr2tdu_req_i,              // CSR-TDU i/f request\n    input  type_scr1_csr_cmd_sel_e                          csr2tdu_cmd_i,              // CSR-TDU i/f command\n    input  logic [SCR1_CSR_ADDR_TDU_OFFS_W-1:0]             csr2tdu_addr_i,             // CSR-TDU i/f address\n    input  logic [SCR1_TDU_DATA_W-1:0]                      csr2tdu_wdata_i,            // CSR-TDU i/f write data\n    output logic [SCR1_TDU_DATA_W-1:0]                      tdu2csr_rdata_o,            // CSR-TDU i/f read data\n    output type_scr1_csr_resp_e                             tdu2csr_resp_o,             // CSR-TDU i/f response\n\n    // TDU <-> EXU interface\n    input  type_scr1_brkm_instr_mon_s                       exu2tdu_imon_i,             // Instruction stream monitoring\n    output logic [SCR1_TDU_ALLTRIG_NUM-1 : 0]               tdu2exu_ibrkpt_match_o,     // Instruction BP match\n    output logic                                            tdu2exu_ibrkpt_exc_req_o,   // Instruction BP exception request\n    input  logic [SCR1_TDU_ALLTRIG_NUM-1 : 0]               exu2tdu_bp_retire_i,        // Map of BPs being retired\n\n    // TDU <-> LSU interface\n`ifndef SCR1_TDU_EN\n    output logic                                            tdu2lsu_brk_en_o,           // TDU-LSU Breakpoint enable\n`endif // SCR1_TDU_EN\n    output logic                                            tdu2lsu_ibrkpt_exc_req_o,   // TDU-LSU Instruction BP exception request\n    input  type_scr1_brkm_lsu_mon_s                         lsu2tdu_dmon_i,             // TDU-LSU Data address stream monitoring\n    output logic [SCR1_TDU_MTRIG_NUM-1 : 0]                 tdu2lsu_dbrkpt_match_o,     // TDU-LSU Data BP match\n    output logic                                            tdu2lsu_dbrkpt_exc_req_o,   // TDU-LSU Data BP exception request\n\n    // TDU <-> HDU interface\n    output logic                                            tdu2hdu_dmode_req_o         // Debug Mode redirection request\n);\n\n//------------------------------------------------------------------------------\n// Local parameters declaration\n//------------------------------------------------------------------------------\n\nlocalparam int unsigned MTRIG_NUM   = SCR1_TDU_MTRIG_NUM;\nlocalparam int unsigned ALLTRIG_NUM = SCR1_TDU_ALLTRIG_NUM;\nlocalparam int unsigned ALLTRIG_W   = $clog2(ALLTRIG_NUM+1);\n\n//------------------------------------------------------------------------------\n// Local signals declaration\n//------------------------------------------------------------------------------\n\n// TDU CSRs read/write i/f signals\n//------------------------------------------------------------------------------\n\n// Write signals\nlogic                                           csr_wr_req;\nlogic [SCR1_TDU_DATA_W-1:0]                     csr_wr_data;\n\n// Register select\nlogic                                           csr_addr_tselect;\nlogic [MTRIG_NUM-1:0]                           csr_addr_mcontrol;\nlogic [MTRIG_NUM-1:0]                           csr_addr_tdata2;\n`ifdef SCR1_TDU_ICOUNT_EN\nlogic                                           csr_addr_icount;\n`endif // SCR1_TDU_ICOUNT_EN\n\n// TDU CSRs\n//------------------------------------------------------------------------------\n\n// TSELECT register\nlogic                                           csr_tselect_upd;\nlogic [ALLTRIG_W-1:0]                           csr_tselect_ff;\n\n// MCONTROL register\nlogic [MTRIG_NUM-1:0]                           csr_mcontrol_wr_req;\nlogic [MTRIG_NUM-1:0]                           csr_mcontrol_clk_en;\nlogic [MTRIG_NUM-1:0]                           csr_mcontrol_upd;\n\nlogic [MTRIG_NUM-1:0]                           csr_mcontrol_dmode_ff;\nlogic [MTRIG_NUM-1:0]                           csr_mcontrol_dmode_next;\nlogic [MTRIG_NUM-1:0]                           csr_mcontrol_m_ff;\nlogic [MTRIG_NUM-1:0]                           csr_mcontrol_m_next;\nlogic [MTRIG_NUM-1:0]                           csr_mcontrol_exec_ff;\nlogic [MTRIG_NUM-1:0]                           csr_mcontrol_exec_next;\nlogic [MTRIG_NUM-1:0]                           csr_mcontrol_load_ff;\nlogic [MTRIG_NUM-1:0]                           csr_mcontrol_load_next;\nlogic [MTRIG_NUM-1:0]                           csr_mcontrol_store_ff;\nlogic [MTRIG_NUM-1:0]                           csr_mcontrol_store_next;\nlogic [MTRIG_NUM-1:0]                           csr_mcontrol_action_ff;\nlogic [MTRIG_NUM-1:0]                           csr_mcontrol_action_next;\nlogic [MTRIG_NUM-1:0]                           csr_mcontrol_hit_ff;\nlogic [MTRIG_NUM-1:0]                           csr_mcontrol_hit_next;\n\nlogic [MTRIG_NUM-1:0]                           csr_mcontrol_exec_hit;\nlogic [MTRIG_NUM-1:0]                           csr_mcontrol_ldst_hit;\n\n// ICOUNT register\n`ifdef SCR1_TDU_ICOUNT_EN\nlogic                                           csr_icount_wr_req;\nlogic                                           csr_icount_clk_en;\nlogic                                           csr_icount_upd;\n\nlogic                                           csr_icount_dmode_ff;\nlogic                                           csr_icount_dmode_next;\nlogic                                           csr_icount_m_ff;\nlogic                                           csr_icount_m_next;\nlogic                                           csr_icount_action_ff;\nlogic                                           csr_icount_action_next;\nlogic                                           csr_icount_hit_ff;\nlogic                                           csr_icount_hit_next;\nlogic [SCR1_TDU_ICOUNT_COUNT_HI-SCR1_TDU_ICOUNT_COUNT_LO:0]\n                                                csr_icount_count_ff;\nlogic [SCR1_TDU_ICOUNT_COUNT_HI-SCR1_TDU_ICOUNT_COUNT_LO:0]\n                                                csr_icount_count_next;\nlogic                                           csr_icount_skip_ff;\nlogic                                           csr_icount_skip_next;\n\nlogic                                           csr_icount_decr_en;\nlogic                                           csr_icount_count_decr;\nlogic                                           csr_icount_skip_dsbl;\nlogic                                           csr_icount_hit;\n`endif // SCR1_TDU_ICOUNT_EN\n\n// TDATA2 register\nlogic [MTRIG_NUM-1:0]                           csr_tdata2_upd;\nlogic [MTRIG_NUM-1:0] [SCR1_TDU_DATA_W-1:0]     csr_tdata2_ff;\n\n//------------------------------------------------------------------------------\n// CSR read/write interface\n//------------------------------------------------------------------------------\n\n// Read logic\n//------------------------------------------------------------------------------\n\nassign tdu2csr_resp_o = csr2tdu_req_i ? SCR1_CSR_RESP_OK : SCR1_CSR_RESP_ER;\n\nalways_comb begin\n    tdu2csr_rdata_o = '0;\n    if (csr2tdu_req_i) begin\n        case (csr2tdu_addr_i)\n            SCR1_CSR_ADDR_TDU_OFFS_TSELECT: begin\n                tdu2csr_rdata_o = {'0, csr_tselect_ff};\n            end\n            SCR1_CSR_ADDR_TDU_OFFS_TDATA2 : begin\n                for(int unsigned i = 0; i < MTRIG_NUM; ++i) begin\n                    if(csr_tselect_ff == ALLTRIG_W'(i)) begin\n                        tdu2csr_rdata_o = csr_tdata2_ff[i];\n                    end\n                end\n            end\n            SCR1_CSR_ADDR_TDU_OFFS_TDATA1 : begin\n                for(int unsigned i = 0; i < MTRIG_NUM; ++i) begin\n                    if(csr_tselect_ff == ALLTRIG_W'(i)) begin\n                        tdu2csr_rdata_o[SCR1_TDU_TDATA1_TYPE_HI:\n                                       SCR1_TDU_TDATA1_TYPE_LO]      = SCR1_TDU_MCONTROL_TYPE_VAL;\n                        tdu2csr_rdata_o[SCR1_TDU_TDATA1_DMODE]       = csr_mcontrol_dmode_ff[i];\n                        tdu2csr_rdata_o[SCR1_TDU_MCONTROL_MASKMAX_HI:\n                                       SCR1_TDU_MCONTROL_MASKMAX_LO] = SCR1_TDU_MCONTROL_MASKMAX_VAL;\n                        tdu2csr_rdata_o[SCR1_TDU_MCONTROL_HIT]       = csr_mcontrol_hit_ff[i];\n                        tdu2csr_rdata_o[SCR1_TDU_MCONTROL_SELECT]    = SCR1_TDU_MCONTROL_SELECT_VAL;\n                        tdu2csr_rdata_o[SCR1_TDU_MCONTROL_TIMING]    = SCR1_TDU_MCONTROL_TIMING_VAL;\n                        tdu2csr_rdata_o[SCR1_TDU_MCONTROL_ACTION_HI:\n                                       SCR1_TDU_MCONTROL_ACTION_LO]  = {5'b0, csr_mcontrol_action_ff[i]};\n                        tdu2csr_rdata_o[SCR1_TDU_MCONTROL_CHAIN]     = 1'b0;\n                        tdu2csr_rdata_o[SCR1_TDU_MCONTROL_MATCH_HI:\n                                       SCR1_TDU_MCONTROL_MATCH_LO]   = 4'b0;\n                        tdu2csr_rdata_o[SCR1_TDU_MCONTROL_M]         = csr_mcontrol_m_ff[i];\n                        tdu2csr_rdata_o[SCR1_TDU_MCONTROL_RESERVEDA] = SCR1_TDU_MCONTROL_RESERVEDA_VAL;\n                        tdu2csr_rdata_o[SCR1_TDU_MCONTROL_S]         = 1'b0;\n                        tdu2csr_rdata_o[SCR1_TDU_MCONTROL_U]         = 1'b0;\n                        tdu2csr_rdata_o[SCR1_TDU_MCONTROL_EXECUTE]   = csr_mcontrol_exec_ff [i];\n                        tdu2csr_rdata_o[SCR1_TDU_MCONTROL_STORE]     = csr_mcontrol_store_ff[i];\n                        tdu2csr_rdata_o[SCR1_TDU_MCONTROL_LOAD]      = csr_mcontrol_load_ff [i];\n                    end\n                end\n`ifdef SCR1_TDU_ICOUNT_EN\n                if(csr_tselect_ff == ALLTRIG_W'(SCR1_TDU_ALLTRIG_NUM - 1'b1)) begin\n                    tdu2csr_rdata_o[SCR1_TDU_TDATA1_TYPE_HI:\n                                   SCR1_TDU_TDATA1_TYPE_LO]    = SCR1_TDU_ICOUNT_TYPE_VAL;\n                    tdu2csr_rdata_o[SCR1_TDU_TDATA1_DMODE]     = csr_icount_dmode_ff;\n                    tdu2csr_rdata_o[SCR1_TDU_ICOUNT_HIT]       = csr_icount_hit_ff;\n                    tdu2csr_rdata_o[SCR1_TDU_ICOUNT_COUNT_HI:\n                                   SCR1_TDU_ICOUNT_COUNT_LO]   = csr_icount_count_ff;\n                    tdu2csr_rdata_o[SCR1_TDU_ICOUNT_U]         = 1'b0;\n                    tdu2csr_rdata_o[SCR1_TDU_ICOUNT_S]         = 1'b0;\n                    tdu2csr_rdata_o[SCR1_TDU_ICOUNT_M]         = csr_icount_m_ff;\n                    tdu2csr_rdata_o[SCR1_TDU_ICOUNT_ACTION_HI:\n                                   SCR1_TDU_ICOUNT_ACTION_LO]  = {5'b0, csr_icount_action_ff};\n                end\n`endif // SCR1_TDU_ICOUNT_EN\n            end\n            SCR1_CSR_ADDR_TDU_OFFS_TINFO : begin\n                for(int unsigned i = 0; i < MTRIG_NUM; ++i) begin\n                    if(csr_tselect_ff == ALLTRIG_W'(i)) begin\n                        tdu2csr_rdata_o[SCR1_TDU_MCONTROL_TYPE_VAL] = 1'b1;\n                    end\n                end\n`ifdef SCR1_TDU_ICOUNT_EN\n                if(csr_tselect_ff == ALLTRIG_W'(SCR1_TDU_ALLTRIG_NUM - 1'b1)) begin\n                    tdu2csr_rdata_o[SCR1_TDU_ICOUNT_TYPE_VAL] = 1'b1;\n                end\n`endif // SCR1_TDU_ICOUNT_EN\n            end\n            default : begin\n            end\n        endcase\n    end\nend\n\n// Write logic\n//------------------------------------------------------------------------------\n\nalways_comb begin\n    csr_wr_req  = 1'b0;\n    csr_wr_data = '0;\n\n    case (csr2tdu_cmd_i)\n        SCR1_CSR_CMD_WRITE: begin\n            csr_wr_req  = 1'b1;\n            csr_wr_data = csr2tdu_wdata_i;\n        end\n        SCR1_CSR_CMD_SET  : begin\n            csr_wr_req  = |csr2tdu_wdata_i;\n            csr_wr_data = tdu2csr_rdata_o | csr2tdu_wdata_i;\n        end\n        SCR1_CSR_CMD_CLEAR: begin\n            csr_wr_req  = |csr2tdu_wdata_i;\n            csr_wr_data = tdu2csr_rdata_o & ~csr2tdu_wdata_i;\n        end\n        default : begin\n        end\n    endcase\nend\n\n// Register selection\n//------------------------------------------------------------------------------\n\nalways_comb begin\n    csr_addr_tselect  = 1'b0;\n    csr_addr_tdata2   = '0;\n    csr_addr_mcontrol = '0;\n`ifdef SCR1_TDU_ICOUNT_EN\n    csr_addr_icount   = '0;\n`endif // SCR1_TDU_ICOUNT_EN\n\n    if (csr2tdu_req_i) begin\n        case (csr2tdu_addr_i)\n            SCR1_CSR_ADDR_TDU_OFFS_TSELECT: begin\n                csr_addr_tselect = 1'b1;\n            end\n            SCR1_CSR_ADDR_TDU_OFFS_TDATA1 : begin\n                for(int unsigned i = 0; i < MTRIG_NUM; ++i) begin\n                    if(csr_tselect_ff == ALLTRIG_W'(i)) begin\n                        csr_addr_mcontrol[i] = 1'b1;\n                    end\n                end\n`ifdef SCR1_TDU_ICOUNT_EN\n                if(csr_tselect_ff == ALLTRIG_W'(SCR1_TDU_ALLTRIG_NUM - 1'b1)) begin\n                    csr_addr_icount = 1'b1;\n                end\n`endif // SCR1_TDU_ICOUNT_EN\n            end\n            SCR1_CSR_ADDR_TDU_OFFS_TDATA2 : begin\n                for(int unsigned i = 0; i < MTRIG_NUM; ++i) begin\n                    if(csr_tselect_ff == ALLTRIG_W'(i) ) begin\n                        csr_addr_tdata2[i] = 1'b1;\n                    end\n                end\n            end\n            default : begin\n            end\n        endcase\n    end\nend\n\n//------------------------------------------------------------------------------\n// TDU CSRs\n//------------------------------------------------------------------------------\n//\n // TDU CSRs consist of the following registers:\n // - TSELECT\n // - TDATA1/MCONTROL/ICOUNT (depending on the type field value)\n // - TDATA2\n//\n\n// TSELECT register\n//------------------------------------------------------------------------------\n// Determines which trigger is accessible through the other trigger registers\n\nassign csr_tselect_upd = clk_en & csr_addr_tselect & csr_wr_req\n                       & (csr_wr_data[ALLTRIG_W-1:0] < ALLTRIG_W'(ALLTRIG_NUM));\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if(~rst_n) begin\n        csr_tselect_ff <= '0;\n    end else if(csr_tselect_upd) begin\n        csr_tselect_ff <= csr_wr_data[ALLTRIG_W-1:0];\n    end\nend\n\n`ifdef SCR1_TDU_ICOUNT_EN\n// ICOUNT register\n//------------------------------------------------------------------------------\n// Provides a trigger that fires when the certain number of instructions has retired\n// Is intended to be used as a single step trigger (in this case count must be 1)\n\nassign csr_icount_wr_req = csr_addr_icount & csr_wr_req;\nassign csr_icount_clk_en = clk_en & (csr_icount_wr_req | csr_icount_m_ff);\nassign csr_icount_upd    = ~csr_icount_dmode_ff\n                         ? csr_icount_wr_req\n                         : tdu_dsbl_i & csr_icount_wr_req;\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if(~rst_n) begin\n        csr_icount_dmode_ff  <= 1'b0;\n        csr_icount_m_ff      <= 1'b0;\n        csr_icount_action_ff <= 1'b0;\n        csr_icount_hit_ff    <= 1'b0;\n        csr_icount_count_ff  <= '0;\n        csr_icount_skip_ff   <= 1'b0;\n    end else if (csr_icount_clk_en) begin\n        csr_icount_dmode_ff  <= csr_icount_dmode_next;\n        csr_icount_m_ff      <= csr_icount_m_next;\n        csr_icount_action_ff <= csr_icount_action_next;\n        csr_icount_hit_ff    <= csr_icount_hit_next;\n        csr_icount_count_ff  <= csr_icount_count_next;\n        csr_icount_skip_ff   <= csr_icount_skip_next;\n    end\nend\n\nassign csr_icount_decr_en    = (~tdu_dsbl_i & csr_icount_m_ff)\n                             ? exu2tdu_imon_i.vd & (csr_icount_count_ff != 14'b0)\n                             : 1'b0;\nassign csr_icount_count_decr = exu2tdu_imon_i.req & csr_icount_decr_en & ~csr_icount_skip_ff;\nassign csr_icount_skip_dsbl  = exu2tdu_imon_i.req & csr_icount_decr_en & csr_icount_skip_ff;\n\nalways_comb begin\n    if (csr_icount_upd) begin\n        csr_icount_dmode_next  = csr_wr_data[SCR1_TDU_TDATA1_DMODE];\n        csr_icount_m_next      = csr_wr_data[SCR1_TDU_ICOUNT_M];\n        csr_icount_action_next = (csr_wr_data[SCR1_TDU_ICOUNT_ACTION_HI\n                                             :SCR1_TDU_ICOUNT_ACTION_LO] == 'b1);\n        csr_icount_hit_next    = csr_wr_data[SCR1_TDU_ICOUNT_HIT];\n        csr_icount_count_next  = csr_wr_data[SCR1_TDU_ICOUNT_COUNT_HI:SCR1_TDU_ICOUNT_COUNT_LO];\n    end else begin\n        csr_icount_dmode_next  = csr_icount_dmode_ff;\n        csr_icount_m_next      = csr_icount_m_ff;\n        csr_icount_action_next = csr_icount_action_ff;\n        csr_icount_hit_next    = exu2tdu_bp_retire_i[ALLTRIG_NUM - 1'b1]\n                               ? 1'b1\n                               : csr_icount_hit_ff;\n        csr_icount_count_next  = csr_icount_count_decr\n                               ? csr_icount_count_ff - 1'b1\n                               : csr_icount_count_ff;\n    end\nend\n\nassign csr_icount_skip_next = csr_icount_wr_req    ? csr_wr_data[SCR1_TDU_ICOUNT_M]\n                            : csr_icount_skip_dsbl ? 1'b0\n                                                   : csr_icount_skip_ff;\n`endif // SCR1_TDU_ICOUNT_EN\n\n// MCONTROL registers\n//------------------------------------------------------------------------------\n// Provides a trigger that fires on the virtual address (stored in TDATA2) match\n// (load, store, exec options supported). Triggers chaining supported\n\ngenvar trig;\ngenerate\nfor (trig = 0; $unsigned(trig) < MTRIG_NUM; ++trig) begin : gblock_mtrig\n\nassign csr_mcontrol_wr_req[trig] = csr_addr_mcontrol[trig] & csr_wr_req;\nassign csr_mcontrol_clk_en[trig] = clk_en\n                                 & (csr_mcontrol_wr_req[trig] | csr_mcontrol_m_ff[trig]);\nassign csr_mcontrol_upd   [trig] = ~csr_mcontrol_dmode_ff[trig]\n                                 ? csr_mcontrol_wr_req[trig]\n                                 : tdu_dsbl_i & csr_mcontrol_wr_req[trig];\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if(~rst_n) begin\n        csr_mcontrol_dmode_ff [trig] <= 1'b0;\n        csr_mcontrol_m_ff     [trig] <= 1'b0;\n        csr_mcontrol_exec_ff  [trig] <= 1'b0;\n        csr_mcontrol_load_ff  [trig] <= 1'b0;\n        csr_mcontrol_store_ff [trig] <= 1'b0;\n        csr_mcontrol_action_ff[trig] <= 1'b0;\n        csr_mcontrol_hit_ff   [trig] <= 1'b0;\n    end else if(csr_mcontrol_clk_en[trig]) begin\n        csr_mcontrol_dmode_ff [trig] <= csr_mcontrol_dmode_next[trig];\n        csr_mcontrol_m_ff     [trig] <= csr_mcontrol_m_next[trig];\n        csr_mcontrol_exec_ff  [trig] <= csr_mcontrol_exec_next[trig];\n        csr_mcontrol_load_ff  [trig] <= csr_mcontrol_load_next[trig];\n        csr_mcontrol_store_ff [trig] <= csr_mcontrol_store_next[trig];\n        csr_mcontrol_action_ff[trig] <= csr_mcontrol_action_next[trig];\n        csr_mcontrol_hit_ff   [trig] <= csr_mcontrol_hit_next[trig];\n    end\nend\n\nalways_comb begin\n    if (csr_mcontrol"}
{"text": "_upd[trig]) begin\n        csr_mcontrol_dmode_next [trig] = csr_wr_data[SCR1_TDU_TDATA1_DMODE];\n        csr_mcontrol_m_next     [trig] = csr_wr_data[SCR1_TDU_MCONTROL_M];\n        csr_mcontrol_exec_next  [trig] = csr_wr_data[SCR1_TDU_MCONTROL_EXECUTE];\n        csr_mcontrol_load_next  [trig] = csr_wr_data[SCR1_TDU_MCONTROL_LOAD];\n        csr_mcontrol_store_next [trig] = csr_wr_data[SCR1_TDU_MCONTROL_STORE];\n        csr_mcontrol_action_next[trig] = (csr_wr_data[SCR1_TDU_MCONTROL_ACTION_HI\n                                                     :SCR1_TDU_MCONTROL_ACTION_LO] == 'b1);\n        csr_mcontrol_hit_next   [trig] = csr_wr_data[SCR1_TDU_MCONTROL_HIT];\n    end else begin\n        csr_mcontrol_dmode_next [trig] = csr_mcontrol_dmode_ff [trig];\n        csr_mcontrol_m_next     [trig] = csr_mcontrol_m_ff     [trig];\n        csr_mcontrol_exec_next  [trig] = csr_mcontrol_exec_ff  [trig];\n        csr_mcontrol_load_next  [trig] = csr_mcontrol_load_ff  [trig];\n        csr_mcontrol_store_next [trig] = csr_mcontrol_store_ff [trig];\n        csr_mcontrol_action_next[trig] = csr_mcontrol_action_ff[trig];\n        csr_mcontrol_hit_next   [trig] = exu2tdu_bp_retire_i[trig]\n                                       ? 1'b1\n                                       : csr_mcontrol_hit_ff[trig];\n    end\nend\n\n// TDATA2 register\n//------------------------------------------------------------------------------\n\nassign csr_tdata2_upd[trig] = ~csr_mcontrol_dmode_ff[trig]\n                            ? clk_en & csr_addr_tdata2[trig] & csr_wr_req\n                            : clk_en & csr_addr_tdata2[trig] & csr_wr_req & tdu_dsbl_i;\n\nalways_ff @(posedge clk) begin\n    if (csr_tdata2_upd[trig]) begin\n        csr_tdata2_ff[trig] <= csr_wr_data;\n    end\nend\n\nend\nendgenerate // gblock_mtrig\n\n//------------------------------------------------------------------------------\n// TDU <-> EXU interface\n//------------------------------------------------------------------------------\n\nassign csr_icount_hit = ~tdu_dsbl_i & csr_icount_m_ff\n                      ? exu2tdu_imon_i.vd & (csr_icount_count_ff == 14'b1) & ~csr_icount_skip_ff\n                      : 1'b0;\n\n`ifndef SCR1_TDU_ICOUNT_EN\nassign tdu2exu_ibrkpt_match_o   = csr_mcontrol_exec_hit;\nassign tdu2exu_ibrkpt_exc_req_o = |csr_mcontrol_exec_hit;\n`else\nassign tdu2exu_ibrkpt_match_o   = {csr_icount_hit, csr_mcontrol_exec_hit};\nassign tdu2exu_ibrkpt_exc_req_o = |csr_mcontrol_exec_hit | csr_icount_hit;\n`endif // SCR1_TDU_ICOUNT_EN\n\n//------------------------------------------------------------------------------\n// TDU <-> LSU interface\n//------------------------------------------------------------------------------\n\n// Breakpoint logic\n//------------------------------------------------------------------------------\n\ngenerate\nfor (trig = 0; $unsigned(trig) < MTRIG_NUM; ++trig) begin : gblock_break_trig\nassign csr_mcontrol_exec_hit[trig] = ~tdu_dsbl_i\n                                   & csr_mcontrol_m_ff[trig]\n                                   & csr_mcontrol_exec_ff[trig]\n                                   & exu2tdu_imon_i.vd\n                                   & exu2tdu_imon_i.addr == csr_tdata2_ff[trig];\nend\nendgenerate\n\n`ifndef SCR1_TDU_ICOUNT_EN\nassign tdu2lsu_ibrkpt_exc_req_o = |csr_mcontrol_exec_hit;\n`else\nassign tdu2lsu_ibrkpt_exc_req_o = |csr_mcontrol_exec_hit | csr_icount_hit;\n`endif // SCR1_TDU_ICOUNT_EN\n\n// Watchpoint logic\n//------------------------------------------------------------------------------\n\ngenerate\nfor( trig = 0; $unsigned(trig) < MTRIG_NUM; ++trig ) begin : gblock_watch_trig\nassign csr_mcontrol_ldst_hit[trig] = ~tdu_dsbl_i\n                                   & csr_mcontrol_m_ff[trig]\n                                   & lsu2tdu_dmon_i.vd\n                                   & ( (csr_mcontrol_load_ff [trig] & lsu2tdu_dmon_i.load)\n                                     | (csr_mcontrol_store_ff[trig] & lsu2tdu_dmon_i.store))\n                                   & lsu2tdu_dmon_i.addr == csr_tdata2_ff[trig];\nend\nendgenerate\n\nassign tdu2lsu_dbrkpt_match_o   = csr_mcontrol_ldst_hit;\nassign tdu2lsu_dbrkpt_exc_req_o = |csr_mcontrol_ldst_hit;\n\n`ifndef SCR1_TDU_EN\nassign tdu2lsu_brk_en_o = |csr_mcontrol_m_ff | csr_icount_m_ff;\n`endif // SCR1_TDU_EN\n\n//------------------------------------------------------------------------------\n// TDU <-> HDU interface\n//------------------------------------------------------------------------------\n\nalways_comb begin\n    tdu2hdu_dmode_req_o = 1'b0;\n\n    for(int unsigned i = 0; i < MTRIG_NUM; ++i) begin\n        tdu2hdu_dmode_req_o |= (csr_mcontrol_action_ff[i] & exu2tdu_bp_retire_i[i]);\n    end\n`ifdef SCR1_TDU_ICOUNT_EN\n    tdu2hdu_dmode_req_o |= (csr_icount_action_ff & exu2tdu_bp_retire_i[ALLTRIG_NUM-1]);\n`endif // SCR1_TDU_ICOUNT_EN\nend\n\n`ifdef SCR1_TRGT_SIMULATION\n//------------------------------------------------------------------------------\n// Assertion\n//------------------------------------------------------------------------------\n\nSVA_TDU_X_CONTROL : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    !$isunknown({clk_en, tdu_dsbl_i, csr2tdu_req_i,\n                 exu2tdu_imon_i.vd, lsu2tdu_dmon_i.vd, exu2tdu_bp_retire_i})\n    ) else $error(\"TDU Error: control signals is X - %0b\", {clk_en,\n    tdu_dsbl_i, csr2tdu_req_i, exu2tdu_imon_i.vd, lsu2tdu_dmon_i.vd, exu2tdu_bp_retire_i});\n\nSVA_DM_X_CLK_EN : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    !$isunknown(clk_en)\n    ) else $error(\"TDU Error: clk_en control signals is X\");\n\nSVA_DM_X_DSBL : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    !$isunknown(tdu_dsbl_i)\n    ) else $error(\"TDU Error: tdu_dsbl_i control signals is X\");\n\nSVA_DM_X_CSR2TDU_REQ : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    !$isunknown(csr2tdu_req_i)\n    ) else $error(\"TDU Error: csr2tdu_req_i control signals is X\");\n\nSVA_DM_X_I_MON_VD : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    !$isunknown(exu2tdu_imon_i.vd)\n    ) else $error(\"TDU Error: exu2tdu_imon_i.vd control signals is X\");\n\nSVA_DM_X_D_MON_VD : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    !$isunknown(lsu2tdu_dmon_i.vd)\n    ) else $error(\"TDU Error: lsu2tdu_dmon_i.vd control signals is X\");\n\nSVA_DM_X_BP_RETIRE : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    !$isunknown(exu2tdu_bp_retire_i)\n    ) else $error(\"TDU Error: exu2tdu_bp_retire_i control signals is X\");\n\nSVA_TDU_X_CSR : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    csr2tdu_req_i |-> !$isunknown({csr2tdu_cmd_i,csr2tdu_addr_i})\n    ) else $error(\"TDU Error: csr is X\");\n\nSVA_TDU_XW_CSR : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    (csr2tdu_req_i & csr_wr_req) |-> !$isunknown(csr2tdu_wdata_i)\n    ) else $error(\"TDU Error: csr wdata is X \");\n\nSVA_TDU_X_IMON : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    exu2tdu_imon_i.vd |-> !$isunknown({exu2tdu_imon_i.req,exu2tdu_imon_i.addr})\n    ) else $error(\"TDU Error: imonitor is X\");\n\nSVA_TDU_X_DMON : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    lsu2tdu_dmon_i.vd |-> !$isunknown({lsu2tdu_dmon_i})\n    ) else $error(\"TDU Error: dmonitor is X\");\n\n`endif // SCR1_TRGT_SIMULATION\n\nendmodule : scr1_pipe_tdu\n\n`endif // SCR1_TDU_EN\n"}
{"text": "/// Copyright by Syntacore LLC \u00a9 2016-2021. See LICENSE for details\n/// @file       <scr1_pipe_top.sv>\n/// @brief      SCR1 pipeline top\n///\n\n`include \"scr1_arch_description.svh\"\n`include \"scr1_memif.svh\"\n`include \"scr1_riscv_isa_decoding.svh\"\n`include \"scr1_csr.svh\"\n\n`ifdef SCR1_IPIC_EN\n`include \"scr1_ipic.svh\"\n`endif // SCR1_IPIC_EN\n\n`ifdef SCR1_DBG_EN\n`include \"scr1_hdu.svh\"\n`endif // SCR1_DBG_EN\n\n`ifdef SCR1_TDU_EN\n`include \"scr1_tdu.svh\"\n`endif // SCR1_TDU_EN\n\nmodule scr1_pipe_top (\n    // Common\n    input   logic                                       pipe_rst_n,                 // Pipe reset\n`ifdef SCR1_DBG_EN\n    input   logic                                       pipe2hdu_rdc_qlfy_i,        // Pipe RDC qualifier\n    input   logic                                       dbg_rst_n,                  // Debug reset\n`endif // SCR1_DBG_EN\n    input   logic                                       clk,                        // Pipe clock\n\n    // Instruction Memory Interface\n    output  logic                                       pipe2imem_req_o,            // IMEM request\n    output  type_scr1_mem_cmd_e                         pipe2imem_cmd_o,            // IMEM command\n    output  logic [`SCR1_IMEM_AWIDTH-1:0]               pipe2imem_addr_o,           // IMEM address\n    input   logic                                       imem2pipe_req_ack_i,        // IMEM request acknowledge\n    input   logic [`SCR1_IMEM_DWIDTH-1:0]               imem2pipe_rdata_i,          // IMEM read data\n    input   type_scr1_mem_resp_e                        imem2pipe_resp_i,           // IMEM response\n\n    // Data Memory Interface\n    output  logic                                       pipe2dmem_req_o,            // DMEM request\n    output  type_scr1_mem_cmd_e                         pipe2dmem_cmd_o,            // DMEM command\n    output  type_scr1_mem_width_e                       pipe2dmem_width_o,          // DMEM data width\n    output  logic [`SCR1_DMEM_AWIDTH-1:0]               pipe2dmem_addr_o,           // DMEM address\n    output  logic [`SCR1_DMEM_DWIDTH-1:0]               pipe2dmem_wdata_o,          // DMEM write data\n    input   logic                                       dmem2pipe_req_ack_i,        // DMEM request acknowledge\n    input   logic [`SCR1_DMEM_DWIDTH-1:0]               dmem2pipe_rdata_i,          // DMEM read data\n    input   type_scr1_mem_resp_e                        dmem2pipe_resp_i,           // DMEM response\n\n`ifdef SCR1_DBG_EN\n    // Debug interface:\n    input  logic                                        dbg_en,                     // 1 - debug operations enabled\n    // DM <-> Pipeline: HART Run Control i/f\n    input  logic                                        dm2pipe_active_i,           // Debug Module active flag\n\n    input  logic                                        dm2pipe_cmd_req_i,          // Request from Debug Module\n    input  type_scr1_hdu_dbgstates_e                    dm2pipe_cmd_i,              // Command from Debug Module\n    output logic                                        pipe2dm_cmd_resp_o,         // Response to Debug Module\n    output logic                                        pipe2dm_cmd_rcode_o,        // Debug Module return code: 0 - Ok; 1 - Error\n    output logic                                        pipe2dm_hart_event_o,       // HART event flag\n    output type_scr1_hdu_hartstatus_s                   pipe2dm_hart_status_o,      // HART status\n\n    // DM <-> Pipeline: Program Buffer - HART instruction execution i/f\n    output logic [SCR1_HDU_PBUF_ADDR_WIDTH-1:0]         pipe2dm_pbuf_addr_o,        // Program Buffer address\n    input  logic [SCR1_HDU_CORE_INSTR_WIDTH-1:0]        dm2pipe_pbuf_instr_i,       // Program Buffer instruction\n\n    // DM <-> Pipeline: HART Abstract Data regs i/f\n    output logic                                        pipe2dm_dreg_req_o,         // Abstract Data Register request\n    output logic                                        pipe2dm_dreg_wr_o,          // Abstract Data Register write\n    output logic [`SCR1_XLEN-1:0]                       pipe2dm_dreg_wdata_o,       // Abstract Data Register write data\n    input  logic                                        dm2pipe_dreg_resp_i,        // Abstract Data Register response\n    input  logic                                        dm2pipe_dreg_fail_i,        // Abstract Data Register fail - possibly not needed?\n    input  logic [`SCR1_XLEN-1:0]                       dm2pipe_dreg_rdata_i,       // Abstract Data Register read data\n\n    // DM <-> Pipeling: PC i/f\n    output logic [`SCR1_XLEN-1:0]                       pipe2dm_pc_sample_o,        // Current PC for sampling\n`endif // SCR1_DBG_EN\n\n    // IRQ\n`ifdef SCR1_IPIC_EN\n    input   logic [SCR1_IRQ_LINES_NUM-1:0]              soc2pipe_irq_lines_i,       // External interrupt request lines\n`else // SCR1_IPIC_EN\n    input   logic                                       soc2pipe_irq_ext_i,         // External interrupt request\n`endif // SCR1_IPIC_EN\n    input   logic                                       soc2pipe_irq_soft_i,        // Software generated interrupt request\n    input   logic                                       soc2pipe_irq_mtimer_i,      // Machine timer interrupt request\n\n    // Memory-mapped external timer\n    input   logic [63:0]                                soc2pipe_mtimer_val_i,      // Machine timer value\n\n`ifdef SCR1_CLKCTRL_EN\n    // CLK_CTRL interface\n    output  logic                                       pipe2clkctl_sleep_req_o,    // CLK disable request to CLK gating circuit\n    output  logic                                       pipe2clkctl_wake_req_o,     // CLK enable request to CLK gating circuit\n    input   logic                                       clkctl2pipe_clk_alw_on_i,   // Not gated CLK\n    input   logic                                       clkctl2pipe_clk_dbgc_i,     // CLK for HDU (not gated for now)\n    input   logic                                       clkctl2pipe_clk_en_i,       // CLK enabled flag\n`endif // SCR1_CLKCTRL_EN\n\n    // Fuse\n    input   logic [`SCR1_XLEN-1:0]                      soc2pipe_fuse_mhartid_i     // Fuse MHARTID value\n);\n\n//-------------------------------------------------------------------------------\n// Local signals declaration\n//-------------------------------------------------------------------------------\n\n// Pipeline control\nlogic [`SCR1_XLEN-1:0]                      curr_pc;                // Current PC\nlogic [`SCR1_XLEN-1:0]                      next_pc;                // Is written to MEPC on interrupt trap\nlogic                                       new_pc_req;             // New PC request (jumps, branches, traps etc)\nlogic [`SCR1_XLEN-1:0]                      new_pc;                 // New PC\n\nlogic                                       stop_fetch;             // Stop IFU\nlogic                                       exu_exc_req;            // Exception request\nlogic                                       brkpt;                  // Breakpoint (sw) on current instruction\nlogic                                       exu_init_pc;            // Reset exit\nlogic                                       wfi_run2halt;           // Transition to WFI halted state\nlogic                                       instret;                // Instruction retirement (with or without exception)\n`ifndef SCR1_CSR_REDUCED_CNT\nlogic                                       instret_nexc;           // Instruction retirement (without exception)\n`endif // SCR1_CSR_REDUCED_CNT\n`ifdef SCR1_IPIC_EN\nlogic                                       ipic2csr_irq;           // IRQ request from IPIC\n`endif // SCR1_IPIC_EN\n`ifdef SCR1_TDU_EN\n `ifdef SCR1_DBG_EN\nlogic                                       brkpt_hw;               // Hardware breakpoint on current instruction\n `endif // SCR1_DBG_EN\n`endif // SCR1_TDU_EN\n`ifdef SCR1_CLKCTRL_EN\nlogic                                       imem_txns_pending;      // There are pending imem transactions\nlogic                                       wfi_halted;             // WFI halted state\n`endif // SCR1_CLKCTRL_EN\n\n// IFU <-> IDU\nlogic                                       ifu2idu_vd;             // IFU request\nlogic [`SCR1_IMEM_DWIDTH-1:0]               ifu2idu_instr;          // IFU instruction\nlogic                                       ifu2idu_imem_err;       // IFU instruction access fault\nlogic                                       ifu2idu_err_rvi_hi;     // 1 - imem fault when trying to fetch second half of an unaligned RVI instruction\nlogic                                       idu2ifu_rdy;            // IDU ready for new data\n\n// IDU <-> EXU\nlogic                                       idu2exu_req;            // IDU request\ntype_scr1_exu_cmd_s                         idu2exu_cmd;            // IDU command (see scr1_riscv_isa_decoding.svh)\nlogic                                       idu2exu_use_rs1;        // Instruction uses rs1\nlogic                                       idu2exu_use_rs2;        // Instruction uses rs2\n`ifndef SCR1_NO_EXE_STAGE\nlogic                                       idu2exu_use_rd;         // Instruction uses rd\nlogic                                       idu2exu_use_imm;        // Instruction uses immediate\n`endif // SCR1_NO_EXE_STAGE\nlogic                                       exu2idu_rdy;            // EXU ready for new data\n\n// EXU <-> MPRF\nlogic [`SCR1_MPRF_AWIDTH-1:0]               exu2mprf_rs1_addr;      // MPRF rs1 read address\nlogic [`SCR1_XLEN-1:0]                      mprf2exu_rs1_data;      // MPRF rs1 read data\nlogic [`SCR1_MPRF_AWIDTH-1:0]               exu2mprf_rs2_addr;      // MPRF rs2 read address\nlogic [`SCR1_XLEN-1:0]                      mprf2exu_rs2_data;      // MPRF rs2 read data\nlogic                                       exu2mprf_w_req;         // MPRF write request\nlogic [`SCR1_MPRF_AWIDTH-1:0]               exu2mprf_rd_addr;       // MPRF rd write address\nlogic [`SCR1_XLEN-1:0]                      exu2mprf_rd_data;       // MPRF rd write data\n\n// EXU <-> CSR\nlogic [SCR1_CSR_ADDR_WIDTH-1:0]             exu2csr_rw_addr;        // CSR read/write address\nlogic                                       exu2csr_r_req;          // CSR read request\nlogic [`SCR1_XLEN-1:0]                      csr2exu_r_data;         // CSR read data\nlogic                                       exu2csr_w_req;          // CSR write request\ntype_scr1_csr_cmd_sel_e                     exu2csr_w_cmd;          // CSR write command\nlogic [`SCR1_XLEN-1:0]                      exu2csr_w_data;         // CSR write data\nlogic                                       csr2exu_rw_exc;         // CSR read/write access exception\n\n// EXU <-> CSR event interface\nlogic                                       exu2csr_take_irq;       // Take IRQ trap\nlogic                                       exu2csr_take_exc;       // Take exception trap\nlogic                                       exu2csr_mret_update;    // MRET update CSR\nlogic                                       exu2csr_mret_instr;     // MRET instruction\ntype_scr1_exc_code_e                        exu2csr_exc_code;       // Exception code (see scr1_arch_types.svh)\nlogic [`SCR1_XLEN-1:0]                      exu2csr_trap_val;       // Trap value\nlogic [`SCR1_XLEN-1:0]                      csr2exu_new_pc;         // Exception/IRQ/MRET new PC\nlogic                                       csr2exu_irq;            // IRQ request\nlogic                                       csr2exu_ip_ie;          // Some IRQ pending and locally enabled\nlogic                                       csr2exu_mstatus_mie_up; // MSTATUS or MIE update in the current cycle\n\n`ifdef SCR1_IPIC_EN\n// CSR <-> IPIC\nlogic                                       csr2ipic_r_req;         // IPIC read request\nlogic                                       csr2ipic_w_req;         // IPIC write request\nlogic [2:0]                                 csr2ipic_addr;          // IPIC address\nlogic [`SCR1_XLEN-1:0]                      csr2ipic_wdata;         // IPIC write data\nlogic [`SCR1_XLEN-1:0]                      ipic2csr_rdata;         // IPIC read data\n`endif // SCR1_IPIC_EN\n\n`ifdef SCR1_TDU_EN\n// CSR <-> TDU\nlogic                                       csr2tdu_req;           // Request to TDU\ntype_scr1_csr_cmd_sel_e                     csr2tdu_cmd;           // TDU command\nlogic [SCR1_CSR_ADDR_TDU_OFFS_W-1:0]        csr2tdu_addr;          // TDU address\nlogic [`SCR1_XLEN-1:0]                      csr2tdu_wdata;         // TDU write data\nlogic [`SCR1_XLEN-1:0]                      tdu2csr_rdata;         // TDU read data\ntype_scr1_csr_resp_e                        tdu2csr_resp;          // TDU response\n `ifdef SCR1_DBG_EN\n                                                                    // Qualified TDU input signals from pipe_rst_n\n                                                                    // reset domain:\nlogic                                       csr2tdu_req_qlfy;      //     Request to TDU\n `endif // SCR1_DBG_EN\n\n// EXU/LSU <-> TDU\ntype_scr1_brkm_instr_mon_s                  exu2tdu_i_mon;         // Instruction monitor\ntype_scr1_brkm_lsu_mon_s                    lsu2tdu_d_mon;         // Data monitor\nlogic [SCR1_TDU_ALLTRIG_NUM-1:0]            tdu2exu_i_match;       // Instruction breakpoint(s) match\nlogic [SCR1_TDU_MTRIG_NUM-1:0]              tdu2lsu_d_match;       // Data breakpoint(s) match\nlogic                                       tdu2exu_i_x_req;       // Instruction breakpoint exception\nlogic                                       tdu2lsu_i_x_req;       // Instruction breakpoint exception\nlogic                                       tdu2lsu_d_x_req;       // Data breakpoint exception\nlogic [SCR1_TDU_ALLTRIG_NUM-1:0]            exu2tdu_bp_retire;     // Instruction with breakpoint flag retire\n `ifdef SCR1_DBG_EN\n                                                                    // Qualified TDU input signals from pipe_rst_n\n                                                                    // reset domain:\ntype_scr1_brkm_instr_mon_s                  exu2tdu_i_mon_qlfy;         // Instruction monitor\ntype_scr1_brkm_lsu_mon_s                    lsu2tdu_d_mon_qlfy;         // Data monitor\nlogic [SCR1_TDU_ALLTRIG_NUM-1:0]            exu2tdu_bp_retire_qlfy;     // Instruction with breakpoint flag retire\n `endif // SCR1_DBG_EN\n`endif // SCR1_TDU_EN\n\n`ifdef SCR1_DBG_EN\n// Debug signals:\nlogic                                       fetch_pbuf;             // Fetch instructions provided by Program Buffer (via HDU)\nlogic                                       csr2hdu_req;            // Request to HDU\ntype_scr1_csr_cmd_sel_e                     csr2hdu_cmd;            // HDU command\nlogic [SCR1_HDU_DEBUGCSR_ADDR_WIDTH-1:0]    csr2hdu_addr;           // HDU address\nlogic [`SCR1_XLEN-1:0]                      csr2hdu_wdata;          // HDU write data\nlogic [`SCR1_XLEN-1:0]                      hdu2csr_rdata;          // HDU read data\ntype_scr1_csr_resp_e                        hdu2csr_resp;           // HDU response\n                                                                    // Qualified HDU input signals from pipe_rst_n\n                                                                    // reset domain:\nlogic                                       csr2hdu_req_qlfy;       //     Request to HDU\n\nlogic                                       hwbrk_dsbl;             // Disables TDU\nlogic                                       hdu_hwbrk_dsbl;         // Disables TDU\nlogic                                       tdu2hdu_dmode_req;      // TDU requests transition to debug mode\n\nlogic                                       exu_no_commit;          // Forbid instruction commitment\nlogic                                       exu_irq_dsbl;           // Disable IRQ\nlogic                                       exu_pc_advmt_dsbl;      // Forbid PC advancement\nlogic                                       exu_dmode_sstep_en;     // Enable single-step\n\nlogic                                       dbg_halted;             // Debug halted state\nlogic                                       dbg_run2halt;           // Transition to debug halted state\nlogic                                       dbg_halt2run;           // Transition to run state\nlogic                                       dbg_run_start;          // First cycle of run state\nlogic [`SCR1_XLEN-1:0]                      dbg_new_pc;             // New PC as starting point for HART Resume\n\nlogic                                       ifu2hdu_pbuf_rdy;\nlogic                                       hdu2ifu_pbuf_vd;\nlogic                                       hdu2ifu_pbuf_err;\nlogic [SCR1_HDU_CORE_INSTR_WIDTH-1:0]       hdu2ifu_pbuf_instr;\n\n// Qualified HDU input signals from pipe_rst_n reset domain:\nlogic                                       ifu2hdu_pbuf_rdy_qlfy;\nlogic                                       exu_busy_qlfy;\nlogic                                       instret_qlfy;\nlogic                                       exu_init_pc_qlfy;\nlogic                                       exu_exc_req_qlfy;\nlogic                                       brkpt_qlfy;\n\n`endif // SCR1_DBG_EN\n\nlogic                                       exu_busy;\n\n\n`ifndef SCR1_CLKCTRL_EN\nlogic                                       pipe2clkctl_wake_req_o;\n`endif // SCR1_CLKCTRL_EN\n\n//-------------------------------------------------------------------------------\n// Pipeline logic\n//-------------------------------------------------------------------------------\nassign stop_fetch   = wfi_run2halt\n`ifdef SCR1_DBG_EN\n                    | fetch_pbuf\n`endif // SCR1_DBG_EN\n                    ;\n\n`ifdef SCR1_CLKCTRL_EN\nassign pipe2clkctl_sleep_req_o = wfi_halted & ~imem_txns_pending;\nassign pipe2clkctl_wake_req_o  = csr2exu_ip_ie\n`ifdef SCR1_DBG_EN\n                    | dm2pipe_active_i\n`endif // SCR1_DBG_EN\n                    ;\n`endif // SCR1_CLKCTRL_EN\n\n`ifdef SCR1_DBG_EN\nassign pipe2dm_pc_sample_o = curr_pc;\n`endif // SCR1_DBG_EN\n\n//-------------------------------------------------------------------------------\n// Instruction fetch unit\n//-------------------------------------------------------------------------------\nscr1_pipe_ifu i_pipe_ifu (\n    .rst_n                    (pipe_rst_n         ),\n    .clk                      (clk                ),\n\n    // Instruction memory interface\n    .imem2ifu_req_ack_i       (imem2pipe_req_ack_i),\n    .ifu2imem_req_o           (pipe2imem_req_o    ),\n    .ifu2imem_cmd_o           (pipe2imem_cmd_o    ),\n    .ifu2imem_addr_o          (pipe2imem_addr_o   ),\n    .imem2ifu_rdata_i         (imem2pipe_rdata_i  ),\n    .imem2ifu_resp_i          (imem2pipe_resp_i   ),\n\n    // New PC interface\n    .exu2ifu_pc_new_req_i     (new_pc_req         ),\n    .exu2ifu_pc_new_i         (new_pc             ),\n    .pipe2ifu_stop_fetch_i    (stop_fetch         ),\n\n`ifdef SCR1_DBG_EN\n    // IFU <-> HDU Program Buffer interface\n    .hdu2ifu_pbuf_fetch_i     (fetch_pbuf         ),\n    .ifu2hdu_pbuf_rdy_o       (ifu2hdu_pbuf_rdy   ),\n    .hdu2ifu_pbuf_vd_i        (hdu2ifu_pbuf_vd    ),\n    .hdu2ifu_pbuf_err_i       (hdu2ifu_pbuf_err   ),\n    .hdu2ifu_pbuf_instr_i     (hdu2ifu_pbuf_instr ),\n`endif // SCR1_DBG_EN\n`ifdef SCR1_CLKCTRL_EN\n    .ifu2pipe_imem_txns_pnd_o (imem_txns_pending  ),\n`endif // SCR1_CLKCTRL_EN\n\n    // IFU <-> IDU interface\n    .idu2ifu_rdy_i            (idu2ifu_rdy        ),\n    .ifu2idu_instr_o          (ifu2idu_instr      ),\n    .ifu2idu_imem_err_o       (ifu2idu_imem_err   ),\n    .ifu2idu_err_rvi_hi_o     (ifu2idu_err_rvi_hi ),\n    .ifu2idu_vd_o             (ifu2idu_vd         )\n);\n\n//-------------------------------------------------------------------------------\n// Instruction decode unit\n//-------------------------------------------------------------------------------\nscr1_pipe_idu i_pipe_idu (\n`ifdef SCR1_TRGT_SIMULATION\n    .rst_n                  (pipe_rst_n        ),\n    .clk                    (clk               ),\n`endif // SCR1_TRG"}
{"text": "T_SIMULATION\n    .idu2ifu_rdy_o          (idu2ifu_rdy       ),\n    .ifu2idu_instr_i        (ifu2idu_instr     ),\n    .ifu2idu_imem_err_i     (ifu2idu_imem_err  ),\n    .ifu2idu_err_rvi_hi_i   (ifu2idu_err_rvi_hi),\n    .ifu2idu_vd_i           (ifu2idu_vd        ),\n\n    .idu2exu_req_o          (idu2exu_req       ),\n    .idu2exu_cmd_o          (idu2exu_cmd       ),\n    .idu2exu_use_rs1_o      (idu2exu_use_rs1   ),\n    .idu2exu_use_rs2_o      (idu2exu_use_rs2   ),\n`ifndef SCR1_NO_EXE_STAGE\n    .idu2exu_use_rd_o       (idu2exu_use_rd    ),\n    .idu2exu_use_imm_o      (idu2exu_use_imm   ),\n`endif // SCR1_NO_EXE_STAGE\n    .exu2idu_rdy_i          (exu2idu_rdy       )\n);\n\n//-------------------------------------------------------------------------------\n// Execution unit\n//-------------------------------------------------------------------------------\nscr1_pipe_exu i_pipe_exu (\n    .rst_n                          (pipe_rst_n              ),\n    .clk                            (clk                     ),\n`ifdef SCR1_CLKCTRL_EN\n    .clk_alw_on                     (clkctl2pipe_clk_alw_on_i),\n    .clk_pipe_en                    (clkctl2pipe_clk_en_i),\n`endif // SCR1_CLKCTRL_EN\n\n    // IDU <-> EXU interface\n    .idu2exu_req_i                  (idu2exu_req             ),\n    .exu2idu_rdy_o                  (exu2idu_rdy             ),\n    .idu2exu_cmd_i                  (idu2exu_cmd             ),\n    .idu2exu_use_rs1_i              (idu2exu_use_rs1         ),\n    .idu2exu_use_rs2_i              (idu2exu_use_rs2         ),\n`ifndef SCR1_NO_EXE_STAGE\n    .idu2exu_use_rd_i               (idu2exu_use_rd          ),\n    .idu2exu_use_imm_i              (idu2exu_use_imm         ),\n`endif // SCR1_NO_EXE_STAGE\n\n    // EXU <-> MPRF interface\n    .exu2mprf_rs1_addr_o            (exu2mprf_rs1_addr       ),\n    .mprf2exu_rs1_data_i            (mprf2exu_rs1_data       ),\n    .exu2mprf_rs2_addr_o            (exu2mprf_rs2_addr       ),\n    .mprf2exu_rs2_data_i            (mprf2exu_rs2_data       ),\n    .exu2mprf_w_req_o               (exu2mprf_w_req          ),\n    .exu2mprf_rd_addr_o             (exu2mprf_rd_addr        ),\n    .exu2mprf_rd_data_o             (exu2mprf_rd_data        ),\n\n    // EXU <-> CSR read/write interface\n    .exu2csr_rw_addr_o              (exu2csr_rw_addr         ),\n    .exu2csr_r_req_o                (exu2csr_r_req           ),\n    .csr2exu_r_data_i               (csr2exu_r_data          ),\n    .exu2csr_w_req_o                (exu2csr_w_req           ),\n    .exu2csr_w_cmd_o                (exu2csr_w_cmd           ),\n    .exu2csr_w_data_o               (exu2csr_w_data          ),\n    .csr2exu_rw_exc_i               (csr2exu_rw_exc          ),\n\n    // EXU <-> CSR event interface\n    .exu2csr_take_irq_o             (exu2csr_take_irq        ),\n    .exu2csr_take_exc_o             (exu2csr_take_exc        ),\n    .exu2csr_mret_update_o          (exu2csr_mret_update     ),\n    .exu2csr_mret_instr_o           (exu2csr_mret_instr      ),\n    .exu2csr_exc_code_o             (exu2csr_exc_code        ),\n    .exu2csr_trap_val_o             (exu2csr_trap_val        ),\n    .csr2exu_new_pc_i               (csr2exu_new_pc          ),\n    .csr2exu_irq_i                  (csr2exu_irq             ),\n    .csr2exu_ip_ie_i                (csr2exu_ip_ie           ),\n    .csr2exu_mstatus_mie_up_i       (csr2exu_mstatus_mie_up  ),\n\n    // EXU <-> DMEM interface\n    .exu2dmem_req_o                 (pipe2dmem_req_o         ),\n    .exu2dmem_cmd_o                 (pipe2dmem_cmd_o         ),\n    .exu2dmem_width_o               (pipe2dmem_width_o       ),\n    .exu2dmem_addr_o                (pipe2dmem_addr_o        ),\n    .exu2dmem_wdata_o               (pipe2dmem_wdata_o       ),\n    .dmem2exu_req_ack_i             (dmem2pipe_req_ack_i     ),\n    .dmem2exu_rdata_i               (dmem2pipe_rdata_i       ),\n    .dmem2exu_resp_i                (dmem2pipe_resp_i        ),\n\n`ifdef SCR1_DBG_EN\n    // EXU <-> HDU interface\n    .hdu2exu_no_commit_i            (exu_no_commit           ),\n    .hdu2exu_irq_dsbl_i             (exu_irq_dsbl            ),\n    .hdu2exu_pc_advmt_dsbl_i        (exu_pc_advmt_dsbl       ),\n    .hdu2exu_dmode_sstep_en_i       (exu_dmode_sstep_en      ),\n    .hdu2exu_pbuf_fetch_i           (fetch_pbuf              ),\n    .hdu2exu_dbg_halted_i           (dbg_halted              ),\n    .hdu2exu_dbg_run2halt_i         (dbg_run2halt            ),\n    .hdu2exu_dbg_halt2run_i         (dbg_halt2run            ),\n    .hdu2exu_dbg_run_start_i        (dbg_run_start           ),\n    .hdu2exu_dbg_new_pc_i           (dbg_new_pc              ),\n`endif // SCR1_DBG_EN\n\n`ifdef SCR1_TDU_EN\n    // EXU <-> TDU interface\n    .exu2tdu_imon_o                 (exu2tdu_i_mon           ),\n    .tdu2exu_ibrkpt_match_i         (tdu2exu_i_match         ),\n    .tdu2exu_ibrkpt_exc_req_i       (tdu2exu_i_x_req         ),\n    .lsu2tdu_dmon_o                 (lsu2tdu_d_mon           ),\n    .tdu2lsu_ibrkpt_exc_req_i       (tdu2lsu_i_x_req         ),\n    .tdu2lsu_dbrkpt_match_i         (tdu2lsu_d_match         ),\n    .tdu2lsu_dbrkpt_exc_req_i       (tdu2lsu_d_x_req         ),\n    .exu2tdu_ibrkpt_ret_o           (exu2tdu_bp_retire       ),\n `ifdef SCR1_DBG_EN\n    .exu2hdu_ibrkpt_hw_o            (brkpt_hw                ),\n `endif // SCR1_DBG_EN\n`endif // SCR1_TDU_EN\n\n    // EXU control\n    .exu2pipe_exc_req_o             (exu_exc_req             ),\n    .exu2pipe_brkpt_o               (brkpt                   ),\n    .exu2pipe_init_pc_o             (exu_init_pc             ),\n    .exu2pipe_wfi_run2halt_o        (wfi_run2halt            ),\n    .exu2pipe_instret_o             (instret                 ),\n`ifndef SCR1_CSR_REDUCED_CNT\n    .exu2csr_instret_no_exc_o       (instret_nexc            ),\n`endif // SCR1_CSR_REDUCED_CNT\n    .exu2pipe_exu_busy_o            (exu_busy                ),\n\n    // PC interface\n`ifdef SCR1_CLKCTRL_EN\n    .exu2pipe_wfi_halted_o          (wfi_halted              ),\n`endif // SCR1_CLKCTRL_EN\n    .exu2pipe_pc_curr_o             (curr_pc                 ),\n    .exu2csr_pc_next_o              (next_pc                 ),\n    .exu2ifu_pc_new_req_o           (new_pc_req              ),\n    .exu2ifu_pc_new_o               (new_pc                  )\n);\n\n//-------------------------------------------------------------------------------\n// Multi-port register file\n//-------------------------------------------------------------------------------\nscr1_pipe_mprf i_pipe_mprf (\n`ifdef SCR1_MPRF_RST_EN\n    .rst_n                  (pipe_rst_n       ),\n`endif // SCR1_MPRF_RST_EN\n    .clk                    (clk              ),\n\n    // EXU <-> MPRF interface\n    .exu2mprf_rs1_addr_i    (exu2mprf_rs1_addr),\n    .mprf2exu_rs1_data_o    (mprf2exu_rs1_data),\n    .exu2mprf_rs2_addr_i    (exu2mprf_rs2_addr),\n    .mprf2exu_rs2_data_o    (mprf2exu_rs2_data),\n    .exu2mprf_w_req_i       (exu2mprf_w_req   ),\n    .exu2mprf_rd_addr_i     (exu2mprf_rd_addr ),\n    .exu2mprf_rd_data_i     (exu2mprf_rd_data )\n);\n\n//-------------------------------------------------------------------------------\n// Control and status registers\n//-------------------------------------------------------------------------------\nscr1_pipe_csr i_pipe_csr (\n    .rst_n                      (pipe_rst_n              ),\n    .clk                        (clk                     ),\n`ifndef SCR1_CSR_REDUCED_CNT\n `ifdef SCR1_CLKCTRL_EN\n    .clk_alw_on                 (clkctl2pipe_clk_alw_on_i),\n `endif // SCR1_CLKCTRL_EN\n`endif // SCR1_CSR_REDUCED_CNT\n\n    // EXU <-> CSR read/write interface\n    .exu2csr_r_req_i            (exu2csr_r_req           ),\n    .exu2csr_rw_addr_i          (exu2csr_rw_addr         ),\n    .csr2exu_r_data_o           (csr2exu_r_data          ),\n    .exu2csr_w_req_i            (exu2csr_w_req           ),\n    .exu2csr_w_cmd_i            (exu2csr_w_cmd           ),\n    .exu2csr_w_data_i           (exu2csr_w_data          ),\n    .csr2exu_rw_exc_o           (csr2exu_rw_exc          ),\n\n    // EXU <-> CSR event interface\n    .exu2csr_take_irq_i         (exu2csr_take_irq        ),\n    .exu2csr_take_exc_i         (exu2csr_take_exc        ),\n    .exu2csr_mret_update_i      (exu2csr_mret_update     ),\n    .exu2csr_mret_instr_i       (exu2csr_mret_instr      ),\n    .exu2csr_exc_code_i         (exu2csr_exc_code        ),\n    .exu2csr_trap_val_i         (exu2csr_trap_val        ),\n    .csr2exu_new_pc_o           (csr2exu_new_pc          ),\n    .csr2exu_irq_o              (csr2exu_irq             ),\n    .csr2exu_ip_ie_o            (csr2exu_ip_ie           ),\n    .csr2exu_mstatus_mie_up_o   (csr2exu_mstatus_mie_up  ),\n\n`ifdef SCR1_IPIC_EN\n    // CSR <-> IPIC interface\n    .csr2ipic_r_req_o           (csr2ipic_r_req          ),\n    .csr2ipic_w_req_o           (csr2ipic_w_req          ),\n    .csr2ipic_addr_o            (csr2ipic_addr           ),\n    .csr2ipic_wdata_o           (csr2ipic_wdata          ),\n    .ipic2csr_rdata_i           (ipic2csr_rdata          ),\n`endif // SCR1_IPIC_EN\n\n    // CSR <-> PC interface\n    .exu2csr_pc_curr_i          (curr_pc                 ),\n    .exu2csr_pc_next_i          (next_pc                 ),\n`ifndef SCR1_CSR_REDUCED_CNT\n    .exu2csr_instret_no_exc_i   (instret_nexc            ),\n`endif // SCR1_CSR_REDUCED_CNT\n\n    // IRQ\n`ifdef SCR1_IPIC_EN\n    .soc2csr_irq_ext_i          (ipic2csr_irq            ),\n`else // SCR1_IPIC_EN\n    .soc2csr_irq_ext_i          (soc2pipe_irq_ext_i      ),\n`endif // SCR1_IPIC_EN\n    .soc2csr_irq_soft_i         (soc2pipe_irq_soft_i     ),\n    .soc2csr_irq_mtimer_i       (soc2pipe_irq_mtimer_i   ),\n\n    // Memory-mapped external timer\n    .soc2csr_mtimer_val_i       (soc2pipe_mtimer_val_i   ),\n\n`ifdef SCR1_DBG_EN\n    // CSR <-> HDU interface\n    .csr2hdu_req_o              (csr2hdu_req             ),\n    .csr2hdu_cmd_o              (csr2hdu_cmd             ),\n    .csr2hdu_addr_o             (csr2hdu_addr            ),\n    .csr2hdu_wdata_o            (csr2hdu_wdata           ),\n    .hdu2csr_rdata_i            (hdu2csr_rdata           ),\n    .hdu2csr_resp_i             (hdu2csr_resp            ),\n    .hdu2csr_no_commit_i        (exu_no_commit           ),\n`endif // SCR1_DBG_EN\n\n`ifdef SCR1_TDU_EN\n    // CSR <-> TDU interface\n    .csr2tdu_req_o              (csr2tdu_req             ),\n    .csr2tdu_cmd_o              (csr2tdu_cmd             ),\n    .csr2tdu_addr_o             (csr2tdu_addr            ),\n    .csr2tdu_wdata_o            (csr2tdu_wdata           ),\n    .tdu2csr_rdata_i            (tdu2csr_rdata           ),\n    .tdu2csr_resp_i             (tdu2csr_resp            ),\n`endif // SCR1_TDU_EN\n    .soc2csr_fuse_mhartid_i     (soc2pipe_fuse_mhartid_i )\n);\n\n//-------------------------------------------------------------------------------\n// Integrated programmable interrupt controller\n//-------------------------------------------------------------------------------\n`ifdef SCR1_IPIC_EN\nscr1_ipic i_pipe_ipic (\n    .rst_n                  (pipe_rst_n              ),\n`ifdef SCR1_CLKCTRL_EN\n    .clk                    (clkctl2pipe_clk_alw_on_i),\n`else // SCR1_CLKCTRL_EN\n    .clk                    (clk                     ),\n`endif // SCR1_CLKCTRL_EN\n    .soc2ipic_irq_lines_i   (soc2pipe_irq_lines_i    ),\n    .csr2ipic_r_req_i       (csr2ipic_r_req          ),\n    .csr2ipic_w_req_i       (csr2ipic_w_req          ),\n    .csr2ipic_addr_i        (csr2ipic_addr           ),\n    .csr2ipic_wdata_i       (csr2ipic_wdata          ),\n    .ipic2csr_rdata_o       (ipic2csr_rdata          ),\n    .ipic2csr_irq_m_req_o   (ipic2csr_irq            )\n);\n`endif // SCR1_IPIC_EN\n\n//-------------------------------------------------------------------------------\n// Breakpoint module\n//-------------------------------------------------------------------------------\n`ifdef SCR1_TDU_EN\nscr1_pipe_tdu i_pipe_tdu (\n    // Common signals\n `ifdef SCR1_DBG_EN\n    .rst_n                      (dbg_rst_n             ),\n `else\n    .rst_n                      (pipe_rst_n            ),\n `endif // SCR1_DBG_EN\n    .clk                        (clk                   ),\n    .clk_en                     (1'b1                  ),\n `ifdef SCR1_DBG_EN\n    .tdu_dsbl_i                 (hwbrk_dsbl            ),\n `else // SCR1_DBG_EN\n    .tdu_dsbl_i                 (1'b0                  ),\n `endif // SCR1_DBG_EN\n\n    // TDU <-> CSR interface\n `ifdef SCR1_DBG_EN\n    .csr2tdu_req_i              (csr2tdu_req_qlfy      ),\n    .csr2tdu_cmd_i              (csr2tdu_cmd           ),\n    .csr2tdu_addr_i             (csr2tdu_addr          ),\n    .csr2tdu_wdata_i            (csr2tdu_wdata         ),\n `else // SCR1_DBG_EN\n    .csr2tdu_req_i              (csr2tdu_req           ),\n    .csr2tdu_cmd_i              (csr2tdu_cmd           ),\n    .csr2tdu_addr_i             (csr2tdu_addr          ),\n    .csr2tdu_wdata_i            (csr2tdu_wdata         ),\n `endif // SCR1_DBG_EN\n    .tdu2csr_rdata_o            (tdu2csr_rdata         ),\n    .tdu2csr_resp_o             (tdu2csr_resp          ),\n\n    // TDU <-> EXU interface\n `ifdef SCR1_DBG_EN\n    .exu2tdu_imon_i             (exu2tdu_i_mon_qlfy    ),\n `else // SCR1_DBG_EN\n    .exu2tdu_imon_i             (exu2tdu_i_mon         ),\n `endif // SCR1_DBG_EN\n    .tdu2exu_ibrkpt_match_o     (tdu2exu_i_match       ),\n    .tdu2exu_ibrkpt_exc_req_o   (tdu2exu_i_x_req       ),\n `ifdef SCR1_DBG_EN\n    .exu2tdu_bp_retire_i        (exu2tdu_bp_retire_qlfy),\n `else // SCR1_DBG_EN\n    .exu2tdu_bp_retire_i        (exu2tdu_bp_retire     ),\n `endif // SCR1_DBG_EN\n\n    // TDU <-> LSU interface\n    .tdu2lsu_ibrkpt_exc_req_o   (tdu2lsu_i_x_req       ),\n `ifdef SCR1_DBG_EN\n    .lsu2tdu_dmon_i             (lsu2tdu_d_mon_qlfy    ),\n `else // SCR1_DBG_EN\n    .lsu2tdu_dmon_i             (lsu2tdu_d_mon         ),\n `endif // SCR1_DBG_EN\n    .tdu2lsu_dbrkpt_match_o     (tdu2lsu_d_match       ),\n    .tdu2lsu_dbrkpt_exc_req_o   (tdu2lsu_d_x_req       ),\n    // EPU I/F\n `ifdef SCR1_DBG_EN\n    .tdu2hdu_dmode_req_o        (tdu2hdu_dmode_req     )\n `else // SCR1_DBG_EN\n    .tdu2hdu_dmode_req_o        (                      )\n `endif // SCR1_DBG_EN\n);\n\n `ifdef SCR1_DBG_EN\nassign hwbrk_dsbl               = (~dbg_en) | hdu_hwbrk_dsbl;\n//\nassign csr2tdu_req_qlfy         = dbg_en & csr2tdu_req & pipe2hdu_rdc_qlfy_i;\n//\nassign exu2tdu_i_mon_qlfy.vd    = exu2tdu_i_mon.vd & pipe2hdu_rdc_qlfy_i;\nassign exu2tdu_i_mon_qlfy.req   = exu2tdu_i_mon.req;\nassign exu2tdu_i_mon_qlfy.addr  = exu2tdu_i_mon.addr;\nassign lsu2tdu_d_mon_qlfy.vd    = lsu2tdu_d_mon.vd & pipe2hdu_rdc_qlfy_i;\nassign lsu2tdu_d_mon_qlfy.load  = lsu2tdu_d_mon.load;\nassign lsu2tdu_d_mon_qlfy.store = lsu2tdu_d_mon.store;\nassign lsu2tdu_d_mon_qlfy.addr  = lsu2tdu_d_mon.addr;\nassign exu2tdu_bp_retire_qlfy   = exu2tdu_bp_retire & {$bits(exu2tdu_bp_retire){pipe2hdu_rdc_qlfy_i}};\n `endif // SCR1_DBG_EN\n\n`endif // SCR1_TDU_EN\n\n//-------------------------------------------------------------------------------\n// HART Debug Unit (HDU)\n//-------------------------------------------------------------------------------\n`ifdef SCR1_DBG_EN\nscr1_pipe_hdu i_pipe_hdu (\n    // Common signals\n    .rst_n                      (dbg_rst_n             ),\n    .clk_en                     (dm2pipe_active_i      ),\n`ifdef SCR1_CLKCTRL_EN\n    .clk_pipe_en                (clkctl2pipe_clk_en_i  ),\n    .clk                        (clkctl2pipe_clk_dbgc_i),\n`else\n    .clk                        (clk                   ),\n`endif // SCR1_CLKCTRL_EN\n\n    // Control/status registers i/f\n    .csr2hdu_req_i              (csr2hdu_req_qlfy      ),\n    .csr2hdu_cmd_i              (csr2hdu_cmd           ),\n    .csr2hdu_addr_i             (csr2hdu_addr          ),\n    .csr2hdu_wdata_i            (csr2hdu_wdata         ),\n    .hdu2csr_resp_o             (hdu2csr_resp          ),\n    .hdu2csr_rdata_o            (hdu2csr_rdata         ),\n\n    // HART Run Control i/f\n    .pipe2hdu_rdc_qlfy_i        (pipe2hdu_rdc_qlfy_i   ),\n    .dm2hdu_cmd_req_i           (dm2pipe_cmd_req_i     ),\n    .dm2hdu_cmd_i               (dm2pipe_cmd_i         ),\n    .hdu2dm_cmd_resp_o          (pipe2dm_cmd_resp_o    ),\n    .hdu2dm_cmd_rcode_o         (pipe2dm_cmd_rcode_o   ),\n    .hdu2dm_hart_event_o        (pipe2dm_hart_event_o  ),\n    .hdu2dm_hart_status_o       (pipe2dm_hart_status_o ),\n\n    // Program Buffer - HART instruction execution i/f\n    .hdu2dm_pbuf_addr_o         (pipe2dm_pbuf_addr_o   ),\n    .dm2hdu_pbuf_instr_i        (dm2pipe_pbuf_instr_i  ),\n\n    // HART Abstract Data regs i/f\n    .hdu2dm_dreg_req_o          (pipe2dm_dreg_req_o    ),\n    .hdu2dm_dreg_wr_o           (pipe2dm_dreg_wr_o     ),\n    .hdu2dm_dreg_wdata_o        (pipe2dm_dreg_wdata_o  ),\n    .dm2hdu_dreg_resp_i         (dm2pipe_dreg_resp_i   ),\n    .dm2hdu_dreg_fail_i         (dm2pipe_dreg_fail_i   ),\n    .dm2hdu_dreg_rdata_i        (dm2pipe_dreg_rdata_i  ),\n    //\n`ifdef SCR1_TDU_EN\n    // HDU <-> TDU interface\n    .hdu2tdu_hwbrk_dsbl_o       (hdu_hwbrk_dsbl        ),\n    .tdu2hdu_dmode_req_i        (tdu2hdu_dmode_req     ),\n    .exu2hdu_ibrkpt_hw_i        (brkpt_hw              ),\n`endif // SCR1_TDU_EN\n\n    // HART Run Status\n    .pipe2hdu_exu_busy_i        (exu_busy_qlfy         ),\n    .pipe2hdu_instret_i         (instret_qlfy          ),\n    .pipe2hdu_init_pc_i         (exu_init_pc_qlfy      ),\n\n    // HART Halt Status\n    .pipe2hdu_exu_exc_req_i     (exu_exc_req_qlfy      ),\n    .pipe2hdu_brkpt_i           (brkpt_qlfy            ),\n\n    // HART Run Control\n    .hdu2exu_pbuf_fetch_o       (fetch_pbuf            ),\n    .hdu2exu_no_commit_o        (exu_no_commit         ),\n    .hdu2exu_irq_dsbl_o         (exu_irq_dsbl          ),\n    .hdu2exu_pc_advmt_dsbl_o    (exu_pc_advmt_dsbl     ),\n    .hdu2exu_dmode_sstep_en_o   (exu_dmode_sstep_en    ),\n\n    // HART state\n    .hdu2exu_dbg_halted_o       (dbg_halted            ),\n    .hdu2exu_dbg_run2halt_o     (dbg_run2halt          ),\n    .hdu2exu_dbg_halt2run_o     (dbg_halt2run          ),\n    .hdu2exu_dbg_run_start_o    (dbg_run_start         ),\n\n    // PC interface\n    .pipe2hdu_pc_curr_i         (curr_pc               ),\n    .hdu2exu_dbg_new_pc_o       (dbg_new_pc            ),\n\n    // Prgram Buffer Instruction interface\n    .ifu2hdu_pbuf_instr_rdy_i   (ifu2hdu_pbuf_rdy_qlfy ),\n    .hdu2ifu_pbuf_instr_vd_o    (hdu2ifu_pbuf_vd       ),\n    .hdu2ifu_pbuf_instr_err_o   (hdu2ifu_pbuf_err      ),\n    .hdu2ifu_pbuf_instr_o       (hdu2ifu_pbuf_instr    )\n);\n\nassign csr2hdu_req_qlfy         = csr2hdu_req & dbg_en & pipe2hdu_rdc_qlfy_i;\n//\nassign exu_busy_qlfy            = exu_busy          & {$bits(exu_busy){pipe2hdu_rdc_qlfy_i}};\nassign instret_qlfy             = instret           & {$bits(instret){pipe2hdu_rdc_qlfy_i}};\nassign exu_init_pc_qlfy         = exu_init_pc       & {$bits(exu_init_pc){pipe2hdu_rdc_qlfy_i}};\nassign exu_exc_req_qlfy         = exu_exc_req       & {$bits(exu_exc_req){pipe2hdu_rdc_qlfy_i}};\nassign brkpt_qlfy               = brkpt             & {$bits(brkpt){pipe2hdu_rdc_qlfy_i}};\nassign ifu2hdu_pbuf_rdy_qlfy    = ifu2hdu_pbuf_rdy  & {$bits(ifu2hdu_pbuf_rdy){pipe2hdu_rdc_qlfy_i}};\n\n`endif // SCR1_DBG_EN\n\n`ifdef SCR1_TRGT_SIMULATION\n//-------------------------------------------------------------------------------\n// Tracelog\n//-------------------------------------------------------------------------------\n\nscr1_tracelog i_tracelog (\n    .rst_n                          (pipe_rst_n                         ),\n    .clk                            (clk                                )\n`ifdef SCR1_TRACE_LOG_EN\n    ,\n    .soc2pipe_fuse_mhartid_i        (soc2pipe_fuse_mhartid_i            ),\n\n    // MPRF\n    .mprf2trace_int_i               (i_pipe_mprf.mprf_int               ),\n    .mprf2trace_wr_en_i             (i_pipe_mprf.exu2mprf_w_req_i       ),\n    .mprf2trace_wr_addr_i           (i_pipe_mprf.exu2mprf_rd_addr_i     ),\n    .mprf2trace_wr_data_i           (i_pipe_mprf.exu2mprf_rd_data_i     ),\n\n    // EXU\n    .exu2trace_update_pc_en_i       (i_pipe_exu.update_pc_en            ),\n    .exu2trace_update_pc_i          (i_pipe_exu.update_pc               ),\n\n    // IFU\n    .ifu2trace_instr_i              (i_pipe"}
{"text": "_ifu.ifu2idu_instr_o         ),\n\n    // CSR\n    .csr2trace_mstatus_mie_i        (i_pipe_csr.csr_mstatus_mie_ff      ),\n    .csr2trace_mstatus_mpie_i       (i_pipe_csr.csr_mstatus_mpie_ff     ),\n    .csr2trace_mtvec_base_i         (i_pipe_csr.csr_mtvec_base          ),\n    .csr2trace_mtvec_mode_i         (i_pipe_csr.csr_mtvec_mode          ),\n    .csr2trace_mie_meie_i           (i_pipe_csr.csr_mie_meie_ff         ),\n    .csr2trace_mie_mtie_i           (i_pipe_csr.csr_mie_mtie_ff         ),\n    .csr2trace_mie_msie_i           (i_pipe_csr.csr_mie_msie_ff         ),\n    .csr2trace_mip_meip_i           (i_pipe_csr.csr_mip_meip            ),\n    .csr2trace_mip_mtip_i           (i_pipe_csr.csr_mip_mtip            ),\n    .csr2trace_mip_msip_i           (i_pipe_csr.csr_mip_msip            ),\n    .csr2trace_mepc_i               (i_pipe_csr.csr_mepc_ff             ),\n    .csr2trace_mcause_irq_i         (i_pipe_csr.csr_mcause_i_ff         ),\n    .csr2trace_mcause_ec_i          (i_pipe_csr.csr_mcause_ec_ff        ),\n    .csr2trace_mtval_i              (i_pipe_csr.csr_mtval_ff            ),\n\n    // Events\n    .csr2trace_e_exc_i              (i_pipe_csr.e_exc                   ),\n    .csr2trace_e_irq_i              (i_pipe_csr.e_irq                   ),\n    .pipe2trace_e_wake_i            (pipe2clkctl_wake_req_o             )\n`endif // SCR1_TRACE_LOG_EN\n);\n\n`endif // SCR1_TRGT_SIMULATION\n\nendmodule : scr1_pipe_top\n"}
{"text": "/// Copyright by Syntacore LLC \u00a9 2016-2021. See LICENSE for details\n/// @file       <scr1_sync_rstn.sv>\n/// @brief      Cells for reset handling\n///\n\n//--------------------------------------------------------------------\n// Reset Buffer Cell\n//--------------------------------------------------------------------\nmodule scr1_reset_buf_cell (\n    input   logic           rst_n,\n    input   logic           clk,\n    input   logic           test_mode,\n    input   logic           test_rst_n,\n    input   logic           reset_n_in,\n    output  logic           reset_n_out,\n    output  logic           reset_n_status\n);\n\nlogic       reset_n_ff;\nlogic       reset_n_status_ff;\nlogic       rst_n_mux;\n\nassign rst_n_mux = (test_mode == 1'b1) ? test_rst_n : rst_n;\n\nalways_ff @(negedge rst_n_mux, posedge clk) begin\n    if (~rst_n_mux) begin\n        reset_n_ff <= 1'b0;\n    end else begin\n        reset_n_ff <= reset_n_in;\n    end\nend\n\nassign reset_n_out = (test_mode == 1'b1) ? test_rst_n : reset_n_ff;\n\nalways_ff @(negedge rst_n_mux, posedge clk) begin\n    if (~rst_n_mux) begin\n        reset_n_status_ff <= 1'b0;\n    end else begin\n        reset_n_status_ff <= reset_n_in;\n    end\nend\nassign reset_n_status = reset_n_status_ff;\n\nendmodule : scr1_reset_buf_cell\n\n//--------------------------------------------------------------------\n// Reset CDC Synchronization Cell\n//--------------------------------------------------------------------\nmodule scr1_reset_sync_cell #(\n    parameter int unsigned STAGES_AMOUNT = 2\n) (\n    input   logic           rst_n,\n    input   logic           clk,\n    input   logic           test_rst_n,\n    input   logic           test_mode,\n    input   logic           rst_n_in,\n    output  logic           rst_n_out\n);\n\nlogic [STAGES_AMOUNT-1:0]   rst_n_dff;\nlogic                       local_rst_n_in;\n\nassign local_rst_n_in = (test_mode == 1'b1) ? test_rst_n : rst_n;\n\ngenerate\n\nif (STAGES_AMOUNT == 1)\n\nbegin : gen_reset_sync_cell_single\n    always_ff @(negedge local_rst_n_in, posedge clk) begin\n        if (~local_rst_n_in) begin\n            rst_n_dff <= 1'b0;\n        end else begin\n            rst_n_dff <= rst_n_in;\n        end\n    end\nend : gen_reset_sync_cell_single\n\nelse // STAGES_AMOUNT > 1\n\nbegin : gen_reset_sync_cell_multi\n    always_ff @(negedge local_rst_n_in, posedge clk)\n    begin\n        if (~local_rst_n_in) begin\n            rst_n_dff <= '0;\n        end else begin\n            rst_n_dff <= {rst_n_dff[STAGES_AMOUNT-2:0], rst_n_in};\n        end\n    end\nend : gen_reset_sync_cell_multi\n\nendgenerate\n\nassign rst_n_out = (test_mode == 1'b1) ? test_rst_n : rst_n_dff[STAGES_AMOUNT-1];\n\nendmodule : scr1_reset_sync_cell\n\n//--------------------------------------------------------------------\n// Data CDC/RDC Synchronization Cell\n//--------------------------------------------------------------------\nmodule scr1_data_sync_cell #(\n    parameter int unsigned  STAGES_AMOUNT = 1\n) (\n    input   logic           rst_n,\n    input   logic           clk,\n    input   logic           data_in,\n    output  logic           data_out\n);\n\nlogic [STAGES_AMOUNT-1:0] data_dff;\n\ngenerate\n\nif (STAGES_AMOUNT == 1)\n\nbegin : gen_data_sync_cell_single\n    always_ff @(negedge rst_n, posedge clk)\n    begin\n        if (~rst_n) begin\n            data_dff <= 1'b0;\n        end else begin\n            data_dff <= data_in;\n        end\n    end\nend : gen_data_sync_cell_single\n\nelse // STAGES_AMOUNT > 1\n\nbegin : gen_data_sync_cell_multi\n    always_ff @(negedge rst_n, posedge clk)\n    begin\n        if (~rst_n) begin\n            data_dff <= '0;\n        end else begin\n            data_dff <= {data_dff[STAGES_AMOUNT-2:0], data_in};\n        end\n    end\nend : gen_data_sync_cell_multi\n\nendgenerate\n\nassign data_out = data_dff[STAGES_AMOUNT-1];\n\nendmodule : scr1_data_sync_cell\n\n//--------------------------------------------------------------------\n// Reset / RDC Qualifyer Adapter Cell\n//   (Reset Generation Cell w/ RDC Qualifyer Adaptation circuitry)\n//--------------------------------------------------------------------\n// Total stages amount =\n//    1 Front Sync stage \\\n//  + 1 (delay introduced by the reset output buffer register)\n//--------------------------------------------------------------------\nmodule scr1_reset_qlfy_adapter_cell_sync (\n    input   logic           rst_n,\n    input   logic           clk,\n    input   logic           test_rst_n,\n    input   logic           test_mode,\n    input   logic           reset_n_in_sync,\n    output  logic           reset_n_out_qlfy,\n    output  logic           reset_n_out,\n    output  logic           reset_n_status\n);\n\nlogic rst_n_mux;\nlogic reset_n_front_ff;\n\n// Front sync stage\nassign rst_n_mux = (test_mode == 1'b1) ? test_rst_n : rst_n;\n\nalways_ff @(negedge rst_n_mux, posedge clk) begin\n    if (~rst_n_mux) begin\n        reset_n_front_ff    <= 1'b0;\n    end else begin\n        reset_n_front_ff    <= reset_n_in_sync;\n    end\nend\n\n//   Sync reset output for all reset qualifier chains targeting this reset domain\n// (for reset-domain-crossings with the given reset domain as a destination).\nassign reset_n_out_qlfy = reset_n_front_ff;\n\n// Reset output buffer\nscr1_reset_buf_cell\ni_reset_output_buf (\n    .rst_n              (rst_n),\n    .clk                (clk),\n    .test_mode          (test_mode),\n    .test_rst_n         (test_rst_n),\n    .reset_n_in         (reset_n_front_ff),\n    .reset_n_out        (reset_n_out),\n    .reset_n_status     (reset_n_status)\n);\n\nendmodule : scr1_reset_qlfy_adapter_cell_sync\n\nmodule scr1_reset_and2_cell (\n    input   logic [1:0]     rst_n_in,\n    input   logic           test_rst_n,\n    input   logic           test_mode,\n    output  logic           rst_n_out\n);\n\nassign rst_n_out = (test_mode == 1'b1) ? test_rst_n : (&rst_n_in);\n\nendmodule : scr1_reset_and2_cell\n\n\nmodule scr1_reset_and3_cell (\n    input   logic [2:0]     rst_n_in,\n    input   logic           test_rst_n,\n    input   logic           test_mode,\n    output  logic           rst_n_out\n);\n\nassign rst_n_out = (test_mode == 1'b1) ? test_rst_n : (&rst_n_in);\n\nendmodule : scr1_reset_and3_cell\n\n\nmodule scr1_reset_mux2_cell (\n    input   logic [1:0]     rst_n_in,\n    input   logic           select,\n    input   logic           test_rst_n,\n    input   logic           test_mode,\n    output  logic           rst_n_out\n);\n\nassign rst_n_out = (test_mode == 1'b1) ? test_rst_n : rst_n_in[select];\n\nendmodule : scr1_reset_mux2_cell\n"}
{"text": "/// Copyright by Syntacore LLC \u00a9 2016-2021. See LICENSE for details\n/// @file <scr1_scu.sv>\n/// @brief System Control Unit (SCU)\n///\n\n//------------------------------------------------------------------------------\n //\n // Functionality:\n // - Generates System, Core, HDU and DM resets and their qualifier signals\n // - Provides debugger with software System and Core resets generation functionality\n // - Allows to set the behavior of DM and HDU resets\n // - Shows resets Statuses and Sticky Statuses\n\n // Structure:\n // - TAPC scan-chain interface\n // - SCU CSRs write/read interface\n // - SCU CSRS:\n //   - CONTROL register\n //   - MODE register\n //   - STATUS register\n //   - STICKY_STATUS register\n // - Reset logic\n //   - System Reset\n //   - Core Reset\n //   - DM Reset\n //   - HDU Reset\n//------------------------------------------------------------------------------\n\n`include \"scr1_arch_description.svh\"\n`include \"scr1_scu.svh\"\n\n`ifdef SCR1_DBG_EN\n\nmodule scr1_scu (\n    // Global signals\n    input  logic        pwrup_rst_n,                  // Power-Up Reset\n    input  logic        rst_n,                        // Regular Reset\n    input  logic        cpu_rst_n,                    // CPU Reset\n    input  logic        test_mode,                    // DFT Test Mode\n    input  logic        test_rst_n,                   // DFT Test Reset\n    input  logic        clk,                          // SCU clock\n\n    // TAPC scan-chains\n    input  logic        tapcsync2scu_ch_sel_i,        // TAPC Chain Select\n    input  logic        tapcsync2scu_ch_id_i,         // TAPC Chain ID\n    input  logic        tapcsync2scu_ch_capture_i,    // TAPC Chain Capture\n    input  logic        tapcsync2scu_ch_shift_i,      // TAPC Chain Shift\n    input  logic        tapcsync2scu_ch_update_i,     // TAPC Chain Update\n    input  logic        tapcsync2scu_ch_tdi_i,        // TAPC Chain TDI\n    output logic        scu2tapcsync_ch_tdo_o,        // TAPC Chain TDO\n\n    // Input sync resets:\n    input  logic        ndm_rst_n_i,                  // Non-DM Reset input from DM\n    input  logic        hart_rst_n_i,                 // HART Reset from DM\n\n    // Generated resets\n    output logic        sys_rst_n_o,                  // System/Cluster Reset\n    output logic        core_rst_n_o,                 // Core Reset\n    output logic        dm_rst_n_o,                   // Debug Module Reset\n    output logic        hdu_rst_n_o,                  // HART Debug Unit Reset\n\n    // Resets statuses\n    output logic        sys_rst_status_o,             // System Reset Status (sync'ed to POR reset domain)\n    output logic        core_rst_status_o,            // Core Reset Status (sync'ed to POR reset domain)\n\n    // Reset Domain Crossing (RDC) qualifiers\n    output logic        sys_rdc_qlfy_o,               // System/Cluster-to-ExternalSOC Reset Domain Crossing Qualifier\n    output logic        core_rdc_qlfy_o,              // Core-to-ExternalSOC Reset Domain Crossing Qualifier\n    output logic        core2hdu_rdc_qlfy_o,          // Core-to-HDU Reset Domain Crossing Qualifier\n    output logic        core2dm_rdc_qlfy_o,           // Core-to-DM Reset Domain Crossing Qualifier\n    output logic        hdu2dm_rdc_qlfy_o             // HDU-to-DM Reset Domain Crossing Qualifier\n);\n\n//------------------------------------------------------------------------------\n// Local Parameters\n//======================================================================================================================\nlocalparam int unsigned SCR1_SCU_RST_SYNC_STAGES_NUM        = 2;\n\n//------------------------------------------------------------------------------\n// Local Signals\n//------------------------------------------------------------------------------\n\n// SCU CSR write/read i/f\n//------------------------------------------------------------------------------\n\n// TAPC scan-chain control logic\nlogic                                       scu_csr_req;\nlogic                                       tapc_dr_cap_req;\nlogic                                       tapc_dr_shft_req;\nlogic                                       tapc_dr_upd_req;\n\n// TAPC shift register signals\nlogic                                       tapc_shift_upd;\ntype_scr1_scu_sysctrl_dr_s                  tapc_shift_ff;\ntype_scr1_scu_sysctrl_dr_s                  tapc_shift_next;\n\n// TAPC shadow register signals\ntype_scr1_scu_sysctrl_dr_s                  tapc_shadow_ff;\n\n// SCU CSR write/read i/f\n//------------------------------------------------------------------------------\n\nlogic [SCR1_SCU_DR_SYSCTRL_DATA_WIDTH-1:0]  scu_csr_wdata;\nlogic [SCR1_SCU_DR_SYSCTRL_DATA_WIDTH-1:0]  scu_csr_rdata;\n\n// SCU CSRs signals\n//------------------------------------------------------------------------------\n\n// Control register\ntype_scr1_scu_sysctrl_control_reg_s         scu_control_ff;\nlogic                                       scu_control_wr_req;\n\n// Mode register\ntype_scr1_scu_sysctrl_mode_reg_s            scu_mode_ff;\nlogic                                       scu_mode_wr_req;\n\n// Status register\ntype_scr1_scu_sysctrl_status_reg_s          scu_status_ff;\ntype_scr1_scu_sysctrl_status_reg_s          scu_status_ff_dly;\ntype_scr1_scu_sysctrl_status_reg_s          scu_status_ff_posedge;\n\n// Sticky Status register\ntype_scr1_scu_sysctrl_status_reg_s          scu_sticky_sts_ff;\nlogic                                       scu_sticky_sts_wr_req;\n\n// Reset logic signals\n//------------------------------------------------------------------------------\n\n// Input resets synchronization signals\nlogic                                       pwrup_rst_n_sync;\nlogic                                       rst_n_sync;\nlogic                                       cpu_rst_n_sync;\n\n// System Reset signals\nlogic                                       sys_rst_n_in;\nlogic                                       sys_rst_n_status;\nlogic                                       sys_rst_n_status_sync;\nlogic                                       sys_rst_n_qlfy;\nlogic                                       sys_reset_n;\n\n// Core Reset signals\nlogic                                       core_rst_n_in_sync;\nlogic                                       core_rst_n_status;\nlogic                                       core_rst_n_status_sync;\nlogic                                       core_rst_n_qlfy;\nlogic                                       core_reset_n;\n\n// HDU Reset signals\nlogic                                       hdu_rst_n_in_sync;\nlogic                                       hdu_rst_n_status;\nlogic                                       hdu_rst_n_status_sync;\nlogic                                       hdu_rst_n_qlfy;\n\n// DM Reset signals\nlogic                                       dm_rst_n_in;\nlogic                                       dm_rst_n_status;\n\n//------------------------------------------------------------------------------\n// TAPC scan-chain i/f\n//------------------------------------------------------------------------------\n//\n // Consists of the following functional units:\n // - TAPC scan-chain control logic\n // - TAPC shift register\n // - TAPC shadow register\n//\n\n// TAPC scan-chain control logic\n//------------------------------------------------------------------------------\n\nassign scu_csr_req      = tapcsync2scu_ch_sel_i & (tapcsync2scu_ch_id_i == '0);\nassign tapc_dr_cap_req  = scu_csr_req & tapcsync2scu_ch_capture_i;\nassign tapc_dr_shft_req = scu_csr_req & tapcsync2scu_ch_shift_i;\nassign tapc_dr_upd_req  = scu_csr_req & tapcsync2scu_ch_update_i;\n\n// TAPC shift register\n//------------------------------------------------------------------------------\n\nassign tapc_shift_upd = tapc_dr_cap_req | tapc_dr_shft_req;\n\nalways_ff @(posedge clk, negedge pwrup_rst_n_sync) begin\n    if (~pwrup_rst_n_sync) begin\n        tapc_shift_ff <= '0;\n    end else if (tapc_shift_upd) begin\n        tapc_shift_ff <= tapc_shift_next;\n    end\nend\n\nassign tapc_shift_next = tapc_dr_cap_req  ? tapc_shadow_ff\n                       : tapc_dr_shft_req ? {tapcsync2scu_ch_tdi_i, tapc_shift_ff[$bits(type_scr1_scu_sysctrl_dr_s)-1:1]}\n                                          : tapc_shift_ff;\n\n// TAPC shadow register\n//------------------------------------------------------------------------------\n\nalways_ff @(posedge clk, negedge pwrup_rst_n_sync) begin\n    if (~pwrup_rst_n_sync) begin\n        tapc_shadow_ff      <= '0;\n    end else if (tapc_dr_upd_req) begin\n        tapc_shadow_ff.op   <= tapc_shift_ff.op;\n        tapc_shadow_ff.addr <= tapc_shift_ff.addr;\n        tapc_shadow_ff.data <= scu_csr_wdata;\n    end\nend\n\nassign scu2tapcsync_ch_tdo_o = tapc_shift_ff[0];\n\n//------------------------------------------------------------------------------\n// SCU CSRs write/read interface\n//------------------------------------------------------------------------------\n\n// Write interface\n//------------------------------------------------------------------------------\n\n// Register selection logic\nalways_comb begin\n    scu_control_wr_req    = 1'b0;\n    scu_mode_wr_req       = 1'b0;\n    scu_sticky_sts_wr_req = 1'b0;\n\n    if (tapc_dr_upd_req && (tapc_shift_ff.op != SCR1_SCU_SYSCTRL_OP_READ)) begin\n        case (tapc_shift_ff.addr)\n            SCR1_SCU_SYSCTRL_ADDR_CONTROL: scu_control_wr_req    = 1'b1;\n            SCR1_SCU_SYSCTRL_ADDR_MODE   : scu_mode_wr_req       = 1'b1;\n            SCR1_SCU_SYSCTRL_ADDR_STICKY : scu_sticky_sts_wr_req = (tapc_shift_ff.op == SCR1_SCU_SYSCTRL_OP_CLRBITS);\n            default                      : begin end\n        endcase\n    end\nend\n\n// Write data construction\nalways_comb begin\n    scu_csr_wdata = '0;\n\n    if (tapc_dr_upd_req) begin\n        case (tapc_shift_ff.op)\n            SCR1_SCU_SYSCTRL_OP_WRITE  : scu_csr_wdata = tapc_shift_ff.data;\n            SCR1_SCU_SYSCTRL_OP_READ   : scu_csr_wdata = scu_csr_rdata;\n            SCR1_SCU_SYSCTRL_OP_SETBITS: scu_csr_wdata = scu_csr_rdata |   tapc_shift_ff.data;\n            SCR1_SCU_SYSCTRL_OP_CLRBITS: scu_csr_wdata = scu_csr_rdata & (~tapc_shift_ff.data);\n            default                    : begin end\n        endcase\n    end\nend\n\n// Read interface\n//------------------------------------------------------------------------------\n\n// Read data multiplexer\nalways_comb begin\n    scu_csr_rdata = '0;\n\n    if (tapc_dr_upd_req) begin\n        case (tapc_shift_ff.addr)\n            SCR1_SCU_SYSCTRL_ADDR_CONTROL: scu_csr_rdata = scu_control_ff;\n            SCR1_SCU_SYSCTRL_ADDR_MODE   : scu_csr_rdata = scu_mode_ff;\n            SCR1_SCU_SYSCTRL_ADDR_STATUS : scu_csr_rdata = scu_status_ff;\n            SCR1_SCU_SYSCTRL_ADDR_STICKY : scu_csr_rdata = scu_sticky_sts_ff;\n            default                      : scu_csr_rdata = 'x;\n        endcase\n    end\nend\n\n//------------------------------------------------------------------------------\n// SCU CSRs\n//------------------------------------------------------------------------------\n//\n // Registers:\n // - CONTROL register\n // - MODE register\n // - STATUS register\n // - STICKY_STATUS register\n//\n\n// CONTROL register\n//------------------------------------------------------------------------------\n// Allows debugger to generate System and Core resets\n\nalways_ff @(posedge clk, negedge pwrup_rst_n_sync) begin\n    if (~pwrup_rst_n_sync) begin\n        scu_control_ff <= '0;\n    end else if (scu_control_wr_req) begin\n        scu_control_ff <= scu_csr_wdata;\n    end\nend\n\n// MODE register\n//------------------------------------------------------------------------------\n// Sets reset behavior for DM Reset and HDU Reset signals\n\nalways_ff @(posedge clk, negedge pwrup_rst_n_sync) begin\n    if (~pwrup_rst_n_sync) begin\n        scu_mode_ff <= '0;\n    end else if (scu_mode_wr_req) begin\n        scu_mode_ff <= scu_csr_wdata;\n    end\nend\n\n// STATUS register\n//------------------------------------------------------------------------------\n// Holds the status of every output reset signal (System, Core, DM and HDU)\n\nassign scu_status_ff.sys_reset  = sys_rst_status_o ;\nassign scu_status_ff.core_reset = core_rst_status_o;\nassign scu_status_ff.dm_reset   = ~dm_rst_n_status;\nassign scu_status_ff.hdu_reset  = ~hdu_rst_n_status_sync;\n\n// Status Register positive edge detection logic\nalways_ff @(posedge clk, negedge pwrup_rst_n_sync) begin\n    if (~pwrup_rst_n_sync) begin\n        scu_status_ff_dly <= '0;\n    end else begin\n        scu_status_ff_dly <= scu_status_ff;\n    end\nend\n\nassign scu_status_ff_posedge = scu_status_ff & ~scu_status_ff_dly;\n\n// STICKY_STATUS register\n//------------------------------------------------------------------------------\n// For every output reset signal shows if it was asserted since the last bit clearing\n\nalways_ff @(posedge clk, negedge pwrup_rst_n_sync) begin\n    if (~pwrup_rst_n_sync) begin\n        scu_sticky_sts_ff <= '0;\n    end else begin\n        for (int unsigned i = 0; i < $bits(type_scr1_scu_sysctrl_status_reg_s); ++i) begin\n            if (scu_status_ff_posedge[i]) begin\n                scu_sticky_sts_ff[i] <= 1'b1;\n            end else if (scu_sticky_sts_wr_req) begin\n                scu_sticky_sts_ff[i] <= scu_csr_wdata[i];\n            end\n        end\n    end\nend\n\n//------------------------------------------------------------------------------\n// Reset logic\n//------------------------------------------------------------------------------\n//\n // Consists of the following functional units:\n // - System Reset logic\n // - Core Reset logic\n // - Hart Debug Unit Reset logic\n // - Debug Module Reset logic\n//\n\n// Reset inputs are assumed synchronous\nassign pwrup_rst_n_sync = pwrup_rst_n;\nassign rst_n_sync       = rst_n;\nassign cpu_rst_n_sync   = cpu_rst_n;\n\n// Intermediate resets:\nassign sys_reset_n  = ~scu_control_ff.sys_reset;\nassign core_reset_n = ~scu_control_ff.core_reset;\n\n// System/Cluster Reset: sys_rst_n_o\n//------------------------------------------------------------------------------\n\nscr1_reset_qlfy_adapter_cell_sync   i_sys_rstn_qlfy_adapter_cell_sync (\n    .rst_n                          (pwrup_rst_n_sync),\n    .clk                            (clk             ),\n    .test_rst_n                     (test_rst_n      ),\n    .test_mode                      (test_mode       ),\n    .reset_n_in_sync                (sys_rst_n_in    ),\n    .reset_n_out_qlfy               (sys_rst_n_qlfy  ),\n    .reset_n_out                    (sys_rst_n_o     ),\n    .reset_n_status                 (sys_rst_n_status)\n);\n\nassign sys_rst_n_in = sys_reset_n & ndm_rst_n_i & rst_n_sync;\n\nscr1_data_sync_cell #(\n    .STAGES_AMOUNT       (SCR1_SCU_RST_SYNC_STAGES_NUM)\n) i_sys_rstn_status_sync (\n    .rst_n               (pwrup_rst_n_sync     ),\n    .clk                 (clk                  ),\n    .data_in             (sys_rst_n_status     ),\n    .data_out            (sys_rst_n_status_sync)\n);\n\nassign sys_rst_status_o = ~sys_rst_n_status_sync;\n\n// System/Cluster-to-ExternalSOC RDC qualifier\nassign sys_rdc_qlfy_o = sys_rst_n_qlfy;\n\n// Core Reset: core_rst_n_o\n//------------------------------------------------------------------------------\n\nscr1_reset_qlfy_adapter_cell_sync   i_core_rstn_qlfy_adapter_cell_sync (\n    .rst_n                          (pwrup_rst_n_sync  ),\n    .clk                            (clk               ),\n    .test_rst_n                     (test_rst_n        ),\n    .test_mode                      (test_mode         ),\n    .reset_n_in_sync                (core_rst_n_in_sync),\n    .reset_n_out_qlfy               (core_rst_n_qlfy   ),\n    .reset_n_out                    (core_rst_n_o      ),\n    .reset_n_status                 (core_rst_n_status )\n);\n\nassign core_rst_n_in_sync   = sys_rst_n_in & hart_rst_n_i & core_reset_n & cpu_rst_n_sync;\n\nscr1_data_sync_cell #(\n    .STAGES_AMOUNT        (SCR1_SCU_RST_SYNC_STAGES_NUM)\n) i_core_rstn_status_sync (\n    .rst_n                (pwrup_rst_n_sync      ),\n    .clk                  (clk                   ),\n    .data_in              (core_rst_n_status     ),\n    .data_out             (core_rst_n_status_sync)\n);\n\nassign core_rst_status_o = ~core_rst_n_status_sync;\n\n// Core Reset RDC Qualifiers:\n//  - Core-to-ExternalSOC RDC Qlfy\nassign core_rdc_qlfy_o = core_rst_n_qlfy;\n//  - Core-to-HDU RDC Qlfy\nassign core2hdu_rdc_qlfy_o = core_rst_n_qlfy;\n//  - Core-to-DebugModule RDC Qlfy\nassign core2dm_rdc_qlfy_o  = core_rst_n_qlfy;\n\n// Hart Debug Unit Reset: hdu_rst_n_o\n//------------------------------------------------------------------------------\n\nscr1_reset_qlfy_adapter_cell_sync   i_hdu_rstn_qlfy_adapter_cell_sync (\n    .rst_n                          (pwrup_rst_n_sync ),\n    .clk                            (clk              ),\n    .test_rst_n                     (test_rst_n       ),\n    .test_mode                      (test_mode        ),\n    .reset_n_in_sync                (hdu_rst_n_in_sync),\n    .reset_n_out_qlfy               (hdu_rst_n_qlfy   ),\n    .reset_n_out                    (hdu_rst_n_o      ),\n    .reset_n_status                 (hdu_rst_n_status )\n);\n\nassign hdu_rst_n_in_sync = scu_mode_ff.hdu_rst_bhv | core_rst_n_in_sync;\n\nscr1_data_sync_cell #(\n    .STAGES_AMOUNT       (SCR1_SCU_RST_SYNC_STAGES_NUM)\n) i_hdu_rstn_status_sync (\n    .rst_n               (pwrup_rst_n_sync     ),\n    .clk                 (clk                  ),\n    .data_in             (hdu_rst_n_status     ),\n    .data_out            (hdu_rst_n_status_sync)\n);\n\n// Hart Debug Unit Reset RDC Qualifiers:\n//  - HDU-to-DebugModule RDC Qlfy\nassign hdu2dm_rdc_qlfy_o = hdu_rst_n_qlfy;\n\n// Debug Module Reset: dm_rst_n_o\n//------------------------------------------------------------------------------\n\nscr1_reset_buf_cell i_dm_rstn_buf_cell (\n    .rst_n              (pwrup_rst_n_sync),\n    .clk                (clk             ),\n    .test_mode          (test_mode       ),\n    .test_rst_n         (test_rst_n      ),\n    .reset_n_in         (dm_rst_n_in     ),\n    .reset_n_out        (dm_rst_n_o      ),\n    .reset_n_status     (dm_rst_n_status )\n);\n\nassign dm_rst_n_in  = ~scu_mode_ff.dm_rst_bhv | sys_reset_n;\n\n`ifdef SCR1_TRGT_SIMULATION\n//--------------------------------------------------------------------\n// Assertions\n//--------------------------------------------------------------------\n\n`ifndef VERILATOR\n// Preventing some assertions to be raised at 0 sim time or in the first cycle\ninitial begin\n$assertoff(0, scr1_scu);\nrepeat (2) @(posedge clk) begin end\n$asserton(0, scr1_scu);\nend\n`endif // VERILATOR\n\n// X checks\nSCR1_SVA_SCU_RESETS_XCHECK : assert property (\n    @(negedge clk)\n    !$isunknown({pwrup_rst_n, rst_n, cpu_rst_n, ndm_rst_n_i, hart_rst_n_i})\n) else $error(\"SCU resets error: unknown values of input resets\");\n\n// Qualifiers checks\nSCR1_SVA_SCU_SYS2SOC_QLFY_CHECK : assert property (\n    @(negedge clk) disable iff (~pwrup_rst_n)\n    $fell(sys_rst_n_o) |-> $fell($past(sys_rdc_qlfy_o))\n) else $error(\"SCU sys2soc qlfy error: qlfy wasn't raised prior to reset\");\n\nSCR1_SVA_SCU_CORE2SOC_QLFY_CHECK : assert property (\n    @(negedge clk) disable iff (~pwrup_rst_n)\n    $fell(core_rst_n_o) |-> $fell($past(core_rdc_qlfy_o))\n) else $error(\"SCU core2soc qlfy error: qlfy wasn't raised prior to reset\");\n\nSCR1_SVA_SCU_CORE2HDU_QLFY_CHECK : assert property (\n    @(negedge clk) disable iff (~pwrup_rst_n)\n    $fell(core_rst_n_o) |-> $fell($past(core2hdu_rdc_qlfy_o))\n) else $error(\"SCU core2hdu qlfy error: qlfy wasn't raised prior to reset\");\n\nSCR1_SVA_SCU_CORE2DM_QLFY_CHECK : assert property (\n    @(negedge clk) disable iff (~pwrup_rst_n)\n    $fell(core_rst_n_o) |-> $fell($past(core2dm_rdc_qlfy_o))\n) else $error(\"SCU core2dm qlfy error: qlfy wasn't raised prior to reset\");\n\nSCR1_SVA_SCU_HDU2DM_QLFY_CHECK : assert property (\n    @(negedge clk) disable iff (~pwrup_rst_n)\n    $fell(hdu_rst_n_o) |-> $fell($past(hdu2dm_rdc_qlfy_o))\n) else $error(\"SCU hdu2dm qlfy error: qlfy wasn't raised prior to reset\");\n\n`endif // SCR1_TRGT_SIMULATION\n\nendmodule : scr1_scu\n`endif // SCR1_DBG_EN\n\n"}
{"text": "/// Copyright by Syntacore LLC  2016-2021. See LICENSE for details\n/// @file       <scr1_tapc.sv>\n/// @brief      TAP Controller (TAPC)\n///\n\n//------------------------------------------------------------------------------\n //\n // Functionality:\n // - Controls TAP operation\n // - Allows debugger to access TAP Data registers and DMI/SCU scan-chains via\n //   command written in Instruction register\n //\n // Structure:\n // - Synchronous reset generation\n // - TAPC FSM\n // - TAPC Instruction Registers\n // - TAPC DRs/DMI/SCU scan-chains\n // - TAPC TDO enable and output Registers\n // - TAPC Data Registers\n //   - BYPASS\n //   - IDCODE\n //   - BUILD ID\n //\n//------------------------------------------------------------------------------\n\n`include \"scr1_arch_description.svh\"\n\n`ifdef SCR1_DBG_EN\n`include \"scr1_tapc.svh\"\n`include \"scr1_dm.svh\"\n\nmodule scr1_tapc (\n    // JTAG signals\n    input   logic                                   tapc_trst_n,                    // Test Reset (TRSTn)\n    input   logic                                   tapc_tck,                       // Test Clock (TCK)\n    input   logic                                   tapc_tms,                       // Test Mode Select (TMS)\n    input   logic                                   tapc_tdi,                       // Test Data Input (TDI)\n    output  logic                                   tapc_tdo,                       // Test Data Output (TDO)\n    output  logic                                   tapc_tdo_en,                    // TDO Enable, signal for TDO buffer control\n\n    // Fuses:\n    input   logic [31:0]                            soc2tapc_fuse_idcode_i,         // IDCODE value from fuses\n\n    // DMI/SCU scan-chains\n    output  logic                                   tapc2tapcsync_scu_ch_sel_o,     // SCU Chain Select\n    output  logic                                   tapc2tapcsync_dmi_ch_sel_o,     // DMI Chain Select\n    output  logic [SCR1_DBG_DMI_CH_ID_WIDTH-1:0]    tapc2tapcsync_ch_id_o,          // DMI/SCU Chain Identifier\n    output  logic                                   tapc2tapcsync_ch_capture_o,     // DMI/SCU Chain Capture\n    output  logic                                   tapc2tapcsync_ch_shift_o,       // DMI/SCU Chain Shift\n    output  logic                                   tapc2tapcsync_ch_update_o,      // DMI/SCU Chain Update\n    output  logic                                   tapc2tapcsync_ch_tdi_o,         // DMI/SCU Chain TDI\n    input   logic                                   tapcsync2tapc_ch_tdo_i          // DMI/SCU Chain TDO\n);\n\n//------------------------------------------------------------------------------\n// Local Signals\n//------------------------------------------------------------------------------\n\nlogic                                       trst_n_int;       // Sync reset signal\n\n// TAPC FSM signals\n//------------------------------------------------------------------------------\n\ntype_scr1_tap_state_e                       tap_fsm_ff;       // TAP's current state\ntype_scr1_tap_state_e                       tap_fsm_next;     // TAP's next state\n\n// Control signals\nlogic                                       tap_fsm_reset;\nlogic                                       tap_fsm_ir_upd;\nlogic                                       tap_fsm_ir_cap;\nlogic                                       tap_fsm_ir_shft;\n\n// Registered control signals\nlogic                                       tap_fsm_ir_shift_ff;\nlogic                                       tap_fsm_ir_shift_next;\nlogic                                       tap_fsm_dr_capture_ff;\nlogic                                       tap_fsm_dr_capture_next;\nlogic                                       tap_fsm_dr_shift_ff;\nlogic                                       tap_fsm_dr_shift_next;\nlogic                                       tap_fsm_dr_update_ff;\nlogic                                       tap_fsm_dr_update_next;\n\n// TAPC Instruction Registers signals\n//------------------------------------------------------------------------------\n\nlogic [SCR1_TAP_INSTRUCTION_WIDTH-1:0]      tap_ir_shift_ff;   // Instruction Shift Register\nlogic [SCR1_TAP_INSTRUCTION_WIDTH-1:0]      tap_ir_shift_next; // Instruction Shift Register next value\nlogic [SCR1_TAP_INSTRUCTION_WIDTH-1:0]      tap_ir_ff;         // Instruction Register\nlogic [SCR1_TAP_INSTRUCTION_WIDTH-1:0]      tap_ir_next;       // Instruction Register next value\n\n// TAPC Data Registers signals\n//------------------------------------------------------------------------------\n\n// BYPASS register\nlogic                                       dr_bypass_sel;\nlogic                                       dr_bypass_tdo;\n\n// IDCODE register\nlogic                                       dr_idcode_sel;\nlogic                                       dr_idcode_tdo;\n\n// BUILD ID register\nlogic                                       dr_bld_id_sel;\nlogic                                       dr_bld_id_tdo;\n\nlogic                                       dr_out;\n\n// TDO registers\n//------------------------------------------------------------------------------\n\n// TDO enable register\nlogic                                       tdo_en_ff;\nlogic                                       tdo_en_next;\n\n// TDO output register\nlogic                                       tdo_out_ff;\nlogic                                       tdo_out_next;\n\n//------------------------------------------------------------------------------\n// TAPC Synchronous Reset logic\n//------------------------------------------------------------------------------\n\nalways_ff @(negedge tapc_tck, negedge tapc_trst_n) begin\n    if (~tapc_trst_n) begin\n        trst_n_int <= 1'b0;\n    end else begin\n        trst_n_int <= ~tap_fsm_reset;\n    end\nend\n\n//------------------------------------------------------------------------------\n// TAP's FSM\n//------------------------------------------------------------------------------\n\nalways_ff @(posedge tapc_tck, negedge tapc_trst_n) begin\n    if (~tapc_trst_n) begin\n        tap_fsm_ff <= SCR1_TAP_STATE_RESET;\n    end else begin\n        tap_fsm_ff <= tap_fsm_next;\n    end\nend\n\nalways_comb begin\n    case (tap_fsm_ff)\n        SCR1_TAP_STATE_RESET      : tap_fsm_next = tapc_tms ? SCR1_TAP_STATE_RESET        : SCR1_TAP_STATE_IDLE;\n        SCR1_TAP_STATE_IDLE       : tap_fsm_next = tapc_tms ? SCR1_TAP_STATE_DR_SEL_SCAN  : SCR1_TAP_STATE_IDLE;\n        SCR1_TAP_STATE_DR_SEL_SCAN: tap_fsm_next = tapc_tms ? SCR1_TAP_STATE_IR_SEL_SCAN  : SCR1_TAP_STATE_DR_CAPTURE;\n        SCR1_TAP_STATE_DR_CAPTURE : tap_fsm_next = tapc_tms ? SCR1_TAP_STATE_DR_EXIT1     : SCR1_TAP_STATE_DR_SHIFT;\n        SCR1_TAP_STATE_DR_SHIFT   : tap_fsm_next = tapc_tms ? SCR1_TAP_STATE_DR_EXIT1     : SCR1_TAP_STATE_DR_SHIFT;\n        SCR1_TAP_STATE_DR_EXIT1   : tap_fsm_next = tapc_tms ? SCR1_TAP_STATE_DR_UPDATE    : SCR1_TAP_STATE_DR_PAUSE;\n        SCR1_TAP_STATE_DR_PAUSE   : tap_fsm_next = tapc_tms ? SCR1_TAP_STATE_DR_EXIT2     : SCR1_TAP_STATE_DR_PAUSE;\n        SCR1_TAP_STATE_DR_EXIT2   : tap_fsm_next = tapc_tms ? SCR1_TAP_STATE_DR_UPDATE    : SCR1_TAP_STATE_DR_SHIFT;\n        SCR1_TAP_STATE_DR_UPDATE  : tap_fsm_next = tapc_tms ? SCR1_TAP_STATE_DR_SEL_SCAN  : SCR1_TAP_STATE_IDLE;\n        SCR1_TAP_STATE_IR_SEL_SCAN: tap_fsm_next = tapc_tms ? SCR1_TAP_STATE_RESET        : SCR1_TAP_STATE_IR_CAPTURE;\n        SCR1_TAP_STATE_IR_CAPTURE : tap_fsm_next = tapc_tms ? SCR1_TAP_STATE_IR_EXIT1     : SCR1_TAP_STATE_IR_SHIFT;\n        SCR1_TAP_STATE_IR_SHIFT   : tap_fsm_next = tapc_tms ? SCR1_TAP_STATE_IR_EXIT1     : SCR1_TAP_STATE_IR_SHIFT;\n        SCR1_TAP_STATE_IR_EXIT1   : tap_fsm_next = tapc_tms ? SCR1_TAP_STATE_IR_UPDATE    : SCR1_TAP_STATE_IR_PAUSE;\n        SCR1_TAP_STATE_IR_PAUSE   : tap_fsm_next = tapc_tms ? SCR1_TAP_STATE_IR_EXIT2     : SCR1_TAP_STATE_IR_PAUSE;\n        SCR1_TAP_STATE_IR_EXIT2   : tap_fsm_next = tapc_tms ? SCR1_TAP_STATE_IR_UPDATE    : SCR1_TAP_STATE_IR_SHIFT;\n        SCR1_TAP_STATE_IR_UPDATE  : tap_fsm_next = tapc_tms ? SCR1_TAP_STATE_DR_SEL_SCAN  : SCR1_TAP_STATE_IDLE;\n`ifdef SCR1_XPROP_EN\n        default                   : tap_fsm_next = SCR1_TAP_STATE_XXX;\n`else // SCR1_XPROP_EN\n        default                   : tap_fsm_next = tap_fsm_ff;\n`endif // SCR1_XPROP_EN\n    endcase\nend\n\nassign tap_fsm_reset   = (tap_fsm_ff == SCR1_TAP_STATE_RESET);\nassign tap_fsm_ir_upd  = (tap_fsm_ff == SCR1_TAP_STATE_IR_UPDATE);\nassign tap_fsm_ir_cap  = (tap_fsm_ff == SCR1_TAP_STATE_IR_CAPTURE);\nassign tap_fsm_ir_shft = (tap_fsm_ff == SCR1_TAP_STATE_IR_SHIFT);\n\n//------------------------------------------------------------------------------\n// TAPC Instruction Registers\n//------------------------------------------------------------------------------\n\n// TAPC Instruction Shift register\n//------------------------------------------------------------------------------\n\nalways_ff @(posedge tapc_tck, negedge tapc_trst_n) begin\n    if (~tapc_trst_n) begin\n        tap_ir_shift_ff <= '0;\n    end else if (~trst_n_int) begin\n        tap_ir_shift_ff <= '0;\n    end else begin\n        tap_ir_shift_ff <= tap_ir_shift_next;\n    end\nend\n\nassign tap_ir_shift_next = tap_fsm_ir_cap  ? {{($bits(tap_ir_shift_ff)-1){1'b0}}, 1'b1}\n                         : tap_fsm_ir_shft ? {tapc_tdi, tap_ir_shift_ff[$left(tap_ir_shift_ff):1]}\n                                           : tap_ir_shift_ff;\n\n// TAPC Instruction register\n//------------------------------------------------------------------------------\n\nalways_ff @(negedge tapc_tck, negedge tapc_trst_n) begin\n    if (~tapc_trst_n) begin\n        tap_ir_ff <= SCR1_TAP_INSTR_IDCODE;\n    end else if (~trst_n_int) begin\n        tap_ir_ff <= SCR1_TAP_INSTR_IDCODE;\n    end else begin\n        tap_ir_ff <= tap_ir_next;\n    end\nend\n\nassign tap_ir_next = tap_fsm_ir_upd ? tap_ir_shift_ff : tap_ir_ff;\n\n//------------------------------------------------------------------------------\n// Control signals\n//------------------------------------------------------------------------------\n\nalways_ff @(posedge tapc_tck, negedge tapc_trst_n) begin\n    if (~tapc_trst_n) begin\n        tap_fsm_ir_shift_ff <= 1'b0;\n    end else if (~trst_n_int) begin\n        tap_fsm_ir_shift_ff <= 1'b0;\n    end else begin\n        tap_fsm_ir_shift_ff <= tap_fsm_ir_shift_next;\n    end\nend\n\nassign tap_fsm_ir_shift_next = (tap_fsm_next == SCR1_TAP_STATE_IR_SHIFT);\n\nalways_ff @(posedge tapc_tck, negedge tapc_trst_n) begin\n    if (~tapc_trst_n) begin\n        tap_fsm_dr_capture_ff <= 1'b0;\n    end else if (~trst_n_int) begin\n        tap_fsm_dr_capture_ff <= 1'b0;\n    end else begin\n        tap_fsm_dr_capture_ff <= tap_fsm_dr_capture_next;\n    end\nend\n\nassign tap_fsm_dr_capture_next = (tap_fsm_next == SCR1_TAP_STATE_DR_CAPTURE);\n\nalways_ff @(posedge tapc_tck, negedge tapc_trst_n) begin\n    if (~tapc_trst_n) begin\n        tap_fsm_dr_shift_ff <= 1'b0;\n    end else if (~trst_n_int) begin\n        tap_fsm_dr_shift_ff <= 1'b0;\n    end else begin\n        tap_fsm_dr_shift_ff <= tap_fsm_dr_shift_next;\n    end\nend\n\nassign tap_fsm_dr_shift_next = (tap_fsm_next == SCR1_TAP_STATE_DR_SHIFT);\n\nalways_ff @(posedge tapc_tck, negedge tapc_trst_n) begin\n    if (~tapc_trst_n) begin\n        tap_fsm_dr_update_ff <= 1'b0;\n    end else if (~trst_n_int) begin\n        tap_fsm_dr_update_ff <= 1'b0;\n    end else begin\n        tap_fsm_dr_update_ff <= tap_fsm_dr_update_next;\n    end\nend\n\nassign tap_fsm_dr_update_next = (tap_fsm_next == SCR1_TAP_STATE_DR_UPDATE);\n\n//------------------------------------------------------------------------------\n// TAPC DRs/DMI/SCU scan-chains\n//------------------------------------------------------------------------------\n//\n // Consists of the following functional units:\n // - Data source/destination decoder\n // - DMI channel ID decoder\n\n// - Read data multiplexer\n// Data source/destination decoder\n//------------------------------------------------------------------------------\n\nalways_comb begin\n    dr_bypass_sel               = 1'b0;\n    dr_idcode_sel               = 1'b0;\n    dr_bld_id_sel               = 1'b0;\n    tapc2tapcsync_scu_ch_sel_o  = 1'b0;\n    tapc2tapcsync_dmi_ch_sel_o  = 1'b0;\n    case (tap_ir_ff)\n        SCR1_TAP_INSTR_DTMCS     : tapc2tapcsync_dmi_ch_sel_o = 1'b1;\n        SCR1_TAP_INSTR_DMI_ACCESS: tapc2tapcsync_dmi_ch_sel_o = 1'b1;\n        SCR1_TAP_INSTR_IDCODE    : dr_idcode_sel              = 1'b1;\n        SCR1_TAP_INSTR_BYPASS    : dr_bypass_sel              = 1'b1;\n        SCR1_TAP_INSTR_BLD_ID    : dr_bld_id_sel              = 1'b1;\n        SCR1_TAP_INSTR_SCU_ACCESS: tapc2tapcsync_scu_ch_sel_o = 1'b1;\n        default                  : dr_bypass_sel              = 1'b1;\n    endcase\nend\n\n// DMI channel ID decoder\n//------------------------------------------------------------------------------\n\nalways_comb begin\n    tapc2tapcsync_ch_id_o = '0;\n    case (tap_ir_ff)\n        SCR1_TAP_INSTR_DTMCS     : tapc2tapcsync_ch_id_o = 'd1;\n        SCR1_TAP_INSTR_DMI_ACCESS: tapc2tapcsync_ch_id_o = 'd2;\n        default                  : tapc2tapcsync_ch_id_o = '0;\n    endcase\nend\n\n// Read data multiplexer\n//------------------------------------------------------------------------------\n\nalways_comb begin\n    dr_out = 1'b0;\n    case (tap_ir_ff)\n        SCR1_TAP_INSTR_DTMCS     : dr_out = tapcsync2tapc_ch_tdo_i;\n        SCR1_TAP_INSTR_DMI_ACCESS: dr_out = tapcsync2tapc_ch_tdo_i;\n        SCR1_TAP_INSTR_IDCODE    : dr_out = dr_idcode_tdo;\n        SCR1_TAP_INSTR_BYPASS    : dr_out = dr_bypass_tdo;\n        SCR1_TAP_INSTR_BLD_ID    : dr_out = dr_bld_id_tdo;\n        SCR1_TAP_INSTR_SCU_ACCESS: dr_out = tapcsync2tapc_ch_tdo_i;\n        default                  : dr_out = dr_bypass_tdo;\n    endcase\nend\n\n//------------------------------------------------------------------------------\n// TDO enable and output registers\n//------------------------------------------------------------------------------\n\n// TDO enable register\n//------------------------------------------------------------------------------\n\nalways_ff @(negedge tapc_tck, negedge tapc_trst_n) begin\n    if (~tapc_trst_n) begin\n        tdo_en_ff  <= 1'b0;\n    end else if (~trst_n_int) begin\n        tdo_en_ff  <= 1'b0;\n    end else begin\n        tdo_en_ff  <= tdo_en_next;\n    end\nend\n\nassign tdo_en_next = tap_fsm_dr_shift_ff | tap_fsm_ir_shift_ff;\n\n// TDO output register\n//------------------------------------------------------------------------------\n\nalways_ff @(negedge tapc_tck, negedge tapc_trst_n) begin\n    if (~tapc_trst_n) begin\n        tdo_out_ff <= 1'b0;\n    end else if (~trst_n_int) begin\n        tdo_out_ff <= 1'b0;\n    end else begin\n        tdo_out_ff <= tdo_out_next;\n    end\nend\n\nassign tdo_out_next = tap_fsm_dr_shift_ff ? dr_out\n                    : tap_fsm_ir_shift_ff ? tap_ir_shift_ff[0]\n                                          : 1'b0;\n\n// TAPC TDO signals\nassign tapc_tdo_en = tdo_en_ff;\nassign tapc_tdo    = tdo_out_ff;\n\n//------------------------------------------------------------------------------\n// TAPC Data Registers\n//------------------------------------------------------------------------------\n//\n // Registers:\n // - BYPASS register\n // - IDCODE register\n // - BUILD ID register\n\n// BYPASS register\n//------------------------------------------------------------------------------\n// 1-bit mandatory IEEE 1149.1 compliant register\n\nscr1_tapc_shift_reg  #(\n    .SCR1_WIDTH       (SCR1_TAP_DR_BYPASS_WIDTH),\n    .SCR1_RESET_VALUE (SCR1_TAP_DR_BYPASS_WIDTH'(0))\n) i_bypass_reg        (\n    .clk              (tapc_tck             ),\n    .rst_n            (tapc_trst_n          ),\n    .rst_n_sync       (trst_n_int           ),\n    .fsm_dr_select    (dr_bypass_sel        ),\n    .fsm_dr_capture   (tap_fsm_dr_capture_ff),\n    .fsm_dr_shift     (tap_fsm_dr_shift_ff  ),\n    .din_serial       (tapc_tdi             ),\n    .din_parallel     (1'b0                 ),\n    .dout_serial      (dr_bypass_tdo        ),\n    .dout_parallel    (                     )\n);\n\n// IDCODE register\n//------------------------------------------------------------------------------\n// Holds the Device ID value (mandatory IEEE 1149.1 compliant register)\n\nscr1_tapc_shift_reg  #(\n    .SCR1_WIDTH       (SCR1_TAP_DR_IDCODE_WIDTH),\n    .SCR1_RESET_VALUE (SCR1_TAP_DR_IDCODE_WIDTH'(0))\n) i_tap_idcode_reg    (\n    .clk              (tapc_tck              ),\n    .rst_n            (tapc_trst_n           ),\n    .rst_n_sync       (trst_n_int            ),\n    .fsm_dr_select    (dr_idcode_sel         ),\n    .fsm_dr_capture   (tap_fsm_dr_capture_ff ),\n    .fsm_dr_shift     (tap_fsm_dr_shift_ff   ),\n    .din_serial       (tapc_tdi              ),\n    .din_parallel     (soc2tapc_fuse_idcode_i),\n    .dout_serial      (dr_idcode_tdo         ),\n    .dout_parallel    (                      )\n);\n\n// BUILD ID register\n//------------------------------------------------------------------------------\n// Holds the BUILD ID value\n\nscr1_tapc_shift_reg  #(\n    .SCR1_WIDTH       (SCR1_TAP_DR_BLD_ID_WIDTH),\n    .SCR1_RESET_VALUE (SCR1_TAP_DR_BLD_ID_WIDTH'(0))\n) i_tap_dr_bld_id_reg (\n    .clk              (tapc_tck             ),\n    .rst_n            (tapc_trst_n          ),\n    .rst_n_sync       (trst_n_int           ),\n    .fsm_dr_select    (dr_bld_id_sel        ),\n    .fsm_dr_capture   (tap_fsm_dr_capture_ff),\n    .fsm_dr_shift     (tap_fsm_dr_shift_ff  ),\n    .din_serial       (tapc_tdi             ),\n    .din_parallel     (SCR1_TAP_BLD_ID_VALUE),\n    .dout_serial      (dr_bld_id_tdo        ),\n    .dout_parallel    (                     )\n);\n\n//------------------------------------------------------------------------------\n// DMI/SCU scan-chains signals\n//------------------------------------------------------------------------------\n\nassign tapc2tapcsync_ch_tdi_o     = tapc_tdi;\nassign tapc2tapcsync_ch_capture_o = tap_fsm_dr_capture_ff;\nassign tapc2tapcsync_ch_shift_o   = tap_fsm_dr_shift_ff;\nassign tapc2tapcsync_ch_update_o  = tap_fsm_dr_update_ff;\n\n`ifdef SCR1_TRGT_SIMULATION\n//-------------------------------------------------------------------------------\n// Assertion\n//-------------------------------------------------------------------------------\n\n// X checks\nSCR1_SVA_TAPC_XCHECK : assert property (\n    @(posedge tapc_tck) disable iff (~tapc_trst_n)\n    !$isunknown({tapc_tms, tapc_tdi})\n) else $error(\"TAPC error: unknown values\");\n\nSCR1_SVA_TAPC_XCHECK_NEGCLK : assert property (\n    @(negedge tapc_tck) disable iff (tap_fsm_ff != SCR1_TAP_STATE_DR_SHIFT)\n    !$isunknown({tapcsync2tapc_ch_tdo_i})\n) else $error(\"TAPC @negedge error: unknown values\");\n\n`endif // SCR1_TRGT_SIMULATION\n\nendmodule : scr1_tapc\n\n`endif // SCR1_DBG_EN\n"}
{"text": "/// Copyright by Syntacore LLC \u00a9 2016-2021. See LICENSE for details\n/// @file       <scr1_tapc_shift_reg.sv>\n/// @brief      TAPC shift register. Parameterized implementation of JTAG TAPC's Shift Register.\n///\n\n`include \"scr1_arch_description.svh\"\n\n`ifdef SCR1_DBG_EN\nmodule scr1_tapc_shift_reg #(\n    parameter   int unsigned            SCR1_WIDTH       = 8,   // Register width, bits\n    parameter   logic [SCR1_WIDTH-1:0]  SCR1_RESET_VALUE = '0   // Register's value after reset\n) (\n    input  logic                    clk,            // Clock\n    input  logic                    rst_n,          // Async reset\n    input  logic                    rst_n_sync,     // Sync reset\n                                                    // TAP FSM's control signals:\n    input  logic                    fsm_dr_select,  //   - for this DR selection (operation enabling);\n    input  logic                    fsm_dr_capture, //   - to capture parallel input's data into shift register;\n    input  logic                    fsm_dr_shift,   //   - to enable data shifting;\n                                                    // Inputs:\n    input  logic                    din_serial,     //   - serial (shift_reg[msb/SCR1_WIDTH]);\n    input  logic [SCR1_WIDTH-1:0]   din_parallel,   //   - parallel (shift register's input).\n                                                    // Outputs:\n    output logic                    dout_serial,    //   - serial (shift_reg[0]);\n    output logic [SCR1_WIDTH-1:0]   dout_parallel   //   - parallel (shift register's output).\n);\n\n//-------------------------------------------------------------------------------\n// Local signals declaration\n//-------------------------------------------------------------------------------\nlogic [SCR1_WIDTH-1:0]   shift_reg;\n\n//-------------------------------------------------------------------------------\n// Shift register\n//-------------------------------------------------------------------------------\ngenerate\n    if (SCR1_WIDTH > 1)\n    begin : dr_shift_reg\n\n        always_ff @(posedge clk, negedge rst_n)\n        begin\n            if (~rst_n) begin\n                shift_reg <= SCR1_RESET_VALUE;\n            end\n            else if (~rst_n_sync) begin\n                shift_reg <= SCR1_RESET_VALUE;\n            end\n            else if (fsm_dr_select & fsm_dr_capture) begin\n                shift_reg <= din_parallel;\n            end\n            else if (fsm_dr_select & fsm_dr_shift) begin\n                shift_reg <= {din_serial, shift_reg[SCR1_WIDTH-1:1]};\n            end\n        end\n\n    end\n    else begin : dr_shift_reg\n\n        always_ff @(posedge clk, negedge rst_n)\n        begin\n            if (~rst_n) begin\n                shift_reg <= SCR1_RESET_VALUE;\n            end\n            else if (~rst_n_sync) begin\n                shift_reg <= SCR1_RESET_VALUE;\n            end\n            else if (fsm_dr_select & fsm_dr_capture) begin\n                shift_reg <= din_parallel;\n            end\n            else if (fsm_dr_select & fsm_dr_shift) begin\n                shift_reg <= din_serial;\n            end\n        end\n\n    end\nendgenerate\n\n//-------------------------------------------------------------------------------\n// Parallel output\n//-------------------------------------------------------------------------------\nassign dout_parallel = shift_reg;\n\n//-------------------------------------------------------------------------------\n// Serial output\n//-------------------------------------------------------------------------------\nassign dout_serial = shift_reg[0];\n\n`ifdef SCR1_TRGT_SIMULATION\n//-------------------------------------------------------------------------------\n// Assertion\n//-------------------------------------------------------------------------------\n\n// X checks\nSCR1_SVA_TAPC_SHIFTREG_XCHECK : assert property (\n    @(negedge clk) disable iff (~rst_n)\n    !$isunknown({\n        rst_n_sync,\n        fsm_dr_select,\n        fsm_dr_capture,\n        fsm_dr_shift,\n        din_serial,\n        din_parallel\n    })\n) else begin\n    $error(\"TAPC Shift Reg error: unknown values\");\nend\n\n`endif // SCR1_TRGT_SIMULATION\n\nendmodule : scr1_tapc_shift_reg\n\n`endif // SCR1_DBG_EN\n"}
{"text": "/// Copyright by Syntacore LLC \u00a9 2016-2021. See LICENSE for details\n/// @file       <scr1_tapc_synchronizer.sv>\n/// @brief      TAPC clock domain crossing synchronizer\n///\n\n`include \"scr1_arch_description.svh\"\n\n`ifdef SCR1_DBG_EN\n`include \"scr1_tapc.svh\"\n`include \"scr1_dm.svh\"\n\nmodule scr1_tapc_synchronizer (\n    // System common signals\n    input   logic                                   pwrup_rst_n,                // Power-Up Reset\n    input   logic                                   dm_rst_n,                   // Debug Module Reset\n    input   logic                                   clk,                        // System Clock (SysCLK)\n\n    // JTAG common signals\n    input   logic                                   tapc_trst_n,                // JTAG Test Reset (TRSTn)\n    input   logic                                   tapc_tck,                   // JTAG Test Clock (TCK)\n\n\n    // DMI/SCU scan-chains\n    input  logic                                    tapc2tapcsync_scu_ch_sel_i, // SCU Chain Select input  (TCK domain)\n    output logic                                    tapcsync2scu_ch_sel_o,      // SCU Chain Select output (SysCLK domain)\n    input  logic                                    tapc2tapcsync_dmi_ch_sel_i, // DMI Chain Select input  (TCK domain)\n    output logic                                    tapcsync2dmi_ch_sel_o,      // DMI Chain Select output (SysCLK domain)\n\n    input  logic [SCR1_DBG_DMI_CH_ID_WIDTH-1:0]     tapc2tapcsync_ch_id_i,      // DMI/SCU Chain Identifier input  (TCK domain)\n    output logic [SCR1_DBG_DMI_CH_ID_WIDTH-1:0]     tapcsync2core_ch_id_o,      // DMI/SCU Chain Identifier output (SysCLK domain)\n\n    input  logic                                    tapc2tapcsync_ch_capture_i, // DMI/SCU Chain Capture input  (TCK domain)\n    output logic                                    tapcsync2core_ch_capture_o, // DMI/SCU Chain Capture output (SysCLK domain)\n\n    input  logic                                    tapc2tapcsync_ch_shift_i,   // DMI/SCU Chain Shift input  (TCK domain)\n    output logic                                    tapcsync2core_ch_shift_o,   // DMI/SCU Chain Shift output (SysCLK domain)\n\n    input  logic                                    tapc2tapcsync_ch_update_i,  // DMI/SCU Chain Update input  (TCK domain)\n    output logic                                    tapcsync2core_ch_update_o,  // DMI/SCU Chain Update output (SysCLK domain)\n\n    input  logic                                    tapc2tapcsync_ch_tdi_i,     // DMI/SCU Chain TDI input  (TCK domain)\n    output logic                                    tapcsync2core_ch_tdi_o,     // DMI/SCU Chain TDI output (SysCLK domain)\n\n    output logic                                    tapc2tapcsync_ch_tdo_i,     // DMI/SCU Chain TDO output (TCK domain)\n    input  logic                                    tapcsync2core_ch_tdo_o      // DMI/SCU Chain TDO input  (SysCLK domain)\n);\n\n//-------------------------------------------------------------------------------\n// Local signals declaration\n//-------------------------------------------------------------------------------\n\nlogic           tck_divpos;\nlogic           tck_divneg;\nlogic           tck_rise_load;\nlogic           tck_rise_reset;\nlogic           tck_fall_load;\nlogic           tck_fall_reset;\nlogic [3:0]     tck_divpos_sync;\nlogic [3:0]     tck_divneg_sync;\nlogic [2:0]     dmi_ch_capture_sync;\nlogic [2:0]     dmi_ch_shift_sync;\nlogic [2:0]     dmi_ch_tdi_sync;\n\n//-------------------------------------------------------------------------------\n// Logic\n//-------------------------------------------------------------------------------\n\nalways_ff @(posedge tapc_tck, negedge tapc_trst_n) begin\n    if (~tapc_trst_n) begin\n        tck_divpos      <= 1'b0;\n    end else begin\n        tck_divpos      <= ~tck_divpos;\n    end\nend\n\nalways_ff @(negedge tapc_tck, negedge tapc_trst_n) begin\n    if (~tapc_trst_n) begin\n        tck_divneg      <= 1'b0;\n    end else begin\n        tck_divneg      <= ~tck_divneg;\n    end\nend\n\nalways_ff @(posedge clk, negedge pwrup_rst_n) begin\n    if (~pwrup_rst_n) begin\n        tck_divpos_sync <= 4'd0;\n        tck_divneg_sync <= 4'd0;\n    end else begin\n        tck_divpos_sync <= {tck_divpos_sync[2:0], tck_divpos};\n        tck_divneg_sync <= {tck_divneg_sync[2:0], tck_divneg};\n    end\nend\n\nassign tck_rise_load  = tck_divpos_sync[2] ^ tck_divpos_sync[1];\nassign tck_rise_reset = tck_divpos_sync[3] ^ tck_divpos_sync[2];\nassign tck_fall_load  = tck_divneg_sync[2] ^ tck_divneg_sync[1];\nassign tck_fall_reset = tck_divneg_sync[3] ^ tck_divneg_sync[2];\n\nalways_ff @(posedge clk, negedge pwrup_rst_n) begin\n    if (~pwrup_rst_n) begin\n            tapcsync2core_ch_update_o   <= '0;\n    end else begin\n        if  (tck_fall_load) begin\n            tapcsync2core_ch_update_o   <= tapc2tapcsync_ch_update_i;\n        end else if (tck_fall_reset) begin\n            tapcsync2core_ch_update_o   <= '0;\n        end\n    end\nend\n\nalways_ff @(negedge tapc_tck, negedge tapc_trst_n) begin\n    if (~tapc_trst_n) begin\n        dmi_ch_capture_sync[0] <= '0;\n        dmi_ch_shift_sync[0]   <= '0;\n    end else begin\n        dmi_ch_capture_sync[0] <= tapc2tapcsync_ch_capture_i;\n        dmi_ch_shift_sync[0]   <= tapc2tapcsync_ch_shift_i;\n    end\nend\n\nalways_ff @(posedge clk, negedge pwrup_rst_n) begin\n    if (~pwrup_rst_n) begin\n        dmi_ch_capture_sync[2:1] <= '0;\n        dmi_ch_shift_sync[2:1]   <= '0;\n    end else begin\n        dmi_ch_capture_sync[2:1] <= {dmi_ch_capture_sync[1], dmi_ch_capture_sync[0]};\n        dmi_ch_shift_sync[2:1]   <= {dmi_ch_shift_sync[1], dmi_ch_shift_sync[0]};\n    end\nend\n\nalways_ff @(posedge clk, negedge pwrup_rst_n) begin\n    if (~pwrup_rst_n) begin\n        dmi_ch_tdi_sync     <= '0;\n    end else begin\n        dmi_ch_tdi_sync     <= {dmi_ch_tdi_sync[1:0], tapc2tapcsync_ch_tdi_i};\n    end\nend\n\nalways_ff @(posedge clk, negedge pwrup_rst_n) begin\n    if (~pwrup_rst_n) begin\n            tapcsync2core_ch_capture_o <= '0;\n            tapcsync2core_ch_shift_o   <= '0;\n            tapcsync2core_ch_tdi_o     <= '0;\n    end else begin\n        if (tck_rise_load) begin\n            tapcsync2core_ch_capture_o <= dmi_ch_capture_sync[2];\n            tapcsync2core_ch_shift_o   <= dmi_ch_shift_sync[2];\n            tapcsync2core_ch_tdi_o     <= dmi_ch_tdi_sync[2];\n        end else if (tck_rise_reset) begin\n            tapcsync2core_ch_capture_o <= '0;\n            tapcsync2core_ch_shift_o   <= '0;\n            tapcsync2core_ch_tdi_o     <= '0;\n        end\n    end\nend\n\nalways_ff @(posedge clk, negedge dm_rst_n) begin\n    if (~dm_rst_n) begin\n            tapcsync2dmi_ch_sel_o     <= '0;\n            tapcsync2core_ch_id_o      <= '0;\n    end else begin\n        if (tck_rise_load) begin\n            tapcsync2dmi_ch_sel_o     <= tapc2tapcsync_dmi_ch_sel_i;\n            tapcsync2core_ch_id_o      <= tapc2tapcsync_ch_id_i;\n        end\n    end\nend\n\nalways_ff @(posedge clk, negedge pwrup_rst_n) begin\n    if (~pwrup_rst_n) begin\n            tapcsync2scu_ch_sel_o     <= '0;\n    end else begin\n        if (tck_rise_load) begin\n            tapcsync2scu_ch_sel_o     <= tapc2tapcsync_scu_ch_sel_i;\n        end\n    end\nend\n\nassign tapc2tapcsync_ch_tdo_i = tapcsync2core_ch_tdo_o;\n\nendmodule : scr1_tapc_synchronizer\n\n`endif // SCR1_DBG_EN\n"}
{"text": "/// Copyright by Syntacore LLC \u00a9 2016-2020. See LICENSE for details\n/// @file       <scr1_tcm.sv>\n/// @brief      Tightly-Coupled Memory (TCM)\n///\n\n`include \"scr1_memif.svh\"\n`include \"scr1_arch_description.svh\"\n\n`ifdef SCR1_TCM_EN\nmodule scr1_tcm\n#(\n    parameter SCR1_TCM_SIZE = `SCR1_IMEM_AWIDTH'h00010000\n)\n(\n    // Control signals\n    input   logic                           clk,\n    input   logic                           rst_n,\n\n    // Core instruction interface\n    output  logic                           imem_req_ack,\n    input   logic                           imem_req,\n    input   logic [`SCR1_IMEM_AWIDTH-1:0]   imem_addr,\n    output  logic [`SCR1_IMEM_DWIDTH-1:0]   imem_rdata,\n    output  type_scr1_mem_resp_e            imem_resp,\n\n    // Core data interface\n    output  logic                           dmem_req_ack,\n    input   logic                           dmem_req,\n    input   type_scr1_mem_cmd_e             dmem_cmd,\n    input   type_scr1_mem_width_e           dmem_width,\n    input   logic [`SCR1_DMEM_AWIDTH-1:0]   dmem_addr,\n    input   logic [`SCR1_DMEM_DWIDTH-1:0]   dmem_wdata,\n    output  logic [`SCR1_DMEM_DWIDTH-1:0]   dmem_rdata,\n    output  type_scr1_mem_resp_e            dmem_resp\n);\n\n//-------------------------------------------------------------------------------\n// Local signal declaration\n//-------------------------------------------------------------------------------\nlogic                               imem_req_en;\nlogic                               dmem_req_en;\nlogic                               imem_rd;\nlogic                               dmem_rd;\nlogic                               dmem_wr;\nlogic [`SCR1_DMEM_DWIDTH-1:0]       dmem_writedata;\nlogic [`SCR1_DMEM_DWIDTH-1:0]       dmem_rdata_local;\nlogic [3:0]                         dmem_byteen;\nlogic [1:0]                         dmem_rdata_shift_reg;\n//-------------------------------------------------------------------------------\n// Core interface\n//-------------------------------------------------------------------------------\nassign imem_req_en = (imem_resp == SCR1_MEM_RESP_RDY_OK) ^ imem_req;\nassign dmem_req_en = (dmem_resp == SCR1_MEM_RESP_RDY_OK) ^ dmem_req;\n\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        imem_resp <= SCR1_MEM_RESP_NOTRDY;\n    end else if (imem_req_en) begin\n        imem_resp <= imem_req ? SCR1_MEM_RESP_RDY_OK : SCR1_MEM_RESP_NOTRDY;\n    end\nend\n\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        dmem_resp <= SCR1_MEM_RESP_NOTRDY;\n    end else if (dmem_req_en) begin\n        dmem_resp <= dmem_req ? SCR1_MEM_RESP_RDY_OK : SCR1_MEM_RESP_NOTRDY;\n    end\nend\n\nassign imem_req_ack = 1'b1;\nassign dmem_req_ack = 1'b1;\n//-------------------------------------------------------------------------------\n// Memory data composing\n//-------------------------------------------------------------------------------\nassign imem_rd  = imem_req;\nassign dmem_rd  = dmem_req & (dmem_cmd == SCR1_MEM_CMD_RD);\nassign dmem_wr  = dmem_req & (dmem_cmd == SCR1_MEM_CMD_WR);\n\nalways_comb begin\n    dmem_writedata = dmem_wdata;\n    dmem_byteen    = 4'b1111;\n    case ( dmem_width )\n        SCR1_MEM_WIDTH_BYTE : begin\n            dmem_writedata  = {(`SCR1_DMEM_DWIDTH /  8){dmem_wdata[7:0]}};\n            dmem_byteen     = 4'b0001 << dmem_addr[1:0];\n        end\n        SCR1_MEM_WIDTH_HWORD : begin\n            dmem_writedata  = {(`SCR1_DMEM_DWIDTH / 16){dmem_wdata[15:0]}};\n            dmem_byteen     = 4'b0011 << {dmem_addr[1], 1'b0};\n        end\n        default : begin\n        end\n    endcase\nend\n//-------------------------------------------------------------------------------\n// Memory instantiation\n//-------------------------------------------------------------------------------\nscr1_dp_memory #(\n    .SCR1_WIDTH ( 32            ),\n    .SCR1_SIZE  ( SCR1_TCM_SIZE )\n) i_dp_memory (\n    .clk    ( clk                                   ),\n    // Instruction port\n    // Port A\n    .rena   ( imem_rd                               ),\n    .addra  ( imem_addr[$clog2(SCR1_TCM_SIZE)-1:2]  ),\n    .qa     ( imem_rdata                            ),\n    // Data port\n    // Port B\n    .renb   ( dmem_rd                               ),\n    .wenb   ( dmem_wr                               ),\n    .webb   ( dmem_byteen                           ),\n    .addrb  ( dmem_addr[$clog2(SCR1_TCM_SIZE)-1:2]  ),\n    .qb     ( dmem_rdata_local                      ),\n    .datab  ( dmem_writedata                        )\n);\n//-------------------------------------------------------------------------------\n// Data memory output generation\n//-------------------------------------------------------------------------------\nalways_ff @(posedge clk) begin\n    if (dmem_rd) begin\n        dmem_rdata_shift_reg <= dmem_addr[1:0];\n    end\nend\n\nassign dmem_rdata = dmem_rdata_local >> ( 8 * dmem_rdata_shift_reg );\n\nendmodule : scr1_tcm\n\n`endif // SCR1_TCM_EN\n"}
{"text": "/// Copyright by Syntacore LLC \u00a9 2016-2021. See LICENSE for details\n/// @file       <scr1_timer.sv>\n/// @brief      Memory-mapped Timer\n///\n\n`include \"scr1_arch_description.svh\"\n`include \"scr1_memif.svh\"\n\nmodule scr1_timer (\n    // Common\n    input   logic                                   rst_n,\n    input   logic                                   clk,\n    input   logic                                   rtc_clk,\n\n    // Memory interface\n    input   logic                                   dmem_req,\n    input   type_scr1_mem_cmd_e                     dmem_cmd,\n    input   type_scr1_mem_width_e                   dmem_width,\n    input   logic [`SCR1_DMEM_AWIDTH-1:0]           dmem_addr,\n    input   logic [`SCR1_DMEM_DWIDTH-1:0]           dmem_wdata,\n    output  logic                                   dmem_req_ack,\n    output  logic [`SCR1_DMEM_DWIDTH-1:0]           dmem_rdata,\n    output  type_scr1_mem_resp_e                    dmem_resp,\n\n    // Timer interface\n    output  logic [63:0]                            timer_val,\n    output  logic                                   timer_irq\n);\n\n//-------------------------------------------------------------------------------\n// Local parameters declaration\n//-------------------------------------------------------------------------------\nlocalparam int unsigned SCR1_TIMER_ADDR_WIDTH                               = 5;\nlocalparam logic [SCR1_TIMER_ADDR_WIDTH-1:0] SCR1_TIMER_CONTROL             = 5'h0;\nlocalparam logic [SCR1_TIMER_ADDR_WIDTH-1:0] SCR1_TIMER_DIVIDER             = 5'h4;\nlocalparam logic [SCR1_TIMER_ADDR_WIDTH-1:0] SCR1_TIMER_MTIMELO             = 5'h8;\nlocalparam logic [SCR1_TIMER_ADDR_WIDTH-1:0] SCR1_TIMER_MTIMEHI             = 5'hC;\nlocalparam logic [SCR1_TIMER_ADDR_WIDTH-1:0] SCR1_TIMER_MTIMECMPLO          = 5'h10;\nlocalparam logic [SCR1_TIMER_ADDR_WIDTH-1:0] SCR1_TIMER_MTIMECMPHI          = 5'h14;\n\nlocalparam int unsigned SCR1_TIMER_CONTROL_EN_OFFSET                        = 0;\nlocalparam int unsigned SCR1_TIMER_CONTROL_CLKSRC_OFFSET                    = 1;\nlocalparam int unsigned SCR1_TIMER_DIVIDER_WIDTH                            = 10;\n\n//-------------------------------------------------------------------------------\n// Local signals declaration\n//-------------------------------------------------------------------------------\nlogic [63:0]                                        mtime_reg;\nlogic [63:0]                                        mtime_new;\nlogic [63:0]                                        mtimecmp_reg;\nlogic [63:0]                                        mtimecmp_new;\nlogic                                               timer_en;\nlogic                                               timer_clksrc_rtc;\nlogic [SCR1_TIMER_DIVIDER_WIDTH-1:0]                timer_div;\n\nlogic                                               control_up;\nlogic                                               divider_up;\nlogic                                               mtimelo_up;\nlogic                                               mtimehi_up;\nlogic                                               mtimecmplo_up;\nlogic                                               mtimecmphi_up;\n\nlogic                                               dmem_req_valid;\n\nlogic [3:0]                                         rtc_sync;\nlogic                                               rtc_ext_pulse;\nlogic [SCR1_TIMER_DIVIDER_WIDTH-1:0]                timeclk_cnt;\nlogic                                               timeclk_cnt_en;\nlogic                                               time_posedge;\nlogic                                               time_cmp_flag;\n\n//-------------------------------------------------------------------------------\n// Registers\n//-------------------------------------------------------------------------------\n\n// CONTROL\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        timer_en            <= 1'b1;\n        timer_clksrc_rtc    <= 1'b0;\n    end else begin\n        if (control_up) begin\n            timer_en            <= dmem_wdata[SCR1_TIMER_CONTROL_EN_OFFSET];\n            timer_clksrc_rtc    <= dmem_wdata[SCR1_TIMER_CONTROL_CLKSRC_OFFSET];\n        end\n    end\nend\n\n// DIVIDER\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        timer_div   <= '0;\n    end else begin\n        if (divider_up) begin\n            timer_div   <= dmem_wdata[SCR1_TIMER_DIVIDER_WIDTH-1:0];\n        end\n    end\nend\n\n// MTIME\nassign time_posedge = (timeclk_cnt_en & (timeclk_cnt == 0));\n\nalways_comb begin\n    mtime_new   = mtime_reg;\n    if (time_posedge) begin\n        mtime_new   = mtime_reg + 1'b1;\n    end\n    if (mtimelo_up) begin\n        mtime_new[31:0]     = dmem_wdata;\n    end\n    if (mtimehi_up) begin\n        mtime_new[63:32]    = dmem_wdata;\n    end\nend\n\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        mtime_reg   <= '0;\n    end else begin\n        if (time_posedge | mtimelo_up | mtimehi_up) begin\n            mtime_reg   <= mtime_new;\n        end\n    end\nend\n\n// MTIMECMP\nalways_comb begin\n    mtimecmp_new    = mtimecmp_reg;\n    if (mtimecmplo_up) begin\n        mtimecmp_new[31:0]  = dmem_wdata;\n    end\n    if (mtimecmphi_up) begin\n        mtimecmp_new[63:32] = dmem_wdata;\n    end\nend\n\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        mtimecmp_reg    <= '0;\n    end else begin\n        if (mtimecmplo_up | mtimecmphi_up) begin\n            mtimecmp_reg    <= mtimecmp_new;\n        end\n    end\nend\n\n//-------------------------------------------------------------------------------\n// Interrupt pending\n//-------------------------------------------------------------------------------\nassign time_cmp_flag = (mtime_reg >= ((mtimecmplo_up | mtimecmphi_up) ? mtimecmp_new : mtimecmp_reg));\n\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        timer_irq   <= 1'b0;\n    end else begin\n        if (~timer_irq) begin\n            timer_irq   <= time_cmp_flag;\n        end else begin // 1'b1\n            if (mtimecmplo_up | mtimecmphi_up) begin\n                timer_irq   <= time_cmp_flag;\n            end\n        end\n    end\nend\n\n//-------------------------------------------------------------------------------\n// Timer divider\n//-------------------------------------------------------------------------------\nassign timeclk_cnt_en   = (~timer_clksrc_rtc ? 1'b1 : rtc_ext_pulse) & timer_en;\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        timeclk_cnt <= '0;\n    end else begin\n        case (1'b1)\n            divider_up      : timeclk_cnt   <= dmem_wdata[SCR1_TIMER_DIVIDER_WIDTH-1:0];\n            time_posedge    : timeclk_cnt   <= timer_div;\n            timeclk_cnt_en  : timeclk_cnt   <= timeclk_cnt - 1'b1;\n            default         : begin end\n        endcase\n    end\nend\n\n//-------------------------------------------------------------------------------\n// RTC synchronization\n//-------------------------------------------------------------------------------\nassign rtc_ext_pulse    = rtc_sync[3] ^ rtc_sync[2];\n\nalways_ff @(negedge rst_n, posedge rtc_clk) begin\n    if (~rst_n) begin\n        rtc_sync[0] <= 1'b0;\n    end else begin\n        if (timer_clksrc_rtc) begin\n            rtc_sync[0] <= ~rtc_sync[0];\n        end\n    end\nend\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        rtc_sync[3:1]   <= '0;\n    end else begin\n        if (timer_clksrc_rtc) begin\n            rtc_sync[3:1]   <= rtc_sync[2:0];\n        end\n    end\nend\n\n//-------------------------------------------------------------------------------\n// Memory interface\n//-------------------------------------------------------------------------------\nassign dmem_req_valid   =   (dmem_width == SCR1_MEM_WIDTH_WORD) & (~|dmem_addr[1:0]) &\n                            (dmem_addr[SCR1_TIMER_ADDR_WIDTH-1:2] <= SCR1_TIMER_MTIMECMPHI[SCR1_TIMER_ADDR_WIDTH-1:2]);\n\nassign dmem_req_ack     = 1'b1;\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        dmem_resp   <= SCR1_MEM_RESP_NOTRDY;\n        dmem_rdata  <= '0;\n    end else begin\n        if (dmem_req) begin\n            if (dmem_req_valid) begin\n                dmem_resp   <= SCR1_MEM_RESP_RDY_OK;\n                if (dmem_cmd == SCR1_MEM_CMD_RD) begin\n                    case (dmem_addr[SCR1_TIMER_ADDR_WIDTH-1:0])\n                        SCR1_TIMER_CONTROL      : dmem_rdata    <= `SCR1_DMEM_DWIDTH'({timer_clksrc_rtc, timer_en});\n                        SCR1_TIMER_DIVIDER      : dmem_rdata    <= `SCR1_DMEM_DWIDTH'(timer_div);\n                        SCR1_TIMER_MTIMELO      : dmem_rdata    <= mtime_reg[31:0];\n                        SCR1_TIMER_MTIMEHI      : dmem_rdata    <= mtime_reg[63:32];\n                        SCR1_TIMER_MTIMECMPLO   : dmem_rdata    <= mtimecmp_reg[31:0];\n                        SCR1_TIMER_MTIMECMPHI   : dmem_rdata    <= mtimecmp_reg[63:32];\n                        default                 : begin end\n                    endcase\n                end\n            end else begin\n                dmem_resp   <= SCR1_MEM_RESP_RDY_ER;\n            end\n        end else begin\n            dmem_resp   <= SCR1_MEM_RESP_NOTRDY;\n            dmem_rdata  <= '0;\n        end\n    end\nend\n\nalways_comb begin\n    control_up      = 1'b0;\n    divider_up      = 1'b0;\n    mtimelo_up      = 1'b0;\n    mtimehi_up      = 1'b0;\n    mtimecmplo_up   = 1'b0;\n    mtimecmphi_up   = 1'b0;\n    if (dmem_req & dmem_req_valid & (dmem_cmd == SCR1_MEM_CMD_WR)) begin\n        case (dmem_addr[SCR1_TIMER_ADDR_WIDTH-1:0])\n            SCR1_TIMER_CONTROL      : control_up    = 1'b1;\n            SCR1_TIMER_DIVIDER      : divider_up    = 1'b1;\n            SCR1_TIMER_MTIMELO      : mtimelo_up    = 1'b1;\n            SCR1_TIMER_MTIMEHI      : mtimehi_up    = 1'b1;\n            SCR1_TIMER_MTIMECMPLO   : mtimecmplo_up = 1'b1;\n            SCR1_TIMER_MTIMECMPHI   : mtimecmphi_up = 1'b1;\n            default                 : begin end\n        endcase\n    end\nend\n\n//-------------------------------------------------------------------------------\n// Timer interface\n//-------------------------------------------------------------------------------\nassign timer_val    = mtime_reg;\n\nendmodule : scr1_timer\n"}
{"text": "/// Copyright by Syntacore LLC \u00a9 2016-2021. See LICENSE for details\n/// @file       <scr1_top_ahb.sv>\n/// @brief      SCR1 AHB top\n///\n\n`include \"scr1_arch_description.svh\"\n`include \"scr1_memif.svh\"\n`include \"scr1_ahb.svh\"\n`ifdef SCR1_IPIC_EN\n`include \"scr1_ipic.svh\"\n`endif // SCR1_IPIC_EN\n\n`ifdef SCR1_TCM_EN\n `define SCR1_IMEM_ROUTER_EN\n`endif // SCR1_TCM_EN\n\nmodule scr1_top_ahb (\n    // Control\n    input   logic                                   pwrup_rst_n,            // Power-Up Reset\n    input   logic                                   rst_n,                  // Regular Reset signal\n    input   logic                                   cpu_rst_n,              // CPU Reset (Core Reset)\n    input   logic                                   test_mode,              // Test mode\n    input   logic                                   test_rst_n,             // Test mode's reset\n    input   logic                                   clk,                    // System clock\n    input   logic                                   rtc_clk,                // Real-time clock\n`ifdef SCR1_DBG_EN\n    output  logic                                   sys_rst_n_o,            // External System Reset output\n                                                                            //   (for the processor cluster's components or\n                                                                            //    external SOC (could be useful in small\n                                                                            //    SCR-core-centric SOCs))\n    output  logic                                   sys_rdc_qlfy_o,         // System-to-External SOC Reset Domain Crossing Qualifier\n`endif // SCR1_DBG_EN\n\n    // Fuses\n    input   logic [`SCR1_XLEN-1:0]                  fuse_mhartid,           // Hart ID\n`ifdef SCR1_DBG_EN\n    input   logic [31:0]                            fuse_idcode,            // TAPC IDCODE\n`endif // SCR1_DBG_EN\n\n    // IRQ\n`ifdef SCR1_IPIC_EN\n    input   logic [SCR1_IRQ_LINES_NUM-1:0]          irq_lines,              // IRQ lines to IPIC\n`else // SCR1_IPIC_EN\n    input   logic                                   ext_irq,                // External IRQ input\n`endif // SCR1_IPIC_EN\n    input   logic                                   soft_irq,               // Software IRQ input\n\n`ifdef SCR1_DBG_EN\n    // -- JTAG I/F\n    input   logic                                   trst_n,\n    input   logic                                   tck,\n    input   logic                                   tms,\n    input   logic                                   tdi,\n    output  logic                                   tdo,\n    output  logic                                   tdo_en,\n`endif // SCR1_DBG_EN\n\n    // Instruction Memory Interface\n    output  logic [3:0]                             imem_hprot,\n    output  logic [2:0]                             imem_hburst,\n    output  logic [2:0]                             imem_hsize,\n    output  logic [1:0]                             imem_htrans,\n    output  logic                                   imem_hmastlock,\n    output  logic [SCR1_AHB_WIDTH-1:0]              imem_haddr,\n    input   logic                                   imem_hready,\n    input   logic [SCR1_AHB_WIDTH-1:0]              imem_hrdata,\n    input   logic                                   imem_hresp,\n\n    // Data Memory Interface\n    output  logic [3:0]                             dmem_hprot,\n    output  logic [2:0]                             dmem_hburst,\n    output  logic [2:0]                             dmem_hsize,\n    output  logic [1:0]                             dmem_htrans,\n    output  logic                                   dmem_hmastlock,\n    output  logic [SCR1_AHB_WIDTH-1:0]              dmem_haddr,\n    output  logic                                   dmem_hwrite,\n    output  logic [SCR1_AHB_WIDTH-1:0]              dmem_hwdata,\n    input   logic                                   dmem_hready,\n    input   logic [SCR1_AHB_WIDTH-1:0]              dmem_hrdata,\n    input   logic                                   dmem_hresp\n);\n\n//-------------------------------------------------------------------------------\n// Local parameters\n//-------------------------------------------------------------------------------\nlocalparam int unsigned SCR1_CLUSTER_TOP_RST_SYNC_STAGES_NUM            = 2;\n\n//-------------------------------------------------------------------------------\n// Local signal declaration\n//-------------------------------------------------------------------------------\n// Reset logic\nlogic                                               pwrup_rst_n_sync;\nlogic                                               rst_n_sync;\nlogic                                               cpu_rst_n_sync;\nlogic                                               core_rst_n_local;\n`ifdef SCR1_DBG_EN\nlogic                                               tapc_trst_n;\n`endif // SCR1_DBG_EN\n\n// Instruction memory interface from core to router\nlogic                                               core_imem_req_ack;\nlogic                                               core_imem_req;\ntype_scr1_mem_cmd_e                                 core_imem_cmd;\nlogic [`SCR1_IMEM_AWIDTH-1:0]                       core_imem_addr;\nlogic [`SCR1_IMEM_DWIDTH-1:0]                       core_imem_rdata;\ntype_scr1_mem_resp_e                                core_imem_resp;\n\n// Data memory interface from core to router\nlogic                                               core_dmem_req_ack;\nlogic                                               core_dmem_req;\ntype_scr1_mem_cmd_e                                 core_dmem_cmd;\ntype_scr1_mem_width_e                               core_dmem_width;\nlogic [`SCR1_DMEM_AWIDTH-1:0]                       core_dmem_addr;\nlogic [`SCR1_DMEM_DWIDTH-1:0]                       core_dmem_wdata;\nlogic [`SCR1_DMEM_DWIDTH-1:0]                       core_dmem_rdata;\ntype_scr1_mem_resp_e                                core_dmem_resp;\n\n// Instruction memory interface from router to AHB bridge\nlogic                                               ahb_imem_req_ack;\nlogic                                               ahb_imem_req;\ntype_scr1_mem_cmd_e                                 ahb_imem_cmd;\nlogic [`SCR1_IMEM_AWIDTH-1:0]                       ahb_imem_addr;\nlogic [`SCR1_IMEM_DWIDTH-1:0]                       ahb_imem_rdata;\ntype_scr1_mem_resp_e                                ahb_imem_resp;\n\n// Data memory interface from router to AHB bridge\nlogic                                               ahb_dmem_req_ack;\nlogic                                               ahb_dmem_req;\ntype_scr1_mem_cmd_e                                 ahb_dmem_cmd;\ntype_scr1_mem_width_e                               ahb_dmem_width;\nlogic [`SCR1_DMEM_AWIDTH-1:0]                       ahb_dmem_addr;\nlogic [`SCR1_DMEM_DWIDTH-1:0]                       ahb_dmem_wdata;\nlogic [`SCR1_DMEM_DWIDTH-1:0]                       ahb_dmem_rdata;\ntype_scr1_mem_resp_e                                ahb_dmem_resp;\n\n`ifdef SCR1_TCM_EN\n// Instruction memory interface from router to TCM\nlogic                                               tcm_imem_req_ack;\nlogic                                               tcm_imem_req;\ntype_scr1_mem_cmd_e                                 tcm_imem_cmd;\nlogic [`SCR1_IMEM_AWIDTH-1:0]                       tcm_imem_addr;\nlogic [`SCR1_IMEM_DWIDTH-1:0]                       tcm_imem_rdata;\ntype_scr1_mem_resp_e                                tcm_imem_resp;\n\n// Data memory interface from router to TCM\nlogic                                               tcm_dmem_req_ack;\nlogic                                               tcm_dmem_req;\ntype_scr1_mem_cmd_e                                 tcm_dmem_cmd;\ntype_scr1_mem_width_e                               tcm_dmem_width;\nlogic [`SCR1_DMEM_AWIDTH-1:0]                       tcm_dmem_addr;\nlogic [`SCR1_DMEM_DWIDTH-1:0]                       tcm_dmem_wdata;\nlogic [`SCR1_DMEM_DWIDTH-1:0]                       tcm_dmem_rdata;\ntype_scr1_mem_resp_e                                tcm_dmem_resp;\n`endif // SCR1_TCM_EN\n\n// Data memory interface from router to memory-mapped timer\nlogic                                               timer_dmem_req_ack;\nlogic                                               timer_dmem_req;\ntype_scr1_mem_cmd_e                                 timer_dmem_cmd;\ntype_scr1_mem_width_e                               timer_dmem_width;\nlogic [`SCR1_DMEM_AWIDTH-1:0]                       timer_dmem_addr;\nlogic [`SCR1_DMEM_DWIDTH-1:0]                       timer_dmem_wdata;\nlogic [`SCR1_DMEM_DWIDTH-1:0]                       timer_dmem_rdata;\ntype_scr1_mem_resp_e                                timer_dmem_resp;\n\nlogic                                               timer_irq;\nlogic [63:0]                                        timer_val;\n\n\n//-------------------------------------------------------------------------------\n// Reset logic\n//-------------------------------------------------------------------------------\n// Power-Up Reset synchronizer\nscr1_reset_sync_cell #(\n    .STAGES_AMOUNT       (SCR1_CLUSTER_TOP_RST_SYNC_STAGES_NUM)\n) i_pwrup_rstn_reset_sync (\n    .rst_n          (pwrup_rst_n     ),\n    .clk            (clk             ),\n    .test_rst_n     (test_rst_n      ),\n    .test_mode      (test_mode       ),\n    .rst_n_in       (1'b1            ),\n    .rst_n_out      (pwrup_rst_n_sync)\n);\n\n// Regular Reset synchronizer\nscr1_reset_sync_cell #(\n    .STAGES_AMOUNT       (SCR1_CLUSTER_TOP_RST_SYNC_STAGES_NUM)\n) i_rstn_reset_sync (\n    .rst_n          (pwrup_rst_n     ),\n    .clk            (clk             ),\n    .test_rst_n     (test_rst_n      ),\n    .test_mode      (test_mode       ),\n    .rst_n_in       (rst_n           ),\n    .rst_n_out      (rst_n_sync      )\n);\n\n// CPU Reset synchronizer\nscr1_reset_sync_cell #(\n    .STAGES_AMOUNT       (SCR1_CLUSTER_TOP_RST_SYNC_STAGES_NUM)\n) i_cpu_rstn_reset_sync (\n    .rst_n          (pwrup_rst_n     ),\n    .clk            (clk             ),\n    .test_rst_n     (test_rst_n      ),\n    .test_mode      (test_mode       ),\n    .rst_n_in       (cpu_rst_n       ),\n    .rst_n_out      (cpu_rst_n_sync  )\n);\n\n`ifdef SCR1_DBG_EN\n// TAPC Reset\nscr1_reset_and2_cell i_tapc_rstn_and2_cell (\n    .rst_n_in       ({trst_n, pwrup_rst_n}),\n    .test_rst_n     (test_rst_n      ),\n    .test_mode      (test_mode       ),\n    .rst_n_out      (tapc_trst_n     )\n);\n`endif // SCR1_DBG_EN\n\n//-------------------------------------------------------------------------------\n// SCR1 core instance\n//-------------------------------------------------------------------------------\nscr1_core_top i_core_top (\n    // Common\n    .pwrup_rst_n                (pwrup_rst_n_sync ),\n    .rst_n                      (rst_n_sync       ),\n    .cpu_rst_n                  (cpu_rst_n_sync   ),\n    .test_mode                  (test_mode        ),\n    .test_rst_n                 (test_rst_n       ),\n    .clk                        (clk              ),\n    .core_rst_n_o               (core_rst_n_local ),\n    .core_rdc_qlfy_o            (                 ),\n`ifdef SCR1_DBG_EN\n    .sys_rst_n_o                (sys_rst_n_o      ),\n    .sys_rdc_qlfy_o             (sys_rdc_qlfy_o   ),\n`endif // SCR1_DBG_EN\n\n    // Fuses\n    .core_fuse_mhartid_i        (fuse_mhartid     ),\n`ifdef SCR1_DBG_EN\n    .tapc_fuse_idcode_i         (fuse_idcode      ),\n`endif // SCR1_DBG_EN\n\n    // IRQ\n`ifdef SCR1_IPIC_EN\n    .core_irq_lines_i           (irq_lines        ),\n`else // SCR1_IPIC_EN\n    .core_irq_ext_i             (ext_irq          ),\n`endif // SCR1_IPIC_EN\n    .core_irq_soft_i            (soft_irq         ),\n    .core_irq_mtimer_i          (timer_irq        ),\n\n    // Memory-mapped external timer\n    .core_mtimer_val_i          (timer_val        ),\n\n`ifdef SCR1_DBG_EN\n    // Debug interface\n    .tapc_trst_n                (tapc_trst_n      ),\n    .tapc_tck                   (tck              ),\n    .tapc_tms                   (tms              ),\n    .tapc_tdi                   (tdi              ),\n    .tapc_tdo                   (tdo              ),\n    .tapc_tdo_en                (tdo_en           ),\n`endif // SCR1_DBG_EN\n\n    // Instruction memory interface\n    .imem2core_req_ack_i        (core_imem_req_ack),\n    .core2imem_req_o            (core_imem_req    ),\n    .core2imem_cmd_o            (core_imem_cmd    ),\n    .core2imem_addr_o           (core_imem_addr   ),\n    .imem2core_rdata_i          (core_imem_rdata  ),\n    .imem2core_resp_i           (core_imem_resp   ),\n\n    // Data memory interface\n    .dmem2core_req_ack_i        (core_dmem_req_ack),\n    .core2dmem_req_o            (core_dmem_req    ),\n    .core2dmem_cmd_o            (core_dmem_cmd    ),\n    .core2dmem_width_o          (core_dmem_width  ),\n    .core2dmem_addr_o           (core_dmem_addr   ),\n    .core2dmem_wdata_o          (core_dmem_wdata  ),\n    .dmem2core_rdata_i          (core_dmem_rdata  ),\n    .dmem2core_resp_i           (core_dmem_resp   )\n);\n\n\n`ifdef SCR1_TCM_EN\n//-------------------------------------------------------------------------------\n// TCM instance\n//-------------------------------------------------------------------------------\nscr1_tcm #(\n    .SCR1_TCM_SIZE  (`SCR1_DMEM_AWIDTH'(~SCR1_TCM_ADDR_MASK + 1'b1))\n) i_tcm (\n    .clk            (clk             ),\n    .rst_n          (core_rst_n_local),\n\n    // Instruction interface to TCM\n    .imem_req_ack   (tcm_imem_req_ack),\n    .imem_req       (tcm_imem_req    ),\n    .imem_addr      (tcm_imem_addr   ),\n    .imem_rdata     (tcm_imem_rdata  ),\n    .imem_resp      (tcm_imem_resp   ),\n\n    // Data interface to TCM\n    .dmem_req_ack   (tcm_dmem_req_ack),\n    .dmem_req       (tcm_dmem_req    ),\n    .dmem_cmd       (tcm_dmem_cmd    ),\n    .dmem_width     (tcm_dmem_width  ),\n    .dmem_addr      (tcm_dmem_addr   ),\n    .dmem_wdata     (tcm_dmem_wdata  ),\n    .dmem_rdata     (tcm_dmem_rdata  ),\n    .dmem_resp      (tcm_dmem_resp   )\n);\n`endif // SCR1_TCM_EN\n\n\n//-------------------------------------------------------------------------------\n// Memory-mapped timer instance\n//-------------------------------------------------------------------------------\nscr1_timer i_timer (\n    // Common\n    .rst_n          (core_rst_n_local  ),\n    .clk            (clk               ),\n    .rtc_clk        (rtc_clk           ),\n\n    // Memory interface\n    .dmem_req       (timer_dmem_req    ),\n    .dmem_cmd       (timer_dmem_cmd    ),\n    .dmem_width     (timer_dmem_width  ),\n    .dmem_addr      (timer_dmem_addr   ),\n    .dmem_wdata     (timer_dmem_wdata  ),\n    .dmem_req_ack   (timer_dmem_req_ack),\n    .dmem_rdata     (timer_dmem_rdata  ),\n    .dmem_resp      (timer_dmem_resp   ),\n\n    // Timer interface\n    .timer_val      (timer_val         ),\n    .timer_irq      (timer_irq         )\n);\n\n\n`ifdef SCR1_IMEM_ROUTER_EN\n//-------------------------------------------------------------------------------\n// Instruction memory router\n//-------------------------------------------------------------------------------\nscr1_imem_router #(\n `ifdef SCR1_TCM_EN\n    .SCR1_ADDR_MASK     (SCR1_TCM_ADDR_MASK),\n    .SCR1_ADDR_PATTERN  (SCR1_TCM_ADDR_PATTERN)\n `endif // SCR1_TCM_EN\n) i_imem_router (\n    .rst_n          (core_rst_n_local ),\n    .clk            (clk              ),\n    // Interface to core\n    .imem_req_ack   (core_imem_req_ack),\n    .imem_req       (core_imem_req    ),\n    .imem_cmd       (core_imem_cmd    ),\n    .imem_addr      (core_imem_addr   ),\n    .imem_rdata     (core_imem_rdata  ),\n    .imem_resp      (core_imem_resp   ),\n    // Interface to AHB bridge\n    .port0_req_ack  (ahb_imem_req_ack ),\n    .port0_req      (ahb_imem_req     ),\n    .port0_cmd      (ahb_imem_cmd     ),\n    .port0_addr     (ahb_imem_addr    ),\n    .port0_rdata    (ahb_imem_rdata   ),\n    .port0_resp     (ahb_imem_resp    ),\n `ifdef SCR1_TCM_EN\n    // Interface to TCM\n    .port1_req_ack  (tcm_imem_req_ack ),\n    .port1_req      (tcm_imem_req     ),\n    .port1_cmd      (tcm_imem_cmd     ),\n    .port1_addr     (tcm_imem_addr    ),\n    .port1_rdata    (tcm_imem_rdata   ),\n    .port1_resp     (tcm_imem_resp    )\n `endif // SCR1_TCM_EN\n);\n\n`else // SCR1_IMEM_ROUTER_EN\n\nassign ahb_imem_req         = core_imem_req;\nassign ahb_imem_cmd         = core_imem_cmd;\nassign ahb_imem_addr        = core_imem_addr;\nassign core_imem_req_ack    = ahb_imem_req_ack;\nassign core_imem_resp       = ahb_imem_resp;\nassign core_imem_rdata      = ahb_imem_rdata;\n\n`endif // SCR1_IMEM_ROUTER_EN\n\n//-------------------------------------------------------------------------------\n// Data memory router\n//-------------------------------------------------------------------------------\nscr1_dmem_router #(\n\n`ifdef SCR1_TCM_EN\n    .SCR1_PORT1_ADDR_MASK       (SCR1_TCM_ADDR_MASK),\n    .SCR1_PORT1_ADDR_PATTERN    (SCR1_TCM_ADDR_PATTERN),\n`else // SCR1_TCM_EN\n    .SCR1_PORT1_ADDR_MASK       (32'h00000000),\n    .SCR1_PORT1_ADDR_PATTERN    (32'hFFFFFFFF),\n`endif // SCR1_TCM_EN\n\n    .SCR1_PORT2_ADDR_MASK       (SCR1_TIMER_ADDR_MASK),\n    .SCR1_PORT2_ADDR_PATTERN    (SCR1_TIMER_ADDR_PATTERN)\n\n) i_dmem_router (\n    .rst_n          (core_rst_n_local    ),\n    .clk            (clk                 ),\n    // Interface to core\n    .dmem_req_ack   (core_dmem_req_ack   ),\n    .dmem_req       (core_dmem_req       ),\n    .dmem_cmd       (core_dmem_cmd       ),\n    .dmem_width     (core_dmem_width     ),\n    .dmem_addr      (core_dmem_addr      ),\n    .dmem_wdata     (core_dmem_wdata     ),\n    .dmem_rdata     (core_dmem_rdata     ),\n    .dmem_resp      (core_dmem_resp      ),\n`ifdef SCR1_TCM_EN\n    // Interface to TCM\n    .port1_req_ack  (tcm_dmem_req_ack    ),\n    .port1_req      (tcm_dmem_req        ),\n    .port1_cmd      (tcm_dmem_cmd        ),\n    .port1_width    (tcm_dmem_width      ),\n    .port1_addr     (tcm_dmem_addr       ),\n    .port1_wdata    (tcm_dmem_wdata      ),\n    .port1_rdata    (tcm_dmem_rdata      ),\n    .port1_resp     (tcm_dmem_resp       ),\n`else // SCR1_TCM_EN\n    .port1_req_ack  (1'b0),\n    .port1_req      (                    ),\n    .port1_cmd      (                    ),\n    .port1_width    (                    ),\n    .port1_addr     (                    ),\n    .port1_wdata    (                    ),\n    .port1_rdata    ('0                  ),\n    .port1_resp     (SCR1_MEM_RESP_RDY_ER),\n`endif // SCR1_TCM_EN\n    // Interface to memory-mapped timer\n    .port2_req_ack  (timer_dmem_req_ack  ),\n    .port2_req      (timer_dmem_req      ),\n    .port2_cmd      (timer_dmem_cmd      ),\n    .port2_width    (timer_dmem_width    ),\n    .port2_addr     (timer_dmem_addr     ),\n    .port2_wdata    (timer_dmem_wdata    ),\n    .port2_rdata    (timer_dmem_rdata    ),\n    .port2_resp     (timer_dmem_resp     ),\n    // Interface to AHB bridge\n    .port0_req_ack  (ahb_dmem_req_ack    ),\n    .port0_req      (ahb_dmem_req        ),\n    .port0_cmd      (ahb_dmem_cmd        ),\n    .port0_width    (ahb_dmem_width      ),\n    .port0_addr     (ahb_dmem_addr       ),\n    .port0_wdata    (ahb_dmem_wdata      ),\n    .port0_rdata    (ahb_dmem_rdata      ),\n    .port0_resp     (ahb_dmem_resp       )\n);\n\n\n//-------------------------------------------------------------------------------\n// Instruction memory AHB bridge\n//-------------------------------------------------------------------------------\nscr1_imem_ahb i_imem_ahb (\n    .rst_n          (core_rst_n_local   ),\n    .clk            (clk                ),\n    // Interface to imem router\n    .imem_req_ack   (ahb_imem_req_ack   ),\n    .imem_req       (ahb_imem_req       ),\n    .imem_addr      (ahb_imem_addr      ),\n    .imem_rdata     (ahb_imem_rdata     ),\n    .imem_resp      (ahb_imem_resp      ),\n    // AHB interface\n    .hprot          (imem_hprot         ),\n    .hburst         (imem_hburst        ),\n    .hsize          (imem_hsize         ),\n    .htrans         (imem_htrans        ),\n    .hmastlock      (imem_hmastlock     ),\n    .haddr          (imem_haddr         ),\n    .hready         (imem_hready      "}
{"text": "  ),\n    .hrdata         (imem_hrdata        ),\n    .hresp          (imem_hresp         )\n);\n\n\n//-------------------------------------------------------------------------------\n// Data memory AHB bridge\n//-------------------------------------------------------------------------------\nscr1_dmem_ahb i_dmem_ahb (\n    .rst_n          (core_rst_n_local   ),\n    .clk            (clk                ),\n    // Interface to dmem router\n    .dmem_req_ack   (ahb_dmem_req_ack   ),\n    .dmem_req       (ahb_dmem_req       ),\n    .dmem_cmd       (ahb_dmem_cmd       ),\n    .dmem_width     (ahb_dmem_width     ),\n    .dmem_addr      (ahb_dmem_addr      ),\n    .dmem_wdata     (ahb_dmem_wdata     ),\n    .dmem_rdata     (ahb_dmem_rdata     ),\n    .dmem_resp      (ahb_dmem_resp      ),\n    // AHB interface\n    .hprot          (dmem_hprot         ),\n    .hburst         (dmem_hburst        ),\n    .hsize          (dmem_hsize         ),\n    .htrans         (dmem_htrans        ),\n    .hmastlock      (dmem_hmastlock     ),\n    .haddr          (dmem_haddr         ),\n    .hwrite         (dmem_hwrite        ),\n    .hwdata         (dmem_hwdata        ),\n    .hready         (dmem_hready        ),\n    .hrdata         (dmem_hrdata        ),\n    .hresp          (dmem_hresp         )\n);\n\nendmodule : scr1_top_ahb\n\n\n"}
{"text": "/// Copyright by Syntacore LLC \u00a9 2016-2020. See LICENSE for details\n/// @file       <scr1_top_axi.sv>\n/// @brief      SCR1 AXI top\n///\n\n`include \"scr1_arch_description.svh\"\n`include \"scr1_memif.svh\"\n`ifdef SCR1_IPIC_EN\n`include \"scr1_ipic.svh\"\n`endif // SCR1_IPIC_EN\n\n`ifdef SCR1_TCM_EN\n `define SCR1_IMEM_ROUTER_EN\n`endif // SCR1_TCM_EN\n\nmodule scr1_top_axi (\n    // Control\n    input   logic                                   pwrup_rst_n,            // Power-Up Reset\n    input   logic                                   rst_n,                  // Regular Reset signal\n    input   logic                                   cpu_rst_n,              // CPU Reset (Core Reset)\n    input   logic                                   test_mode,              // Test mode\n    input   logic                                   test_rst_n,             // Test mode's reset\n    input   logic                                   clk,                    // System clock\n    input   logic                                   rtc_clk,                // Real-time clock\n`ifdef SCR1_DBG_EN\n    output  logic                                   sys_rst_n_o,            // External System Reset output\n                                                                            //   (for the processor cluster's components or\n                                                                            //    external SOC (could be useful in small\n                                                                            //    SCR-core-centric SOCs))\n    output  logic                                   sys_rdc_qlfy_o,         // System-to-External SOC Reset Domain Crossing Qualifier\n`endif // SCR1_DBG_EN\n\n    // Fuses\n    input   logic [`SCR1_XLEN-1:0]                  fuse_mhartid,           // Hart ID\n`ifdef SCR1_DBG_EN\n    input   logic [31:0]                            fuse_idcode,            // TAPC IDCODE\n`endif // SCR1_DBG_EN\n\n    // IRQ\n`ifdef SCR1_IPIC_EN\n    input   logic [SCR1_IRQ_LINES_NUM-1:0]          irq_lines,              // IRQ lines to IPIC\n`else // SCR1_IPIC_EN\n    input   logic                                   ext_irq,                // External IRQ input\n`endif // SCR1_IPIC_EN\n    input   logic                                   soft_irq,               // Software IRQ input\n\n`ifdef SCR1_DBG_EN\n    // -- JTAG I/F\n    input   logic                                   trst_n,\n    input   logic                                   tck,\n    input   logic                                   tms,\n    input   logic                                   tdi,\n    output  logic                                   tdo,\n    output  logic                                   tdo_en,\n`endif // SCR1_DBG_EN\n\n    // Instruction Memory Interface\n    output  logic [3:0]                             io_axi_imem_awid,\n    output  logic [31:0]                            io_axi_imem_awaddr,\n    output  logic [7:0]                             io_axi_imem_awlen,\n    output  logic [2:0]                             io_axi_imem_awsize,\n    output  logic [1:0]                             io_axi_imem_awburst,\n    output  logic                                   io_axi_imem_awlock,\n    output  logic [3:0]                             io_axi_imem_awcache,\n    output  logic [2:0]                             io_axi_imem_awprot,\n    output  logic [3:0]                             io_axi_imem_awregion,\n    output  logic [3:0]                             io_axi_imem_awuser,\n    output  logic [3:0]                             io_axi_imem_awqos,\n    output  logic                                   io_axi_imem_awvalid,\n    input   logic                                   io_axi_imem_awready,\n    output  logic [31:0]                            io_axi_imem_wdata,\n    output  logic [3:0]                             io_axi_imem_wstrb,\n    output  logic                                   io_axi_imem_wlast,\n    output  logic [3:0]                             io_axi_imem_wuser,\n    output  logic                                   io_axi_imem_wvalid,\n    input   logic                                   io_axi_imem_wready,\n    input   logic [3:0]                             io_axi_imem_bid,\n    input   logic [1:0]                             io_axi_imem_bresp,\n    input   logic                                   io_axi_imem_bvalid,\n    input   logic [3:0]                             io_axi_imem_buser,\n    output  logic                                   io_axi_imem_bready,\n    output  logic [3:0]                             io_axi_imem_arid,\n    output  logic [31:0]                            io_axi_imem_araddr,\n    output  logic [7:0]                             io_axi_imem_arlen,\n    output  logic [2:0]                             io_axi_imem_arsize,\n    output  logic [1:0]                             io_axi_imem_arburst,\n    output  logic                                   io_axi_imem_arlock,\n    output  logic [3:0]                             io_axi_imem_arcache,\n    output  logic [2:0]                             io_axi_imem_arprot,\n    output  logic [3:0]                             io_axi_imem_arregion,\n    output  logic [3:0]                             io_axi_imem_aruser,\n    output  logic [3:0]                             io_axi_imem_arqos,\n    output  logic                                   io_axi_imem_arvalid,\n    input   logic                                   io_axi_imem_arready,\n    input   logic [3:0]                             io_axi_imem_rid,\n    input   logic [31:0]                            io_axi_imem_rdata,\n    input   logic [1:0]                             io_axi_imem_rresp,\n    input   logic                                   io_axi_imem_rlast,\n    input   logic [3:0]                             io_axi_imem_ruser,\n    input   logic                                   io_axi_imem_rvalid,\n    output  logic                                   io_axi_imem_rready,\n\n    // Data Memory Interface\n    output  logic [3:0]                             io_axi_dmem_awid,\n    output  logic [31:0]                            io_axi_dmem_awaddr,\n    output  logic [7:0]                             io_axi_dmem_awlen,\n    output  logic [2:0]                             io_axi_dmem_awsize,\n    output  logic [1:0]                             io_axi_dmem_awburst,\n    output  logic                                   io_axi_dmem_awlock,\n    output  logic [3:0]                             io_axi_dmem_awcache,\n    output  logic [2:0]                             io_axi_dmem_awprot,\n    output  logic [3:0]                             io_axi_dmem_awregion,\n    output  logic [3:0]                             io_axi_dmem_awuser,\n    output  logic [3:0]                             io_axi_dmem_awqos,\n    output  logic                                   io_axi_dmem_awvalid,\n    input   logic                                   io_axi_dmem_awready,\n    output  logic [31:0]                            io_axi_dmem_wdata,\n    output  logic [3:0]                             io_axi_dmem_wstrb,\n    output  logic                                   io_axi_dmem_wlast,\n    output  logic [3:0]                             io_axi_dmem_wuser,\n    output  logic                                   io_axi_dmem_wvalid,\n    input   logic                                   io_axi_dmem_wready,\n    input   logic [3:0]                             io_axi_dmem_bid,\n    input   logic [1:0]                             io_axi_dmem_bresp,\n    input   logic                                   io_axi_dmem_bvalid,\n    input   logic [3:0]                             io_axi_dmem_buser,\n    output  logic                                   io_axi_dmem_bready,\n    output  logic [3:0]                             io_axi_dmem_arid,\n    output  logic [31:0]                            io_axi_dmem_araddr,\n    output  logic [7:0]                             io_axi_dmem_arlen,\n    output  logic [2:0]                             io_axi_dmem_arsize,\n    output  logic [1:0]                             io_axi_dmem_arburst,\n    output  logic                                   io_axi_dmem_arlock,\n    output  logic [3:0]                             io_axi_dmem_arcache,\n    output  logic [2:0]                             io_axi_dmem_arprot,\n    output  logic [3:0]                             io_axi_dmem_arregion,\n    output  logic [3:0]                             io_axi_dmem_aruser,\n    output  logic [3:0]                             io_axi_dmem_arqos,\n    output  logic                                   io_axi_dmem_arvalid,\n    input   logic                                   io_axi_dmem_arready,\n    input   logic [3:0]                             io_axi_dmem_rid,\n    input   logic [31:0]                            io_axi_dmem_rdata,\n    input   logic [1:0]                             io_axi_dmem_rresp,\n    input   logic                                   io_axi_dmem_rlast,\n    input   logic [3:0]                             io_axi_dmem_ruser,\n    input   logic                                   io_axi_dmem_rvalid,\n    output  logic                                   io_axi_dmem_rready\n);\n\n//-------------------------------------------------------------------------------\n// Local parameters\n//-------------------------------------------------------------------------------\nlocalparam int unsigned SCR1_CLUSTER_TOP_RST_SYNC_STAGES_NUM            = 2;\n\n//-------------------------------------------------------------------------------\n// Local signal declaration\n//-------------------------------------------------------------------------------\n// Reset logic\nlogic                                               pwrup_rst_n_sync;\nlogic                                               rst_n_sync;\nlogic                                               cpu_rst_n_sync;\nlogic                                               core_rst_n_local;\nlogic                                               axi_rst_n;\n`ifdef SCR1_DBG_EN\nlogic                                               tapc_trst_n;\n`endif // SCR1_DBG_EN\n\n// Instruction memory interface from core to router\nlogic                                               core_imem_req_ack;\nlogic                                               core_imem_req;\ntype_scr1_mem_cmd_e                                 core_imem_cmd;\nlogic [`SCR1_IMEM_AWIDTH-1:0]                       core_imem_addr;\nlogic [`SCR1_IMEM_DWIDTH-1:0]                       core_imem_rdata;\ntype_scr1_mem_resp_e                                core_imem_resp;\n\n// Data memory interface from core to router\nlogic                                               core_dmem_req_ack;\nlogic                                               core_dmem_req;\ntype_scr1_mem_cmd_e                                 core_dmem_cmd;\ntype_scr1_mem_width_e                               core_dmem_width;\nlogic [`SCR1_DMEM_AWIDTH-1:0]                       core_dmem_addr;\nlogic [`SCR1_DMEM_DWIDTH-1:0]                       core_dmem_wdata;\nlogic [`SCR1_DMEM_DWIDTH-1:0]                       core_dmem_rdata;\ntype_scr1_mem_resp_e                                core_dmem_resp;\n\n// Instruction memory interface from router to AXI bridge\nlogic                                               axi_imem_req_ack;\nlogic                                               axi_imem_req;\ntype_scr1_mem_cmd_e                                 axi_imem_cmd;\nlogic [`SCR1_IMEM_AWIDTH-1:0]                       axi_imem_addr;\nlogic [`SCR1_IMEM_DWIDTH-1:0]                       axi_imem_rdata;\ntype_scr1_mem_resp_e                                axi_imem_resp;\n\n// Data memory interface from router to AXI bridge\nlogic                                               axi_dmem_req_ack;\nlogic                                               axi_dmem_req;\ntype_scr1_mem_cmd_e                                 axi_dmem_cmd;\ntype_scr1_mem_width_e                               axi_dmem_width;\nlogic [`SCR1_DMEM_AWIDTH-1:0]                       axi_dmem_addr;\nlogic [`SCR1_DMEM_DWIDTH-1:0]                       axi_dmem_wdata;\nlogic [`SCR1_DMEM_DWIDTH-1:0]                       axi_dmem_rdata;\ntype_scr1_mem_resp_e                                axi_dmem_resp;\n\n`ifdef SCR1_TCM_EN\n// Instruction memory interface from router to TCM\nlogic                                               tcm_imem_req_ack;\nlogic                                               tcm_imem_req;\ntype_scr1_mem_cmd_e                                 tcm_imem_cmd;\nlogic [`SCR1_IMEM_AWIDTH-1:0]                       tcm_imem_addr;\nlogic [`SCR1_IMEM_DWIDTH-1:0]                       tcm_imem_rdata;\ntype_scr1_mem_resp_e                                tcm_imem_resp;\n\n// Data memory interface from router to TCM\nlogic                                               tcm_dmem_req_ack;\nlogic                                               tcm_dmem_req;\ntype_scr1_mem_cmd_e                                 tcm_dmem_cmd;\ntype_scr1_mem_width_e                               tcm_dmem_width;\nlogic [`SCR1_DMEM_AWIDTH-1:0]                       tcm_dmem_addr;\nlogic [`SCR1_DMEM_DWIDTH-1:0]                       tcm_dmem_wdata;\nlogic [`SCR1_DMEM_DWIDTH-1:0]                       tcm_dmem_rdata;\ntype_scr1_mem_resp_e                                tcm_dmem_resp;\n`endif // SCR1_TCM_EN\n\n// Data memory interface from router to memory-mapped timer\nlogic                                               timer_dmem_req_ack;\nlogic                                               timer_dmem_req;\ntype_scr1_mem_cmd_e                                 timer_dmem_cmd;\ntype_scr1_mem_width_e                               timer_dmem_width;\nlogic [`SCR1_DMEM_AWIDTH-1:0]                       timer_dmem_addr;\nlogic [`SCR1_DMEM_DWIDTH-1:0]                       timer_dmem_wdata;\nlogic [`SCR1_DMEM_DWIDTH-1:0]                       timer_dmem_rdata;\ntype_scr1_mem_resp_e                                timer_dmem_resp;\n\n// Misc\nlogic                                               timer_irq;\nlogic [63:0]                                        timer_val;\nlogic                                               axi_reinit;\nlogic                                               axi_imem_idle;\nlogic                                               axi_dmem_idle;\n\n//-------------------------------------------------------------------------------\n// Reset logic\n//-------------------------------------------------------------------------------\n// Power-Up Reset synchronizer\nscr1_reset_sync_cell #(\n    .STAGES_AMOUNT       (SCR1_CLUSTER_TOP_RST_SYNC_STAGES_NUM)\n) i_pwrup_rstn_reset_sync (\n    .rst_n          (pwrup_rst_n     ),\n    .clk            (clk             ),\n    .test_rst_n     (test_rst_n      ),\n    .test_mode      (test_mode       ),\n    .rst_n_in       (1'b1            ),\n    .rst_n_out      (pwrup_rst_n_sync)\n);\n\n// Regular Reset synchronizer\nscr1_reset_sync_cell #(\n    .STAGES_AMOUNT       (SCR1_CLUSTER_TOP_RST_SYNC_STAGES_NUM)\n) i_rstn_reset_sync (\n    .rst_n          (pwrup_rst_n     ),\n    .clk            (clk             ),\n    .test_rst_n     (test_rst_n      ),\n    .test_mode      (test_mode       ),\n    .rst_n_in       (rst_n           ),\n    .rst_n_out      (rst_n_sync      )\n);\n\n// CPU Reset synchronizer\nscr1_reset_sync_cell #(\n    .STAGES_AMOUNT       (SCR1_CLUSTER_TOP_RST_SYNC_STAGES_NUM)\n) i_cpu_rstn_reset_sync (\n    .rst_n          (pwrup_rst_n     ),\n    .clk            (clk             ),\n    .test_rst_n     (test_rst_n      ),\n    .test_mode      (test_mode       ),\n    .rst_n_in       (cpu_rst_n       ),\n    .rst_n_out      (cpu_rst_n_sync  )\n);\n\n`ifdef SCR1_DBG_EN\n// TAPC Reset\nscr1_reset_and2_cell i_tapc_rstn_and2_cell (\n    .rst_n_in       ({trst_n, pwrup_rst_n}),\n    .test_rst_n     (test_rst_n      ),\n    .test_mode      (test_mode       ),\n    .rst_n_out      (tapc_trst_n     )\n);\n`endif // SCR1_DBG_EN\n\n`ifdef SCR1_DBG_EN\nassign axi_rst_n = sys_rst_n_o;\n`else // SCR1_DBG_EN\nassign axi_rst_n = rst_n_sync;\n`endif // SCR1_DBG_EN\n\n//-------------------------------------------------------------------------------\n// SCR1 core instance\n//-------------------------------------------------------------------------------\nscr1_core_top i_core_top (\n    // Common\n    .pwrup_rst_n                (pwrup_rst_n_sync ),\n    .rst_n                      (rst_n_sync       ),\n    .cpu_rst_n                  (cpu_rst_n_sync   ),\n    .test_mode                  (test_mode        ),\n    .test_rst_n                 (test_rst_n       ),\n    .clk                        (clk              ),\n    .core_rst_n_o               (core_rst_n_local ),\n    .core_rdc_qlfy_o            (                 ),\n`ifdef SCR1_DBG_EN\n    .sys_rst_n_o                (sys_rst_n_o      ),\n    .sys_rdc_qlfy_o             (sys_rdc_qlfy_o   ),\n`endif // SCR1_DBG_EN\n\n    // Fuses\n    .core_fuse_mhartid_i        (fuse_mhartid     ),\n`ifdef SCR1_DBG_EN\n    .tapc_fuse_idcode_i         (fuse_idcode      ),\n`endif // SCR1_DBG_EN\n\n    // IRQ\n`ifdef SCR1_IPIC_EN\n    .core_irq_lines_i           (irq_lines        ),\n`else // SCR1_IPIC_EN\n    .core_irq_ext_i             (ext_irq          ),\n`endif // SCR1_IPIC_EN\n    .core_irq_soft_i            (soft_irq         ),\n    .core_irq_mtimer_i          (timer_irq        ),\n\n    // Memory-mapped external timer\n    .core_mtimer_val_i          (timer_val        ),\n\n`ifdef SCR1_DBG_EN\n    // Debug interface\n    .tapc_trst_n                (tapc_trst_n      ),\n    .tapc_tck                   (tck              ),\n    .tapc_tms                   (tms              ),\n    .tapc_tdi                   (tdi              ),\n    .tapc_tdo                   (tdo              ),\n    .tapc_tdo_en                (tdo_en           ),\n`endif // SCR1_DBG_EN\n\n    // Instruction memory interface\n    .imem2core_req_ack_i        (core_imem_req_ack),\n    .core2imem_req_o            (core_imem_req    ),\n    .core2imem_cmd_o            (core_imem_cmd    ),\n    .core2imem_addr_o           (core_imem_addr   ),\n    .imem2core_rdata_i          (core_imem_rdata  ),\n    .imem2core_resp_i           (core_imem_resp   ),\n\n    // Data memory interface\n    .dmem2core_req_ack_i        (core_dmem_req_ack),\n    .core2dmem_req_o            (core_dmem_req    ),\n    .core2dmem_cmd_o            (core_dmem_cmd    ),\n    .core2dmem_width_o          (core_dmem_width  ),\n    .core2dmem_addr_o           (core_dmem_addr   ),\n    .core2dmem_wdata_o          (core_dmem_wdata  ),\n    .dmem2core_rdata_i          (core_dmem_rdata  ),\n    .dmem2core_resp_i           (core_dmem_resp   )\n);\n\n\n`ifdef SCR1_TCM_EN\n//-------------------------------------------------------------------------------\n// TCM instance\n//-------------------------------------------------------------------------------\nscr1_tcm #(\n    .SCR1_TCM_SIZE  (`SCR1_DMEM_AWIDTH'(~SCR1_TCM_ADDR_MASK + 1'b1))\n) i_tcm (\n    .clk            (clk             ),\n    .rst_n          (core_rst_n_local),\n\n    // Instruction interface to TCM\n    .imem_req_ack   (tcm_imem_req_ack),\n    .imem_req       (tcm_imem_req    ),\n    .imem_addr      (tcm_imem_addr   ),\n    .imem_rdata     (tcm_imem_rdata  ),\n    .imem_resp      (tcm_imem_resp   ),\n\n    // Data interface to TCM\n    .dmem_req_ack   (tcm_dmem_req_ack),\n    .dmem_req       (tcm_dmem_req    ),\n    .dmem_cmd       (tcm_dmem_cmd    ),\n    .dmem_width     (tcm_dmem_width  ),\n    .dmem_addr      (tcm_dmem_addr   ),\n    .dmem_wdata     (tcm_dmem_wdata  ),\n    .dmem_rdata     (tcm_dmem_rdata  ),\n    .dmem_resp      (tcm_dmem_resp   )\n);\n`endif // SCR1_TCM_EN\n\n\n//-------------------------------------------------------------------------------\n// Memory-mapped timer instance\n//-------------------------------------------------------------------------------\nscr1_timer i_timer (\n    // Common\n    .rst_n          (core_rst_n_local  ),\n    .clk            (clk               ),\n    .rtc_clk        (rtc_clk           ),\n\n    // Memory interface\n    .dmem_req       (timer_dmem_req    ),\n    .dmem_cmd       (timer_dmem_cmd    ),\n    .dmem_width     (timer_dmem_width  ),\n    .dmem_addr      (timer_dmem_addr   ),\n    .dmem_wdata     (timer_dmem_wdata  ),\n    .dmem_req_ack   (timer_dmem_re"}
{"text": "q_ack),\n    .dmem_rdata     (timer_dmem_rdata  ),\n    .dmem_resp      (timer_dmem_resp   ),\n\n    // Timer interface\n    .timer_val      (timer_val         ),\n    .timer_irq      (timer_irq         )\n);\n\n\n`ifdef SCR1_IMEM_ROUTER_EN\n//-------------------------------------------------------------------------------\n// Instruction memory router\n//-------------------------------------------------------------------------------\nscr1_imem_router #(\n    .SCR1_ADDR_MASK     (SCR1_TCM_ADDR_MASK),\n    .SCR1_ADDR_PATTERN  (SCR1_TCM_ADDR_PATTERN)\n) i_imem_router (\n    .rst_n          (core_rst_n_local ),\n    .clk            (clk              ),\n\n    // Interface to core\n    .imem_req_ack   (core_imem_req_ack),\n    .imem_req       (core_imem_req    ),\n    .imem_cmd       (core_imem_cmd    ),\n    .imem_addr      (core_imem_addr   ),\n    .imem_rdata     (core_imem_rdata  ),\n    .imem_resp      (core_imem_resp   ),\n\n    // Interface to AXI bridge\n    .port0_req_ack  (axi_imem_req_ack ),\n    .port0_req      (axi_imem_req     ),\n    .port0_cmd      (axi_imem_cmd     ),\n    .port0_addr     (axi_imem_addr    ),\n    .port0_rdata    (axi_imem_rdata   ),\n    .port0_resp     (axi_imem_resp    ),\n\n    // Interface to TCM\n    .port1_req_ack  (tcm_imem_req_ack ),\n    .port1_req      (tcm_imem_req     ),\n    .port1_cmd      (tcm_imem_cmd     ),\n    .port1_addr     (tcm_imem_addr    ),\n    .port1_rdata    (tcm_imem_rdata   ),\n    .port1_resp     (tcm_imem_resp    )\n);\n\n`else // SCR1_IMEM_ROUTER_EN\n\nassign axi_imem_req         = core_imem_req;\nassign axi_imem_cmd         = core_imem_cmd;\nassign axi_imem_addr        = core_imem_addr;\nassign core_imem_req_ack    = axi_imem_req_ack;\nassign core_imem_resp       = axi_imem_resp;\nassign core_imem_rdata      = axi_imem_rdata;\n\n`endif // SCR1_IMEM_ROUTER_EN\n\n\n//-------------------------------------------------------------------------------\n// Data memory router\n//-------------------------------------------------------------------------------\nscr1_dmem_router #(\n\n`ifdef SCR1_TCM_EN\n    .SCR1_PORT1_ADDR_MASK       (SCR1_TCM_ADDR_MASK),\n    .SCR1_PORT1_ADDR_PATTERN    (SCR1_TCM_ADDR_PATTERN),\n`else // SCR1_TCM_EN\n    .SCR1_PORT1_ADDR_MASK       (32'h00000000),\n    .SCR1_PORT1_ADDR_PATTERN    (32'hFFFFFFFF),\n`endif // SCR1_TCM_EN\n\n    .SCR1_PORT2_ADDR_MASK       (SCR1_TIMER_ADDR_MASK),\n    .SCR1_PORT2_ADDR_PATTERN    (SCR1_TIMER_ADDR_PATTERN)\n\n) i_dmem_router (\n    .rst_n          (core_rst_n_local    ),\n    .clk            (clk                 ),\n\n    // Interface to core\n    .dmem_req_ack   (core_dmem_req_ack   ),\n    .dmem_req       (core_dmem_req       ),\n    .dmem_cmd       (core_dmem_cmd       ),\n    .dmem_width     (core_dmem_width     ),\n    .dmem_addr      (core_dmem_addr      ),\n    .dmem_wdata     (core_dmem_wdata     ),\n    .dmem_rdata     (core_dmem_rdata     ),\n    .dmem_resp      (core_dmem_resp      ),\n\n`ifdef SCR1_TCM_EN\n    // Interface to TCM\n    .port1_req_ack  (tcm_dmem_req_ack    ),\n    .port1_req      (tcm_dmem_req        ),\n    .port1_cmd      (tcm_dmem_cmd        ),\n    .port1_width    (tcm_dmem_width      ),\n    .port1_addr     (tcm_dmem_addr       ),\n    .port1_wdata    (tcm_dmem_wdata      ),\n    .port1_rdata    (tcm_dmem_rdata      ),\n    .port1_resp     (tcm_dmem_resp       ),\n`else // SCR1_TCM_EN\n    .port1_req_ack  (1'b0                ),\n    .port1_req      (                    ),\n    .port1_cmd      (                    ),\n    .port1_width    (                    ),\n    .port1_addr     (                    ),\n    .port1_wdata    (                    ),\n    .port1_rdata    ('0                  ),\n    .port1_resp     (SCR1_MEM_RESP_RDY_ER),\n`endif // SCR1_TCM_EN\n\n    // Interface to memory-mapped timer\n    .port2_req_ack  (timer_dmem_req_ack  ),\n    .port2_req      (timer_dmem_req      ),\n    .port2_cmd      (timer_dmem_cmd      ),\n    .port2_width    (timer_dmem_width    ),\n    .port2_addr     (timer_dmem_addr     ),\n    .port2_wdata    (timer_dmem_wdata    ),\n    .port2_rdata    (timer_dmem_rdata    ),\n    .port2_resp     (timer_dmem_resp     ),\n\n    // Interface to AXI bridge\n    .port0_req_ack  (axi_dmem_req_ack    ),\n    .port0_req      (axi_dmem_req        ),\n    .port0_cmd      (axi_dmem_cmd        ),\n    .port0_width    (axi_dmem_width      ),\n    .port0_addr     (axi_dmem_addr       ),\n    .port0_wdata    (axi_dmem_wdata      ),\n    .port0_rdata    (axi_dmem_rdata      ),\n    .port0_resp     (axi_dmem_resp       )\n);\n\n\n//-------------------------------------------------------------------------------\n// Instruction memory AXI bridge\n//-------------------------------------------------------------------------------\nscr1_mem_axi #(\n`ifdef SCR1_IMEM_AXI_REQ_BP\n    .SCR1_AXI_REQ_BP    (1),\n`else // SCR1_IMEM_AXI_REQ_BP\n    .SCR1_AXI_REQ_BP    (0),\n`endif // SCR1_IMEM_AXI_REQ_BP\n`ifdef SCR1_IMEM_AXI_RESP_BP\n    .SCR1_AXI_RESP_BP   (1)\n`else // SCR1_IMEM_AXI_RESP_BP\n    .SCR1_AXI_RESP_BP   (0)\n`endif // SCR1_IMEM_AXI_RESP_BP\n) i_imem_axi (\n    .clk            (clk                    ),\n    .rst_n          (axi_rst_n              ),\n    .axi_reinit     (axi_reinit             ),\n\n    // Interface to core\n    .core_idle      (axi_imem_idle          ),\n    .core_req_ack   (axi_imem_req_ack       ),\n    .core_req       (axi_imem_req           ),\n    .core_cmd       (axi_imem_cmd           ),\n    .core_width     (SCR1_MEM_WIDTH_WORD    ),\n    .core_addr      (axi_imem_addr          ),\n    .core_wdata     ('0                     ),\n    .core_rdata     (axi_imem_rdata         ),\n    .core_resp      (axi_imem_resp          ),\n\n    // AXI I/O\n    .awid           (io_axi_imem_awid       ),\n    .awaddr         (io_axi_imem_awaddr     ),\n    .awlen          (io_axi_imem_awlen      ),\n    .awsize         (io_axi_imem_awsize     ),\n    .awburst        (io_axi_imem_awburst    ),\n    .awlock         (io_axi_imem_awlock     ),\n    .awcache        (io_axi_imem_awcache    ),\n    .awprot         (io_axi_imem_awprot     ),\n    .awregion       (io_axi_imem_awregion   ),\n    .awuser         (io_axi_imem_awuser     ),\n    .awqos          (io_axi_imem_awqos      ),\n    .awvalid        (io_axi_imem_awvalid    ),\n    .awready        (io_axi_imem_awready    ),\n    .wdata          (io_axi_imem_wdata      ),\n    .wstrb          (io_axi_imem_wstrb      ),\n    .wlast          (io_axi_imem_wlast      ),\n    .wuser          (io_axi_imem_wuser      ),\n    .wvalid         (io_axi_imem_wvalid     ),\n    .wready         (io_axi_imem_wready     ),\n    .bid            (io_axi_imem_bid        ),\n    .bresp          (io_axi_imem_bresp      ),\n    .bvalid         (io_axi_imem_bvalid     ),\n    .buser          (io_axi_imem_buser      ),\n    .bready         (io_axi_imem_bready     ),\n    .arid           (io_axi_imem_arid       ),\n    .araddr         (io_axi_imem_araddr     ),\n    .arlen          (io_axi_imem_arlen      ),\n    .arsize         (io_axi_imem_arsize     ),\n    .arburst        (io_axi_imem_arburst    ),\n    .arlock         (io_axi_imem_arlock     ),\n    .arcache        (io_axi_imem_arcache    ),\n    .arprot         (io_axi_imem_arprot     ),\n    .arregion       (io_axi_imem_arregion   ),\n    .aruser         (io_axi_imem_aruser     ),\n    .arqos          (io_axi_imem_arqos      ),\n    .arvalid        (io_axi_imem_arvalid    ),\n    .arready        (io_axi_imem_arready    ),\n    .rid            (io_axi_imem_rid        ),\n    .rdata          (io_axi_imem_rdata      ),\n    .rresp          (io_axi_imem_rresp      ),\n    .rlast          (io_axi_imem_rlast      ),\n    .ruser          (io_axi_imem_ruser      ),\n    .rvalid         (io_axi_imem_rvalid     ),\n    .rready         (io_axi_imem_rready     )\n);\n\n\n//-------------------------------------------------------------------------------\n// Data memory AXI bridge\n//-------------------------------------------------------------------------------\nscr1_mem_axi #(\n`ifdef SCR1_DMEM_AXI_REQ_BP\n    .SCR1_AXI_REQ_BP    (1),\n`else // SCR1_DMEM_AXI_REQ_BP\n    .SCR1_AXI_REQ_BP    (0),\n`endif // SCR1_DMEM_AXI_REQ_BP\n`ifdef SCR1_DMEM_AXI_RESP_BP\n    .SCR1_AXI_RESP_BP   (1)\n`else // SCR1_DMEM_AXI_RESP_BP\n    .SCR1_AXI_RESP_BP   (0)\n`endif // SCR1_DMEM_AXI_RESP_BP\n) i_dmem_axi (\n    .clk            (clk                    ),\n    .rst_n          (axi_rst_n              ),\n    .axi_reinit     (axi_reinit             ),\n\n    // Interface to core\n    .core_idle      (axi_dmem_idle          ),\n    .core_req_ack   (axi_dmem_req_ack       ),\n    .core_req       (axi_dmem_req           ),\n    .core_cmd       (axi_dmem_cmd           ),\n    .core_width     (axi_dmem_width         ),\n    .core_addr      (axi_dmem_addr          ),\n    .core_wdata     (axi_dmem_wdata         ),\n    .core_rdata     (axi_dmem_rdata         ),\n    .core_resp      (axi_dmem_resp          ),\n\n    // AXI I/O\n    .awid           (io_axi_dmem_awid       ),\n    .awaddr         (io_axi_dmem_awaddr     ),\n    .awlen          (io_axi_dmem_awlen      ),\n    .awsize         (io_axi_dmem_awsize     ),\n    .awburst        (io_axi_dmem_awburst    ),\n    .awlock         (io_axi_dmem_awlock     ),\n    .awcache        (io_axi_dmem_awcache    ),\n    .awprot         (io_axi_dmem_awprot     ),\n    .awregion       (io_axi_dmem_awregion   ),\n    .awuser         (io_axi_dmem_awuser     ),\n    .awqos          (io_axi_dmem_awqos      ),\n    .awvalid        (io_axi_dmem_awvalid    ),\n    .awready        (io_axi_dmem_awready    ),\n    .wdata          (io_axi_dmem_wdata      ),\n    .wstrb          (io_axi_dmem_wstrb      ),\n    .wlast          (io_axi_dmem_wlast      ),\n    .wuser          (io_axi_dmem_wuser      ),\n    .wvalid         (io_axi_dmem_wvalid     ),\n    .wready         (io_axi_dmem_wready     ),\n    .bid            (io_axi_dmem_bid        ),\n    .bresp          (io_axi_dmem_bresp      ),\n    .bvalid         (io_axi_dmem_bvalid     ),\n    .buser          (io_axi_dmem_buser      ),\n    .bready         (io_axi_dmem_bready     ),\n    .arid           (io_axi_dmem_arid       ),\n    .araddr         (io_axi_dmem_araddr     ),\n    .arlen          (io_axi_dmem_arlen      ),\n    .arsize         (io_axi_dmem_arsize     ),\n    .arburst        (io_axi_dmem_arburst    ),\n    .arlock         (io_axi_dmem_arlock     ),\n    .arcache        (io_axi_dmem_arcache    ),\n    .arprot         (io_axi_dmem_arprot     ),\n    .arregion       (io_axi_dmem_arregion   ),\n    .aruser         (io_axi_dmem_aruser     ),\n    .arqos          (io_axi_dmem_arqos      ),\n    .arvalid        (io_axi_dmem_arvalid    ),\n    .arready        (io_axi_dmem_arready    ),\n    .rid            (io_axi_dmem_rid        ),\n    .rdata          (io_axi_dmem_rdata      ),\n    .rresp          (io_axi_dmem_rresp      ),\n    .rlast          (io_axi_dmem_rlast      ),\n    .ruser          (io_axi_dmem_ruser      ),\n    .rvalid         (io_axi_dmem_rvalid     ),\n    .rready         (io_axi_dmem_rready     )\n);\n\n//-------------------------------------------------------------------------------\n// AXI reinit logic\n//-------------------------------------------------------------------------------\nalways_ff @(negedge core_rst_n_local, posedge clk) begin\n    if (~core_rst_n_local)                      axi_reinit <= 1'b1;\n    else if (axi_imem_idle & axi_dmem_idle)     axi_reinit <= 1'b0;\nend\n\nendmodule : scr1_top_axi\n"}
{"text": "/// Copyright by Syntacore LLC \u00a9 2016-2020. See LICENSE for details\n/// @file       <scr1_top_tb_ahb.sv>\n/// @brief      SCR1 top testbench AHB\n///\n\n`include \"scr1_arch_description.svh\"\n`include \"scr1_ahb.svh\"\n`ifdef SCR1_IPIC_EN\n`include \"scr1_ipic.svh\"\n`endif // SCR1_IPIC_EN\n\nmodule scr1_top_tb_ahb (\n`ifdef VERILATOR\n    input logic clk\n`endif // VERILATOR\n);\n\n//-------------------------------------------------------------------------------\n// Local parameters\n//-------------------------------------------------------------------------------\nlocalparam                          SCR1_MEM_SIZE       = 1024*1024;\nlocalparam                          TIMEOUT             = 'd2000_000;//20ms;\nlocalparam                          ARCH                = 'h1;\nlocalparam                          COMPLIANCE          = 'h2;\nlocalparam                          ADDR_START          = 'h200;\nlocalparam                          ADDR_TRAP_VECTOR    = 'h240;\nlocalparam                          ADDR_TRAP_DEFAULT   = 'h1C0;\n\n//-------------------------------------------------------------------------------\n// Local signal declaration\n//-------------------------------------------------------------------------------\nlogic                                   rst_n;\n`ifndef VERILATOR\nlogic                                   clk         = 1'b0;\n`endif // VERILATOR\nlogic                                   rtc_clk     = 1'b0;\n`ifdef SCR1_IPIC_EN\nlogic [SCR1_IRQ_LINES_NUM-1:0]          irq_lines;\n`else // SCR1_IPIC_EN\nlogic                                   ext_irq;\n`endif // SCR1_IPIC_EN\nlogic                                   soft_irq;\nlogic [31:0]                            fuse_mhartid;\ninteger                                 imem_req_ack_stall;\ninteger                                 dmem_req_ack_stall;\n\nlogic                                   test_mode   = 1'b0;\n`ifdef SCR1_DBG_EN\nlogic                                   trst_n;\nlogic                                   tck;\nlogic                                   tms;\nlogic                                   tdi;\nlogic                                   tdo;\nlogic                                   tdo_en;\n`endif // SCR1_DBG_EN\n\n// Instruction Memory Interface\nlogic   [3:0]                           imem_hprot;\nlogic   [2:0]                           imem_hburst;\nlogic   [2:0]                           imem_hsize;\nlogic   [1:0]                           imem_htrans;\nlogic   [SCR1_AHB_WIDTH-1:0]            imem_haddr;\nlogic                                   imem_hready;\nlogic   [SCR1_AHB_WIDTH-1:0]            imem_hrdata;\nlogic                                   imem_hresp;\n\n// Memory Interface\nlogic   [3:0]                           dmem_hprot;\nlogic   [2:0]                           dmem_hburst;\nlogic   [2:0]                           dmem_hsize;\nlogic   [1:0]                           dmem_htrans;\nlogic   [SCR1_AHB_WIDTH-1:0]            dmem_haddr;\nlogic                                   dmem_hwrite;\nlogic   [SCR1_AHB_WIDTH-1:0]            dmem_hwdata;\nlogic                                   dmem_hready;\nlogic   [SCR1_AHB_WIDTH-1:0]            dmem_hrdata;\nlogic                                   dmem_hresp;\n\n// Wathdogs\nint unsigned                            watchdogs_cnt;\n\nint unsigned                            f_results;\nint unsigned                            f_info;\n\nstring                                  s_results;\nstring                                  s_info;\n`ifdef SIGNATURE_OUT\nstring                                  s_testname;\nbit                                     b_single_run_flag;\n`endif  //  SIGNATURE_OUT\n`ifdef VERILATOR\nlogic [255:0]                           test_file;\n`else // VERILATOR\nstring                                  test_file;\n`endif // VERILATOR\n\nbit                                     test_running;\nint unsigned                            tests_passed;\nint unsigned                            tests_total;\n\nbit [1:0]                               rst_cnt;\nbit                                     rst_init;\n\n\n`ifdef VERILATOR\nfunction int identify_test (logic [255:0] testname);\n    bit res;\n    logic [79:0] pattern_compliance;\n    logic [22:0] pattern_arch;\nbegin\n    pattern_compliance = 80'h636f6d706c69616e6365; // compliance\n    pattern_arch       = 'h61726368;             // arch\n    res = 0;\n    for (int i = 0; i<= 176; i++) begin\n        if(testname[i+:80] == pattern_compliance) begin\n            return COMPLIANCE;\n        end\n    end\n    for (int i = 0; i<= 233; i++) begin\n        if(testname[i+:23] == pattern_arch) begin\n            return ARCH;\n        end\n    end\n    `ifdef SIGNATURE_OUT\n        return ~res;\n    `else\n        return res;\n    `endif\nend\nendfunction : identify_test\n\nfunction logic [255:0] get_filename (logic [255:0] testname);\nlogic [255:0] res;\nint i, j;\nbegin\n    testname[7:0] = 8'h66;\n    testname[15:8] = 8'h6C;\n    testname[23:16] = 8'h65;\n\n    for (i = 0; i <= 248; i += 8) begin\n        if (testname[i+:8] == 0) begin\n            break;\n        end\n    end\n    i -= 8;\n    for (j = 255; i >= 0;i -= 8) begin\n        res[j-:8] = testname[i+:8];\n        j -= 8;\n    end\n    for (; j >= 0;j -= 8) begin\n        res[j-:8] = 0;\n    end\n\n    return res;\nend\nendfunction : get_filename\n\nfunction logic [255:0] get_ref_filename (logic [255:0] testname);\nlogic [255:0] res;\nint i, j;\nlogic [79:0] pattern_compliance;\nlogic [22:0] pattern_arch;\nbegin\n    pattern_compliance = 80'h636f6d706c69616e6365; // compliance\n    pattern_arch       = 'h61726368;             // arch\n\n    for(int i = 0; i <= 176; i++) begin\n        if(testname[i+:80] == pattern_compliance) begin\n            testname[(i-8)+:88] = 0;\n            break;\n        end\n    end\n\n    for(int i = 0; i <= 233; i++) begin\n        if(testname[i+:23] == pattern_arch) begin\n            testname[(i-8)+:31] = 0;\n            break;\n        end\n    end\n\n    for(i = 32; i <= 248; i += 8) begin\n        if(testname[i+:8] == 0) break;\n    end\n    i -= 8;\n    for(j = 255; i > 24; i -= 8) begin\n        res[j-:8] = testname[i+:8];\n        j -= 8;\n    end\n    for(; j >=0;j -= 8) begin\n        res[j-:8] = 0;\n    end\n\n    return res;\nend\nendfunction : get_ref_filename\n\nfunction logic [2047:0] remove_trailing_whitespaces (logic [2047:0] str);\nint i;\nbegin\n    for (i = 0; i <= 2040; i += 8) begin\n        if (str[i+:8] != 8'h20) begin\n            break;\n        end\n    end\n    str = str >> i;\n    return str;\nend\nendfunction: remove_trailing_whitespaces\n\n`else // VERILATOR\nfunction int identify_test (string testname);\n    begin\n        if (testname.substr(0, 3) == \"arch\") begin\n            return ARCH;\n        end else if (testname.substr(0, 9) == \"compliance\") begin\n            return COMPLIANCE;\n        end else begin\n            return 0;\n        end\n    end\nendfunction : identify_test\n\nfunction string get_filename (string testname);\n        int length;\n        begin\n            length = testname.len();\n            testname[length-1] = \"f\";\n            testname[length-2] = \"l\";\n            testname[length-3] = \"e\";\n\n            return testname;\n        end\nendfunction : get_filename\n\nfunction string get_ref_filename (string testname);\n    begin\n        if (identify_test(test_file) == COMPLIANCE) begin\n            return testname.substr(11, testname.len() - 5);\n        end else if (identify_test(test_file) == ARCH) begin\n            return testname.substr(5, testname.len() - 5);\n        end\n    end\nendfunction : get_ref_filename\n\n`endif // VERILATOR\n\n`ifndef VERILATOR\nalways #5   clk     = ~clk;         // 100 MHz\nalways #500 rtc_clk = ~rtc_clk;     // 1 MHz\n`endif // VERILATOR\n\n// Reset logic\nassign rst_n = &rst_cnt;\n\nalways_ff @(posedge clk) begin\n    if (rst_init)       rst_cnt <= '0;\n    else if (~&rst_cnt) rst_cnt <= rst_cnt + 1'b1;\nend\n\n\n`ifdef SCR1_DBG_EN\ninitial begin\n    trst_n  = 1'b0;\n    tck     = 1'b0;\n    tdi     = 1'b0;\n    #900ns trst_n   = 1'b1;\n    #500ns tms      = 1'b1;\n    #800ns tms      = 1'b0;\n    #500ns trst_n   = 1'b0;\n    #100ns tms      = 1'b1;\nend\n`endif // SCR1_DBG_EN\n\n\n\n//-------------------------------------------------------------------------------\n// Run tests\n//-------------------------------------------------------------------------------\n\n`include \"scr1_top_tb_runtests.sv\"\n//-------------------------------------------------------------------------------\n// Core instance\n//-------------------------------------------------------------------------------\nscr1_top_ahb i_top (\n    // Reset\n    .pwrup_rst_n            (rst_n                  ),\n    .rst_n                  (rst_n                  ),\n    .cpu_rst_n              (rst_n                  ),\n`ifdef SCR1_DBG_EN\n    .sys_rst_n_o            (                       ),\n    .sys_rdc_qlfy_o         (                       ),\n`endif // SCR1_DBG_EN\n\n    // Clock\n    .clk                    (clk                    ),\n    .rtc_clk                (rtc_clk                ),\n\n    // Fuses\n    .fuse_mhartid           (fuse_mhartid           ),\n`ifdef SCR1_DBG_EN\n    .fuse_idcode            (`SCR1_TAP_IDCODE       ),\n`endif // SCR1_DBG_EN\n\n    // IRQ\n`ifdef SCR1_IPIC_EN\n    .irq_lines              (irq_lines              ),\n`else // SCR1_IPIC_EN\n    .ext_irq                (ext_irq                ),\n`endif // SCR1_IPIC_EN\n    .soft_irq               (soft_irq               ),\n\n    // DFT\n    .test_mode              (1'b0                   ),\n    .test_rst_n             (1'b1                   ),\n\n`ifdef SCR1_DBG_EN\n    // JTAG\n    .trst_n                 (trst_n                 ),\n    .tck                    (tck                    ),\n    .tms                    (tms                    ),\n    .tdi                    (tdi                    ),\n    .tdo                    (tdo                    ),\n    .tdo_en                 (tdo_en                 ),\n`endif // SCR1_DBG_EN\n\n    // Instruction Memory Interface\n    .imem_hprot         (imem_hprot     ),\n    .imem_hburst        (imem_hburst    ),\n    .imem_hsize         (imem_hsize     ),\n    .imem_htrans        (imem_htrans    ),\n    .imem_hmastlock     (),\n    .imem_haddr         (imem_haddr     ),\n    .imem_hready        (imem_hready    ),\n    .imem_hrdata        (imem_hrdata    ),\n    .imem_hresp         (imem_hresp     ),\n\n    // Data Memory Interface\n    .dmem_hprot         (dmem_hprot     ),\n    .dmem_hburst        (dmem_hburst    ),\n    .dmem_hsize         (dmem_hsize     ),\n    .dmem_htrans        (dmem_htrans    ),\n    .dmem_hmastlock     (),\n    .dmem_haddr         (dmem_haddr     ),\n    .dmem_hwrite        (dmem_hwrite    ),\n    .dmem_hwdata        (dmem_hwdata    ),\n    .dmem_hready        (dmem_hready    ),\n    .dmem_hrdata        (dmem_hrdata    ),\n    .dmem_hresp         (dmem_hresp     )\n);\n\n//-------------------------------------------------------------------------------\n// Memory instance\n//-------------------------------------------------------------------------------\nscr1_memory_tb_ahb #(\n    .SCR1_MEM_POWER_SIZE    ($clog2(SCR1_MEM_SIZE))\n) i_memory_tb (\n    // Control\n    .rst_n                  (rst_n),\n    .clk                    (clk),\n`ifdef SCR1_IPIC_EN\n    .irq_lines              (irq_lines),\n`else // SCR1_IPIC_EN\n    .ext_irq                (ext_irq),\n`endif // SCR1_IPIC_EN\n    .soft_irq               (soft_irq),\n    .imem_req_ack_stall_in  (imem_req_ack_stall),\n    .dmem_req_ack_stall_in  (dmem_req_ack_stall),\n\n    // Instruction Memory Interface\n    // .imem_hprot             (imem_hprot ),\n    // .imem_hburst            (imem_hburst),\n    .imem_hsize             (imem_hsize ),\n    .imem_htrans            (imem_htrans),\n    .imem_haddr             (imem_haddr ),\n    .imem_hready            (imem_hready),\n    .imem_hrdata            (imem_hrdata),\n    .imem_hresp             (imem_hresp ),\n\n    // Data Memory Interface\n    // .dmem_hprot             (dmem_hprot ),\n    // .dmem_hburst            (dmem_hburst),\n    .dmem_hsize             (dmem_hsize ),\n    .dmem_htrans            (dmem_htrans),\n    .dmem_haddr             (dmem_haddr ),\n    .dmem_hwrite            (dmem_hwrite),\n    .dmem_hwdata            (dmem_hwdata),\n    .dmem_hready            (dmem_hready),\n    .dmem_hrdata            (dmem_hrdata),\n    .dmem_hresp             (dmem_hresp )\n);\n\nendmodule : scr1_top_tb_ahb\n\n"}
{"text": "/// Copyright by Syntacore LLC \u00a9 2016-2020. See LICENSE for details\n/// @file       <scr1_top_tb_axi.sv>\n/// @brief      SCR1 top testbench AXI\n///\n\n`include \"scr1_arch_description.svh\"\n`ifdef SCR1_IPIC_EN\n`include \"scr1_ipic.svh\"\n`endif // SCR1_IPIC_EN\n\nmodule scr1_top_tb_axi (\n`ifdef VERILATOR\n    input logic clk\n`endif // VERILATOR\n);\n\n//------------------------------------------------------------------------------\n// Local parameters\n//------------------------------------------------------------------------------\nlocalparam                          SCR1_MEM_SIZE       = 1024*1024;\nlocalparam                          TIMEOUT             = 'd2000_000;//20ms;\nlocalparam                          ARCH                = 'h1;\nlocalparam                          COMPLIANCE          = 'h2;\nlocalparam                          ADDR_START          = 'h200;\nlocalparam                          ADDR_TRAP_VECTOR    = 'h240;\nlocalparam                          ADDR_TRAP_DEFAULT   = 'h1C0;\n\n//------------------------------------------------------------------------------\n// Local signal declaration\n//------------------------------------------------------------------------------\nlogic                                   rst_n;\n`ifndef VERILATOR\nlogic                                   clk         = 1'b0;\n`endif // VERILATOR\nlogic                                   rtc_clk     = 1'b0;\nlogic   [31:0]                          fuse_mhartid;\ninteger                                 imem_req_ack_stall;\ninteger                                 dmem_req_ack_stall;\n`ifdef SCR1_IPIC_EN\nlogic [SCR1_IRQ_LINES_NUM-1:0]          irq_lines;\n`else // SCR1_IPIC_EN\nlogic                                   ext_irq;\n`endif // SCR1_IPIC_EN\nlogic                                   soft_irq;\n\n`ifdef SCR1_DBG_EN\nlogic                                   trst_n;\nlogic                                   tck;\nlogic                                   tms;\nlogic                                   tdi;\nlogic                                   tdo;\nlogic                                   tdo_en;\n`endif // SCR1_DBG_EN\n\n// Instruction Memory\nlogic [3:0]                             io_axi_imem_awid;\nlogic [31:0]                            io_axi_imem_awaddr;\nlogic [7:0]                             io_axi_imem_awlen;\nlogic [2:0]                             io_axi_imem_awsize;\nlogic [1:0]                             io_axi_imem_awburst;\nlogic                                   io_axi_imem_awlock;\nlogic [3:0]                             io_axi_imem_awcache;\nlogic [2:0]                             io_axi_imem_awprot;\nlogic [3:0]                             io_axi_imem_awregion;\nlogic [3:0]                             io_axi_imem_awuser;\nlogic [3:0]                             io_axi_imem_awqos;\nlogic                                   io_axi_imem_awvalid;\nlogic                                   io_axi_imem_awready;\nlogic [31:0]                            io_axi_imem_wdata;\nlogic [3:0]                             io_axi_imem_wstrb;\nlogic                                   io_axi_imem_wlast;\nlogic [3:0]                             io_axi_imem_wuser;\nlogic                                   io_axi_imem_wvalid;\nlogic                                   io_axi_imem_wready;\nlogic [3:0]                             io_axi_imem_bid;\nlogic [1:0]                             io_axi_imem_bresp;\nlogic                                   io_axi_imem_bvalid;\nlogic [3:0]                             io_axi_imem_buser;\nlogic                                   io_axi_imem_bready;\nlogic [3:0]                             io_axi_imem_arid;\nlogic [31:0]                            io_axi_imem_araddr;\nlogic [7:0]                             io_axi_imem_arlen;\nlogic [2:0]                             io_axi_imem_arsize;\nlogic [1:0]                             io_axi_imem_arburst;\nlogic                                   io_axi_imem_arlock;\nlogic [3:0]                             io_axi_imem_arcache;\nlogic [2:0]                             io_axi_imem_arprot;\nlogic [3:0]                             io_axi_imem_arregion;\nlogic [3:0]                             io_axi_imem_aruser;\nlogic [3:0]                             io_axi_imem_arqos;\nlogic                                   io_axi_imem_arvalid;\nlogic                                   io_axi_imem_arready;\nlogic [3:0]                             io_axi_imem_rid;\nlogic [31:0]                            io_axi_imem_rdata;\nlogic [1:0]                             io_axi_imem_rresp;\nlogic                                   io_axi_imem_rlast;\nlogic [3:0]                             io_axi_imem_ruser;\nlogic                                   io_axi_imem_rvalid;\nlogic                                   io_axi_imem_rready;\n\n// Data Memory\nlogic [3:0]                             io_axi_dmem_awid;\nlogic [31:0]                            io_axi_dmem_awaddr;\nlogic [7:0]                             io_axi_dmem_awlen;\nlogic [2:0]                             io_axi_dmem_awsize;\nlogic [1:0]                             io_axi_dmem_awburst;\nlogic                                   io_axi_dmem_awlock;\nlogic [3:0]                             io_axi_dmem_awcache;\nlogic [2:0]                             io_axi_dmem_awprot;\nlogic [3:0]                             io_axi_dmem_awregion;\nlogic [3:0]                             io_axi_dmem_awuser;\nlogic [3:0]                             io_axi_dmem_awqos;\nlogic                                   io_axi_dmem_awvalid;\nlogic                                   io_axi_dmem_awready;\nlogic [31:0]                            io_axi_dmem_wdata;\nlogic [3:0]                             io_axi_dmem_wstrb;\nlogic                                   io_axi_dmem_wlast;\nlogic [3:0]                             io_axi_dmem_wuser;\nlogic                                   io_axi_dmem_wvalid;\nlogic                                   io_axi_dmem_wready;\nlogic [3:0]                             io_axi_dmem_bid;\nlogic [1:0]                             io_axi_dmem_bresp;\nlogic                                   io_axi_dmem_bvalid;\nlogic [3:0]                             io_axi_dmem_buser;\nlogic                                   io_axi_dmem_bready;\nlogic [3:0]                             io_axi_dmem_arid;\nlogic [31:0]                            io_axi_dmem_araddr;\nlogic [7:0]                             io_axi_dmem_arlen;\nlogic [2:0]                             io_axi_dmem_arsize;\nlogic [1:0]                             io_axi_dmem_arburst;\nlogic                                   io_axi_dmem_arlock;\nlogic [3:0]                             io_axi_dmem_arcache;\nlogic [2:0]                             io_axi_dmem_arprot;\nlogic [3:0]                             io_axi_dmem_arregion;\nlogic [3:0]                             io_axi_dmem_aruser;\nlogic [3:0]                             io_axi_dmem_arqos;\nlogic                                   io_axi_dmem_arvalid;\nlogic                                   io_axi_dmem_arready;\nlogic [3:0]                             io_axi_dmem_rid;\nlogic [31:0]                            io_axi_dmem_rdata;\nlogic [1:0]                             io_axi_dmem_rresp;\nlogic                                   io_axi_dmem_rlast;\nlogic [3:0]                             io_axi_dmem_ruser;\nlogic                                   io_axi_dmem_rvalid;\nlogic                                   io_axi_dmem_rready;\n\n// Wathdogs\nint unsigned                            watchdogs_cnt;\n\nint unsigned                            f_results;\nint unsigned                            f_info;\nstring                                  s_results;\nstring                                  s_info;\n`ifdef SIGNATURE_OUT\nstring                                  s_testname;\nbit                                     b_single_run_flag;\n`endif  //  SIGNATURE_OUT\n`ifdef VERILATOR\nlogic [255:0]                           test_file;\n`else // VERILATOR\nstring                                  test_file;\n`endif // VERILATOR\n\nbit                                     test_running;\nint unsigned                            tests_passed;\nint unsigned                            tests_total;\n\nbit [1:0]                               rst_cnt;\nbit                                     rst_init;\n\n\n`ifdef VERILATOR\nfunction int identify_test (logic [255:0] testname);\n    bit res;\n    logic [79:0] pattern_compliance;\n    logic [22:0] pattern_arch;\nbegin\n    pattern_compliance = 80'h636f6d706c69616e6365; // compliance\n    pattern_arch       = 'h61726368;             // arch\n    res = 0;\n    for (int i = 0; i<= 176; i++) begin\n        if(testname[i+:80] == pattern_compliance) begin\n            return COMPLIANCE;\n        end\n    end\n    for (int i = 0; i<= 233; i++) begin\n        if(testname[i+:23] == pattern_arch) begin\n            return ARCH;\n        end\n    end\n    `ifdef SIGNATURE_OUT\n        return ~res;\n    `else\n        return res;\n    `endif\nend\nendfunction : identify_test\n\nfunction logic [255:0] get_filename (logic [255:0] testname);\nlogic [255:0] res;\nint i, j;\nbegin\n    testname[7:0] = 8'h66;\n    testname[15:8] = 8'h6C;\n    testname[23:16] = 8'h65;\n\n    for (i = 0; i <= 248; i += 8) begin\n        if (testname[i+:8] == 0) begin\n            break;\n        end\n    end\n    i -= 8;\n    for (j = 255; i >= 0;i -= 8) begin\n        res[j-:8] = testname[i+:8];\n        j -= 8;\n    end\n    for (; j >= 0;j -= 8) begin\n        res[j-:8] = 0;\n    end\n\n    return res;\nend\nendfunction : get_filename\n\nfunction logic [255:0] get_ref_filename (logic [255:0] testname);\n    logic [255:0] res;\n    int i, j;\n    logic [79:0] pattern_compliance;\n    logic [22:0] pattern_arch;\n    begin\n        pattern_compliance = 80'h636f6d706c69616e6365; // compliance\n        pattern_arch       = 'h61726368;             // arch\n\n        for(int i = 0; i <= 176; i++) begin\n            if(testname[i+:80] == pattern_compliance) begin\n                testname[(i-8)+:88] = 0;\n                break;\n            end\n        end\n\n        for(int i = 0; i <= 233; i++) begin\n            if(testname[i+:23] == pattern_arch) begin\n                testname[(i-8)+:31] = 0;\n                break;\n            end\n        end\n\n        for(i = 32; i <= 248; i += 8) begin\n            if(testname[i+:8] == 0) break;\n        end\n        i -= 8;\n        for(j = 255; i > 24; i -= 8) begin\n            res[j-:8] = testname[i+:8];\n            j -= 8;\n        end\n        for(; j >=0;j -= 8) begin\n            res[j-:8] = 0;\n        end\n\n        return res;\n    end\n    endfunction : get_ref_filename\n\nfunction logic [2047:0] remove_trailing_whitespaces (logic [2047:0] str);\nint i;\nbegin\n    for (i = 0; i <= 2040; i += 8) begin\n        if (str[i+:8] != 8'h20) begin\n            break;\n        end\n    end\n    str = str >> i;\n    return str;\nend\nendfunction: remove_trailing_whitespaces\n\n`else // VERILATOR\nfunction int identify_test (string testname);\n    begin\n        if (testname.substr(0, 3) == \"arch\") begin\n            return ARCH;\n        end else if (testname.substr(0, 9) == \"compliance\") begin\n            return COMPLIANCE;\n        end else begin\n            return 0;\n        end\n    end\nendfunction : identify_test\n\nfunction string get_filename (string testname);\n        int length;\n        begin\n            length = testname.len();\n            testname[length-1] = \"f\";\n            testname[length-2] = \"l\";\n            testname[length-3] = \"e\";\n\n            return testname;\n        end\nendfunction : get_filename\n\nfunction string get_ref_filename (string testname);\n    begin\n        if (identify_test(test_file) == COMPLIANCE) begin\n            return testname.substr(11, testname.len() - 5);\n        end else if (identify_test(test_file) == ARCH) begin\n            return testname.substr(5, testname.len() - 5);\n        end\n    end\nendfunction : get_ref_filename\n\n`endif // VERILATOR\n\n`ifndef VERILATOR\nalways #5   clk     = ~clk;         // 100 MHz\nalways #500 rtc_clk = ~rtc_clk;     // 1 MHz\n`endif // VERILATOR\n\n// Reset logic\nassign rst_n = &rst_cnt;\n\nalways_ff @(posedge clk) begin\n    if (rst_init)       rst_cnt <= '0;\n    else if (~&rst_cnt) rst_cnt <= rst_cnt + 1'b1;\nend\n\n\n`ifdef SCR1_DBG_EN\ninitial begin\n    trst_n  = 1'b0;\n    tck     = 1'b0;\n    tdi     = 1'b0;\n    #900ns trst_n   = 1'b1;\n    #500ns tms      = 1'b1;\n    #800ns tms      = 1'b0;\n    #500ns trst_n   = 1'b0;\n    #100ns tms      = 1'b1;\nend\n`endif // SCR1_DBG_EN\n\n//-------------------------------------------------------------------------------\n// Run tests\n//-------------------------------------------------------------------------------\n\n`include \"scr1_top_tb_runtests.sv\"\n\n//------------------------------------------------------------------------------\n// Core instance\n//------------------------------------------------------------------------------\nscr1_top_axi i_top (\n    // Reset\n    .pwrup_rst_n            (rst_n                  ),\n    .rst_n                  (rst_n                  ),\n    .cpu_rst_n              (rst_n                  ),\n`ifdef SCR1_DBG_EN\n    .sys_rst_n_o            (                       ),\n    .sys_rdc_qlfy_o         (                       ),\n`endif // SCR1_DBG_EN\n\n    // Clock\n    .clk                    (clk                    ),\n    .rtc_clk                (rtc_clk                ),\n\n    // Fuses\n    .fuse_mhartid           (fuse_mhartid           ),\n`ifdef SCR1_DBG_EN\n    .fuse_idcode            (`SCR1_TAP_IDCODE       ),\n`endif // SCR1_DBG_EN\n\n    // IRQ\n`ifdef SCR1_IPIC_EN\n    .irq_lines              (irq_lines              ),\n`else // SCR1_IPIC_EN\n    .ext_irq                (ext_irq                ),\n`endif // SCR1_IPIC_EN\n    .soft_irq               (soft_irq               ),\n\n    // DFT\n    .test_mode              (1'b0                   ),\n    .test_rst_n             (1'b1                   ),\n\n`ifdef SCR1_DBG_EN\n    // JTAG\n    .trst_n                 (trst_n                 ),\n    .tck                    (tck                    ),\n    .tms                    (tms                    ),\n    .tdi                    (tdi                    ),\n    .tdo                    (tdo                    ),\n    .tdo_en                 (tdo_en                 ),\n`endif // SCR1_DBG_EN\n\n    // Instruction memory interface\n    .io_axi_imem_awid       (io_axi_imem_awid       ),\n    .io_axi_imem_awaddr     (io_axi_imem_awaddr     ),\n    .io_axi_imem_awlen      (io_axi_imem_awlen      ),\n    .io_axi_imem_awsize     (io_axi_imem_awsize     ),\n    .io_axi_imem_awburst    (),\n    .io_axi_imem_awlock     (),\n    .io_axi_imem_awcache    (),\n    .io_axi_imem_awprot     (),\n    .io_axi_imem_awregion   (),\n    .io_axi_imem_awuser     (),\n    .io_axi_imem_awqos      (),\n    .io_axi_imem_awvalid    (io_axi_imem_awvalid    ),\n    .io_axi_imem_awready    (io_axi_imem_awready    ),\n    .io_axi_imem_wdata      (io_axi_imem_wdata      ),\n    .io_axi_imem_wstrb      (io_axi_imem_wstrb      ),\n    .io_axi_imem_wlast      (io_axi_imem_wlast      ),\n    .io_axi_imem_wuser      (),\n    .io_axi_imem_wvalid     (io_axi_imem_wvalid     ),\n    .io_axi_imem_wready     (io_axi_imem_wready     ),\n    .io_axi_imem_bid        (io_axi_imem_bid        ),\n    .io_axi_imem_bresp      (io_axi_imem_bresp      ),\n    .io_axi_imem_bvalid     (io_axi_imem_bvalid     ),\n    .io_axi_imem_buser      (4'd0                   ),\n    .io_axi_imem_bready     (io_axi_imem_bready     ),\n    .io_axi_imem_arid       (io_axi_imem_arid       ),\n    .io_axi_imem_araddr     (io_axi_imem_araddr     ),\n    .io_axi_imem_arlen      (io_axi_imem_arlen      ),\n    .io_axi_imem_arsize     (io_axi_imem_arsize     ),\n    .io_axi_imem_arburst    (io_axi_imem_arburst    ),\n    .io_axi_imem_arlock     (),\n    .io_axi_imem_arcache    (),\n    .io_axi_imem_arprot     (),\n    .io_axi_imem_arregion   (),\n    .io_axi_imem_aruser     (),\n    .io_axi_imem_arqos      (),\n    .io_axi_imem_arvalid    (io_axi_imem_arvalid    ),\n    .io_axi_imem_arready    (io_axi_imem_arready    ),\n    .io_axi_imem_rid        (io_axi_imem_rid        ),\n    .io_axi_imem_rdata      (io_axi_imem_rdata      ),\n    .io_axi_imem_rresp      (io_axi_imem_rresp      ),\n    .io_axi_imem_rlast      (io_axi_imem_rlast      ),\n    .io_axi_imem_ruser      (4'd0                   ),\n    .io_axi_imem_rvalid     (io_axi_imem_rvalid     ),\n    .io_axi_imem_rready     (io_axi_imem_rready     ),\n\n    // Data memory interface\n    .io_axi_dmem_awid       (io_axi_dmem_awid       ),\n    .io_axi_dmem_awaddr     (io_axi_dmem_awaddr     ),\n    .io_axi_dmem_awlen      (io_axi_dmem_awlen      ),\n    .io_axi_dmem_awsize     (io_axi_dmem_awsize     ),\n    .io_axi_dmem_awburst    (),\n    .io_axi_dmem_awlock     (),\n    .io_axi_dmem_awcache    (),\n    .io_axi_dmem_awprot     (),\n    .io_axi_dmem_awregion   (),\n    .io_axi_dmem_awuser     (),\n    .io_axi_dmem_awqos      (),\n    .io_axi_dmem_awvalid    (io_axi_dmem_awvalid    ),\n    .io_axi_dmem_awready    (io_axi_dmem_awready    ),\n    .io_axi_dmem_wdata      (io_axi_dmem_wdata      ),\n    .io_axi_dmem_wstrb      (io_axi_dmem_wstrb      ),\n    .io_axi_dmem_wlast      (io_axi_dmem_wlast      ),\n    .io_axi_dmem_wuser      (),\n    .io_axi_dmem_wvalid     (io_axi_dmem_wvalid     ),\n    .io_axi_dmem_wready     (io_axi_dmem_wready     ),\n    .io_axi_dmem_bid        (io_axi_dmem_bid        ),\n    .io_axi_dmem_bresp      (io_axi_dmem_bresp      ),\n    .io_axi_dmem_bvalid     (io_axi_dmem_bvalid     ),\n    .io_axi_dmem_buser      (4'd0                   ),\n    .io_axi_dmem_bready     (io_axi_dmem_bready     ),\n    .io_axi_dmem_arid       (io_axi_dmem_arid       ),\n    .io_axi_dmem_araddr     (io_axi_dmem_araddr     ),\n    .io_axi_dmem_arlen      (io_axi_dmem_arlen      ),\n    .io_axi_dmem_arsize     (io_axi_dmem_arsize     ),\n    .io_axi_dmem_arburst    (io_axi_dmem_arburst    ),\n    .io_axi_dmem_arlock     (),\n    .io_axi_dmem_arcache    (),\n    .io_axi_dmem_arprot     (),\n    .io_axi_dmem_arregion   (),\n    .io_axi_dmem_aruser     (),\n    .io_axi_dmem_arqos      (),\n    .io_axi_dmem_arvalid    (io_axi_dmem_arvalid    ),\n    .io_axi_dmem_arready    (io_axi_dmem_arready    ),\n    .io_axi_dmem_rid        (io_axi_dmem_rid        ),\n    .io_axi_dmem_rdata      (io_axi_dmem_rdata      ),\n    .io_axi_dmem_rresp      (io_axi_dmem_rresp      ),\n    .io_axi_dmem_rlast      (io_axi_dmem_rlast      ),\n    .io_axi_dmem_ruser      (4'd0                   ),\n    .io_axi_dmem_rvalid     (io_axi_dmem_rvalid     ),\n    .io_axi_dmem_rready     (io_axi_dmem_rready     )\n);\n\n\n//-------------------------------------------------------------------------------\n// Memory instance\n//-------------------------------------------------------------------------------\nscr1_memory_tb_axi #(\n    .SIZE    (SCR1_MEM_SIZE),\n    .N_IF    (2            ),\n    .W_ADR   (32           ),\n    .W_DATA  (32           )\n) i_memory_tb (\n    // Common\n    .rst_n          (rst_n),\n    .clk            (clk),\n`ifdef SCR1_IPIC_EN\n    .irq_lines      (irq_lines),\n`else // SCR1_IPIC_EN\n    .ext_irq        (ext_irq),\n`endif // SCR1_IPIC_EN\n    .soft_irq       (soft_irq),\n\n    // Write address channel\n    .awid           ( {io_axi_imem_awid,   io_axi_dmem_awid}      ),\n    .awaddr         ( {io_axi_imem_awaddr, io_axi_dmem_awaddr}    ),\n    .awsize         ( {io_axi_imem_awsize, io_axi_dmem_awsize}    ),\n    .awlen          ( {io_axi_imem_awlen,  io_axi_dmem_awlen}     ),\n    .awvalid        ( {io_axi_imem_awvalid,io_axi_dmem_awvalid}   ),\n    .awready        ( {io_axi_imem_awready,io_axi_dmem_awready}   ),\n\n    // Write data channel\n    .wdata          ( {io_axi_imem_wdata,  io_axi_dmem_wdata}     ),\n    .wstrb          ( {io_axi_imem_wstrb,  io_axi_dmem_wstrb}     ),\n    .wvalid         ( {io_axi_imem_wvalid, io_axi_dmem_wvalid}    ),\n    .wlast          ( {io_axi_imem_wlast,  io_axi_dmem_wlast}     ),\n    .wready         ( {io_axi_imem_wready, io_axi_dmem_wready}    ),\n\n    // Write response channel\n    .bready         ( {io_axi_imem_bready, io_axi_dmem_bready}    ),\n    .bvalid         ( {io_axi_imem_bvalid, io_axi_dmem_bvalid}    ),\n    .bid     "}
{"text": "       ( {io_axi_imem_bid,    io_axi_dmem_bid}       ),\n    .bresp          ( {io_axi_imem_bresp,  io_axi_dmem_bresp}     ),\n\n    // Read address channel\n    .arid           ( {io_axi_imem_arid,   io_axi_dmem_arid}      ),\n    .araddr         ( {io_axi_imem_araddr, io_axi_dmem_araddr}    ),\n    .arburst        ( {io_axi_imem_arburst,io_axi_dmem_arburst}   ),\n    .arsize         ( {io_axi_imem_arsize, io_axi_dmem_arsize}    ),\n    .arlen          ( {io_axi_imem_arlen,  io_axi_dmem_arlen}     ),\n    .arvalid        ( {io_axi_imem_arvalid,io_axi_dmem_arvalid}   ),\n    .arready        ( {io_axi_imem_arready,io_axi_dmem_arready}   ),\n\n    // Read data channel\n    .rvalid         ( {io_axi_imem_rvalid, io_axi_dmem_rvalid}    ),\n    .rready         ( {io_axi_imem_rready, io_axi_dmem_rready}    ),\n    .rid            ( {io_axi_imem_rid,    io_axi_dmem_rid}       ),\n    .rdata          ( {io_axi_imem_rdata,  io_axi_dmem_rdata}     ),\n    .rlast          ( {io_axi_imem_rlast,  io_axi_dmem_rlast}     ),\n    .rresp          ( {io_axi_imem_rresp,  io_axi_dmem_rresp}     )\n);\n\nendmodule : scr1_top_tb_axi\n"}
{"text": "/// Copyright by Syntacore LLC \u00a9 2016-2021. See LICENSE for details\n/// @file       <scr1_top_tb_runtests.sv>\n/// @brief      SCR1 testbench run tests\n///\n\n//-------------------------------------------------------------------------------\n// Run tests\n//-------------------------------------------------------------------------------\n\ninitial begin\n    $value$plusargs(\"imem_pattern=%h\", imem_req_ack_stall);\n    $value$plusargs(\"dmem_pattern=%h\", dmem_req_ack_stall);\n\n`ifdef SIGNATURE_OUT\n    $value$plusargs(\"test_name=%s\", s_testname);\n    b_single_run_flag = 1;\n`else // SIGNATURE_OUT\n\n    $value$plusargs(\"test_info=%s\", s_info);\n    $value$plusargs(\"test_results=%s\", s_results);\n\n    f_info      = $fopen(s_info, \"r\");\n    f_results   = $fopen(s_results, \"a\");\n`endif // SIGNATURE_OUT\n\n    fuse_mhartid = 0;\n\nend\n\nalways_ff @(posedge clk) begin\n    bit           test_pass;\n    bit           test_error;\n    int unsigned  f_test;\n    watchdogs_cnt <= watchdogs_cnt + 'b1;\n    if (test_running) begin\n        test_pass = 1;\n        rst_init <= 1'b0;\n        if ((i_top.i_core_top.i_pipe_top.curr_pc == SCR1_SIM_EXIT_ADDR) & ~rst_init & &rst_cnt) begin\n            `ifdef VERILATOR\n                logic [255:0] full_filename;\n                full_filename = test_file;\n            `else // VERILATOR\n                string full_filename;\n                full_filename = test_file;\n            `endif // VERILATOR\n\n            if (identify_test(test_file)) begin\n\n                logic [31:0] tmpv, start, stop, ref_data, test_data, start_addr, trap_addr;\n                integer fd;\n                logic [31:0] code;\n                `ifdef VERILATOR\n                logic [2047:0] tmpstr;\n                `else // VERILATOR\n                string tmpstr;\n                `endif // VERILATOR\n\n                test_running <= 1'b0;\n                test_pass    = 1;\n                test_error   = 0;\n\n                $sformat(tmpstr, \"riscv64-unknown-elf-readelf -s %s | grep 'begin_signature\\\\|end_signature\\\\| _start\\\\|trap_vector' | awk '{print $2}' > elfinfo\", get_filename(test_file));\n                fd = $fopen(\"script.sh\", \"w\");\n                if (fd == 0) begin\n                    $write(\"Can't open script.sh\\n\");\n                    test_error = 1;\n                end\n                $fwrite(fd, \"%s\", tmpstr);\n                $fclose(fd);\n\n                $system(\"sh script.sh\");\n\n                fd = $fopen(\"elfinfo\", \"r\");\n                if (fd == 0) begin\n                    $write(\"Can't open elfinfo\\n\");\n                    test_error = 1;\n                end\n                if ($fscanf(fd,\"%h\\n%h\\n%h\\n%h\", trap_addr, start, stop, start_addr) != 4) begin\n                    $write(\"Wrong elfinfo data\\n\");\n                    test_error = 1;\n                end\n                if ((trap_addr != ADDR_TRAP_VECTOR & trap_addr != ADDR_TRAP_DEFAULT) | start_addr != ADDR_START) begin\n                    $write(\"\\nError trap_vector %h or/and _start %h are incorrectly aligned and are not at their address\\n\", trap_addr, start_addr);\n                    test_error = 1;\n                end\n                if (start > stop) begin\n                    tmpv = start;\n                    start = stop;\n                    stop = tmpv;\n                end\n                $fclose(fd);\n\n                `ifdef SIGNATURE_OUT\n\n                    $sformat(tmpstr, \"%s.signature.output\", s_testname);\n`ifdef VERILATOR\n                    tmpstr = remove_trailing_whitespaces(tmpstr);\n`endif\n                    fd = $fopen(tmpstr, \"w\");\n                    while ((start != stop)) begin\n                        test_data = {i_memory_tb.memory[start+3], i_memory_tb.memory[start+2], i_memory_tb.memory[start+1], i_memory_tb.memory[start]};\n                        $fwrite(fd, \"%x\", test_data);\n                        $fwrite(fd, \"%s\", \"\\n\");\n                        start += 4;\n                    end\n                    $fclose(fd);\n                `else //SIGNATURE_OUT\n                    if (identify_test(test_file) == COMPLIANCE) begin\n                        $sformat(tmpstr, \"riscv_compliance/ref_data/%s\", get_ref_filename(test_file));\n                    end else if (identify_test(test_file) == ARCH) begin\n                        $sformat(tmpstr, \"riscv_arch/ref_data/%s\", get_ref_filename(test_file));\n                    end\n`ifdef VERILATOR\n                    tmpstr = remove_trailing_whitespaces(tmpstr);\n`endif\n                    fd = $fopen(tmpstr,\"r\");\n                    if (fd == 0) begin\n                        $write(\"Can't open reference_data file: %s\\n\", tmpstr);\n                        test_error = 1;\n                    end\n                    while (!$feof(fd) && (start != stop)) begin\n                        if (($fscanf(fd, \"%h\", ref_data)=='h1)) begin\n                            test_data = {i_memory_tb.memory[start+3], i_memory_tb.memory[start+2], i_memory_tb.memory[start+1], i_memory_tb.memory[start]};\n                            test_pass &= (ref_data == test_data);\n                            start += 4;\n                        end else begin\n                            $write(\"Wrong $fscanf\\n\");\n                            test_pass = 0;\n                        end\n                    end\n                    $fclose(fd);\n                    tests_total += 1;\n                    tests_passed += (test_pass & !test_error);\n                    watchdogs_cnt <= '0;\n                    if ((test_pass & !test_error)) begin\n                        $write(\"\\033[0;32mTest passed\\033[0m\\n\");\n                    end else begin\n                        $write(\"\\033[0;31mTest failed\\033[0m\\n\");\n                    end\n                `endif  // SIGNATURE_OUT\n            end else begin\n                test_running <= 1'b0;\n                test_pass = (i_top.i_core_top.i_pipe_top.i_pipe_mprf.mprf_int[10] == 0);\n                tests_total     += 1;\n                tests_passed    += (test_pass & !test_error);\n                watchdogs_cnt    <= '0;\n                `ifndef SIGNATURE_OUT\n                    if ((test_pass & !test_error)) begin\n                        $write(\"\\033[0;32mTest passed\\033[0m\\n\");\n                    end else begin\n                        $write(\"\\033[0;31mTest failed\\033[0m\\n\");\n                    end\n                `endif //SIGNATURE_OUT\n            end\n            $fwrite(f_results, \"%s\\t\\t%s\\t%s\\n\", test_file, \"OK\" , ((test_pass & !test_error) ? \"PASS\" : \"__FAIL\"));\n        end\n    end else begin\n`ifdef SIGNATURE_OUT\n        if ((s_testname.len() != 0) && (b_single_run_flag)) begin\n            $sformat(test_file, \"%s.bin\", s_testname);\n`else // SIGNATURE_OUT\n        if (f_info) begin\n`ifdef VERILATOR\n        if ($fgets(test_file,f_info)) begin\n            test_file = test_file >> 8; // < Removing trailing LF symbol ('\\n')\n`else // VERILATOR\n        if (!$feof(f_info)) begin\n            void'($fscanf(f_info, \"%s\\n\", test_file));\n`endif // VERILATOR\n`endif // SIGNATURE_OUT\n            f_test = $fopen(test_file,\"r\");\n            if (f_test != 0) begin\n            // Launch new test\n                `ifdef SCR1_TRACE_LOG_EN\n                    i_top.i_core_top.i_pipe_top.i_tracelog.test_name = test_file;\n                `endif // SCR1_TRACE_LOG_EN\n                i_memory_tb.test_file = test_file;\n                i_memory_tb.test_file_init = 1'b1;\n                `ifndef SIGNATURE_OUT\n                    $write(\"\\033[0;34m---Test: %s\\033[0m\\n\", test_file);\n                `endif //SIGNATURE_OUT\n                test_running <= 1'b1;\n                rst_init <= 1'b1;\n                `ifdef SIGNATURE_OUT\n                    b_single_run_flag = 0;\n                `endif\n            end else begin\n                $fwrite(f_results, \"%s\\t\\t%s\\t%s\\n\", test_file, \"__FAIL\", \"--------\");\n            end\n        end else begin\n            // Exit\n            `ifndef SIGNATURE_OUT\n                $display(\"\\n#--------------------------------------\");\n                $display(\"# Summary: %0d/%0d tests passed\", tests_passed, tests_total);\n                $display(\"#--------------------------------------\\n\");\n                $fclose(f_info);\n                $fclose(f_results);\n            `endif\n            $finish();\n        end\n`ifndef SIGNATURE_OUT\n        end else begin\n            $write(\"\\033[0;31mError: could not open file %s\\033[0m\\n\", s_info);\n            $finish();\n        end\n`endif // SIGNATURE_OUT\n    end\n    if (watchdogs_cnt == TIMEOUT) begin\n        if (test_file == \"watchdog.hex\") begin\n            tests_total  += 'b1;\n            tests_passed += 'b1;\n            $fwrite(f_results, \"%s\\t\\t%s\\t%s\\n\", test_file, \"OK\" , \"PASS\");\n            test_running  <= '0;\n            watchdogs_cnt <= '0;\n        end else begin\n            tests_total  += 'b1;\n            tests_passed += 'b0;\n            $write(\"\\033[0;31mError: TIMEOUT  %s\\033[0m\\n\", test_file);\n            $fwrite(f_results, \"%s\\t\\t%s\\t%s\\n\", test_file, \"OK\" , \"__FAIL\");\n            test_running  <= '0;\n            watchdogs_cnt <= '0;\n        end\n    end\nend\n"}
{"text": "/// Copyright by Syntacore LLC \u00a9 2016-2021. See LICENSE for details\n/// @file       <scr1_tracelog.sv>\n/// @brief      Core tracelog module\n///\n\n`include \"scr1_arch_description.svh\"\n`include \"scr1_arch_types.svh\"\n`include \"scr1_csr.svh\"\n\n`ifdef SCR1_TRGT_SIMULATION\n\nmodule scr1_tracelog (\n    input   logic                                 rst_n,                        // Tracelog reset\n    input   logic                                 clk                           // Tracelog clock\n`ifdef SCR1_TRACE_LOG_EN\n    ,\n    input   logic [`SCR1_XLEN-1:0]                soc2pipe_fuse_mhartid_i,      // Fuse MHARTID\n\n    // MPRF\n`ifdef  SCR1_MPRF_RAM\n    input   logic   [`SCR1_XLEN-1:0]            mprf2trace_int_i   [1:`SCR1_MPRF_SIZE-1], // MPRF registers content\n`else // SCR1_MPRF_RAM\n    input   type_scr1_mprf_v [1:`SCR1_MPRF_SIZE-1] mprf2trace_int_i,             // MPRF registers content\n`endif // SCR1_MPRF_RAM\n    input   logic                                 mprf2trace_wr_en_i,           // MPRF write enable\n    input   logic [`SCR1_MPRF_AWIDTH-1:0]         mprf2trace_wr_addr_i,         // MPRF write address\n    input   logic [`SCR1_XLEN-1:0]                mprf2trace_wr_data_i,         // MPRF write data\n\n    // EXU\n    input   logic                                 exu2trace_update_pc_en_i,     // PC updated flag\n    input   logic [`SCR1_XLEN-1:0]                exu2trace_update_pc_i,        // Next PC value\n\n    // IFU\n    input   logic [`SCR1_IMEM_DWIDTH-1:0]         ifu2trace_instr_i,            // Current instruction from IFU stage\n\n    // CSR\n    input   logic                                 csr2trace_mstatus_mie_i,      // CSR MSTATUS.mie bit\n    input   logic                                 csr2trace_mstatus_mpie_i,     // CSR MSTATUS.mpie bit\n    input   logic [`SCR1_XLEN-1:6]                csr2trace_mtvec_base_i,       // CSR MTVEC.\n    input   logic                                 csr2trace_mtvec_mode_i,       // CSR MTVEC.\n    input   logic                                 csr2trace_mie_meie_i,         // CSR MIE.meie bit\n    input   logic                                 csr2trace_mie_mtie_i,         // CSR MIE.mtie bit\n    input   logic                                 csr2trace_mie_msie_i,         // CSR MIE.msie bit\n    input   logic                                 csr2trace_mip_meip_i,         // CSR MIP.meip bit\n    input   logic                                 csr2trace_mip_mtip_i,         // CSR MIP.mtip bit\n    input   logic                                 csr2trace_mip_msip_i,         // CSR MIP.msip bit\n `ifdef SCR1_RVC_EXT\n    input   logic [`SCR1_XLEN-1:1]                csr2trace_mepc_i,             // CSR MEPC register\n `else // SCR1_RVC_EXT\n    input   logic [`SCR1_XLEN-1:2]                csr2trace_mepc_i,             // CSR MEPC register\n `endif // SCR1_RVC_EXT\n    input   logic                                 csr2trace_mcause_irq_i,       // CSR MCAUSE.interrupt bit\n    input   type_scr1_exc_code_e                  csr2trace_mcause_ec_i,        // CSR MCAUSE.exception_code bit\n    input   logic [`SCR1_XLEN-1:0]                csr2trace_mtval_i,            // CSR MTVAL register\n\n    // Events\n    input   logic                                 csr2trace_e_exc_i,            // exception event\n    input   logic                                 csr2trace_e_irq_i,            // interrupt event\n    input   logic                                 pipe2trace_e_wake_i           // pipe wakeup event\n`endif // SCR1_TRACE_LOG_EN\n);\n\n//-------------------------------------------------------------------------------\n// Local types declaration\n//-------------------------------------------------------------------------------\n`ifdef SCR1_TRACE_LOG_EN\ntypedef struct {\n    logic [`SCR1_XLEN-1:0]      INT_00_ZERO ;\n    logic [`SCR1_XLEN-1:0]      INT_01_RA   ;\n    logic [`SCR1_XLEN-1:0]      INT_02_SP   ;\n    logic [`SCR1_XLEN-1:0]      INT_03_GP   ;\n    logic [`SCR1_XLEN-1:0]      INT_04_TP   ;\n    logic [`SCR1_XLEN-1:0]      INT_05_T0   ;\n    logic [`SCR1_XLEN-1:0]      INT_06_T1   ;\n    logic [`SCR1_XLEN-1:0]      INT_07_T2   ;\n    logic [`SCR1_XLEN-1:0]      INT_08_S0   ;\n    logic [`SCR1_XLEN-1:0]      INT_09_S1   ;\n    logic [`SCR1_XLEN-1:0]      INT_10_A0   ;\n    logic [`SCR1_XLEN-1:0]      INT_11_A1   ;\n    logic [`SCR1_XLEN-1:0]      INT_12_A2   ;\n    logic [`SCR1_XLEN-1:0]      INT_13_A3   ;\n    logic [`SCR1_XLEN-1:0]      INT_14_A4   ;\n    logic [`SCR1_XLEN-1:0]      INT_15_A5   ;\n`ifndef SCR1_RVE_EXT\n    logic [`SCR1_XLEN-1:0]      INT_16_A6   ;\n    logic [`SCR1_XLEN-1:0]      INT_17_A7   ;\n    logic [`SCR1_XLEN-1:0]      INT_18_S2   ;\n    logic [`SCR1_XLEN-1:0]      INT_19_S3   ;\n    logic [`SCR1_XLEN-1:0]      INT_20_S4   ;\n    logic [`SCR1_XLEN-1:0]      INT_21_S5   ;\n    logic [`SCR1_XLEN-1:0]      INT_22_S6   ;\n    logic [`SCR1_XLEN-1:0]      INT_23_S7   ;\n    logic [`SCR1_XLEN-1:0]      INT_24_S8   ;\n    logic [`SCR1_XLEN-1:0]      INT_25_S9   ;\n    logic [`SCR1_XLEN-1:0]      INT_26_S10  ;\n    logic [`SCR1_XLEN-1:0]      INT_27_S11  ;\n    logic [`SCR1_XLEN-1:0]      INT_28_T3   ;\n    logic [`SCR1_XLEN-1:0]      INT_29_T4   ;\n    logic [`SCR1_XLEN-1:0]      INT_30_T5   ;\n    logic [`SCR1_XLEN-1:0]      INT_31_T6   ;\n`endif // SCR1_RVE_EXT\n} type_scr1_ireg_name_s;\n\ntypedef struct packed {\n    logic [`SCR1_XLEN-1:0]  mstatus;\n    logic [`SCR1_XLEN-1:0]  mtvec;\n    logic [`SCR1_XLEN-1:0]  mie;\n    logic [`SCR1_XLEN-1:0]  mip;\n    logic [`SCR1_XLEN-1:0]  mepc;\n    logic [`SCR1_XLEN-1:0]  mcause;\n    logic [`SCR1_XLEN-1:0]  mtval;\n} type_scr1_csr_trace_s;\n`endif // SCR1_TRACE_LOG_EN\n\n//-------------------------------------------------------------------------------\n// Local Signal Declaration\n//-------------------------------------------------------------------------------\n`ifdef SCR1_TRACE_LOG_EN\n\ntype_scr1_ireg_name_s               mprf_int_alias;\n\n\ntime                                current_time;\n\n// Tracelog control signals\nlogic                               trace_flag;\nlogic                               trace_update;\nlogic                               trace_update_r;\nbyte                                event_type;\n\nlogic [`SCR1_XLEN-1:0]              trace_pc;\nlogic [`SCR1_XLEN-1:0]              trace_npc;\nlogic [`SCR1_IMEM_DWIDTH-1:0]       trace_instr;\n\ntype_scr1_csr_trace_s               csr_trace1;\n\n// File handlers\nint unsigned                        trace_fhandler_core;\n\n// MPRF signals\nlogic                               mprf_up;\nlogic [`SCR1_MPRF_AWIDTH-1:0]       mprf_addr;\nlogic [`SCR1_XLEN-1:0]              mprf_wdata;\n\nstring                              hart;\nstring                              test_name;\n\n`endif // SCR1_TRACE_LOG_EN\n\n//-------------------------------------------------------------------------------\n// Local tasks\n//-------------------------------------------------------------------------------\n\n`ifdef SCR1_TRACE_LOG_EN\n\ntask trace_write_common;\n    $fwrite(trace_fhandler_core, \"%16d  \", current_time);\n    // $fwrite(trace_fhandler_core, \" 0  \");\n    $fwrite(trace_fhandler_core, \" %s  \",  event_type);\n    $fwrite(trace_fhandler_core, \" %8x  \", trace_pc);\n    $fwrite(trace_fhandler_core, \" %8x  \", trace_instr);\n    $fwrite(trace_fhandler_core, \" %8x  \", trace_npc);\nendtask // trace_write_common\n\ntask trace_write_int_walias;\n    case (mprf_addr)\n        0  :  $fwrite(trace_fhandler_core, \" x00_zero  \");\n        1  :  $fwrite(trace_fhandler_core, \" x01_ra    \");\n        2  :  $fwrite(trace_fhandler_core, \" x02_sp    \");\n        3  :  $fwrite(trace_fhandler_core, \" x03_gp    \");\n        4  :  $fwrite(trace_fhandler_core, \" x04_tp    \");\n        5  :  $fwrite(trace_fhandler_core, \" x05_t0    \");\n        6  :  $fwrite(trace_fhandler_core, \" x06_t1    \");\n        7  :  $fwrite(trace_fhandler_core, \" x07_t2    \");\n        8  :  $fwrite(trace_fhandler_core, \" x08_s0    \");\n        9  :  $fwrite(trace_fhandler_core, \" x09_s1    \");\n        10 :  $fwrite(trace_fhandler_core, \" x10_a0    \");\n        11 :  $fwrite(trace_fhandler_core, \" x11_a1    \");\n        12 :  $fwrite(trace_fhandler_core, \" x12_a2    \");\n        13 :  $fwrite(trace_fhandler_core, \" x13_a3    \");\n        14 :  $fwrite(trace_fhandler_core, \" x14_a4    \");\n        15 :  $fwrite(trace_fhandler_core, \" x15_a5    \");\n`ifndef SCR1_RVE_EXT\n        16 :  $fwrite(trace_fhandler_core, \" x16_a6    \");\n        17 :  $fwrite(trace_fhandler_core, \" x17_a7    \");\n        18 :  $fwrite(trace_fhandler_core, \" x18_s2    \");\n        19 :  $fwrite(trace_fhandler_core, \" x19_s3    \");\n        20 :  $fwrite(trace_fhandler_core, \" x20_s4    \");\n        21 :  $fwrite(trace_fhandler_core, \" x21_s5    \");\n        22 :  $fwrite(trace_fhandler_core, \" x22_s6    \");\n        23 :  $fwrite(trace_fhandler_core, \" x23_s7    \");\n        24 :  $fwrite(trace_fhandler_core, \" x24_s8    \");\n        25 :  $fwrite(trace_fhandler_core, \" x25_s9    \");\n        26 :  $fwrite(trace_fhandler_core, \" x26_s10   \");\n        27 :  $fwrite(trace_fhandler_core, \" x27_s11   \");\n        28 :  $fwrite(trace_fhandler_core, \" x28_t3    \");\n        29 :  $fwrite(trace_fhandler_core, \" x29_t4    \");\n        30 :  $fwrite(trace_fhandler_core, \" x30_t5    \");\n        31 :  $fwrite(trace_fhandler_core, \" x31_t6    \");\n`endif // SCR1_RVE_EXT\n        default: begin\n              $fwrite(trace_fhandler_core, \" xxx       \");\n        end\n    endcase\nendtask\n\n//-------------------------------------------------------------------------------\n// MPRF Registers assignment\n//-------------------------------------------------------------------------------\nassign mprf_int_alias.INT_00_ZERO   = '0;\nassign mprf_int_alias.INT_01_RA     = mprf2trace_int_i[1];\nassign mprf_int_alias.INT_02_SP     = mprf2trace_int_i[2];\nassign mprf_int_alias.INT_03_GP     = mprf2trace_int_i[3];\nassign mprf_int_alias.INT_04_TP     = mprf2trace_int_i[4];\nassign mprf_int_alias.INT_05_T0     = mprf2trace_int_i[5];\nassign mprf_int_alias.INT_06_T1     = mprf2trace_int_i[6];\nassign mprf_int_alias.INT_07_T2     = mprf2trace_int_i[7];\nassign mprf_int_alias.INT_08_S0     = mprf2trace_int_i[8];\nassign mprf_int_alias.INT_09_S1     = mprf2trace_int_i[9];\nassign mprf_int_alias.INT_10_A0     = mprf2trace_int_i[10];\nassign mprf_int_alias.INT_11_A1     = mprf2trace_int_i[11];\nassign mprf_int_alias.INT_12_A2     = mprf2trace_int_i[12];\nassign mprf_int_alias.INT_13_A3     = mprf2trace_int_i[13];\nassign mprf_int_alias.INT_14_A4     = mprf2trace_int_i[14];\nassign mprf_int_alias.INT_15_A5     = mprf2trace_int_i[15];\n`ifndef SCR1_RVE_EXT\nassign mprf_int_alias.INT_16_A6     = mprf2trace_int_i[16];\nassign mprf_int_alias.INT_17_A7     = mprf2trace_int_i[17];\nassign mprf_int_alias.INT_18_S2     = mprf2trace_int_i[18];\nassign mprf_int_alias.INT_19_S3     = mprf2trace_int_i[19];\nassign mprf_int_alias.INT_20_S4     = mprf2trace_int_i[20];\nassign mprf_int_alias.INT_21_S5     = mprf2trace_int_i[21];\nassign mprf_int_alias.INT_22_S6     = mprf2trace_int_i[22];\nassign mprf_int_alias.INT_23_S7     = mprf2trace_int_i[23];\nassign mprf_int_alias.INT_24_S8     = mprf2trace_int_i[24];\nassign mprf_int_alias.INT_25_S9     = mprf2trace_int_i[25];\nassign mprf_int_alias.INT_26_S10    = mprf2trace_int_i[26];\nassign mprf_int_alias.INT_27_S11    = mprf2trace_int_i[27];\nassign mprf_int_alias.INT_28_T3     = mprf2trace_int_i[28];\nassign mprf_int_alias.INT_29_T4     = mprf2trace_int_i[29];\nassign mprf_int_alias.INT_30_T5     = mprf2trace_int_i[30];\nassign mprf_int_alias.INT_31_T6     = mprf2trace_int_i[31];\n`endif // SCR1_RVE_EXT\n`endif // SCR1_TRACE_LOG_EN\n\n//-------------------------------------------------------------------------------\n// Legacy time counter\n//-------------------------------------------------------------------------------\n// The counter is left for compatibility with the current UVM environment\n\nint     time_cnt;\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n        time_cnt    <= 0;\n    end else begin\n        time_cnt    <= time_cnt + 1;\n    end\nend\n\n//-------------------------------------------------------------------------------\n// Initial part pipeline tracelog\n//-------------------------------------------------------------------------------\n\n`ifdef SCR1_TRACE_LOG_EN\n// Files opening and writing initial header\ninitial begin\n    $timeformat(-9, 0, \" ns\", 10);\n    #1 hart.hextoa(soc2pipe_fuse_mhartid_i);\n\n    trace_fhandler_core = $fopen({\"tracelog_core_\", hart, \".log\"}, \"w\");\n\n    // Writing initial header\n    $fwrite(trace_fhandler_core,  \"# RTL_ID %h\\n\", SCR1_CSR_MIMPID);\n    $fwrite(trace_fhandler_core,  \"#\\n\");\n    // $fwrite(trace_fhandler_core,  \"# R - return from trap:\\n\");\n    // $fwrite(trace_fhandler_core,  \"#    1 - MRET\\n\");\n    // $fwrite(trace_fhandler_core,  \"#    0 - no return\\n\");\n    $fwrite(trace_fhandler_core,  \"# Events:\\n\");\n    $fwrite(trace_fhandler_core,  \"#    N - no event\\n\");\n    $fwrite(trace_fhandler_core,  \"#    E - exception\\n\");\n    $fwrite(trace_fhandler_core,  \"#    I - interrupt\\n\");\n    $fwrite(trace_fhandler_core,  \"#    W - wakeup\\n\");\nend\n\n// Core reset logging and header printing\nalways @(posedge rst_n) begin\n    $fwrite(trace_fhandler_core, \"# =====================================================================================\\n\");\n`ifndef VERILATOR\n    $fwrite(trace_fhandler_core, \"# %16d ns : Core Reset\\n\", $time());\n`else\n    $fwrite(trace_fhandler_core, \"# : Core Reset\\n\");\n`endif\n    $fwrite(trace_fhandler_core, \"# =====================================================================================\\n\");\n    $fwrite(trace_fhandler_core,  \"# Test: %s\\n\", test_name);\n    $fwrite(trace_fhandler_core,  \"#           Time  \");\n    // $fwrite(trace_fhandler_core,  \" R  \");\n    $fwrite(trace_fhandler_core,  \" Ev \");\n    $fwrite(trace_fhandler_core,  \" Curr_PC   \");\n    $fwrite(trace_fhandler_core,  \" Instr     \");\n    $fwrite(trace_fhandler_core,  \" Next_PC   \");\n    $fwrite(trace_fhandler_core,  \" Reg       \");\n    $fwrite(trace_fhandler_core,  \" Value     \");\n    $fwrite(trace_fhandler_core, \"\\n\");\n    $fwrite(trace_fhandler_core, \"# =====================================================================================\\n\");\nend\n\n//-------------------------------------------------------------------------------\n// Common trace part\n//-------------------------------------------------------------------------------\n\nassign trace_flag   = 1'b1;\nassign trace_update = (exu2trace_update_pc_en_i | mprf2trace_wr_en_i) & trace_flag;\n\nalways_ff @(posedge clk) begin\n    if (~rst_n) begin\n        current_time    <= 0;\n        event_type      <= \"N\";\n\n        trace_pc        <= 'x;\n        trace_npc       <= 'x;\n        trace_instr     <= 'x;\n\n        trace_update_r  <= 1'b0;\n\n        mprf_up         <= '0;\n        mprf_addr       <= '0;\n        mprf_wdata      <= '0;\n    end else begin\n        trace_update_r <= trace_update;\n        if (trace_update) begin\n`ifdef VERILATOR\n            current_time  <= time_cnt;\n`else\n            current_time  <= $time();\n`endif\n            trace_pc      <= trace_npc;\n            trace_npc     <= exu2trace_update_pc_i;\n            trace_instr   <= ifu2trace_instr_i;\n\n            if (csr2trace_e_exc_i) begin\n                // Exception\n                event_type  <= \"E\";\n            end\n            else if (csr2trace_e_irq_i) begin\n                // IRQ\n                event_type  <= \"I\";\n            end\n            else if (pipe2trace_e_wake_i) begin\n                // Wake\n                event_type <= \"W\";\n            end\n            else begin\n                // No event\n                event_type <= \"N\";\n            end\n        end\n\n        // Write log signals\n        mprf_up    <= mprf2trace_wr_en_i;\n        mprf_addr  <= mprf2trace_wr_en_i ? mprf2trace_wr_addr_i : 'x;\n        mprf_wdata <= mprf2trace_wr_en_i ? mprf2trace_wr_data_i : 'x;\n    end\nend\n\n//-------------------------------------------------------------------------------\n// Core MPRF logging\n//-------------------------------------------------------------------------------\n\nalways_ff @(negedge rst_n, posedge clk) begin\n    if (~rst_n) begin\n    end else begin\n        if (trace_update_r) begin\n\n            trace_write_common();\n\n            case (event_type)\n                \"W\"     : begin\n                    // Wakeup\n                    if (csr_trace1.mip & csr_trace1.mie) begin\n                        $fwrite(trace_fhandler_core, \" mip        %08x\\n\", csr_trace1.mip );\n                        trace_write_common();\n                        $fwrite(trace_fhandler_core, \" mie        %08x\", csr_trace1.mie );\n                    end\n                end\n                \"N\"     : begin\n                    // Regular\n                    if (mprf_up && mprf_addr != 0) begin\n                        // $fwrite(trace_fhandler_core, \" x%2d      %08x\", mprf_addr, mprf_wdata);\n                        trace_write_int_walias();\n                        $fwrite(trace_fhandler_core, \" %08x\", mprf_wdata);\n                    end else begin\n                        $fwrite(trace_fhandler_core, \" ---        --------\");\n                    end\n                end\n                \"R\"     : begin\n                    // MRET\n                    $fwrite(trace_fhandler_core, \" mstatus    %08x\", csr_trace1.mstatus);\n                end\n                \"E\", \"I\": begin\n                    // IRQ/Exception\n                    $fwrite(trace_fhandler_core, \" mstatus    %08x\\n\", csr_trace1.mstatus);\n                    trace_write_common();\n                    $fwrite(trace_fhandler_core, \" mepc       %08x\\n\", csr_trace1.mepc);\n                    trace_write_common();\n                    $fwrite(trace_fhandler_core, \" mcause     %08x\\n\", csr_trace1.mcause);\n                    trace_write_common();\n                    $fwrite(trace_fhandler_core, \" mtval      %08x\",   csr_trace1.mtval);\n                end\n                default : begin\n                    $fwrite(trace_fhandler_core,  \"\\n\");\n                end\n            endcase\n            $fwrite(trace_fhandler_core,  \"\\n\");\n        end\n    end\nend\n\n//-------------------------------------------------------------------------------\n// Core CSR logging\n//-------------------------------------------------------------------------------\n\nalways_comb begin\n    csr_trace1.mtvec        = {csr2trace_mtvec_base_i, 4'd0, 2'(csr2trace_mtvec_mode_i)};\n    csr_trace1.mepc         =\n`ifdef SCR1_RVC_EXT\n                              {csr2trace_mepc_i, 1'b0};\n`else // SCR1_RVC_EXT\n                              {csr2trace_mepc_i, 2'b00};\n`endif // SCR1_RVC_EXT\n    csr_trace1.mcause       = {csr2trace_mcause_irq_i, type_scr1_csr_mcause_ec_v'(csr2trace_mcause_ec_i)};\n    csr_trace1.mtval        = csr2trace_mtval_i;\n\n    csr_trace1.mstatus      = '0;\n    csr_trace1.mie          = '0;\n    csr_trace1.mip          = '0;\n\n    csr_trace1.mstatus[SCR1_CSR_MSTATUS_MIE_OFFSET]     = csr2trace_mstatus_mie_i;\n    csr_trace1.mstatus[SCR1_CSR_MSTATUS_MPIE_OFFSET]    = csr2trace_mstatus_mpie_i;\n    csr_trace1.mstatus[SCR1_CSR_MSTATUS_MPP_OFFSET+1:SCR1_CSR_MSTATUS_MPP_OFFSET]   = SCR1_CSR_MSTATUS_MPP;\n    csr_trace1.mie[SCR1_CSR_MIE_MSIE_OFFSET]            = csr2trace_mie_msie_i;\n    csr_trace1.mie[SCR1_CSR_MIE_MTIE_OFFSET]            = csr2trace_mie_mtie_i;\n    csr_trace1.mie[SCR1_CSR_MIE_MEIE_OFFSET]            = csr2trace_mie_meie_i;\n    csr_trace1.mip[SCR1_CSR_MIE_MSIE_OFFSET]            = csr2trace_mip_msip_i;\n    csr_trace1.mip[SCR1_CSR_MIE_MTIE_OFFSET]            = csr2trace_mip_mtip_i;\n    csr_trace1.mip[SCR1_CSR_MIE_MEIE_OFFSET]            = csr2trace_mip_meip_i;\nend\n\n`endif // SCR1_TRACE_LOG_EN\n\nendmodule : scr1_tracelog\n\n`endif // SCR1_TRGT_SIMULATION\n"}
