{"text": "/////////////////////////////////////////////////////////////////////////////////////\n//\n//Copyright 2019  Li Xinbing\n//\n//Licensed under the Apache License, Version 2.0 (the \"License\");\n//you may not use this file except in compliance with the License.\n//You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n//Unless required by applicable law or agreed to in writing, software\n//distributed under the License is distributed on an \"AS IS\" BASIS,\n//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//See the License for the specific language governing permissions and\n//limitations under the License.\n//\n/////////////////////////////////////////////////////////////////////////////////////\n\n`include \"define.v\"\nmodule alu (\n    input                                clk,\n\tinput                                rst,\n\n\tinput                                vld,\n    input `N(`XLEN)                      instr,\n\tinput `N(`EXEC_PARA_LEN)             para,\n    input `N(`XLEN)                      pc, \n  \n    output `N(`RGBIT)                    rs0_sel,\n    output `N(`RGBIT)                    rs1_sel,\n    input  `N(`XLEN)                     rs0_word,\n    input  `N(`XLEN)                     rs1_word,\n  \n    output `N(`RGBIT)                    rd_sel,\n    output `N(`XLEN)                     rd_data,\n\t\n    output                               mem_vld,\n    output `N(`MMBUF_PARA_LEN)           mem_para,\n    output `N(`XLEN)                     mem_addr,\n    output `N(`XLEN)                     mem_wdata\n\n);\n\n//---------------------------------------------------------------------------\n//signal defination\n//---------------------------------------------------------------------------\n    wire                      mem, alu;\n\twire `N(`RGBIT)           rd,rs1,rs0;\n\treg  `N(`XLEN)            operand1;\t\n\treg  `N(`XLEN)            operand2;\n\treg  `N(`XLEN)            rg_data;\n\treg  `N(`MMBUF_PARA_LEN)  lsu_para;\n\treg  `N(`XLEN)            mem_imm;\n\n\n//---------------------------------------------------------------------------\n//statements area\n//---------------------------------------------------------------------------\n\n\tassign { mem,alu,rd,rs1,rs0 } = para;\n\t\n\tassign rs0_sel = rs0;\n\t\n\tassign rs1_sel = rs1;\n\t\n\tassign rd_sel  = (vld & alu) ? rd : 0;\n\n\talways @*\n\tif ( instr[1:0]==2'b11 )\n\t    case( instr[6:2] )\n\t\t5'b00101,\n\t\t5'b11011,\n\t\t5'b11001 :  operand1 = pc;\n\t\tdefault  :  operand1 = rs0_word;\n\t\tendcase\n\telse if ( ({instr[15:13],instr[1:0]}==5'b001_01)| ( ({instr[15:13],instr[1:0]}==5'b100_10) & instr[12] & (instr[11:7]!=5'h0) & (instr[6:2]==5'h0) ) )\n\t    operand1 = pc;\n\telse\n\t    operand1 = rs0_word;\n\n\talways @*\n\tif ( instr[1:0]==2'b11 )\n\t    case( instr[6:2] )\n\t\t5'b01101,\n        5'b00101 : operand2 =  { instr[31:12],12'b0 };\n\t\t5'b11011,\n\t\t5'b11001 : operand2 =  4;\n\t\t5'b00100 : operand2 =  { {21{instr[31]}},instr[30:20] };\n\t\tdefault  : operand2 = rs1_word;\n\t\tendcase\n\telse case({instr[15:13],instr[1:0]}) \n\t    5'b000_00: operand2 = { instr[10:7],instr[12:11],instr[5],instr[6],2'b0 };\n\t\t5'b000_01,\n\t\t5'b010_01: operand2 = { {27{instr[12]}},instr[6:2] };\n\t\t5'b001_01: operand2 = 2;\n\t\t5'b011_01: operand2 = (instr[11:7]==5'd2) ?  { {23{instr[12]}},instr[4:3],instr[5],instr[2],instr[6],4'b0 } : { {15{instr[12]}},instr[6:2],12'b0};\n\t\t5'b100_01: operand2 = (instr[11:10]!=2'b11) ? { {27{instr[12]}},instr[6:2] } : rs1_word;\n        5'b000_10: operand2 = { {27{instr[12]}},instr[6:2] };\n        5'b100_10: operand2 = ( instr[12] & (instr[11:7]!=5'h0) & (instr[6:2]==5'h0) ) ? 2 : rs1_word;\n        default  : operand2 = rs1_word;\n        endcase\n\t\t\n    wire alu_sub = (instr[1:0]==2'b11) ? ((instr[6:2]==5'b01100)&instr[30]) : ({instr[15:13],instr[1:0]}==5'b100_01);\n\n    wire `N(`XLEN) add_out = alu_sub ? ( operand1 - operand2 ) : ( operand1 + operand2 );\n    wire `N(`XLEN) xor_out = operand1 ^ operand2;\n    wire `N(`XLEN) or_out  = operand1 | operand2;\n    wire `N(`XLEN) and_out = operand1 & operand2;\t\n   \n    wire alu_arith = (instr[1:0]==2'b11) ? instr[30]  : instr[10];\n   \twire `N(5)  shift_num = operand2[4:0];\n    wire `N(`XLEN) shift_left_out  = rs0_word<<shift_num;\n    wire `N(`XLEN) shift_right_out =  {{(`XLEN-1){alu_arith&rs0_word[`XLEN-1]}},rs0_word}>>shift_num;\n\t\n\talways @*\n\tif ( instr[1:0]==2'b11 )\n        if ( (instr[6:2]==5'b00100)|(instr[6:2]==5'b01100) )\n            case( instr[14:12] )\n\t        3'b000  : rg_data = add_out;\n\t        3'b010  : rg_data = (operand1[31]^operand2[31]) ? operand1[31] : (operand1<operand2);\n\t        3'b011  : rg_data = (operand1<operand2);\n\t        3'b100  : rg_data = xor_out;\n\t        3'b110  : rg_data = or_out;\n\t        3'b111  : rg_data = and_out;\n\t        3'b001  : rg_data = shift_left_out;\n\t        3'b101  : rg_data = shift_right_out;\n\t        default : rg_data = add_out;\n\t        endcase\n        else \n            rg_data = add_out;\n    else if ( {instr[15:13],instr[1:0]}==5'b100_01 )\n        case(instr[11:10])\n        2'b00 : rg_data = shift_right_out;\n        2'b01 : rg_data = shift_right_out;\n        2'b10 : rg_data = and_out;\n        2'b11 : case({instr[12],instr[6:5]})\n                3'b000 : rg_data = add_out;\n                3'b001 : rg_data = xor_out;\n                3'b010 : rg_data = or_out;\n                3'b011 : rg_data = and_out;\n                default: rg_data = add_out;\n                endcase\n        endcase\n    else if ( {instr[15:13],instr[1:0]}==5'b000_10 )\n        rg_data = shift_left_out;\n    else\n        rg_data = add_out;\n\n    assign rd_data = rg_data;\n\n\n    wire `N(`XLEN) mem_rs0_word = rs0_word;\n\twire `N(`XLEN) mem_rs1_word = rs1_word;\n\n    assign mem_vld = vld & mem;\n\t\n    always @*\n\tif ( instr[1:0]==2'b11 )\n\t\tif ( instr[6:4]==3'b011 ) //mul\n\t\t    lsu_para = { 1'b1, instr[11:7], 1'b0, instr[14:12] };\n\t    else\n\t        lsu_para = { (instr[5] ? 5'b0 : instr[11:7]), instr[5] ,instr[14:12] };\n\telse case({instr[15:13],instr[1:0]})\n        5'b010_00: lsu_para = { {2'b1,instr[4:2]}, 1'b0, 3'b010  };\n\t\t5'b110_00: lsu_para = {              5'h0, 1'b1, 3'b010  };\n\t\t5'b010_10: lsu_para = {       instr[11:7], 1'b0, 3'b010  };\n\t\t5'b110_10: lsu_para = {              5'h0, 1'b1, 3'b010  };\n\t\tdefault  : lsu_para = 0;\n\t\tendcase\t\t\n    \n    assign mem_para =  lsu_para;\n\t\n\talways @*\n\tif ( instr[1:0]==2'b11 )\n\t    if ( instr[6:4]==3'b011 )\n\t\t    mem_imm = 0;\n\t\telse \n\t        mem_imm = instr[5] ?  { {20{instr[31]}},instr[31:25],instr[11:7] } :  { {20{instr[31]}},instr[31:20] };\n\telse if ( instr[1:0]==2'b00 )\n        mem_imm = {instr[5],instr[12:10],instr[6],2'b0};\n    else\n        mem_imm = instr[15] ? {instr[8:7],instr[12:9],2'b0} : {instr[3:2],instr[12],instr[6:4],2'b0};\n\n\tassign mem_addr = mem_rs0_word + mem_imm;\t\n\n    assign mem_wdata = mem_rs1_word;\t\t\n\t\nendmodule"}
{"text": "/////////////////////////////////////////////////////////////////////////////////////\n//\n//Copyright 2019  Li Xinbing\n//\n//Licensed under the Apache License, Version 2.0 (the \"License\");\n//you may not use this file except in compliance with the License.\n//You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n//Unless required by applicable law or agreed to in writing, software\n//distributed under the License is distributed on an \"AS IS\" BASIS,\n//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//See the License for the specific language governing permissions and\n//limitations under the License.\n//\n/////////////////////////////////////////////////////////////////////////////////////\n\n\n`ifndef RTL_DEF\n`define RTL_DEF\n\n//`timescale 1 ns/1 ps\n\n//index definition\n`define IDX(x,y)    ((x)*(y))+:(y)\n`define N(n)        [(n)-1:0]\n\n//port ddefinition\n`define IN(n)       input [(n)-1:0]\n`define OUT(n)      output [(n)-1:0]\n`define OUTW(n)     output wire [(n)-1:0]\n`define OUTR(n)     output reg  [(n)-1:0]\n\n//wire & reg definition\n`define WIRE(n)    wire [(n)-1:0]\n`define REG(n)     reg  [(n)-1:0]\n\n//combanation logic definition\n`define COMB        always @*   \n\n//sequential logic definitiaon\n`define FF(clk)                         always @ ( posedge (clk) )\n`define FFpos(clk, rst,signal,bits)     always @ ( posedge clk or posedge  rst ) if (   rst   )  signal <= bits;  else\n`define FFneg(clk,rstn,signal,bits)     always @ ( posedge clk or negedge rstn ) if ( ~(rstn) )  signal <= bits;  else\n`define FFx(signal,bits)           always @ ( posedge clk or posedge  rst ) if (   rst   )  signal <= bits;  else\n\n//others\n`include \"define_para.v\"\n\n`endif\n"}
{"text": "/////////////////////////////////////////////////////////////////////////////////////\n//\n//Copyright 2019  Li Xinbing\n//\n//Licensed under the Apache License, Version 2.0 (the \"License\");\n//you may not use this file except in compliance with the License.\n//You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n//Unless required by applicable law or agreed to in writing, software\n//distributed under the License is distributed on an \"AS IS\" BASIS,\n//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//See the License for the specific language governing permissions and\n//limitations under the License.\n//\n/////////////////////////////////////////////////////////////////////////////////////\n\n//Below are simulation with the help of Syntacore SCR1, you can comment or uncomment  \n\n`define USE_SSRV                                         //comment for SCR1 core working; others SSRV do\n`define WIDE_INSTR_BUS                                   //SCR1 core simulation couldn't supply more than 32-bit BUS, if BUS_LEN is not 1, this defination should work. \n//`define BENCHMARK_LOG                                    //In benchmark test,there is a log for instructions execuated.\n`define INSTR_MISALLIGNED\n\n//-------------------------------------------------------------------------------\n// Recommended core architecture configurations (modifiable)\n//-------------------------------------------------------------------------------\n//4 or 5 stages implementation\n`define FETCH_REGISTERED \n\n//How many hardware multiplier/divider.\n`define MULT_NUM               3\n\n//-------------------------------------------------------------------------------\n//\"instrbits\" buffer\n//-------------------------------------------------------------------------------\n//The bus width of AHB-lite or AXI: 1 --- 32 bits  2 --- 64 bits, 4 ---- 128 bits. Only 2^x is allowed. If it is bigger than 1, WIDE_INSTR_BUS should be defined.\n`define BUFFER0_IN_LEN         4\n//How many words it holds:  1 --- 32 bits, 2 --- 64 bits. Any integer\n`define BUFFER0_BUF_LEN        8//(2*`BUFFER0_IN_LEN) \n//How many instructions are generated to the next stage. 1 --- 1 instr, 2 -- 2 instr, Any integer\n`define BUFFER0_OUT_LEN        4\n\n//-------------------------------------------------------------------------------\n//\"schedule\" buffer\n//-------------------------------------------------------------------------------\n//no IN_LEN, because it equals to BUFFER0_OUT_LEN\n//How many instructions are kept. 1 -- 1 instr, 2-- 2 instr, Any integer\n`define BUFFER1_BUF_LEN        6\n//How many instructions are generated for multiple exec units. 1-- 1 instr, 2 -- 2 instr, Any integer\n`define BUFFER1_OUT_LEN        3\n\n//-------------------------------------------------------------------------------\n//\"membuf\" buffer\n//-------------------------------------------------------------------------------\n//no IN_LEN, because it equals to BUFFER1_OUT_LEN\n//How many MEM instructions are kept. 1 -- 1 instr, 2-- 2 instr, Any integer\n`define BUFFER2_BUF_LEN        8//(2*`BUFFER1_OUT_LEN) \n//How many LSU/MUL instructions to be retired at the same clock, it could be 1 or 2 instructions.\n`define BUFFER2_OUT_LEN        2\n\n//-------------------------------------------------------------------------------\n//\"mprf\" buffer\n//-------------------------------------------------------------------------------\n//no IN_LEN, because it equals to BUFFER1_OUT_LEN\n//How many ALU instructions are kept. 1 -- 1 instr, 2-- 2 instr, Any integer. (2*`BUFFER1_OUT_LEN) is recommanded\n`define BUFFER3_BUF_LEN        8//(2*`BUFFER1_OUT_LEN) \n//How many ALU instructions are allowed to write to the register file in the same cycle, 1 -- 1 instr, 2-- 2 instr, Any integer, BUFFER1_OUT_LEN is recommanded\n`define BUFFER3_OUT_LEN        3//`BUFFER1_OUT_LEN\n\n\n\n\n\n\n\n//-------------------------------------------------------------------------------\n// Setting recommended configurations(Please make sure you know these defination)\n//-------------------------------------------------------------------------------\n\n//instrman.v\n`define XLEN                   32\n`define BUS_LEN                `BUFFER0_IN_LEN                                                //1->HRDATA[31:0]  2->HRDATA[63:0] 4->HRDATA[127:0], it should be 1,2,4,8,16... etc\n`define BUS_WID                (`BUS_LEN*`XLEN)                                               //1->HRDATA[31:0]  2->HRDATA[63:0] 4->HRDATA[127:0]  \n`ifdef INSTR_MISALLIGNED\n`define PC_ALIGN               {`XLEN{1'b1}}\n`else\n`define PC_ALIGN               ( ((1'b1<<`XLEN)-1)^( (1'b1<<($clog2(`BUS_LEN)+2))-1'b1 ) )    //1->FFFFFFFC 2->FFFFFFF8 4->FFFFFFF0\n`endif\n\n//predictor.v\n`define PDT_LEN                16\n`define PDT_OFF                $clog2(`PDT_LEN+1)\n`define PDT_ADDR               10\n`define PDT_BLEN               5\n\n//instrbits.v\n`define HLEN                   16\n`define BUS_OFF                $clog2(2*`BUS_LEN)\n`define INBUF_LEN              (2*`BUFFER0_BUF_LEN)\n`define INBUF_OFF              $clog2(`INBUF_LEN+1)\n`define JCBUF_LEN              5\n`define JCBUF_OFF              $clog2(`JCBUF_LEN+1)\n`define FETCH_LEN              `BUFFER0_OUT_LEN                                               \n`define FETCH_OFF              $clog2(`FETCH_LEN+1)      \n  \n//schedule.v\n`define RGBIT                  5\n`define RGLEN                  32\n`define SDBUF_LEN              `BUFFER1_BUF_LEN\n`define SDBUF_OFF              $clog2(`SDBUF_LEN+1)\n`define MMCMB_OFF              $clog2(`MMBUF_LEN+`SDBUF_LEN+1)\n`define EXEC_LEN               `BUFFER1_OUT_LEN\n`define EXEC_OFF               $clog2(`EXEC_LEN+1)\n`define FETCH_PARA_LEN         (11+3*`RGBIT)\n`define EXEC_PARA_LEN          (2+3*`RGBIT)\n`define LASTBIT_MASK           ( {`RGLEN{1'b1}}<<1 )\n\n//membuf.v\n`define MMBUF_LEN              `BUFFER2_BUF_LEN\n`define MMBUF_OFF              $clog2(`MMBUF_LEN+1)\n`define MMBUF_PARA_LEN         10\n`define MEM_LEN                `BUFFER2_OUT_LEN\n`define MEM_OFF                $clog2(`MEM_LEN+1)\n\n//mprf.v\n`define RFBUF_LEN              `BUFFER3_BUF_LEN\n`define RFBUF_OFF              $clog2(`RFBUF_LEN+1)\n`define RFINTO_LEN             `BUFFER3_OUT_LEN\n`define RFINTO_OFF             $clog2(`RFINTO_LEN+1)\n\n//mul.v\n`define MUL_LEN                `MULT_NUM\n`define MUL_OFF                ( (`MUL_LEN==1)+$clog2(`MUL_LEN) )//$clog2(`MUL_LEN+1)\n`define MULBUF_LEN             1\n`define MULBUF_OFF             $clog2(`MULBUF_LEN+1)\n\n//lsu.v\n`define LSUBUF_LEN             2\n`define LSUBUF_OFF             $clog2(`LSUBUF_LEN+1)\n"}
{"text": "/////////////////////////////////////////////////////////////////////////////////////\n//\n//Copyright 2019  Li Xinbing\n//\n//Licensed under the Apache License, Version 2.0 (the \"License\");\n//you may not use this file except in compliance with the License.\n//You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n//Unless required by applicable law or agreed to in writing, software\n//distributed under the License is distributed on an \"AS IS\" BASIS,\n//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//See the License for the specific language governing permissions and\n//limitations under the License.\n//\n/////////////////////////////////////////////////////////////////////////////////////\t\n\t\n    `define RV_PARA_LEN            (11+`RGBIT*3)\t\n\t\n\tfunction `N(`RV_PARA_LEN) rv_para(input `N(`XLEN) i,input err);\n\t    reg             illegal,mul,fencei,fence,sys,csr,jalr,jal,jcond,mem,alu;\n\t\treg `N(`RGBIT)  rd,rs1,rs0;\n\t    begin\n\t        illegal = 0;\n\t\t\tmul     = 0;\n\t\t\tfencei  = 0;\n\t\t\tfence   = 0;\n\t\t\tsys     = 0;\n\t\t\tcsr     = 0;\n\t\t\tjalr    = 0;\n\t\t\tjal     = 0;\n\t\t\tjcond   = 0;\n\t\t\tmem     = 0;\n\t\t\talu     = 0;\n\t\t\trd      = 0;\n\t\t\trs1     = 0;\n\t\t\trs0     = 0;\n\t\t\tif ( 1'b1 ) begin\n\t\t\t    if ( i[1:0]==2'b11 ) \n\t\t\t\t    case(i[6:2])\n\t\t\t\t\t5'b01101 :                        //LUI\n\t\t\t\t\t            begin\n\t\t\t\t\t\t            alu     = 1;\n\t\t\t\t\t\t        \trd      = i[11:7];\n\t\t\t\t\t\t        end\n\t\t\t\t\t5'b00101 :                        //AUIPC\n\t\t\t\t\t            begin\n\t\t\t\t\t\t            alu     = 1;\n\t\t\t\t\t\t        \trd      = i[11:7];\t\t\t\t\t\t    \n\t\t\t\t\t\t        end\n                    5'b11011 :                        //JAL\n                                begin\n\t\t\t\t\t\t            jal     = 1;\n\t\t\t\t\t\t        \trd      = i[11:7];                            \n                                end\n                    5'b11001 :                       //JALR\n                                begin\n\t\t\t\t\t\t            jalr    = 1;\n\t\t\t\t\t\t        \trd      = i[11:7];\n                                    rs0     = i[19:15];                            \n                                end\t\n                    5'b11000 :                       //BRANCH\n                                begin\n                                    jcond   = 1;\n\t\t\t\t\t\t\t\t\trs0     = i[19:15];\n\t\t\t\t\t\t\t\t\trs1     = i[24:20];\n                                end\t\t\t\t\t\t\t\t\n\t\t\t\t\t5'b00000 :                       //LOAD\n\t\t\t\t\t            begin\n\t\t\t\t\t                mem     = 1;\n\t\t\t\t\t\t\t\t\trd      = i[11:7];\n\t\t\t\t\t\t\t\t\trs0     = i[19:15];\n\t\t\t\t\t                illegal = (i[14:12]==3'b011)|(i[14:12]==3'b110)|(i[14:12]==3'b111);\n\t\t\t\t\t            end\n\t\t\t\t\t5'b01000 :                       //STORE\t\t\t\n\t\t\t\t\t            begin\n\t\t\t\t\t                mem     = 1;\n\t\t\t\t\t\t\t\t\trs0     = i[19:15];\n\t\t\t\t\t\t\t\t\trs1     = i[24:20];\n\t\t\t\t\t                illegal = (i[14:12]>=3'b011);\n\t\t\t\t\t            end\t\t\t\t\t\t\t\t\n\t\t\t\t\t5'b00100 :                       //OP_IMM\n                                begin\n\t\t\t\t\t                alu     = 1;\n\t\t\t\t\t\t\t\t\trd      = i[11:7];\n\t\t\t\t\t\t\t\t\trs0     = i[19:15];                                    \n                                    illegal = (i[14:12]==3'b001) ? (i[31:25]!=7'b0) : ( (i[14:12]==3'b101) ?  ( ~( (i[31:25]==7'b0000000)|(i[31:25]==7'b0100000) ) ) : 0 );\n                                end\t\n                    5'b01100 :                       //OP\n                                begin\n\t\t\t\t\t\t\t\t    mul     = i[25];\n\t\t\t\t\t                alu     = ~i[25];\n\t\t\t\t\t\t\t\t\trd      = i[11:7];\n\t\t\t\t\t\t\t\t\trs0     = i[19:15];       \n                                    rs1     = i[24:20];\t\t\t\t\t\t\t\t\t\n                                    if ( i[31:25]==7'b0000000 )\n\t\t\t\t\t\t\t\t\t    illegal = 0;\n\t\t\t\t\t\t\t\t\telse if ( i[31:25]==7'b0100000 )\n\t\t\t\t\t\t\t\t\t    illegal = ~( (i[14:12]==3'b000)|(i[14:12]==3'b101) );\n\t\t\t\t\t\t\t\t\telse if ( i[31:25]==7'b0000001 )\n\t\t\t\t\t\t\t\t\t    illegal = 0;\n\t\t\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\t\t    illegal = 1;\n                                end\t\n\t\t\t\t\t5'b00011 :                      //MISC_MEM\n\t\t\t\t\t            begin\n\t\t\t\t\t\t\t\t    fencei = i[12];\n\t\t\t\t\t\t\t\t\tfence  = ~i[12];\n\t\t\t\t\t\t\t\t\tif ( i[14:12]==3'b000 )\n\t\t\t\t\t\t\t\t\t    illegal = |{i[31:28], i[19:15], i[11:7]};\n\t\t\t\t\t\t\t\t    else if ( i[14:12]==3'b001 )\n\t\t\t\t\t\t\t\t\t    illegal = |{i[31:15], i[11:7]};\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t    illegal = 1;\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t5'b11100 :                    //ECALL/EBREAK/CSRR\n\t\t\t\t\t            begin\n\t\t\t\t\t\t\t\t    if ( i[14:12]==3'b000 ) begin\n\t\t\t\t\t\t\t\t\t    sys     = 1;\n\t\t\t\t\t\t\t\t\t\tif ( {i[19:15], i[11:7]}==10'b0 )\n\t\t\t\t\t\t\t\t\t\t    illegal = ~( (i[31:20]==12'h000)|(i[31:20]==12'h001)|(i[31:20]==12'h302)|(i[31:20]==12'h105) );\n\t\t\t\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\t\t\t    illegal = 1;\n\t\t\t\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\t\t\t    csr     = 1;\n\t\t\t\t\t\t\t\t\t\trd      = i[11:7];\n\t\t\t\t\t\t\t\t\t\trs0     = i[14] ? 5'h0 : i[19:15];\n\t\t\t\t\t\t\t\t\t    illegal = (i[14:12]==3'b100);\n\t\t\t\t\t\t\t\t    end\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\tdefault  :  illegal = 1;\t\t\t\n\t\t\t\t\tendcase\n\t\t\t\telse  case({i[15:13],i[1:0]})                                            \n                    5'b000_00:   //C.ADDI4SPN\n\t\t\t\t\t            begin\n\t\t\t\t\t\t\t\t    alu     = 1;\n\t\t\t\t\t\t\t\t\trd      = {2'b1,i[4:2]};\n\t\t\t\t\t\t\t\t\trs0     = 5'h2;\n\t\t\t\t\t\t\t\t\tillegal = ~(|i[12:5]);\n\t\t\t\t\t\t\t\tend\n                    5'b010_00:   //C.LW\n\t\t\t\t\t            begin\n\t\t\t\t\t\t\t\t    mem     = 1;\n\t\t\t\t\t\t\t\t\trd      = {2'b1,i[4:2]};\n\t\t\t\t\t\t\t\t\trs0     = {2'b1,i[9:7]};\n\t\t\t\t\t\t\t\tend\n                    5'b110_00:   //C.SW\n\t\t\t\t\t            begin\n\t\t\t\t\t\t\t\t    mem     = 1;\n\t\t\t\t\t\t\t\t\trs0     = {2'b1,i[9:7]};\n\t\t\t\t\t\t\t\t\trs1     = {2'b1,i[4:2]};\n\t\t\t\t\t\t\t\tend\n                    5'b000_01:   //C.ADDI\n                                begin\n                                    alu     = 1;\n\t\t\t\t\t\t\t\t\trd      = i[11:7];\n\t\t\t\t\t\t\t\t\trs0     = i[11:7];\n                                end\t\t\t\t\t\t\t\t\n                    5'b001_01:   //C.JAL\t\n                                begin\n                                    jal     = 1;\n\t\t\t\t\t\t\t\t\trd      = 5'h1;\n                                end\t\t\t\t\t\t\t\t\n                    5'b010_01:   //C.LI\n\t\t\t\t\t            begin\n\t\t\t\t\t\t\t\t    alu     = 1;\n\t\t\t\t\t\t\t\t\trd      = i[11:7];\n\t\t\t\t\t\t\t\tend\n                    5'b011_01:   //C.ADDI16SP/C.LUI\n                                begin\n\t\t\t\t\t\t\t\t    alu     = 1;\n\t\t\t\t\t\t\t\t\trd      = i[11:7];\n\t\t\t\t\t\t\t\t\trs0     = (i[11:7]==5'h2) ? 5'h2 : 5'h0;\n\t\t\t\t\t\t\t\t\tillegal = ~(|{i[12], i[6:2]});\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t5'b100_01:  \n             \t\t\t\t\tif (i[11:10]!=2'b11)      //C.SRLI/C.SRAI/C.ANDI\n                                    begin\n\t\t\t\t\t\t\t\t        alu     = 1;\n\t\t\t\t\t\t\t\t\t\trd      = {2'b1,i[9:7]};\n\t\t\t\t\t\t\t\t\t\trs0     = {2'b1,i[9:7]};\n\t\t\t\t\t\t\t\t\t\tillegal = ~i[11] & i[12];\n\t\t\t\t\t\t\t\t    end\n\t\t\t\t\t\t\t\telse //C.SUB/C.XOR/C.OR/C.AND\n\t\t\t\t\t\t\t\t    begin\n\t\t\t\t\t\t\t\t\t    alu     = 1;\n\t\t\t\t\t\t\t\t\t\trd      = {2'b1,i[9:7]};\n\t\t\t\t\t\t\t\t\t\trs0     = {2'b1,i[9:7]};\n\t\t\t\t\t\t\t\t\t\trs1     = {2'b1,i[4:2]};\n\t\t\t\t\t\t\t\t\t\tillegal = i[12];\n\t\t\t\t\t\t\t\t\tend\n                    5'b101_01:   //C.J\n\t\t\t\t\t            begin\n\t\t\t\t\t\t\t\t    jal     = 1;\n\t\t\t\t\t\t\t\tend\n                    5'b110_01,                                                                                                           \n                    5'b111_01:   //C.BEQZ/C.BNEZ\n\t\t\t\t\t            begin\n\t\t\t\t\t\t\t\t    jcond   = 1;\n\t\t\t\t\t\t\t\t\trs0     = {2'b1,i[9:7]};\n\t\t\t\t\t\t\t\tend\n                    5'b000_10:   //C.SLLI\n\t\t\t\t\t            begin\n\t\t\t\t\t\t\t\t    alu     = 1;\n\t\t\t\t\t\t\t\t\trd      = i[11:7];\n\t\t\t\t\t\t\t\t\trs0     = i[11:7];\n\t\t\t\t\t\t\t\t\tillegal = i[12];\n\t\t\t\t\t\t\t\tend\n                    5'b010_10:   //C.LWSP\n\t\t\t\t\t            begin\n\t\t\t\t\t\t\t\t    mem     = 1;\n\t\t\t\t\t\t\t\t\trd      = i[11:7];\n\t\t\t\t\t\t\t\t\trs0     = 5'h2;\n\t\t\t\t\t\t\t\t\tillegal = ~(|i[11:7]);\n\t\t\t\t\t\t\t\tend\n                    5'b100_10:   \n\t\t\t\t\t            if ( ~i[12] & (i[6:2]==5'h0) ) //C.JR\n\t\t\t\t\t\t\t\t    begin\n                                        jalr    = 1;\n\t\t\t\t\t\t\t\t\t\trs0     = i[11:7];\n                                        illegal = ~(|i[11:7]);\n                                    end\t\t\t\t\t\t\t\t\t\n                                else if ( ~i[12] & (i[6:2]!=5'h0)  )  //C.MV\n                                    begin\n\t\t\t\t\t\t\t\t\t    alu     = 1;\n\t\t\t\t\t\t\t\t\t\trd      = i[11:7];\n\t\t\t\t\t\t\t\t\t\trs1     = i[6:2];\n\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\telse if((i[11:7]==5'h0)&(i[6:2]==5'h0)) //C.EBREAK\n\t\t\t\t\t\t\t\t    begin\n\t\t\t\t\t\t\t\t\t    sys      = 1;\n\t\t\t\t\t\t\t\t\tend\n                                else if (i[6:2]==5'h0)        //C.JALR\n                                    begin\n\t\t\t\t\t\t\t\t\t    jalr     = 1;\n\t\t\t\t\t\t\t\t\t\trd       = 5'h1;\n\t\t\t\t\t\t\t\t\t\trs0      = i[11:7];\n\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\telse                 //C.ADD \n\t\t\t\t\t\t\t\t    begin\n                                        alu      = 1;\n\t\t\t\t\t\t\t\t\t\trd       = i[11:7];\n\t\t\t\t\t\t\t\t\t\trs0      = i[11:7];\n\t\t\t\t\t\t\t\t\t\trs1      = i[6:2];\n                                    end\t\t\t\t\t\t\t\t\t\n                    5'b110_10:   //C.SWSP\n\t\t\t\t\t            begin\n\t\t\t\t\t\t\t\t    mem       = 1;\n\t\t\t\t\t\t\t\t\trs0       = 5'h2;\n\t\t\t\t\t\t\t\t\trs1       = i[6:2];\n\t\t\t\t\t\t\t\tend\n                    default  :  illegal = 1;\n                    endcase\n\t        end \n\t\t\trv_para = { err,illegal,sys,fencei,fence,csr,jalr,jal,jcond,(mem|mul),(alu|jal|jalr),rd,rs1,rs0 };\n\t    end\n\tendfunction\n\t\n\t\n    function `N(`XLEN) jal_offset(input `N(`XLEN) instr);\n        begin\n            if ( instr[1:0]==2'b11 )\n\t    \t    jal_offset = { {12{instr[31]}},instr[19:12],instr[20],instr[30:21],1'b0 };\n\t    \telse\n\t    \t    jal_offset = { {21{instr[12]}},instr[8],instr[10:9],instr[6],instr[7],instr[2],instr[11],instr[5:3],1'b0 }; \n        end\n    endfunction\t  \n\n    function `N(`XLEN) jalr_offset(input `N(`XLEN) instr);\n        begin\n            if ( instr[1:0]==2'b11 )\n\t    \t    jalr_offset = { {21{instr[31]}},instr[30:20] };\n\t    \telse\n\t    \t    jalr_offset = 32'h0; \n        end\n    endfunction\t\n\t\n    function `N(`XLEN) jcond_offset(input `N(`XLEN) instr);\n        begin\n            if ( instr[1:0]==2'b11 )\n\t    \t    jcond_offset = { {20{instr[31]}},instr[7],instr[30:25],instr[11:8],1'b0 };\n\t    \telse\n\t    \t    jcond_offset = { {24{instr[12]}},instr[6:5],instr[2],instr[11:10],instr[4:3],1'b0};\t \n        end\n    endfunction\t\t\n\t\n\tfunction `N(`MMCMB_OFF) sub_order(input `N(`MMCMB_OFF) n, input `N(`MEM_OFF) x);\n\t    begin\n\t\t    sub_order = (n<x) ? 0 : (n-x);\n\t\tend\n\tendfunction\n\t\n\tfunction `N(`JCBUF_OFF) sub_level(input `N(`JCBUF_OFF) n, input x);\n\t    begin\n\t\t    sub_level = (n==0) ? 0 : (n-x);\n\t\tend\n\tendfunction\n\t\n    function condition_satisfied( input `N(4) para, input `N(`XLEN) rs0_word, rs1_word );\n\tbegin\n        if ( para[3] )\n            case(para[2:0])\n            3'b000 : condition_satisfied =    rs0_word==rs1_word;\n            3'b001 : condition_satisfied = ~( rs0_word==rs1_word );\n            3'b100 : condition_satisfied =    (rs0_word[31]^rs1_word[31]) ? rs0_word[31] : (rs0_word<rs1_word);\n            3'b101 : condition_satisfied = ~( (rs0_word[31]^rs1_word[31]) ? rs0_word[31] : (rs0_word<rs1_word) );\n            3'b110 : condition_satisfied =    rs0_word<rs1_word;\n            3'b111 : condition_satisfied = ~( rs0_word<rs1_word );\n            default: condition_satisfied = 1'b0;\n            endcase\n        else if ( para[1] )\n            condition_satisfied = rs0_word != rs1_word;\n        else\n            condition_satisfied = rs0_word == rs1_word;  \t\n\tend\n\tendfunction\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t"}
{"text": "/////////////////////////////////////////////////////////////////////////////////////\n//\n//Copyright 2020  Li Xinbing\n//\n//Licensed under the Apache License, Version 2.0 (the \"License\");\n//you may not use this file except in compliance with the License.\n//You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n//Unless required by applicable law or agreed to in writing, software\n//distributed under the License is distributed on an \"AS IS\" BASIS,\n//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//See the License for the specific language governing permissions and\n//limitations under the License.\n//\n/////////////////////////////////////////////////////////////////////////////////////\n\n`include \"define.v\"\nmodule instrbits\n(\n    input                                 clk,\n    input                                 rst,\n\n    input                                 jump_vld,\n\tinput  `N(`XLEN)                      jump_pc,\t\n    output                                branch_vld,\n\toutput `N(`XLEN)                      branch_pc,\t\n    output                                buffer_free,\t\n\n    input                                 instr_vld,\n    input  `N(`BUS_WID)                   instr_data,\n\tinput                                 instr_err,\t\n\tinput  `N(2*`BUS_LEN)                 instr_predict,\n\t\n\toutput                                jcond_vld,\n\toutput `N(`XLEN)                      jcond_pc,\n\toutput                                jcond_hit,\n\toutput                                jcond_taken,\t\n\t\n\toutput                                sys_vld,\n\toutput `N(`XLEN)                      sys_instr,\n\toutput `N(`XLEN)                      sys_pc,\n\toutput `N(4)                          sys_para,\n\t\n\toutput                                csr_vld,\n\toutput `N(`XLEN)                      csr_instr,\n\toutput `N(`XLEN)                      csr_rs,\n\toutput `N(`RGBIT)                     csr_rd_sel,\n\t \n    output `N(`RGBIT)                     rs0_sel,\n\toutput `N(`RGBIT)                     rs1_sel,\n\tinput  `N(`XLEN)                      rs0_word,\n\tinput  `N(`XLEN)                      rs1_word,\n\n    input  `N(`SDBUF_OFF)                 sdbuf_left_num,\n\toutput `N(`FETCH_LEN)                 fetch_vld,\n    output `N(`FETCH_LEN*`XLEN)           fetch_instr,\n\toutput `N(`FETCH_LEN*`XLEN)           fetch_pc,\n    output `N(`FETCH_LEN*`EXEC_PARA_LEN)  fetch_para,\n\toutput `N(`FETCH_LEN*`JCBUF_OFF)      fetch_level,\n\t\n\tinput  `N(`RGLEN)                     pipeline_instr_rdlist,\n\tinput                                 pipeline_is_empty,\n\t\n\toutput                                level_decrease,\n\toutput                                level_clear\n\n\n);\n\n    //---------------------------------------------------------------------------\n    //function defination\n    //---------------------------------------------------------------------------\n\n    `include \"include_func.v\"\n\t\n    //---------------------------------------------------------------------------\n    //signal defination\n    //---------------------------------------------------------------------------\n\t\n\twire  `N(`RGLEN)                      fetch_instr_rdlist;\n\twire  `N(`FETCH_OFF)                  fetch_length;\n\twire                                  fetch_is_empty;\n\t\n\twire                                  jalr_vld;\n\twire  `N(`XLEN)                       jalr_instr;\n\twire                                  jalr_rs0_valid;\n\t\t\n\t\n\twire  `N(`INBUF_OFF)                  eval_start              `N(`FETCH_LEN+1);\n    wire                                  following_bypass        `N(`FETCH_LEN+1);\n\n\twire  `N(`FETCH_LEN)                  eval_vld; \n\twire  `N(`FETCH_LEN*`XLEN)            eval_instr;\n\twire  `N(`FETCH_LEN*`XLEN)            eval_pc;\n\twire  `N(`FETCH_LEN*`EXEC_PARA_LEN)   eval_para;\n    wire  `N(`FETCH_LEN*`JCBUF_OFF)       eval_level;\t\n\twire  `N(`FETCH_OFF)                  eval_length             `N(`FETCH_LEN+1);\n\twire  `N(`INBUF_OFF)                  eval_offset             `N(`FETCH_LEN+1);\t\n\t\n\twire                                  jcget_vld               `N(`FETCH_LEN+1);\n\twire  `N(`XLEN)                       jcget_instr             `N(`FETCH_LEN+1);\n\twire  `N(`XLEN)                       jcget_pc                `N(`FETCH_LEN+1);\n\twire  `N(`RGBIT)                      jcget_rs0               `N(`FETCH_LEN+1);\n\twire  `N(`RGBIT)                      jcget_rs1               `N(`FETCH_LEN+1);\n\twire                                  jcget_predict           `N(`FETCH_LEN+1);\n\t\n\twire                                  chain_bnch_initial      `N(`FETCH_LEN+1);\n\twire  `N(`XLEN)                       chain_bnch_instr        `N(`FETCH_LEN+1);\n\twire  `N(`XLEN)                       chain_bnch_pc           `N(`FETCH_LEN+1);\n\twire                                  chain_bnch_jal          `N(`FETCH_LEN+1);\t\n\t\n\treg   `N(`INBUF_LEN*`HLEN)            inbuf_bits;\n\treg   `N(`INBUF_LEN)                  inbuf_err;\n\treg   `N(`INBUF_LEN)                  inbuf_predict;\n    reg   `N(`INBUF_OFF)                  inbuf_length;\n\treg   `N(`XLEN)                       inbuf_pc;\t\n\t\n    reg   `N(`JCBUF_LEN*`XLEN)            jcbuf_instr;\n\treg   `N(`JCBUF_LEN*`XLEN)            jcbuf_pc;\n\treg   `N(`JCBUF_LEN*`RGBIT)           jcbuf_rs0;\n\treg   `N(`JCBUF_LEN*`RGBIT)           jcbuf_rs1;\n\treg   `N(`JCBUF_LEN)                  jcbuf_predict;\n\treg   `N(`JCBUF_OFF)                  jcbuf_length;\n\n    genvar i,j;\n    //---------------------------------------------------------------------------\n    //statement description\n    //---------------------------------------------------------------------------\n\n    //---------------------------------------------------------------------------\n\t//prepare incoming data\n\t//---------------------------------------------------------------------------\n\n`ifdef INSTR_MISALLIGNED\n   \n    wire  `N(`BUS_OFF)                    instr_offset = 0;\n\n`else\n\n    reg   `N(`BUS_OFF)                    instr_offset;\t\n   \n    //to remove redundant part of line_data\n\t`FFx(instr_offset,0)\n\tif ( jump_vld )\n\t    instr_offset <= jump_pc[`BUS_OFF:1];\n\telse if ( branch_vld )\n\t    instr_offset <= branch_pc[`BUS_OFF:1];\n\telse if ( instr_vld )\n\t    instr_offset <= 0;\n\telse;\n \n`endif \n\t\n    wire `N(`BUS_WID)                     imem_data = instr_vld ? ( instr_data>>(instr_offset*`HLEN) ) : 0; \t\n\twire `N(2*`BUS_LEN)                    imem_err = instr_vld ? ( { (2*`BUS_LEN){instr_err} }>>instr_offset ) : 0;\n\twire `N(2*`BUS_LEN)                imem_predict = instr_vld ? ( instr_predict>>instr_offset ) : 0;\n    wire `N(`BUS_OFF+1)                 imem_length = instr_vld ? ( (2*`BUS_LEN) - instr_offset ) : 0;\t\n\n\n    //---------------------------------------------------------------------------\n\t//inbuf processing\n\t//---------------------------------------------------------------------------\n\n    wire `N(`INBUF_LEN*`HLEN)            inall_bits = inbuf_bits|(imem_data<<(inbuf_length*`HLEN));\n    wire `N(`INBUF_LEN)                   inall_err = inbuf_err|(imem_err<<inbuf_length);\n\twire `N(`INBUF_LEN)               inall_predict = inbuf_predict|(imem_predict<<inbuf_length);\n    wire `N(`INBUF_OFF)                inall_length = inbuf_length + imem_length;\n\n    wire                           leading_is_empty = pipeline_is_empty & fetch_is_empty;\n\n\twire `N(`RGLEN)                  leading_rdlist = (pipeline_instr_rdlist | fetch_instr_rdlist) & `LASTBIT_MASK;\n\twire `N(`RGBIT)                        jalr_rs0 = gen_inbuf[0].rs0;\n\twire                       jalr_rs0_invalid_bit = leading_rdlist>>jalr_rs0;\n\tassign                           jalr_rs0_valid = ~jalr_rs0_invalid_bit;\t\n\n\twire                           no_cond_assuming = ( jcbuf_length==0 );\n\n\twire `N(`FETCH_OFF)               eval_capacity = ( sdbuf_left_num>=fetch_length ) ? `FETCH_LEN : (`FETCH_LEN - fetch_length + sdbuf_left_num);\n\t\n    assign                            eval_start[0] = 0;\n\tassign                      following_bypass[0] = 0;\n\tassign                           eval_length[0] = 0;\n\tassign                           eval_offset[0] = 0;\n\n\tassign                             jcget_vld[0] = jcbuf_length==`JCBUF_LEN;\n\tassign                           jcget_instr[0] = 0;\n\tassign                              jcget_pc[0] = 0;\n\tassign                             jcget_rs0[0] = 0;\n\tassign                             jcget_rs1[0] = 0;\n\tassign                         jcget_predict[0] = 0;\n\t\n\tassign                    chain_bnch_initial[0] = 0;\n\tassign                      chain_bnch_instr[0] = 0;\n\tassign                         chain_bnch_pc[0] = 0;\n\tassign                        chain_bnch_jal[0] = 0;\n\n\n\t//rv_para = { err,illegal,sys,fencei,fence,csr,jalr,jal,jcond,(mem|mul),alu,rd,rs1,rs0 };\n    generate\n\tfor (i=0;i<`FETCH_LEN;i=i+1) begin:gen_inbuf\n\t    //basic info\n\t\twire `N(`XLEN)                        instr = inall_bits>>(eval_start[i]*`HLEN);\n\t\tassign                      eval_start[i+1] = eval_start[i] + ((instr[1:0]==2'b11) ? 2'b10 : 2'b1);\n\t    wire                                    vld = (i<eval_capacity)&(eval_start[i+1]<=inall_length);\n\t\twire `N(`XLEN)                           pc = inbuf_pc + (eval_start[i]<<1);\n\t\twire `N(2)                             errs = inall_err>>eval_start[i];\n\t\twire                                    err = (instr[1:0]==2'b11) ? ( |errs ) : errs[0];\n\t\twire `N(2)                          predict = inall_predict>>eval_start[i];\n\t\t\n\t\t//parameter\n        wire `N(`FETCH_PARA_LEN)               para = rv_para(instr,err);\n\t\twire `N(`RGBIT)                         rs0 = para;\n\t\twire `N(`RGBIT)                         rs1 = para>>`RGBIT;\n\t\twire `N(`RGBIT)                          rd = para>>(2*`RGBIT);\n\t\twire `N(9)                            point = para>>`EXEC_PARA_LEN;\n        wire                                  jcond = point;\n\t\twire                                    jal = point>>1;\n\t\twire                                   jalr = point>>2;\n\t\twire                                    csr = point>>3;\n\t\twire                                  fence = point>>4;\n\t\twire                                    sys = |(point>>5);\n\t\t\n\t\t//variable\n\t\twire                           sys_approved = (i==0) ? ( no_cond_assuming & leading_is_empty ) : 0;\n        wire                          jalr_approved = (i==0) ? ( no_cond_assuming & jalr_rs0_valid ) : 0; \t\t\t\n\t\twire                                 bypass = sys|( (fence|csr) & ~sys_approved )|jalr|jal|( jcond & (jcget_vld[i]|predict) );\t\n        wire                                  leave = bypass ? ( (jalr & jalr_approved)|jal ) : 1'b1;\n\t\tassign                following_bypass[i+1] = following_bypass[i]|(vld & bypass);\t\t\t\t\n\t\t\n\t\t//eval output\t\t\t\n\t\tassign                          eval_vld[i] = vld & leave & ~following_bypass[i];\n\t\tassign            eval_instr[`IDX(i,`XLEN)] = instr;\n\t\tassign               eval_pc[`IDX(i,`XLEN)] = pc;\n\t\tassign    eval_para[`IDX(i,`EXEC_PARA_LEN)] = para;\t\t\n\t\tassign       eval_level[`IDX(i,`JCBUF_OFF)] = (jcbuf_length==`JCBUF_LEN) ? `JCBUF_LEN : (jcbuf_length + jcget_vld[i]);\n\t\tassign                     eval_length[i+1] = eval_vld[i] ? (i+1) : eval_length[i];\n\t\tassign                     eval_offset[i+1] = eval_vld[i] ? ( eval_start[i+1] ) : eval_offset[i];\t\t\n\t\n        //jcget output\n\t\twire                            jcget_occur = vld & jcond & ~jcget_vld[i] & ~following_bypass[i];\n        assign                       jcget_vld[i+1] = jcget_vld[i]|jcget_occur; \t\t\n\t    assign                     jcget_instr[i+1] = jcget_occur ? instr : jcget_instr[i];\n\t\tassign                        jcget_pc[i+1] = jcget_occur ? pc : jcget_pc[i];\n\t\tassign                       jcget_rs0[i+1] = jcget_occur ? rs0 : jcget_rs0[i];\n\t\tassign                       jcget_rs1[i+1] = jcget_occur ? rs1 : jcget_rs1[i];\n\t\tassign                   jcget_predict[i+1] = jcget_occur ? predict : jcget_predict[i];\t\n\t\n        //branch output\n\t\twire                           branch_occur = vld & (jal|(jcond & ~jcget_vld[i] & predict)) & ~following_bypass[i];\n\t    assign              chain_bnch_initial[i+1] = chain_bnch_initial[i]|branch_occur;\n\t\tassign                chain_bnch_instr[i+1] = branch_occur ? instr : chain_bnch_instr[i];\n        assign                   chain_bnch_pc[i+1] = branch_occur ? pc : chain_bnch_pc[i];\n\t\tassign                  chain_bnch_jal[i+1] = branch_occur ? jal : chain_bnch_jal[i];\n\tend\n\tendgenerate\n\t\n\tassign                                  sys_vld = gen_inbuf[0].vld & gen_inbuf[0].sys & gen_inbuf[0].sys_approved;\n\tassign                                sys_instr = gen_inbuf[0].instr;\n\tassign                                   sys_pc = gen_inbuf[0].pc;\n\tassign                                 sys_para = (gen_inbuf[0].point>>5); \n\t\n\tassign                                  csr_vld = gen_inbuf[0].vld & gen_inbuf[0].csr & gen_inbuf[0].sys_approved;\n\tassign                                csr_instr = gen_inbuf[0].instr;\n\tassign                               csr_rd_sel = gen_inbuf[0].rd;\n\tassign                                   csr_rs = rs0_word;\t\n\n\tassign                                 jalr_vld = gen_inbuf[0].vld & gen_inbuf[0].jalr & gen_inbuf[0].jalr_approved;\n\tassign                               jalr_instr = gen_inbuf[0].instr;\n\t\n\twire `N(`INBUF_OFF)                inbuf_offset = eval_offset[`FETCH_LEN];\n\t\n\t`FFx(inbuf_bits,0)\n\tinbuf_bits <= ( jump_vld|branch_vld ) ? 0 : ( inall_bits>>(inbuf_offset*`HLEN) );\n\n    `FFx(inbuf_err,0)\n    inbuf_err <= ( jump_vld|branch_vld ) ? 0 : ( inall_err>>inbuf_offset );\n\t\n\t`FFx(inbuf_predict,0)\n\tinbuf_predict <= ( jump_vld|branch_vld ) ? 0 : ( inall_predict>>inbuf_offset );\t\n\t\n\t`FFx(inbuf_length,0)\n\tinbuf_length <= ( jump_vld|branch_vld ) ? 0 : ( inall_length - inbuf_offset );\n\t\n\t`FFx(inbuf_pc,0)\n\tinbuf_pc <= jump_vld ? jump_pc : ( branch_vld ? branch_pc : ( inbuf_pc + (inbuf_offset<<1) ) );\n\n    //---------------------------------------------------------------------------\n\t//jcbuf evaluation\n\t//---------------------------------------------------------------------------\t\n\t\n\twire `N(`XLEN)                       jcin_instr = jcget_instr[`FETCH_LEN];\n\twire `N(`XLEN)                          jcin_pc = jcget_pc[`FETCH_LEN];\n\twire `N(`RGBIT)                        jcin_rs0 = jcget_rs0[`FETCH_LEN];\n\twire `N(`RGBIT)                        jcin_rs1 = jcget_rs1[`FETCH_LEN];\n\twire                               jcin_predict = jcget_predict[`FETCH_LEN];\n\twire                                jcin_length = jcget_vld[`FETCH_LEN];\n\t\n\twire `N(`JCBUF_LEN*`XLEN)           jcall_instr = jcbuf_instr|( jcin_instr<<(jcbuf_length*`XLEN) );\n\twire `N(`JCBUF_LEN*`XLEN)              jcall_pc = jcbuf_pc|( jcin_pc<<(jcbuf_length*`XLEN) );\n\twire `N(`JCBUF_LEN*`RGBIT)            jcall_rs0 = jcbuf_rs0|( jcin_rs0<<(jcbuf_length*`RGBIT) );\n\twire `N(`JCBUF_LEN*`RGBIT)            jcall_rs1 = jcbuf_rs1|( jcin_rs1<<(jcbuf_length*`RGBIT) );\n\twire `N(`JCBUF_LEN)               jcall_predict = jcbuf_predict|( jcin_predict<<jcbuf_length );\n\twire `N(`JCBUF_OFF)                jcall_length = ( jcbuf_length==`JCBUF_LEN ) ? `JCBUF_LEN : ( jcbuf_length + jcin_length );\n\t\n\twire `N(`XLEN)                      jcout_instr = jcbuf_instr;\n\twire `N(`XLEN)                         jcout_pc = jcbuf_pc;\n\twire `N(`RGBIT)                       jcout_rs0 = jcbuf_rs0;\n\twire `N(`RGBIT)                       jcout_rs1 = jcbuf_rs1;\n\twire                              jcout_predict = jcbuf_predict;\n\t\n\tassign                                  rs0_sel = no_cond_assuming ? jalr_rs0 : jcout_rs0;\n    assign                                  rs1_sel = jcout_rs1;\n    wire                          jcond_rs0_invalid = leading_rdlist>>jcout_rs0;\n    wire                          jcond_rs1_invalid = leading_rdlist>>jcout_rs1;\n\twire                           jcond_rs_invalid = jcond_rs0_invalid|jcond_rs1_invalid;\n\twire                                jcond_valid = (jcbuf_length!=0) & ~jcond_rs_invalid;\n\t\n\twire `N(4)                           jcond_para = { (jcout_instr[1:0]==2'b11),jcout_instr[14:12] };\n\twire                               jcond_result = condition_satisfied(jcond_para,rs0_word,rs1_word);\n\n\twire                             jcond_decrease = jcond_valid & ( jcout_predict==jcond_result ); \n\twire                                jcond_clear = jcond_valid & ( jcout_predict!=jcond_result ); \n\twire `N(`XLEN)                 jcond_clear_true = jcout_pc + jcond_offset(jcout_instr);\n\twire `N(`XLEN)                jcond_clear_false = jcout_pc + ( (jcout_instr[1:0]==2'b11) ? 3'h4 : 3'h2 );\n\twire `N(`XLEN)                   jcond_clear_pc = jcond_result ? jcond_clear_true : jcond_clear_false; \n\t\n    assign                           level_decrease = jcond_decrease;\n    assign                              level_clear = jcond_clear;\n\n\t`FFx(jcbuf_instr,0)\n\tjcbuf_instr <= ( jump_vld|level_clear ) ? 0 : ( jcall_instr>>(jcond_valid*`XLEN) );\n\t\n\t`FFx(jcbuf_pc,0)\n\tjcbuf_pc <= ( jump_vld|level_clear ) ? 0 : ( jcall_pc>>(jcond_valid*`XLEN) );\n\t\n\t`FFx(jcbuf_rs0,0)\n\tjcbuf_rs0 <= ( jump_vld|level_clear ) ? 0 : ( jcall_rs0>>(jcond_valid*`RGBIT) );\n\t\n\t`FFx(jcbuf_rs1,0)\n\tjcbuf_rs1 <= ( jump_vld|level_clear ) ? 0 : ( jcall_rs1>>(jcond_valid*`RGBIT) );\t\n\t\n    `FFx(jcbuf_predict,0)\n\tjcbuf_predict <=  ( jump_vld|level_clear ) ? 0 : ( jcall_predict>>jcond_valid );\n\t\n\t`FFx(jcbuf_length,0)\n\tjcbuf_length <=  ( jump_vld|level_clear ) ? 0 : ( jcall_length - jcond_valid );\n\t\n  \n\tassign                                jcond_vld = jcond_valid;\n\tassign                                 jcond_pc = jcout_pc;\n\tassign                                jcond_hit = ( jcout_predict==jcond_result );\n\tassign                              jcond_taken = jcond_result;\t\n\t\n    //---------------------------------------------------------------------------\n\t//fetch preparation\n\t//---------------------------------------------------------------------------\t\n\n`ifdef FETCH_REGISTERED\n\treg  `N(`FETCH_LEN)                 dump_vld;\n    reg  `N(`FETCH_LEN*`XLEN)           dump_instr;\n\treg  `N(`FETCH_LEN*`XLEN)           dump_pc;\n    reg  `N(`FETCH_LEN*`EXEC_PARA_LEN)  dump_para;\n\treg  `N(`FETCH_LEN*`JCBUF_OFF)      dump_level;\n\treg  `N(`FETCH_LEN*`RGLEN)          dump_instr_rdlist;\n\treg  `N(`FETCH_OFF)                 dump_length;\n\t\n\twire `N(`FETCH_OFF)                  dump_drop_offset = ( sdbuf_left_num>=dump_length ) ? dump_length : sdbuf_left_num;\n\twire `N(`FETCH_OFF)                  dump_left_offset = ( sdbuf_left_num>=dump_length ) ? 0 : ( dump_length - sdbuf_left_num );\n\t\n\twire `N(`FETCH_LEN)                        dumpin_vld = ( dump_vld>>dump_drop_offset )|(eval_vld<<dump_left_offset);     \n\twire `N(`FETCH_LEN*`XLEN)                dumpin_instr = ( dump_instr>>(dump_drop_offset*`XLEN) )|( eval_instr<<(dump_left_offset*`XLEN) );\n\twire `N(`FETCH_LEN*`XLEN)                   dumpin_pc = ( dump_pc>>(dump_drop_offset*`XLEN) )|( eval_pc<<(dump_left_offset*`XLEN) );\n\twire `N(`FETCH_LEN*`EXEC_PARA_LEN)        dumpin_para = ( dump_para>>(dump_drop_offset*`EXEC_PARA_LEN) )|( eval_para<<(dump_left_offset*`EXEC_PARA_LEN) );\n\twire `N(`FETCH_LEN*`JCBUF_OFF)           dumpin_level = ( dump_level>>(dump_drop_offset*`JCBUF_OFF) )|( eval_level<<(dump_left_offset*`JCBUF_OFF) );\n\twire `N(`FETCH_OFF)                     dumpin_length = dump_left_offset + eval_length[`FETCH_LEN];\n\n\t\n\twire `N(`FETCH_LEN)                 dumpin_vldx;\n\twire `N(`FETCH_LEN*`XLEN)           dumpin_instrx;\n\twire `N(`FETCH_LEN*`XLEN)           dumpin_pcx;\n\twire `N(`FETCH_LEN*`EXEC_PARA_LEN)  dumpin_parax;\n\twire `N(`FETCH_LEN*`JCBUF_OFF)      dumpin_levelx;\n\twire `N(`FETCH_OFF)                 chain_dump_length       `N(`FETCH_LEN+1);\n\twire `N(`RGLEN)                     chain_dump_instr_rdlist `N(`FETCH_LEN+1);\n\t\n\tassign                           chain_dump_length[0] = 0;\n\tassign                     chain_dump_instr_rdlist[0] = 0;\n\t\n    generate\n    for (i=0;i<`FETCH_LEN;i=i+1) begin:gen_dumpin\n\t    wire                                          vld = dumpin_vld>>i;\n\t\twire `N(`XLEN)   "}
{"text": "                           instr = dumpin_instr>>(i*`XLEN);\n\t\twire `N(`XLEN)                                 pc = dumpin_pc>>(i*`XLEN);\n\t\twire `N(`EXEC_PARA_LEN)                      para = dumpin_para>>(i*`EXEC_PARA_LEN);\n\t\twire `N(`JCBUF_OFF)                         level = dumpin_level>>(i*`JCBUF_OFF);\n\t\twire `N(`JCBUF_OFF)                        levelx = sub_level(level,level_decrease);\n\t\twire `N(`RGBIT)                                rd = para>>(2*`RGBIT);\n        wire                                        clear = level_clear & (level!=0);\t\t\n\t\twire                                         vldx = vld & ~clear;\n\t\twire                                   level_zero = (level==0)|((level==1)&level_decrease);\n        assign                             dumpin_vldx[i] = vldx; \t\t\n\t\tassign               dumpin_instrx[`IDX(i,`XLEN)] = vldx ? instr : 0;\n\t\tassign                  dumpin_pcx[`IDX(i,`XLEN)] = vldx ? pc : 0;\n\t\tassign       dumpin_parax[`IDX(i,`EXEC_PARA_LEN)] = vldx ? para : 0;\n        assign          dumpin_levelx[`IDX(i,`JCBUF_OFF)] = vldx ? levelx : 0;\n\t\tassign                     chain_dump_length[i+1] = vldx ? (i+1) : chain_dump_length[i];\n\t\tassign               chain_dump_instr_rdlist[i+1] = chain_dump_instr_rdlist[i]|( (vld&level_zero)<<rd );\n    end\n    endgenerate\t\t\n\t\n\t`FFx(dump_vld,0)\n\tdump_vld <= jump_vld ? 0 : dumpin_vldx;\n\t\n\t`FFx(dump_instr,0)\n\tdump_instr <= jump_vld ? 0 : dumpin_instrx;\n\t\n\t`FFx(dump_pc,0)\n\tdump_pc <= jump_vld ? 0 : dumpin_pcx;\n\t\n\t`FFx(dump_para,0)\n\tdump_para <= jump_vld ? 0 : dumpin_parax;\n\t\n\t`FFx(dump_level,0)\n\tdump_level <= jump_vld ? 0 : dumpin_levelx;\t\n\t\n\t`FFx(dump_length,0)\n\tdump_length <= jump_vld ? 0 : chain_dump_length[`FETCH_LEN];\t\n\t\n\t`FFx(dump_instr_rdlist,0)\n\tdump_instr_rdlist <= jump_vld ? 0 : chain_dump_instr_rdlist[`FETCH_LEN];\n\t\n\t\n\tassign            fetch_vld = dump_vld;\n\tassign          fetch_instr = dump_instr;\n    assign             fetch_pc = dump_pc;\n\tassign           fetch_para = dump_para;\t\n\tassign          fetch_level = dump_level;\n\tassign   fetch_instr_rdlist = dump_instr_rdlist;\n\tassign         fetch_length = dump_length;\n\tassign       fetch_is_empty = ( dump_length==0 );\n`else\n\tassign            fetch_vld = eval_vld;\n\tassign          fetch_instr = eval_instr;\n    assign             fetch_pc = eval_pc;\n\tassign           fetch_para = eval_para;\t\n\tassign          fetch_level = eval_level;\n\tassign   fetch_instr_rdlist = 0;\n\tassign         fetch_length = `FETCH_LEN;\n\tassign       fetch_is_empty = 1;\n`endif\t\n\t\n\n    //---------------------------------------------------------------------------\n\t//branch operation\n\t//---------------------------------------------------------------------------\n\t\n\twire                  jal_vld = chain_bnch_initial[`FETCH_LEN] &  chain_bnch_jal[`FETCH_LEN];\n\twire            jcond_pdt_vld = chain_bnch_initial[`FETCH_LEN] & ~chain_bnch_jal[`FETCH_LEN];\n\twire `N(`XLEN)       form0_pc = chain_bnch_pc[`FETCH_LEN] + ( chain_bnch_jal[`FETCH_LEN] ? jal_offset(chain_bnch_instr[`FETCH_LEN]) : jcond_offset(chain_bnch_instr[`FETCH_LEN]) );\n    wire `N(`XLEN)       form1_pc = rs0_word + jalr_offset(jalr_instr);\t\n    \n    assign             branch_vld = jcond_clear|jalr_vld|jal_vld|jcond_pdt_vld;\n\tassign              branch_pc = jcond_clear ? jcond_clear_pc : ( jalr_vld ? form1_pc : form0_pc );\n\t\n\tassign            buffer_free = (inall_length - inbuf_offset)<=(`INBUF_LEN-(2*`BUS_LEN));\n\t\nendmodule\n"}
{"text": "/////////////////////////////////////////////////////////////////////////////////////\n//\n//Copyright 2020  Li Xinbing\n//\n//Licensed under the Apache License, Version 2.0 (the \"License\");\n//you may not use this file except in compliance with the License.\n//You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n//Unless required by applicable law or agreed to in writing, software\n//distributed under the License is distributed on an \"AS IS\" BASIS,\n//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//See the License for the specific language governing permissions and\n//limitations under the License.\n//\n/////////////////////////////////////////////////////////////////////////////////////\n\n//THis module manages instruction memory request. There are 3 methods to change PC.\n//1--- jump_vld/jump_pc: System jump to PC\n//2--- branch_vld/branch_pc: branch to PC\n//3--- buffer_free: Keep fetching instructions\n\n`include \"define.v\"\nmodule instrman\n(   \n    input                           clk,\n\tinput                           rst,\n\n    output                          imem_req,\n\toutput `N(`XLEN)                imem_addr,\n\tinput                           imem_resp,\n\tinput  `N(`BUS_WID)             imem_rdata,\n\tinput                           imem_err,\n\n\tinput                           jump_vld,\n\tinput  `N(`XLEN)                jump_pc,\n\tinput                           branch_vld,\n\tinput  `N(`XLEN)                branch_pc,\n\tinput                           buffer_free,\n\t\n\toutput                          imem_vld,\n\toutput `N(`BUS_WID)             imem_instr,\n\toutput                          imem_status\n\n);\n\n    //---------------------------------------------------------------------------\n    //signal defination\n    //---------------------------------------------------------------------------\n\treg `N(`XLEN)   pc;\t\n\treg             req_sent;\n\treg             instr_verified;\n\t\n    //---------------------------------------------------------------------------\n    //statements description\n    //---------------------------------------------------------------------------\n\n    wire             reload_vld = jump_vld|branch_vld;\n\twire `N(`XLEN)    reload_pc = ( jump_vld ? jump_pc : branch_pc ) & ( {`XLEN{1'b1}}<<1 );\n\twire `N(`XLEN)   fetch_addr = reload_vld ? reload_pc : pc;\n\tassign            imem_addr = fetch_addr & `PC_ALIGN;\t\t\n\t\n\t//imem_addr\n\t`FFx(pc,0)\n\tif ( imem_req )\n\t    pc <= fetch_addr + 4*`BUS_LEN;\n\telse if ( reload_vld )\n\t    pc <= reload_pc;\n\telse;\t\n\t\n\t//imem_req\n\twire             request_go = buffer_free|reload_vld;\n\t\n\t//if req_sent is 0, request_go can be asserted any time, if it is 1, only when imem_resp is OK.\n\t`FFx(req_sent,1'b0)\n\tif ( ~req_sent|imem_resp )\n\t    req_sent <= request_go;\n\telse;\n\t\n\tassign             imem_req = request_go & ( ~req_sent|imem_resp );\t\n\t\n\t//rdata could be cancelled by \"reload_vld\"\n\t`FFx(instr_verified,1'b0)\n\tif ( imem_req )\n\t    instr_verified <= 1'b1;\n\telse if ( reload_vld|imem_resp )\n\t    instr_verified <= 1'b0;\n\telse;\n\t\n\tassign             imem_vld = instr_verified & imem_resp;\n\tassign           imem_instr = imem_rdata;\n\tassign          imem_status = imem_err;\n\t\n\nendmodule\n"}
{"text": "/////////////////////////////////////////////////////////////////////////////////////\n//\n//Copyright 2020  Li Xinbing\n//\n//Licensed under the Apache License, Version 2.0 (the \"License\");\n//you may not use this file except in compliance with the License.\n//You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n//Unless required by applicable law or agreed to in writing, software\n//distributed under the License is distributed on an \"AS IS\" BASIS,\n//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//See the License for the specific language governing permissions and\n//limitations under the License.\n//\n/////////////////////////////////////////////////////////////////////////////////////\n\n`include \"define.v\"\nmodule lsu(\n\n    input                                                                    clk,\n    input                                                                    rst,\n\t\n    output                                                                   dmem_req,\n\toutput                                                                   dmem_cmd,\n\toutput `N(2)                                                             dmem_width,\n\toutput `N(`XLEN)                                                         dmem_addr,\n\toutput `N(`XLEN)                                                         dmem_wdata,\n\tinput  `N(`XLEN)                                                         dmem_rdata,\n\tinput                                                                    dmem_resp,\n\tinput                                                                    dmem_err,\t\n\n\tinput                                                                    lsu_initial,\n\tinput  `N(`MMBUF_PARA_LEN)                                               lsu_para,\n\tinput  `N(`XLEN)                                                         lsu_addr,\n\tinput  `N(`XLEN)                                                         lsu_wdata,\n\toutput                                                                   lsu_ready,\n    output                                                                   lsu_finished,\n\toutput                                                                   lsu_status,\n\toutput `N(`XLEN)                                                         lsu_rdata,\n\tinput                                                                    lsu_ack,\t\n\n    input                                                                    clear_pipeline\n\n);\n\n\n\n    //---------------------------------------------------------------------------\n    //signal defination\n    //---------------------------------------------------------------------------\n    reg              req_sent;\n    reg  `N(4)       req_para;\n\n    //---------------------------------------------------------------------------\n    //statements area\n    //---------------------------------------------------------------------------\t\n\t\t\n\t//dmem request\n\tassign     dmem_req = lsu_initial & lsu_ready & ~clear_pipeline;\n\tassign     dmem_cmd = lsu_para>>3;\n\tassign   dmem_width = lsu_para;\n\tassign    dmem_addr = lsu_addr & ( {`XLEN{1'b1}}<<dmem_width );\n    assign   dmem_wdata = lsu_wdata;\n\n\t`FFx(req_sent,1'b0)\n\tif ( ~req_sent|dmem_resp )\n\t    req_sent <= dmem_req;\n\telse;\n\t\n    `FFx(req_para,0)\n\tif ( ~req_sent|dmem_resp )\n\t    req_para <= lsu_para;\n\telse;\n\t\n\twire `N(`XLEN)   unsigned_word = req_para[0] ? dmem_rdata[15:0] : dmem_rdata[7:0];\n\twire `N(`XLEN)     signed_word = req_para[0] ? { {16{dmem_rdata[15]}},dmem_rdata[15:0] } : { {24{dmem_rdata[7]}},dmem_rdata[7:0] };\n\twire `N(`XLEN)        get_word = req_para[2] ? unsigned_word : ( req_para[1] ? dmem_rdata : signed_word );\n\twire `N(`XLEN)        out_word = req_para[3] ? 0 : get_word;\n\t\n\twire                  out_resp = req_sent & dmem_resp; \n\twire `N(`XLEN)       out_rdata = out_resp ? out_word : 0;\n\twire                out_status = out_resp ? dmem_err : 0;\n\t\n\t//lsu buffer\n\treg  `N(`LSUBUF_LEN*`XLEN)  lsubuf_rdata;\n\treg  `N(`LSUBUF_LEN)        lsubuf_status;\n\treg  `N(`LSUBUF_OFF)        lsubuf_length;\n\t\n\twire `N(`LSUBUF_LEN*`XLEN)   incoming_rdata = lsubuf_rdata|(out_rdata<<(lsubuf_length*`XLEN));\n\twire `N(`LSUBUF_LEN)        incoming_status = lsubuf_status|(out_status<<lsubuf_length);\n\twire `N(`LSUBUF_OFF)        incoming_length = lsubuf_length + out_resp;\n\t\n\tassign                            lsu_rdata = incoming_rdata;\n\tassign                           lsu_status = incoming_status;\n\tassign                         lsu_finished = incoming_length!=0;\n\t\n\t`FFx(lsubuf_rdata,0)\n\tlsubuf_rdata <= clear_pipeline ? 0 : ( incoming_rdata>>( lsu_ack*`XLEN) );\n\t\n\t`FFx(lsubuf_status,0)\n\tlsubuf_status <= clear_pipeline ? 0 : ( incoming_status>>lsu_ack );\n\t\n\twire `N(`LSUBUF_OFF)           total_length = incoming_length - lsu_ack; \n\t\n\t`FFx(lsubuf_length,0 )\n\tlsubuf_length <= clear_pipeline ? 0 : total_length;\n\t\n\tassign lsu_ready = ~(|incoming_status) & ( total_length<`LSUBUF_LEN ) & ( ~req_sent|dmem_resp );\n\nendmodule\n\n"}
{"text": "/////////////////////////////////////////////////////////////////////////////////////\n//\n//Copyright 2019  Li Xinbing\n//\n//Licensed under the Apache License, Version 2.0 (the \"License\");\n//you may not use this file except in compliance with the License.\n//You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n//Unless required by applicable law or agreed to in writing, software\n//distributed under the License is distributed on an \"AS IS\" BASIS,\n//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//See the License for the specific language governing permissions and\n//limitations under the License.\n//\n/////////////////////////////////////////////////////////////////////////////////////\n\n`include \"define.v\"\nmodule membuf(\n    input                                    clk,\n\tinput                                    rst,\n\n    //interface with mul\n    output `N(`MUL_LEN)                      mul_initial,\n\toutput `N(`MUL_LEN*3)                    mul_para,\n\toutput `N(`MUL_LEN*`XLEN)                mul_rs0,\n\toutput `N(`MUL_LEN*`XLEN)                mul_rs1,\n\tinput  `N(`MUL_LEN)                      mul_ready,\n\tinput  `N(`MUL_LEN)                      mul_finished,\n\tinput  `N(`MUL_LEN*`XLEN)                mul_data,\n\toutput `N(`MUL_LEN)                      mul_ack,\n\t\n\t//interface with lsu\n    output                                   lsu_initial,\n\toutput `N(`MMBUF_PARA_LEN)               lsu_para,\n\toutput `N(`XLEN)                         lsu_addr,\n\toutput `N(`XLEN)                         lsu_wdata,\n\tinput                                    lsu_ready,\n\tinput                                    lsu_finished,\n\tinput                                    lsu_status,\n\tinput  `N(`XLEN)                         lsu_rdata,\n    output                                   lsu_ack,\t\n\n    //interface with mprf\n\tinput  `N(`EXEC_LEN)                     mem_vld,\n\tinput  `N(`EXEC_LEN*`MMBUF_PARA_LEN)     mem_para,\n\tinput  `N(`EXEC_LEN*`XLEN)               mem_addr,\n\tinput  `N(`EXEC_LEN*`XLEN)               mem_wdata,\n\tinput  `N(`EXEC_LEN*`XLEN)               mem_pc,\n\tinput  `N(`EXEC_LEN*`JCBUF_OFF)          mem_level,\n    output `N(`MEM_LEN*`RGBIT)               mem_sel,\n    output `N(`MEM_LEN*`XLEN)                mem_data,\t\n    output `N(`MEM_OFF)                      mem_release,\n\t\n\t//misc signals\n\tinput                                    clear_pipeline,\n\tinput                                    level_decrease,\n\tinput                                    level_clear,\n\tinput  `N(`RGLEN)                        rfbuf_order_list,\n\toutput `N(`RGBIT)                        mmbuf_check_rdnum,\n    output `N(`RGLEN)                        mmbuf_check_rdlist,\t\n\toutput `N(`RGLEN)                        mmbuf_instr_rdlist,\n\toutput `N(`MMBUF_OFF)                    mmbuf_mem_num,\t    \n\toutput                                   mmbuf_intflag,\n    output `N(`XLEN)                         mmbuf_intpc,\n    output `N(2)                             dmem_exception,\n\toutput                                   mem_busy\n\n\n);\n\n    //---------------------------------------------------------------------------\n    //function defination\n    //---------------------------------------------------------------------------\n\t\n\tfunction `N(`MUL_OFF) lowest_mul( input `N(`MUL_LEN) d );\n\t    integer i;\n\tbegin\n\t    lowest_mul = 0;\n\t    for (i=0;i<`MUL_LEN;i=i+1) \n\t\t    if ( d[`MUL_LEN-1-i] )\n\t\t\t    lowest_mul = `MUL_LEN-1-i;\n\tend\n\tendfunction\n\n    //---------------------------------------------------------------------------\n    //signal defination\n    //---------------------------------------------------------------------------\n\twire `N(`EXEC_OFF)                       chain_in_num            `N(`EXEC_LEN+1);\n\twire `N(`EXEC_OFF)                       array_in_shift          `N(`EXEC_LEN);\n\n\treg  `N(`EXEC_LEN*`MMBUF_PARA_LEN)       in_para;\n\treg  `N(`EXEC_LEN*`XLEN)                 in_addr;\n\treg  `N(`EXEC_LEN*`XLEN)                 in_wdata;\n\treg  `N(`EXEC_LEN*`XLEN)                 in_pc;\n\treg  `N(`EXEC_LEN*`JCBUF_OFF)            in_level;\n    wire `N(`EXEC_OFF)                       in_length;\t\n\t\n\twire `N(`MMBUF_LEN*`MMBUF_PARA_LEN)      comb_para;\n\twire `N(`MMBUF_LEN*`XLEN)                comb_addr;\n\twire `N(`MMBUF_LEN*`XLEN)                comb_wdata;\n\twire `N(`MMBUF_LEN*`XLEN)                comb_pc;\t\n\twire `N(`MMBUF_LEN*`JCBUF_OFF)           comb_level;\t\n\twire `N(`MMBUF_OFF)                      comb_length;\t\n\t\n\twire `N(`MMBUF_LEN*`MMBUF_PARA_LEN)      out_para;\n\twire `N(`MMBUF_LEN*`XLEN)                out_addr;\n\twire `N(`MMBUF_LEN*`XLEN)                out_wdata;\n\twire `N(`MMBUF_LEN*`XLEN)                out_pc;\t\n\twire `N(`MMBUF_LEN*`JCBUF_OFF)           out_level;\n\twire `N(`MMBUF_OFF)                      out_length;\n\t\n\twire `N(`MMBUF_OFF)                      chain_ot_length         `N(`MMBUF_LEN+1);\n\twire `N(`MMBUF_OFF)                      chain_mul_next          `N(`MMBUF_LEN+1);\t\n\twire `N(`MMBUF_LEN)                      array_lsu_start;\n\twire `N(`MMBUF_LEN)                      array_mul_flag;\n\twire `N(`MMBUF_LEN*`RGBIT)               array_mem_check;\n\t\n    reg  `N(`MMBUF_OFF)                      mmbuf_length;\n\treg  `N(`MMBUF_LEN*`MMBUF_PARA_LEN)      mmbuf_para;\n\treg  `N(`MMBUF_LEN*`XLEN)                mmbuf_addr;\n\treg  `N(`MMBUF_LEN*`XLEN)                mmbuf_wdata;\n\treg  `N(`MMBUF_LEN*`XLEN)                mmbuf_pc;\n\treg  `N(`MMBUF_LEN*`JCBUF_OFF)           mmbuf_level;\n\n\treg  `N(`MMBUF_OFF)                      mul_bottom;\n    reg  `N(`MMBUF_OFF)                      mul_order;\n\n    reg  `N(`MMBUF_OFF)                      lsu_order;\n\n\n    genvar i;\n\t\n\t`include \"include_func.v\"\n    //---------------------------------------------------------------------------\n    //Statement area\n    //---------------------------------------------------------------------------\n\n\n\n    //---------------------------------------------------------------------------\n    //remove redundant instructions \n    //---------------------------------------------------------------------------\n\n\tassign       chain_in_num[0] = 0;\n\t\n\tgenerate\n\tfor (i=0;i<`EXEC_LEN;i=i+1) begin:gen_in_num\n\t\tassign array_in_shift[i] = mem_vld[i] ? chain_in_num[i] : `EXEC_LEN;\n\t\tassign chain_in_num[i+1] = chain_in_num[i] + mem_vld[i];\n\tend\n\tendgenerate\n\t\n    always @* begin:comb_in_series\n\t    integer i;\n\t\tin_para  = 0;\n\t\tin_addr  = 0;\n\t\tin_wdata = 0;\n\t\tin_pc    = 0;\n\t\tin_level = 0;\n\t    for (i=0;i<`EXEC_LEN;i=i+1) begin\n\t\t    in_para  = in_para|( mem_para[`IDX(i,`MMBUF_PARA_LEN)]<<(array_in_shift[i]*`MMBUF_PARA_LEN) );\n\t\t\tin_addr  = in_addr|( mem_addr[`IDX(i,`XLEN)]<<(array_in_shift[i]*`XLEN) );\n\t\t\tin_wdata = in_wdata|( mem_wdata[`IDX(i,`XLEN)]<<(array_in_shift[i]*`XLEN) );\n\t\t\tin_pc    = in_pc|( mem_pc[`IDX(i,`XLEN)]<<(array_in_shift[i]*`XLEN) );\n\t\t\tin_level = in_level|( mem_level[`IDX(i,`JCBUF_OFF)]<<(array_in_shift[i]*`JCBUF_OFF) );\n\t\tend\n\tend\n\n    assign in_length = chain_in_num[`EXEC_LEN];\n\t\n\t\n    //---------------------------------------------------------------------------\n    //main generate statement\n    //---------------------------------------------------------------------------\t\n\t\n\t//processing\t\n\tassign                                    comb_para = mmbuf_para|( in_para<<(mmbuf_length*`MMBUF_PARA_LEN) );\n\tassign                                    comb_addr = mmbuf_addr|( in_addr<<(mmbuf_length*`XLEN) );\n\tassign                                   comb_wdata = mmbuf_wdata|( in_wdata<<(mmbuf_length*`XLEN) );\n\tassign                                      comb_pc = mmbuf_pc|( in_pc<<(mmbuf_length*`XLEN) );\n\tassign                                   comb_level = mmbuf_level|( in_level<<(mmbuf_length*`JCBUF_OFF) );\n\tassign                                  comb_length = mmbuf_length + in_length;\t\n\t\n\tassign                           chain_ot_length[0] = 0;\t\n\tassign                            chain_mul_next[0] = `MMBUF_LEN;\n\t\n\tgenerate\n    for (i=0;i<`MMBUF_LEN;i=i+1) begin:gen_mmbuf_update\t\n\t    //basic info\n    \twire                                        vld = i<comb_length;\n\t\twire `N(`MMBUF_PARA_LEN)                   para = comb_para>>(i*`MMBUF_PARA_LEN);\n        wire `N(`XLEN)                             addr = comb_addr>>(i*`XLEN);\n        wire `N(`XLEN)                            wdata = comb_wdata>>(i*`XLEN);\n        wire `N(`XLEN)                               pc = comb_pc>>(i*`XLEN);\t\t\n\t\t//para\n\t\twire                                        mul = para>>(`MMBUF_PARA_LEN-1);\n\t\twire                                        lsu = ~mul;\n\t\t//level\n\t\twire `N(`JCBUF_OFF)                       level = comb_level>>(i*`JCBUF_OFF);\n\t\twire `N(`JCBUF_OFF)                    level_up = sub_level(level,level_decrease);\n\t\twire                                 level_zero = level_up==0;\n\t\twire                                      clear = level_clear & (level!=0);\n\t\twire                                       pass = vld & ~clear;\n\t\t//out\n        assign        out_para[`IDX(i,`MMBUF_PARA_LEN)] = pass ? para : 0;  \n        assign                  out_addr[`IDX(i,`XLEN)] = pass ? addr : 0;\n        assign                 out_wdata[`IDX(i,`XLEN)] = pass ? wdata : 0;\n        assign                    out_pc[`IDX(i,`XLEN)] = pass ? pc : 0;\t\t\n\t\tassign            out_level[`IDX(i,`JCBUF_OFF)] = level_up;\n\t\tassign                     chain_ot_length[i+1] = pass ? (i+1) : chain_ot_length[i];\n        //mul\n\t\tassign                      chain_mul_next[i+1] = ( (i>=mul_bottom) & vld & mul & level_zero & (chain_mul_next[i]==`MMBUF_LEN) ) ? i : chain_mul_next[i];\n\t\t//lsu\n\t\tassign                       array_lsu_start[i] = vld & lsu & level_zero;\n\t\tassign                        array_mul_flag[i] = vld & mul & level_zero;\n\t\t//mem check\n\t\twire `N(`RGBIT)                              rd = para>>4;\n\t\tassign          array_mem_check[`IDX(i,`RGBIT)] = rd;\n\tend\n\tendgenerate\n\n\tassign                                   out_length = chain_ot_length[`MMBUF_LEN];\n\t\n\t`FFx(mmbuf_para,0)\n\tmmbuf_para <= clear_pipeline ? 0 : ( out_para>>(mem_release*`MMBUF_PARA_LEN) );\n\n    `FFx(mmbuf_addr,0)\n\tmmbuf_addr <= clear_pipeline ? 0 : ( out_addr>>(mem_release*`XLEN) );\n\n    `FFx(mmbuf_wdata,0)\n\tmmbuf_wdata <= clear_pipeline ? 0 : ( out_wdata>>(mem_release*`XLEN) );\n\n    `FFx(mmbuf_pc,0)\n\tmmbuf_pc <= clear_pipeline ? 0 : ( out_pc>>(mem_release*`XLEN) );\n\n    `FFx(mmbuf_level,0)\n\tmmbuf_level <= (clear_pipeline|level_clear) ? 0 : ( out_level>>(mem_release*`JCBUF_OFF) );\n\n\t`FFx(mmbuf_length,0)\n\tmmbuf_length <= clear_pipeline ? 0 : (out_length - mem_release);\t\t\n\t\n\n    //---------------------------------------------------------------------------\n    //mul processing\n    //---------------------------------------------------------------------------\n\t\n\twire                                    mul_get_vld = mul_order!=`MMBUF_LEN;\n\twire `N(3)                             mul_get_para = mmbuf_para>>(mul_order*`MMBUF_PARA_LEN);\n\twire `N(`XLEN)                          mul_get_rs0 = mmbuf_addr>>(mul_order*`XLEN);\n\twire `N(`XLEN)                          mul_get_rs1 = mmbuf_wdata>>(mul_order*`XLEN);\t\n\n\twire                                   mul_idle_vld = |mul_ready;\n\twire `N(`MUL_OFF)                      mul_idle_num = lowest_mul(mul_ready);\n\t\n\twire                                    mul_hit_vld = mul_get_vld & mul_idle_vld;\t\n\twire `N(`MUL_OFF)                       mul_hit_pos = mul_hit_vld ? mul_idle_num : 0;\n\t\n\tassign                                  mul_initial = mul_hit_vld<<mul_idle_num;\n\tassign                                     mul_para = {`MUL_LEN{mul_get_para}};\n\tassign                                      mul_rs0 = {`MUL_LEN{mul_get_rs0}};\n\tassign                                      mul_rs1 = {`MUL_LEN{mul_get_rs1}};\n\n    wire `N(`MMBUF_OFF)                  mul_next_order = chain_mul_next[`MMBUF_LEN];\n\n    `FFx(mul_bottom,0)\n    if ( clear_pipeline )\n        mul_bottom <= 0;\n    else if ( ((mul_order==`MMBUF_LEN)|mul_hit_vld) & (mul_next_order!=`MMBUF_LEN) )\n\t    mul_bottom <= mul_next_order + 1'b1 - mem_release;\n\telse\n\t    mul_bottom <= (mul_bottom < mem_release) ? 0 : (mul_bottom - mem_release);\n\n\n    `FFx(mul_order,`MMBUF_LEN)\n    if ( clear_pipeline )\n        mul_order <= `MMBUF_LEN;\n    else if ( (mul_order==`MMBUF_LEN)|mul_hit_vld )\n        mul_order <= (mul_next_order==`MMBUF_LEN) ? `MMBUF_LEN : (mul_next_order - mem_release);\n\telse\n\t    mul_order <= mul_order - mem_release;\n\n\n    //---------------------------------------------------------------------------\n    //lsu processing\n    //---------------------------------------------------------------------------\n\n    assign                                  lsu_initial = array_lsu_start>>lsu_order;\n\tassign                                     lsu_para = comb_para>>(lsu_order*`MMBUF_PARA_LEN);\n\tassign                                     lsu_addr = comb_addr>>(lsu_order*`XLEN);\n\tassign                                    lsu_wdata = comb_wdata>>(lsu_order*`XLEN);         \n\n    wire                                     lsu_accept = lsu_initial & lsu_ready;\n    wire                                        lsu_inc = lsu_accept|( array_mul_flag>>lsu_order );\n\twire `N(`MMBUF_OFF)                    lsu_order_in = lsu_order + lsu_inc;\n\t\n\t`FFx(lsu_order,0)\n\tlsu_order <= clear_pipeline ? 0 : ( ( lsu_order_in < mem_release ) ? 0 : ( lsu_order_in - mem_release ) );\n\t\n\n    //---------------------------------------------------------------------------\n    //mem release\n    //---------------------------------------------------------------------------\n\n\treg  `N(`MMBUF_LEN)             mmbuf_done_vld;\n\treg  `N(`MMBUF_LEN)             mmbuf_done_sel;\n\treg  `N(`MMBUF_LEN*`MUL_OFF)    mmbuf_done_mul;\n\t\n\t`FFx(mmbuf_done_vld,0)\n\tmmbuf_done_vld <= clear_pipeline ? 0 : ( ( mmbuf_done_vld|(mul_hit_vld<<mul_order)|(lsu_accept<<lsu_order) )>>mem_release );\n\t\n\t`FFx(mmbuf_done_sel,0)\n\tmmbuf_done_sel <= clear_pipeline ? 0 : ( ( mmbuf_done_sel|(mul_hit_vld<<mul_order) )>>mem_release );\n\t\n\t`FFx(mmbuf_done_mul,0)\n\tmmbuf_done_mul <= clear_pipeline ? 0 : ( ( mmbuf_done_mul|(mul_hit_pos<<(mul_order*`MUL_OFF)) )>>(mem_release*`MUL_OFF) );\n\t\n\t\n\twire `N(`MUL_LEN)    chain_mul_finished `N(`MEM_LEN+1);\n\twire                 chain_lsu_finished `N(`MEM_LEN+1);\n\twire              chain_last_unfinished `N(`MEM_LEN+1);\n\twire `N(`MEM_OFF)         chain_release `N(`MEM_LEN+1);\n\twire `N(`MUL_LEN)         chain_mul_ack `N(`MEM_LEN+1);\n\twire                      chain_lsu_ack `N(`MEM_LEN+1);\n\t\n\tassign                        chain_mul_finished[0] = mul_finished;\n\tassign                        chain_lsu_finished[0] = lsu_finished;\n\tassign                     chain_last_unfinished[0] = 0;\n    assign                             chain_release[0] = 0;\t\n\tassign                             chain_mul_ack[0] = 0;\n\tassign                             chain_lsu_ack[0] = 0;\n\t\n\tgenerate\n\tfor (i=0;i<`MEM_LEN;i=i+1) begin:gen_mem_data\n\t    //data\n\t    wire                                        vld = mmbuf_done_vld>>i;\n\t\twire                                        sel = mmbuf_done_sel>>i;\n\t    wire `N(`MUL_OFF)                    mul_offset = mmbuf_done_mul>>(i*`MUL_OFF);\n\t\twire `N(`XLEN)                          mul_out = mul_data>>(mul_offset*`XLEN);\n        wire `N(`XLEN)                          lsu_out = lsu_rdata;\n        wire `N(`XLEN)                          mem_out = sel ? mul_out : lsu_out;\n\t\t//hit\n\t\twire `N(`MMBUF_PARA_LEN)                   para = mmbuf_para>>(i*`MMBUF_PARA_LEN);\n\t\twire `N(`RGBIT)                              rd = para>>4;\n\t\twire                                        hit = ( rfbuf_order_list & `LASTBIT_MASK ) >> rd;\n\t\t//mark\n\t\twire                                     mul_ok = chain_mul_finished[i]>>mul_offset;\n        wire                                     lsu_ok = chain_lsu_finished[i];\t\t\n\t\twire                                    this_ok = sel ? mul_ok : lsu_ok;\n\t\tassign                  chain_mul_finished[i+1] = chain_mul_finished[i]^( (sel&mul_ok)<<mul_offset );\n\t\tassign                  chain_lsu_finished[i+1] = chain_lsu_finished[i]^( ~sel&lsu_ok );\n\t\t//output\n\t\twire                                     permit = vld & this_ok & ~hit;\n\t\tassign               chain_last_unfinished[i+1] = chain_last_unfinished[i]|(~permit);\n\t\twire                                        mok = permit & ~chain_last_unfinished[i];\n\t\tassign                  mem_sel[`IDX(i,`RGBIT)] = mok ? rd : 0;\n\t\tassign                  mem_data[`IDX(i,`XLEN)] = mem_out;\n\t    assign                       chain_release[i+1] = chain_release[i] + mok;\n\t\tassign                       chain_mul_ack[i+1] = chain_mul_ack[i]|( (mok & sel)<<mul_offset );\n\t\tassign                       chain_lsu_ack[i+1] = chain_lsu_ack[i]|( mok & ~sel );\n\tend\n\tendgenerate\n\t\n\tassign                                  mem_release = chain_release[`MEM_LEN];\n\tassign                                      mul_ack = chain_mul_ack[`MEM_LEN];\n\tassign                                      lsu_ack = chain_lsu_ack[`MEM_LEN];\n\t\n\t\n    //---------------------------------------------------------------------------\n    //info collection\n    //---------------------------------------------------------------------------\t\n\t\n\t//\"check\" : list all Rds. \n    assign                            mmbuf_check_rdnum = array_mem_check>>(mem_release*`RGBIT);\n\t\n\twire `N(`RGLEN)                    chain_mem_check `N(`MMBUF_LEN+1);\n\t\n\tassign                           chain_mem_check[0] = 0;\n\t\n\tgenerate\n\tfor (i=0;i<`MMBUF_LEN;i=i+1) begin:gen_mem_check\n\t    wire `N(`RGBIT)                              rd = array_mem_check>>(i*`RGBIT);\n\t\twire                                     remove = (i<=mem_release);\n\t\twire                                        get = ~remove;\n\t\tassign                     chain_mem_check[i+1] = chain_mem_check[i]|(get<<rd);\n\tend\n\tendgenerate\n\t\n\tassign                           mmbuf_check_rdlist = chain_mem_check[`MMBUF_LEN];\n\t\n\t//\"level\" : only list Rds (level==0) of membuf\n\n    wire `N(`RGLEN)                  chain_mem_level `N(`MMBUF_LEN+1);\n\n    assign                           chain_mem_level[0] = 0;\n  \n    generate\n\tfor (i=0;i<`MMBUF_LEN;i=i+1) begin:gen_mem_level\n\t    wire `N(`MMBUF_PARA_LEN)                   para = mmbuf_para>>(i*`MMBUF_PARA_LEN);\n\t\twire `N(`RGBIT)                              rd = para>>4;\n\t\twire `N(`JCBUF_OFF)                       level = mmbuf_level>>(i*`JCBUF_OFF);\n\t\twire                                 level_zero = level==0;\n\t\twire                                     remove = (i<mem_release);\n        wire                                        get = level_zero & ~remove;\t\t\n\t\tassign                     chain_mem_level[i+1] = chain_mem_level[i]|(get<<rd);\n\tend\n\tendgenerate\n\n    assign                           mmbuf_instr_rdlist = chain_mem_level[`MMBUF_LEN];\n\n    //others\n\n\tassign                                mmbuf_mem_num = mmbuf_length;\n\n    assign                            dmem_exception[1] = 0;\n\n    assign                            dmem_exception[0] = 0;\n \n    assign                                mmbuf_intflag = 0;\n\n    assign                                  mmbuf_intpc = 0;\n\t\n\tassign                                     mem_busy = 0;\n\t\nendmodule"}
{"text": "/////////////////////////////////////////////////////////////////////////////////////\n//\n//Copyright 2019  Li Xinbing\n//\n//Licensed under the Apache License, Version 2.0 (the \"License\");\n//you may not use this file except in compliance with the License.\n//You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n//Unless required by applicable law or agreed to in writing, software\n//distributed under the License is distributed on an \"AS IS\" BASIS,\n//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//See the License for the specific language governing permissions and\n//limitations under the License.\n//\n/////////////////////////////////////////////////////////////////////////////////////\n\n`include \"define.v\"\nmodule mprf(\n    input                                clk,\n\tinput                                rst,\n   \n\tinput  `N(`EXEC_LEN*`RGBIT)          rd_sel,\n\tinput  `N(`EXEC_LEN*`MMCMB_OFF)      rd_order,\n\tinput  `N(`EXEC_LEN*`JCBUF_OFF)      rd_level,\n\tinput  `N(`EXEC_LEN*`XLEN)           rd_data,\n\n\tinput                                csr_vld,\n\tinput  `N(`RGBIT)                    csr_rd_sel,\n\tinput  `N(`XLEN)                     csr_data,\n\t\n\tinput  `N(`MEM_LEN*`RGBIT)           mem_sel,\n\tinput  `N(`MEM_LEN*`XLEN)            mem_data,\t\n\tinput  `N(`MEM_OFF)                  mem_release,\n\t\n\tinput                                clear_pipeline,\t\n\tinput                                level_decrease,\n\tinput                                level_clear,\t\n\n\tinput  `N(`EXEC_LEN*`RGBIT)          rs0_sel,\n\tinput  `N(`EXEC_LEN*`RGBIT)          rs1_sel,    \t\n\toutput `N(`EXEC_LEN*`XLEN)           rs0_word,\n\toutput `N(`EXEC_LEN*`XLEN)           rs1_word,\n\t\n    input  `N(`RGBIT)                    extra_rs0_sel,\n\tinput  `N(`RGBIT)                    extra_rs1_sel,\n\toutput `N(`XLEN)                     extra_rs0_word,\n    output `N(`XLEN)                     extra_rs1_word,\n\n\toutput `N(`RFBUF_OFF)                rfbuf_alu_num,\n\toutput `N(`RGLEN)                    rfbuf_order_list\n);\n\n    //---------------------------------------------------------------------------\n    //function defination\n    //---------------------------------------------------------------------------\n\n    `include \"include_func.v\"\n\t\n\tfunction `N(1+`XLEN) get_from_array(input `N(`RGBIT)                       target_sel,\n\t                                    input `N((`RFBUF_LEN+`MEM_LEN)*`RGBIT) array_sel,\n\t                                    input `N((`RFBUF_LEN+`MEM_LEN)*`XLEN)  array_data);\n\t    integer         i;\n\t\treg `N(`RGBIT)  sel;\n\t\treg `N(`XLEN)   data;\n\t\treg             get;\n\t\treg `N(`XLEN)   out_word;\n\tbegin\n\t    get            = 0;\n\t\tout_word       = 0;\n\t    for (i=0;i<(`RFBUF_LEN+`MEM_LEN);i=i+1) begin\n\t\t    sel        = array_sel>>(i*`RGBIT);\n\t\t\tdata       = array_data>>(i*`XLEN);\n\t\t\tget        = get|(target_sel==sel);\n\t\t\tout_word   = (target_sel==sel) ? data : out_word;\n\t\tend\n\t\tget            = (target_sel==0) ? 1'b0 : get;\n\t\tget_from_array = { get,out_word };\n\tend\n\tendfunction\n\t\t\n\tfunction `N(1+`XLEN) get_from_array_level\n\t                                   (input `N(`RGBIT)                            target_sel, \n\t                                    input `N((`RFBUF_LEN+`MEM_LEN)*`RGBIT)      array_sel,\n\t                                    input `N((`RFBUF_LEN+`MEM_LEN)*`XLEN)       array_data,\n\t\t\t\t\t\t\t\t\t\tinput `N((`RFBUF_LEN+`MEM_LEN)*`JCBUF_OFF)  array_level);\n\t    integer            i;\n\t\treg `N(`RGBIT)     sel;\n\t\treg `N(`JCBUF_OFF) level;\n\t\treg `N(`XLEN)      data;\n\t\treg                get;\n\t\treg `N(`XLEN)      out_word;\n\tbegin\n\t    get                  = 0;\n\t\tout_word             = 0;\n\t    for (i=0;i<(`RFBUF_LEN+`MEM_LEN);i=i+1) begin\n\t\t    sel              = array_sel>>(i*`RGBIT);\n\t\t\tlevel            = array_level>>(i*`JCBUF_OFF);\n\t\t\tdata             = array_data>>(i*`XLEN);\n\t\t\tget              = get|((target_sel==sel) & (level==0));\n\t\t\tout_word         = ((target_sel==sel) & (level==0)) ? data : out_word;\n\t\tend\n\t\tget                  = (target_sel==0) ? 1'b0 : get;\n\t\tget_from_array_level = { get,out_word };\n\tend\n\tendfunction\t\t\n\t\t\n    //---------------------------------------------------------------------------\n    //signal defination\n    //---------------------------------------------------------------------------\n    reg `N(`XLEN)                       rbank           [31:0];\n\t\n\twire `N(`EXEC_OFF)                  chain_in_num    `N(`EXEC_LEN+1);\t\t\n\twire `N(`EXEC_LEN*`RGBIT)           chain_in_sel    `N(`EXEC_LEN+1);\n\twire `N(`EXEC_LEN*`MMCMB_OFF)       chain_in_order  `N(`EXEC_LEN+1);\n\twire `N(`EXEC_LEN*`JCBUF_OFF)       chain_in_level  `N(`EXEC_LEN+1);\n\twire `N(`EXEC_LEN*`XLEN)            chain_in_data   `N(`EXEC_LEN+1);\t\n\twire `N(`RGLEN)                     chain_in_list   `N(`EXEC_LEN+1);\n\t\n    reg  `N(`RFBUF_LEN*`RGBIT)          rfbuf_sel;\n\treg  `N(`RFBUF_LEN*`MMCMB_OFF)      rfbuf_order;\n\treg  `N(`RFBUF_LEN*`JCBUF_OFF)      rfbuf_level;\n\treg  `N(`RFBUF_LEN*`XLEN)           rfbuf_data;\t\n\treg  `N(`RFBUF_OFF)                 rfbuf_length;\n\t\n\twire `N(`RFINTO_LEN)                chain_away_active `N(`RFBUF_LEN+1);\n\twire `N(`RFINTO_OFF)                chain_away_num    `N(`RFBUF_LEN+1);\n\twire `N(`RFINTO_LEN*`RGBIT)         chain_away_sel    `N(`RFBUF_LEN+1);\n\twire `N(`RFINTO_LEN*`XLEN)          chain_away_data   `N(`RFBUF_LEN+1);\t\n\t\n\twire `N(`RFBUF_OFF)                 chain_stay_num    `N(`RFBUF_LEN+1);\n\twire `N(`RFBUF_LEN*`RGBIT)          chain_stay_sel    `N(`RFBUF_LEN+1);\n\twire `N(`RFBUF_LEN*`MMCMB_OFF)      chain_stay_order  `N(`RFBUF_LEN+1);\n\twire `N(`RFBUF_LEN*`JCBUF_OFF)      chain_stay_level  `N(`RFBUF_LEN+1);\n\twire `N(`RFBUF_LEN*`XLEN)           chain_stay_data   `N(`RFBUF_LEN+1);\n    wire `N(`RGLEN)                     chain_stay_list   `N(`RFBUF_LEN+1);\n\t\n\treg  `N(`RGLEN)                     zero_order_list;\t\n\t\n\twire `N(`RFINTO_LEN*`RGBIT)         away_sel;\n\twire `N(`RFINTO_LEN*`XLEN)          away_data;\t\n\n    genvar i,j;\n\n    //---------------------------------------------------------------------------\n    //statements area\n    //---------------------------------------------------------------------------\t\n\t\n\n    //---------------------------------------------------------------------------\n    //incoming processing\n    //---------------------------------------------------------------------------\t\t\n    //incoming\n\tassign                     chain_in_num[0] = 0;\n\tassign                     chain_in_sel[0] = 0;\n\tassign                   chain_in_order[0] = 0;\n\tassign                   chain_in_level[0] = 0;\n\tassign                    chain_in_data[0] = 0;\n\tassign                    chain_in_list[0] = 0;\n\t\n\tgenerate\n\tfor (i=0;i<`EXEC_LEN;i=i+1) begin:gen_incoming\t    \n\t\twire `N(`RGBIT)                    sel = rd_sel>>(i*`RGBIT);\n\t\twire `N(`MMCMB_OFF)              order = rd_order>>(i*`MMCMB_OFF);\n\t\twire `N(`JCBUF_OFF)              level = rd_level>>(i*`JCBUF_OFF);\n\t\twire `N(`XLEN)                    data = rd_data>>(i*`XLEN);\t\t\n\t\twire `N(`MMCMB_OFF)           order_up = sub_order(order,mem_release);\n\t\twire `N(`JCBUF_OFF)           level_up = sub_level(level,level_decrease);\t\t\n\t\twire                             clear = ( clear_pipeline & ~( (order_up==0)&(level==0) ) )|( level_clear & (level!=0) );\n\t\t\n\t\twire                               vld = (sel!=0);\n\t\twire `N(`EXEC_OFF)               shift = vld ? chain_in_num[i] : `EXEC_LEN;\n\t\tassign               chain_in_num[i+1] = chain_in_num[i] + vld;\n\t\tassign               chain_in_sel[i+1] = chain_in_sel[i]|( (clear ? 0 : sel)<<(shift*`RGBIT) );\n\t\tassign             chain_in_order[i+1] = chain_in_order[i]|( order_up<<(shift*`MMCMB_OFF) );\n\t\tassign             chain_in_level[i+1] = chain_in_level[i]|( level_up<<(shift*`JCBUF_OFF) );\n\t\tassign              chain_in_data[i+1] = chain_in_data[i]|( data<<(shift*`XLEN) );\n\t\tassign              chain_in_list[i+1] = chain_in_list[i]|( (vld & ~clear) <<sel );\n\tend\n\tendgenerate\t\n\t\n\twire `N(`EXEC_OFF)                  incoming_length = chain_in_num[`EXEC_LEN];\t\t\n\twire `N(`EXEC_LEN*`RGBIT)              incoming_sel = chain_in_sel[`EXEC_LEN];\n\twire `N(`EXEC_LEN*`MMCMB_OFF)        incoming_order = chain_in_order[`EXEC_LEN];\n\twire `N(`EXEC_LEN*`JCBUF_OFF)        incoming_level = chain_in_level[`EXEC_LEN];\n\twire `N(`EXEC_LEN*`XLEN)              incoming_data = chain_in_data[`EXEC_LEN];\n\twire `N(`RGLEN)                       incoming_list = chain_in_list[`EXEC_LEN];\n\t\n    //---------------------------------------------------------------------------\n    //rfbuf processing\n    //---------------------------------------------------------------------------\t\n\n    //rfbuf\n    assign                   chain_away_active[0] = {`RFINTO_LEN{1'b1}};\n\tassign                      chain_away_num[0] = 0;\n\tassign                      chain_away_sel[0] = 0;\n\tassign                     chain_away_data[0] = 0;\t\n\t\n\tassign                      chain_stay_num[0] = 0;\n\tassign                      chain_stay_sel[0] = 0;\n    assign                    chain_stay_order[0] = 0;\n    assign                    chain_stay_level[0] = 0;\n    assign                     chain_stay_data[0] = 0;\n    assign                     chain_stay_list[0] = 0;\n\t\n    generate \n\tfor (i=0;i<`RFBUF_LEN;i=i+1) begin:gen_rfbuf\t\n\t    wire `N(`RGBIT)                       sel = rfbuf_sel>>(i*`RGBIT);\n\t\twire `N(`XLEN)                       data = rfbuf_data>>(i*`XLEN);\n\t    wire `N(`MMCMB_OFF)                 order = rfbuf_order>>(i*`MMCMB_OFF);\n\t    wire `N(`MMCMB_OFF)              order_up = sub_order(order,mem_release);\n\t\twire `N(`JCBUF_OFF)                 level = rfbuf_level>>(i*`JCBUF_OFF);\n\t\twire `N(`JCBUF_OFF)              level_up = sub_level(level,level_decrease);\n\t\twire                                clear = ( clear_pipeline & ~( (order_up==0)&(level==0) ))|( level_clear & (level!=0) );\n\t    wire                                  vld = (i<rfbuf_length) & (sel!=0);\t\t\n\t\t\n        wire                                leave = (order_up==0) & (level==0);\t\t\n\t\twire                                 idle = chain_away_active[i];\n\t\twire                                 away = vld & leave & idle;\n\t\twire `N(`RFINTO_OFF)           away_shift = away ? chain_away_num[i] : `RFINTO_LEN;\n\t\tassign             chain_away_active[i+1] = chain_away_active[i]>>away;\n\t\tassign                chain_away_num[i+1] = chain_away_num[i] + away;\n\t\tassign                chain_away_sel[i+1] = chain_away_sel[i]|(sel<<(away_shift*`RGBIT));\n\t\tassign               chain_away_data[i+1] = chain_away_data[i]|(data<<(away_shift*`XLEN));\n\n        wire                                 stay = vld & ~away;\n        wire `N(`RFBUF_OFF)            stay_shift = stay ? chain_stay_num[i] : `RFBUF_LEN;\n\t\tassign                chain_stay_num[i+1] = chain_stay_num[i] + stay;\n\t\tassign                chain_stay_sel[i+1] = chain_stay_sel[i]|( (clear ? 0 : sel)<<(stay_shift*`RGBIT) );\n\t\tassign              chain_stay_order[i+1] = chain_stay_order[i]|(order_up<<(stay_shift*`MMCMB_OFF));\n\t\tassign              chain_stay_level[i+1] = chain_stay_level[i]|(level_up<<(stay_shift*`JCBUF_OFF));\n\t\tassign               chain_stay_data[i+1] = chain_stay_data[i]|(data<<(stay_shift*`XLEN));\n        assign               chain_stay_list[i+1] = chain_stay_list[i]|((stay & ~clear)<<sel);\t\n    end\n\tendgenerate\n\t\n\t`FFx(zero_order_list,0)\n\tzero_order_list <= chain_stay_list[`RFBUF_LEN]|incoming_list;\n\t\n\tassign                       rfbuf_order_list = zero_order_list;\n\t\n\twire `N(`RFBUF_OFF)               stay_length = chain_stay_num[`RFBUF_LEN];\n\t\n\t`FFx(rfbuf_length,0)\n\trfbuf_length <= stay_length + incoming_length;\n\n    `FFx(rfbuf_sel,0)\n\trfbuf_sel <= chain_stay_sel[`RFBUF_LEN]|(incoming_sel<<(stay_length*`RGBIT));\n    \n\t`FFx(rfbuf_order,0)\n\trfbuf_order <= chain_stay_order[`RFBUF_LEN]|(incoming_order<<(stay_length*`MMCMB_OFF));\n\t\n\t`FFx(rfbuf_level,0)\n\trfbuf_level <= chain_stay_level[`RFBUF_LEN]|(incoming_level<<(stay_length*`JCBUF_OFF));\n    \n\t`FFx(rfbuf_data,0)\n\trfbuf_data <= chain_stay_data[`RFBUF_LEN]|(incoming_data<<(stay_length*`XLEN));\n\n\t\n    //---------------------------------------------------------------------------\n    //regfile\n    //---------------------------------------------------------------------------\t\n\n    assign  away_sel = chain_away_sel[`RFBUF_LEN];\n    assign away_data = chain_away_data[`RFBUF_LEN];\t\n\t\n\twire `N(`MEM_LEN*`RGBIT)   ch_sel;\n\twire `N(`MEM_LEN*`XLEN)    ch_data;\n\tgenerate\n\tfor (i=0;i<`MEM_LEN;i=i+1) begin:gen_ch_rbank\n\t    assign             ch_sel[`IDX(i,`RGBIT)] = ( (i==0) & csr_vld ) ? csr_rd_sel : mem_sel[`IDX(i,`RGBIT)];\n\t\tassign             ch_data[`IDX(i,`XLEN)] = ( (i==0) & csr_vld ) ? csr_data : mem_data[`IDX(i,`XLEN)];\n\tend\n\tendgenerate\n\t\n\tgenerate \n\tfor (i=0;i<32;i=i+1) begin:gen_rbank\n\t    `FFx(rbank[i],0) begin:ff_rbank\n\t        integer n;\n\t\t    for (n=0;n<`RFINTO_LEN;n=n+1) begin\n\t\t        if ( ( away_sel[`IDX(n,`RGBIT)]!=0 ) & ( away_sel[`IDX(n,`RGBIT)]==i ) ) begin\n\t\t\t        rbank[i] <= away_data[`IDX(n,`XLEN)];\n\t\t\t    end\n\t\t    end\n\t\t    for (n=0;n<`MEM_LEN;n=n+1) begin\n\t\t\t    if ( ( ch_sel[`IDX(n,`RGBIT)]!=0 ) & ( ch_sel[`IDX(n,`RGBIT)]==i ) ) begin\n\t\t\t        rbank[i] <= ch_data[`IDX(n,`XLEN)];\n\t\t\t    end\n\t\t    end\t\t    \n\t\tend\n\tend\n\tendgenerate\n\n    //---------------------------------------------------------------------------\n    //output Rs0 and Rs1\n    //---------------------------------------------------------------------------\t\n\n\tgenerate\n    for(i=0;i<`EXEC_LEN;i=i+1) begin:gen_rs_data\n        wire `N(`RGBIT)                  rs0 = rs0_sel>>(i*`RGBIT);\n\t\twire `N(1+`XLEN)            rs0_info = get_from_array(rs0,{mem_sel,rfbuf_sel},{mem_data,rfbuf_data});\n\t\tassign       rs0_word[`IDX(i,`XLEN)] = rs0_info[`XLEN] ? rs0_info : ( rbank[rs0] );\n\n        wire `N(`RGBIT)                  rs1 = rs1_sel>>(i*`RGBIT);\n\t\twire `N(1+`XLEN)            rs1_info = get_from_array(rs1,{mem_sel,rfbuf_sel},{mem_data,rfbuf_data});\n\t\tassign       rs1_word[`IDX(i,`XLEN)] = rs1_info[`XLEN] ? rs1_info : ( rbank[rs1] );\n\tend\n\tendgenerate\t\n\t\n\twire `N(1+`XLEN)          extra_rs0_info = get_from_array_level(extra_rs0_sel,{mem_sel,rfbuf_sel},{mem_data,rfbuf_data},rfbuf_level);\n\tassign                    extra_rs0_word = extra_rs0_info[`XLEN] ? extra_rs0_info : ( rbank[extra_rs0_sel] );\n\t\n\twire `N(1+`XLEN)          extra_rs1_info = get_from_array_level(extra_rs1_sel,{mem_sel,rfbuf_sel},{mem_data,rfbuf_data},rfbuf_level);\n\tassign                    extra_rs1_word = extra_rs1_info[`XLEN] ? extra_rs1_info : ( rbank[extra_rs1_sel] );\t\n\t\n    assign                     rfbuf_alu_num = rfbuf_length;\t\n\t\nendmodule\n"}
{"text": "/////////////////////////////////////////////////////////////////////////////////////\n//\n//Copyright 2019  Li Xinbing\n//\n//Licensed under the Apache License, Version 2.0 (the \"License\");\n//you may not use this file except in compliance with the License.\n//You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n//Unless required by applicable law or agreed to in writing, software\n//distributed under the License is distributed on an \"AS IS\" BASIS,\n//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//See the License for the specific language governing permissions and\n//limitations under the License.\n//\n/////////////////////////////////////////////////////////////////////////////////////\n\n`include \"define.v\"\nmodule mul(\n    input                                    clk,\n    input                                    rst,\n\t\n\tinput                                    mul_initial,\n\tinput  `N(3)                             mul_para,\n\tinput  `N(`XLEN)                         mul_rs0,\n\tinput  `N(`XLEN)                         mul_rs1,\n\toutput                                   mul_ready,\n\t\n\tinput                                    clear_pipeline,\n\n\toutput                                   mul_finished,\n\toutput `N(`XLEN)                         mul_data,\t\n\tinput                                    mul_ack\n\t\n);\n\n\n    //---------------------------------------------------------------------------\n    //function defination\n    //---------------------------------------------------------------------------\n\n    function `N($clog2(`XLEN+1)) highest_pos(input `N(`XLEN) d);\n\tinteger i;\n\tbegin\n\t    highest_pos = 0;\n\t    for (i=0;i<`XLEN;i=i+1)\n\t\t    if ( d[i] )\n\t            highest_pos = i;\n\tend\n\tendfunction\n\n\tfunction `N($clog2(`XLEN+1)) sumbits(input `N(`XLEN) d);\n\tinteger i;\n\tbegin\n\t    sumbits = 0;\n\t\tfor (i=0;i<`XLEN;i=i+1)\n\t\t    sumbits = sumbits + d[i];\n\tend\n\tendfunction\n\n    //---------------------------------------------------------------------------\n    //signal defination\n    //---------------------------------------------------------------------------\n\n\treg                           calc_flag;\n\treg  `N(3)                    calc_para;\n\treg                           calc_sign_xor,calc_sign_rs0;\n\treg  `N(`XLEN)                calc_a,calc_b,calc_x,calc_y;\n\treg  `N($clog2(`XLEN+1))      calc_a_pos,calc_b_pos;\n\twire                          calc_over;\n\twire `N(`XLEN)                calc_a_in,calc_b_in,calc_x_in,calc_y_in;\t\n\t\n\treg                           write_flag;\n\treg  `N(`XLEN)                write_data;\n    wire                          write_over;\n\t\n    //---------------------------------------------------------------------------\n    //statements area\n    //---------------------------------------------------------------------------\t\n\n\twire `N(`XLEN)              rs0_word = mul_rs0;\n\twire `N(`XLEN)              rs1_word = mul_rs1;\n\twire                        rs0_sign = mul_para[2] ? (~mul_para[0] & rs0_word[31]) : ( (mul_para[1:0]!=2'b11) & rs0_word[31] );\n\twire                        rs1_sign = mul_para[2] ? (~mul_para[0] & rs1_word[31]) : ( ~mul_para[1] & rs1_word[31] );\t\n\twire `N(`XLEN)              rs0_data = rs0_sign ? ( ~rs0_word + 1'b1 ) : rs0_word;\n\twire `N(`XLEN)              rs1_data = rs1_sign ? ( ~rs1_word + 1'b1 ) : rs1_word;\t\n\n    wire                      mul_direct = mul_para[2] ? ((rs1_word==0)|(rs0_data<rs1_data)) : ((rs0_word==0)|(rs1_word==0));\t\n    wire                     mul_is_busy = calc_flag|(write_flag & ~write_over);\n\tassign                     mul_ready = ~mul_is_busy;\n\t\n\t//to calcuate MUL/DIV function\n\twire                      calc_start = mul_initial & ~mul_direct & ~mul_is_busy & ~clear_pipeline;\t\n\twire                     write_start = mul_initial &  mul_direct & ~mul_is_busy & ~clear_pipeline;\n\t\n\t`FFx(calc_flag,0)\n\tif ( calc_start )\n\t    calc_flag <= 1'b1;\n\telse if ( calc_over|clear_pipeline )\n\t    calc_flag <= 1'b0;\n\telse;\n\t\n\t`FFx(calc_para,0)\n\tif ( calc_start|write_start )\n\t    calc_para <= mul_para[2:0];\n\telse;\n\t\n\t`FFx(calc_sign_xor,0)\n\tif ( calc_start|write_start )\n\t    calc_sign_xor <= (mul_para[2]&(rs1_word==0)) ? 0 : (rs0_sign^rs1_sign);\n\telse;\n\t\n\t`FFx(calc_sign_rs0,0)\n\tif ( calc_start|write_start )\n\t    calc_sign_rs0 <= rs0_sign;\n    else;\n\n\twire                num_less_compare = sumbits(rs0_data)<sumbits(rs1_data);\n\n\t`FFx(calc_a,0)\n\tif ( calc_start|write_start )\n\t    if ( mul_para[2] )\n\t\t    calc_a <= rs0_data;\n\t\telse\n\t\t    calc_a <= num_less_compare ? rs1_data : rs0_data;\n\telse if ( calc_flag )\n\t    calc_a <= calc_a_in;\n\telse;\n\t\n\t`FFx(calc_b,0)\n\tif ( calc_start|write_start )\n\t    if ( mul_para[2] )\n\t\t    calc_b <= rs1_data;\n\t\telse\n\t\t    calc_b <= num_less_compare ? rs0_data : rs1_data;\n\telse if ( calc_flag )\n\t    calc_b <= calc_b_in;\n\telse;\n\t\n\t`FFx(calc_x,0)\n\tif ( calc_start|write_start )\n\t    if ( mul_para[2] )\n\t\t    calc_x <= ( rs1_word==0 ) ? 32'hffffffff : 0;\n\t\telse\n\t\t    calc_x <= 0;\n\telse if ( calc_flag )\n\t    calc_x <= calc_x_in;\n\telse;\n\t\n\t`FFx(calc_y,0)\n\tif ( calc_start|write_start )\n\t    calc_y <= 0;\n\telse if ( calc_flag )\n\t    calc_y <= calc_y_in;\n\telse;\n\t\n    wire `N(`XLEN)              pos_a_in = calc_flag ? calc_a_in : rs0_data;\n    wire `N(5)                 pos_a_out = highest_pos(pos_a_in);\n    wire `N(`XLEN)              pos_b_in = calc_flag ? calc_b_in : rs1_data;\n    wire `N(5)                 pos_b_out = highest_pos(pos_b_in);\n\n    `FFx(calc_a_pos,0)\n\tif ( calc_start|write_start )\n        if ( mul_para[2] )\n            calc_a_pos <= pos_a_out;\n        else \n            calc_a_pos <= num_less_compare ? pos_b_out : pos_a_out;\n\telse if ( calc_flag )\n\t    calc_a_pos <= pos_a_out;\n    else;\n\n    `FFx(calc_b_pos,0)\n\tif ( calc_start|write_start )\n        if ( mul_para[2] )\n            calc_b_pos <= pos_b_out;\n        else \n            calc_b_pos <= num_less_compare ? pos_a_out : pos_b_out;\n\telse if ( calc_flag )\n\t    calc_b_pos <= pos_b_out;\n    else;\n\t\n\twire `N($clog2(`XLEN+1)) calc_ab_gap = calc_a_pos - calc_b_pos;\n\twire `N($clog2(`XLEN))  calc_ab_diff = calc_ab_gap;\n\n\twire `N(2*`XLEN)           mul_shift = calc_a<<calc_b_pos;\n\twire                        sub_sign = calc_para[2] ? 1'b1 : calc_sign_xor;\n\n\twire `N(`XLEN)           low_add_in0 = calc_para[2] ? calc_a : calc_x;\n\twire `N(`XLEN)           low_add_in1 = calc_para[2] ? ( calc_b<<calc_ab_diff ) : mul_shift;\n    wire `N(`XLEN+1)         low_add_out = sub_sign ? (low_add_in0 - low_add_in1) : (low_add_in0 + low_add_in1);\n\t\n\twire                       carry_bit = low_add_out[`XLEN];\n\twire                    high_add_bit = calc_para[2] ? 1'b0 : carry_bit;\n\n    wire `N(`XLEN)          high_add_in0 = calc_para[2] ? calc_a : calc_y;\n    wire `N(`XLEN)          high_add_in1 = calc_para[2] ? ( ( calc_b<<calc_ab_diff )>>1 ) : (mul_shift>>`XLEN);\n    wire `N(`XLEN)          high_add_out = sub_sign ? (high_add_in0 - high_add_in1 - high_add_bit) : (high_add_in0 + high_add_in1 + high_add_bit);\n\n\tassign                     calc_a_in = calc_para[2] ?  ( carry_bit ? high_add_out : low_add_out ) : calc_a;\n\tassign                     calc_b_in = calc_para[2] ? calc_b : ( calc_b ^ (1'b1<<calc_b_pos) );\n\tassign                     calc_x_in = calc_para[2] ? ( calc_x|( (1'b1<<calc_ab_diff)>>carry_bit ) ) : low_add_out;\n\tassign                     calc_y_in = calc_para[2] ? calc_y : high_add_out;\n\t\n\tassign                     calc_over = calc_flag & ( calc_para[2] ? ( calc_a_in<calc_b ) : (calc_b_in==0) );\n\t\n\t//write from mem channel\n\t\n\t`FFx(write_flag,0)\n\tif( write_start|calc_over )\n\t    write_flag <= 1'b1;\n\telse if ( write_over|clear_pipeline )\n\t    write_flag <= 1'b0;\n\telse;\n\t\n\talways @*\n\tif ( write_flag )\n\t    case(calc_para)\n\t    3'h0          :  write_data = calc_x;\n\t    3'h1,3'h2,3'h3:  write_data = calc_y;\n        3'h4,3'h5     :  write_data = calc_sign_xor ? (~calc_x+1'b1) : calc_x;\n        3'h6,3'h7     :  write_data = calc_sign_rs0 ? (~calc_a+1'b1) : calc_a;\n        endcase\n\telse\n\t    write_data = 0;\n\n    //mul buffer\n\treg  `N(`MULBUF_LEN*`XLEN) mulbuf_data;\n\treg  `N(`MULBUF_OFF)       mulbuf_length;\n\t\n\twire `N(`MULBUF_LEN*`XLEN) primary_data   = mulbuf_data|(write_data<<(mulbuf_length*`XLEN));\n\twire `N(`MULBUF_OFF)       primary_length = (mulbuf_length==`MULBUF_LEN) ? `MULBUF_LEN : (mulbuf_length + write_flag);\n\n    assign write_over = write_flag & (mulbuf_length<`MULBUF_LEN);\n\n    assign mul_finished   = primary_length!=0;\n    assign mul_data       = primary_data;\n\t\n    `FFx(mulbuf_data,0)\n    if ( clear_pipeline )\t\n\t    mulbuf_data <= 0;\n\telse\n\t    mulbuf_data <= primary_data>>(mul_ack*`XLEN);\n\t\t\n\t`FFx(mulbuf_length,0)\n\tif ( clear_pipeline )\n\t    mulbuf_length <= 0;\n\telse\n\t    mulbuf_length <= primary_length - mul_ack;\nendmodule\n\n"}
{"text": "/////////////////////////////////////////////////////////////////////////////////////\n//\n//Copyright 2019  Li Xinbing\n//\n//Licensed under the Apache License, Version 2.0 (the \"License\");\n//you may not use this file except in compliance with the License.\n//You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n//Unless required by applicable law or agreed to in writing, software\n//distributed under the License is distributed on an \"AS IS\" BASIS,\n//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//See the License for the specific language governing permissions and\n//limitations under the License.\n//\n/////////////////////////////////////////////////////////////////////////////////////\n\n\n\n`include \"define.v\"\n\n\nmodule predictor(\n    input                       clk,\n\tinput                       rst,\n\t\n\tinput                       imem_req,\n\tinput  `N(`XLEN)            imem_addr,\t\n    output `N(2*`BUS_LEN)       imem_predict,\n\t\n\tinput                       jcond_vld,\n\tinput  `N(`XLEN)            jcond_pc,\n\tinput                       jcond_hit,\n\tinput                       jcond_taken\n\n);\n\n\n    //---------------------------------------------------------------------------\n    //function defination\n    //---------------------------------------------------------------------------\n\n    function predict_bit( input `N(`PDT_BLEN) bits );\n\tbegin\n\t    case(bits)\n\t\t5'b00000 : predict_bit = 0;\n\t\t5'b00001 : predict_bit = 0;\n\t\t5'b00010 : predict_bit = 0;\n\t\t5'b00011 : predict_bit = 1;\n        5'b00100 : predict_bit = 0;\n\t\t5'b00101 : predict_bit = 0;\n\t\t5'b00110 : predict_bit = 0;\n\t\t5'b00111 : predict_bit = 1;\n\t\t5'b01000 : predict_bit = 0;\n\t\t5'b01001 : predict_bit = 0;\n\t\t5'b01010 : predict_bit = 1;\n\t\t5'b01011 : predict_bit = 1;\n\t\t5'b01100 : predict_bit = 0;\n\t\t5'b01101 : predict_bit = 1;\n\t\t5'b01110 : predict_bit = 0;\n\t\t5'b01111 : predict_bit = 1;\n\t\t5'b10000 : predict_bit = 0;\n\t\t5'b10001 : predict_bit = 0;\n\t\t5'b10010 : predict_bit = 1;\n\t\t5'b10011 : predict_bit = 1;\n        5'b10100 : predict_bit = 0;\n\t\t5'b10101 : predict_bit = 0;\n\t\t5'b10110 : predict_bit = 1;\n\t\t5'b10111 : predict_bit = 1;\n\t\t5'b11000 : predict_bit = 0;\n\t\t5'b11001 : predict_bit = 1;\n\t\t5'b11010 : predict_bit = 1;\n\t\t5'b11011 : predict_bit = 1;\n\t\t5'b11100 : predict_bit = 0;\n\t\t5'b11101 : predict_bit = 1;\n\t\t5'b11110 : predict_bit = 1;\n\t\t5'b11111 : predict_bit = 1;\t\t\n        endcase\n    end\n    endfunction\t\n\n\n    //---------------------------------------------------------------------------\n    //signal defination\n    //---------------------------------------------------------------------------\n    reg  `N(`PDT_LEN)                 pdt_vld;\n\treg  `N(`PDT_ADDR*`PDT_LEN)       pdt_address;\n\treg  `N(`PDT_BLEN*`PDT_LEN)       pdt_bits;\n\n    wire `N(2*`BUS_LEN)               chain_predict      `N(`PDT_LEN+1);\n\n    reg  `N(2*`BUS_LEN)               get_predict;\n\n    genvar i;\n    //---------------------------------------------------------------------------\n    //statements area\n    //---------------------------------------------------------------------------\n\t\n    //---------------------------------------------------------------------------\n\t//output predict bit\n\t//---------------------------------------------------------------------------\t\n\t\n\tassign                              chain_predict[0] = 0;\n\n`ifdef INSTR_MISALLIGNED\n    \n\twire `N(`PDT_ADDR)                   target_original = imem_addr>>1;\n\twire `N(`BUS_OFF)                       target_shift = target_original;\n\twire `N(`PDT_ADDR-`BUS_OFF)           target_address = target_original>>`BUS_OFF;\n\t\n\tgenerate\n\tfor (i=0;i<`PDT_LEN;i=i+1) begin:gen_imem_predict\n\t\twire `N(`BUS_OFF)                     this_shift = pdt_address[`IDX(i,`PDT_ADDR)];\n\t\twire `N(`PDT_ADDR-`BUS_OFF)         this_address = pdt_address[`IDX(i,`PDT_ADDR)]>>`BUS_OFF;\t\t\n\t\twire                                      bigger = this_shift>=target_shift;\n\t\twire `N(`PDT_ADDR-`BUS_OFF)           to_address = bigger ? target_address : ( target_address + 1'b1 );\n\t\twire                                    this_bit = pdt_vld[i] & (to_address==this_address) & predict_bit(pdt_bits[`IDX(i,`PDT_BLEN)]);\t\t\n\t\twire `N(`BUS_OFF)                       to_shift = this_shift - target_shift;\n\t    assign                        chain_predict[i+1] = chain_predict[i]|(this_bit<<to_shift);\t\t\n    end    \n\tendgenerate\n\t\n`else\n\n\twire `N(`PDT_ADDR-`BUS_OFF)           target_address = imem_addr>>(1+`BUS_OFF);\n\n    generate\n\tfor (i=0;i<`PDT_LEN;i=i+1) begin:gen_imem_predict\n\t\twire `N(`BUS_OFF)                     this_shift = pdt_address[`IDX(i,`PDT_ADDR)];\n\t\twire `N(`PDT_ADDR-`BUS_OFF)         this_address = pdt_address[`IDX(i,`PDT_ADDR)]>>`BUS_OFF;\n\t\twire                                    this_bit = pdt_vld[i] & (target_address==this_address) & predict_bit(pdt_bits[`IDX(i,`PDT_BLEN)]);\n\t    assign                        chain_predict[i+1] = chain_predict[i]|(this_bit<<this_shift);\n\tend\n\tendgenerate\n\t\n`endif\t\n\n\t`FFx(get_predict,0)\n\tif ( imem_req )\n\t    get_predict <= chain_predict[`PDT_LEN];\n\telse;\n\t\n\tassign imem_predict = get_predict;\n\n    //---------------------------------------------------------------------------\n\t//update predict items\n\t//---------------------------------------------------------------------------\t\n\n    wire `N(`PDT_LEN+1)  chain_find_vld;\n\twire `N(`PDT_OFF)    chain_find_index `N(`PDT_LEN+1);\n\t\n\tassign                          chain_find_vld[0] = 0;\n\tassign                        chain_find_index[0] = 0;\n\t\n\twire `N(`PDT_ADDR)                       find_aim = jcond_pc>>1;\n\t\n\tgenerate\n\tfor (i=0;i<`PDT_LEN;i=i+1) begin:gen_find_index\n\t    assign                    chain_find_vld[i+1] = chain_find_vld[i]|(pdt_vld[i] & (pdt_address[`IDX(i,`PDT_ADDR)]==find_aim));\n\t\tassign                  chain_find_index[i+1] = (pdt_vld[i] & (pdt_address[`IDX(i,`PDT_ADDR)]==find_aim)) ? i : chain_find_index[i];\n\tend\n\tendgenerate\n    \n    wire                                     find_vld = chain_find_vld[`PDT_LEN];\n\twire  `N(`PDT_OFF)                     find_index = chain_find_index[`PDT_LEN];\n\t\n    wire  `N(`PDT_OFF)                     high_shift = find_index + find_vld;\n    wire  `N(`PDT_LEN)                       high_vld = pdt_vld & ( ~((1'b1<<high_shift)-1'b1) );\n    wire  `N(`PDT_ADDR*`PDT_LEN)         high_address = pdt_address & ( ~((1'b1<<(high_shift*`PDT_ADDR))-1'b1) );\n\twire  `N(`PDT_BLEN*`PDT_LEN)            high_bits = pdt_bits & ( ~((1'b1<<(high_shift*`PDT_BLEN))-1'b1) );\n\t\n\twire  `N(`PDT_OFF)                      low_shift = find_index;\n\twire  `N(`PDT_LEN)                        low_vld = pdt_vld & ( (1'b1<<low_shift)-1'b1 );\n    wire  `N(`PDT_ADDR*`PDT_LEN)          low_address = pdt_address & ( (1'b1<<(low_shift*`PDT_ADDR))-1'b1 );\n\twire  `N(`PDT_BLEN*`PDT_LEN)             low_bits = pdt_bits & ( (1'b1<<(low_shift*`PDT_BLEN))-1'b1 );    \n\n    wire                                      new_vld = jcond_vld & ( find_vld|(~jcond_hit) );\n\twire `N(`PDT_ADDR)                    new_address = find_aim;\n\twire `N(`PDT_BLEN)                       old_bits = find_vld ? ( pdt_bits>>(find_index*`PDT_BLEN) ) : 5'b11111;\n\twire `N(`PDT_BLEN)                       new_bits = { old_bits,jcond_taken };\n\n    wire `N(`PDT_LEN)                          go_vld = ( high_vld<<(find_vld ? 1'b0 : 1'b1) )|( low_vld<<1 )|new_vld;\n\twire `N(`PDT_ADDR*`PDT_LEN)            go_address = ( high_address<<(find_vld ? 0 : `PDT_ADDR) )|( low_address<<`PDT_ADDR )|new_address;\n    wire `N(`PDT_BLEN*`PDT_LEN)               go_bits = ( high_bits<<(find_vld ? 0 : `PDT_BLEN) )|( low_bits<<`PDT_BLEN )|new_bits;\n\t\n\t`FFx(pdt_vld,0)\n\tif ( new_vld )\n\t    pdt_vld <= go_vld;\n\telse;\n\t\n\t`FFx(pdt_address,0)\n\tif ( new_vld )\n\t    pdt_address <= go_address;\n\telse;\n\t\n\t`FFx(pdt_bits,0)\n\tif ( new_vld )\n\t    pdt_bits <= go_bits;\n\telse;\n\nendmodule\n"}
{"text": "/////////////////////////////////////////////////////////////////////////////////////\n//\n//Copyright 2019  Li Xinbing\n//\n//Licensed under the Apache License, Version 2.0 (the \"License\");\n//you may not use this file except in compliance with the License.\n//You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n//Unless required by applicable law or agreed to in writing, software\n//distributed under the License is distributed on an \"AS IS\" BASIS,\n//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//See the License for the specific language governing permissions and\n//limitations under the License.\n//\n/////////////////////////////////////////////////////////////////////////////////////\n\n`include \"define.v\"\n\n`define  TIMING_STYLE\n\nmodule schedule(\n\n    input                                                                    clk,\n    input                                                                    rst,\n \n    output `N(`SDBUF_OFF)                                                    sdbuf_left_num, \n    input  `N(`FETCH_LEN)                                                    fetch_vld,\n    input  `N(`FETCH_LEN*`XLEN)                                              fetch_instr,\n    input  `N(`FETCH_LEN*`XLEN)                                              fetch_pc,\n    input  `N(`FETCH_LEN*`EXEC_PARA_LEN)                                     fetch_para,\n\tinput  `N(`FETCH_LEN*`JCBUF_OFF)                                         fetch_level,\n \n\toutput `N(`EXEC_LEN)                                                     exec_vld,\n\toutput reg `N(`EXEC_LEN*`XLEN)                                           exec_instr,\n\toutput reg `N(`EXEC_LEN*`XLEN)                                           exec_pc,\t\n\toutput reg `N(`EXEC_LEN*`EXEC_PARA_LEN)                                  exec_para,\n\toutput reg `N(`EXEC_LEN*`JCBUF_OFF)                                      exec_level,\t\n\toutput reg `N(`EXEC_LEN*`MMCMB_OFF)                                      exec_order,\n \n\tinput  `N(`RGBIT)                                                        mmbuf_check_rdnum,\n\tinput  `N(`RGLEN)                                                        mmbuf_check_rdlist,\n\tinput  `N(`RGLEN)                                                        mmbuf_instr_rdlist,\n\tinput  `N(`MMBUF_OFF)                                                    mmbuf_mem_num,\n\tinput  `N(`RFBUF_OFF)                                                    rfbuf_alu_num,\n    input  `N(`MEM_OFF)                                                      mem_release,\n    input                                                                    clear_pipeline,\n\tinput                                                                    level_decrease,\n\tinput                                                                    level_clear,\n    output `N(`RGLEN)                                                        pipeline_instr_rdlist,\n    output                                                                   pipeline_is_empty,\t\n\toutput                                                                   schd_intflag,\n    output `N(`XLEN)                   \t                                     schd_intpc\n\t\n);\n\n    //---------------------------------------------------------------------------\n    //function defination\n    //---------------------------------------------------------------------------\n\n    `include \"include_func.v\"\n\n`ifdef TIMING_STYLE\n    function check_hard( input `N(`EXEC_PARA_LEN) a_para,b_para );\n\t\treg a_mem,a_alu,b_mem,b_alu;\n\t\treg `N(`RGBIT) a_rs0,a_rs1,a_rd,b_rs0,b_rs1,b_rd;\n\tbegin\n\t\ta_mem      = (a_para>>((3*`RGBIT)+1));\n\t\ta_alu      = (a_para>>(3*`RGBIT));\n\t\ta_rs0      = a_para;\n\t\ta_rs1      = a_para>>`RGBIT;\n\t\ta_rd       = a_para>>(2*`RGBIT);\n\t\tb_mem      = (b_para>>((3*`RGBIT)+1));\n\t\tb_alu      = (b_para>>(3*`RGBIT));\t\n\t\tb_rs0      = b_para;\n\t\tb_rs1      = b_para>>`RGBIT;\n\t\tb_rd       = b_para>>(2*`RGBIT);\t\t\n\n        check_hard =  (a_rd!=0)&(((a_rd==b_rs0)|(a_rd==b_rs1))|(a_mem&(a_rd==b_rd)));\t\n\t\n\tend\n\tendfunction\n\n    function check_soft( input `N(`EXEC_PARA_LEN) a_para,b_para );\n\t\treg  a_mem,a_alu,b_mem,b_alu;\n\t\treg `N(`RGBIT) a_rs0,a_rs1,a_rd,b_rs0,b_rs1,b_rd;\n\tbegin\n\t\ta_mem      = (a_para>>((3*`RGBIT)+1));\n\t\ta_alu      = (a_para>>(3*`RGBIT));\n\t\ta_rs0      = a_para;\n\t\ta_rs1      = a_para>>`RGBIT;\n\t\ta_rd       = a_para>>(2*`RGBIT);\n\t\tb_mem      = (b_para>>((3*`RGBIT)+1));\n\t\tb_alu      = (b_para>>(3*`RGBIT));\t\n\t\tb_rs0      = b_para;\n\t\tb_rs1      = b_para>>`RGBIT;\n\t\tb_rd       = b_para>>(2*`RGBIT);\t\t\n\t\n\t    check_soft = (b_rd!=0)&((a_rs0==b_rd)|(a_rs1==b_rd)|(a_alu&(a_rd==b_rd)));\t\n\t\n\tend\n\tendfunction\n\n`endif\t\n\t\n\tfunction check_blacklist( input `N(`EXEC_PARA_LEN) para, input `N(`RGLEN) rd_list,rs_list );\n        reg `N(`RGBIT) rs0,rs1,rd;\t\n        reg    rd_hit, rs_hit;\t\t\n\tbegin\n        rs0             = para;\n\t\trs1             = para>>`RGBIT;\n\t\trd              = para>>(2*`RGBIT);\n        \n        rd_hit          = |( ( rd_list & `LASTBIT_MASK ) & ( 1'b1<<rd ) );\n        rs_hit          = |( ( rs_list & `LASTBIT_MASK ) & ( ( 1'b1<<rs0 )|( 1'b1<<rs1 ) ) );\n        \n        check_blacklist = rd_hit|rs_hit; \t\t\n\tend\n\tendfunction\n\t\t\n\tfunction check_gray( input `N(`EXEC_PARA_LEN) para, input `N(`RGBIT) gray_num );\n        reg `N(`RGBIT) rs0,rs1,rd;\t \n\tbegin\n        rs0             = para;\n\t\trs1             = para>>`RGBIT;\n\t\trd              = para>>(2*`RGBIT);\n\n        check_gray      = ((rs0==gray_num)|(rs1==gray_num)|(rd==gray_num))&(gray_num!=0);\t\t\n\tend\n\tendfunction\n\t\n    //---------------------------------------------------------------------------\n    //signal defination\n    //---------------------------------------------------------------------------\t\n\twire `N((`FETCH_LEN+1)*`MMCMB_OFF)       chain_order;\t\n    wire `N(`FETCH_LEN*`MMCMB_OFF)           fetch_order;\n\t\n    wire `N(`SDBUF_LEN)                      go_vld;  \n\twire `N(`SDBUF_LEN*`XLEN)                go_instr;\n\twire `N(`SDBUF_LEN*`XLEN)                go_pc;   \n\twire `N(`SDBUF_LEN*`EXEC_PARA_LEN)       go_para;\n\twire `N(`SDBUF_LEN*`MMCMB_OFF)           go_order;\n\twire `N(`SDBUF_LEN*`JCBUF_OFF)           go_level;\n\twire `N(`SDBUF_LEN)                      go_stay;\n\n\twire `N(`RGBIT)                          check_num;\n\twire `N(`RGLEN)                          check_rdlist;\t\n\n`ifndef TIMING_STYLE\n    wire `N(`RGLEN)                          rd_checklist             `N(`SDBUF_LEN+1);\n\twire `N(`RGLEN)                          rs_checklist             `N(`SDBUF_LEN+1);\n`endif\t\n    wire `N(`MMBUF_LEN)                      mem_active               `N(`SDBUF_LEN+1);\n    wire `N(`RFBUF_LEN)                      rf_active                `N(`SDBUF_LEN+1);\n    wire `N(`EXEC_LEN)                       exec_active              `N(`SDBUF_LEN+1);\n\twire `N(`EXEC_OFF)                       exec_num                 `N(`SDBUF_LEN+1);\n\twire `N(`SDBUF_OFF)                      sdbuf_num                `N(`SDBUF_LEN+1);\n\n\twire `N(`EXEC_LEN)                       chain_exec_direct        `N(`SDBUF_LEN+1);\n\twire `N(`EXEC_LEN)                       chain_exec_preload       `N(`SDBUF_LEN+1);\n\twire `N(`EXEC_LEN*`XLEN)                 chain_exec_instr         `N(`SDBUF_LEN+1);\n\twire `N(`EXEC_LEN*`XLEN)                 chain_exec_pc            `N(`SDBUF_LEN+1);\n\twire `N(`EXEC_LEN*`EXEC_PARA_LEN)        chain_exec_para          `N(`SDBUF_LEN+1);\n\twire `N(`EXEC_LEN*`MMCMB_OFF)            chain_exec_order         `N(`SDBUF_LEN+1);\t\n\twire `N(`EXEC_LEN*`JCBUF_OFF)            chain_exec_level         `N(`SDBUF_LEN+1);\n\n\twire `N(`SDBUF_LEN)                      chain_sdbuf_direct       `N(`SDBUF_LEN+1);\n\twire `N(`SDBUF_LEN)                      chain_sdbuf_preload      `N(`SDBUF_LEN+1);\t\n\twire `N(`SDBUF_LEN*`XLEN)                chain_sdbuf_instr        `N(`SDBUF_LEN+1);\n\twire `N(`SDBUF_LEN*`XLEN)                chain_sdbuf_pc           `N(`SDBUF_LEN+1);\n\twire `N(`SDBUF_LEN*`EXEC_PARA_LEN)       chain_sdbuf_para         `N(`SDBUF_LEN+1);\n\twire `N(`SDBUF_LEN*`MMCMB_OFF)           chain_sdbuf_order        `N(`SDBUF_LEN+1);\t\n\twire `N(`SDBUF_LEN*`JCBUF_OFF)           chain_sdbuf_level        `N(`SDBUF_LEN+1);\n\t\n\twire `N(`SDBUF_OFF)                      chain_sdexec_mem_num     `N(`SDBUF_LEN+1);\n\twire `N(`RGLEN)                          chain_sdbuf_instr_rdlist `N(`SDBUF_LEN+1);\t\t\n\t\n\twire `N(`EXEC_OFF)                       chain_exec_mem_num0      `N(`SDBUF_LEN+1);\n\twire `N(`EXEC_OFF)                       chain_exec_mem_num1      `N(`SDBUF_LEN+1);\t\n\twire `N(`EXEC_OFF)                       chain_exec_alu_num0      `N(`SDBUF_LEN+1);\n\twire `N(`EXEC_OFF)                       chain_exec_alu_num1      `N(`SDBUF_LEN+1);\t\n\t\n\twire                                     chain_find_mem           `N(`SDBUF_LEN+1);\n\twire `N(`XLEN)                           chain_find_pc            `N(`SDBUF_LEN+1);\t\t\n\t\n\treg  `N(`EXEC_LEN)                       exec_direct;\n\treg  `N(`EXEC_LEN)                       exec_preload;\n\n    reg  `N(`SDBUF_LEN)                      sdbuf_direct;\n\treg  `N(`SDBUF_LEN)                      sdbuf_preload;\n    wire `N(`SDBUF_LEN)                      sdbuf_vld;\n    reg  `N(`SDBUF_LEN*`XLEN)                sdbuf_instr;\n\treg  `N(`SDBUF_LEN*`XLEN)                sdbuf_pc;\n\treg  `N(`SDBUF_LEN*`EXEC_PARA_LEN)       sdbuf_para;\n\treg  `N(`SDBUF_LEN*`MMCMB_OFF)           sdbuf_order;\n\treg  `N(`SDBUF_LEN*`JCBUF_OFF)           sdbuf_level;\n\treg  `N(`SDBUF_OFF)                      sdbuf_length;\n\n    reg  `N(`SDBUF_OFF)                      sdexec_mem_num;\n\treg  `N(`RGLEN)                          sdbuf_instr_rdlist;\n\t\n\treg  `N(`EXEC_OFF)                       exec_mem_num0;\n\treg  `N(`EXEC_OFF)                       exec_mem_num1;\n\twire `N(`EXEC_OFF)                       exec_mem_num;\t\n\treg  `N(`EXEC_OFF)                       exec_alu_num0;\n\treg  `N(`EXEC_OFF)                       exec_alu_num1;\t\n\twire `N(`EXEC_OFF)                       exec_alu_num;\t\t\n\treg  `N(`RGBIT)                          exec_check_rdnum0;\n\treg  `N(`RGBIT)                          exec_check_rdnum1;\n\twire `N(`RGBIT)                          exec_check_rdnum;\n\treg  `N(`RGLEN)                          exec_check_rdlist0;\n\treg  `N(`RGLEN)                          exec_check_rdlist1;\n\twire `N(`RGLEN)                          exec_check_rdlist;\n\t\n    genvar i,j;\n    //---------------------------------------------------------------------------\n    //statements area\n    //---------------------------------------------------------------------------\n\t\n    //-------------------------------------------------------------------------------------------\n    //to get order for every instuction: how many MEM instructions exist in membuf and sdbuf.\n\t//-------------------------------------------------------------------------------------------\n\t\n\tassign       chain_order[`IDX(0,`MMCMB_OFF)] = mmbuf_mem_num + sdexec_mem_num;\n\t\n\tgenerate\n\tfor (i=0;i<`FETCH_LEN;i=i+1) begin:gen_fetch_order\n\t    wire                                 vld = fetch_vld>>i;\n\t    wire `N(`EXEC_PARA_LEN)             para = fetch_para>>(i*`EXEC_PARA_LEN);\n\t\twire                                 mem = para>>(1+3*`RGBIT);\n\t\tassign chain_order[`IDX(i+1,`MMCMB_OFF)] = chain_order[`IDX(i,`MMCMB_OFF)] + (vld&mem);\n\tend\n\tendgenerate\n\t\n\tassign                           fetch_order = chain_order>>`MMCMB_OFF;\n\t\n\t//-------------------------------------------------------------------------------------------\n\t//to evaluate sdbuf\n\t//-------------------------------------------------------------------------------------------\n    //to combine incoming instructions and sdbuf instructions.\n\tassign                                go_vld = sdbuf_vld|(fetch_vld<<sdbuf_length);\n\tassign                              go_instr = sdbuf_instr|(fetch_instr<<(sdbuf_length*`XLEN));\n\tassign                                 go_pc = sdbuf_pc|(fetch_pc<<(sdbuf_length*`XLEN));\n\tassign                               go_para = sdbuf_para|(fetch_para<<(sdbuf_length*`EXEC_PARA_LEN));\n\tassign                              go_order = sdbuf_order|(fetch_order<<(sdbuf_length*`MMCMB_OFF));\n\tassign                              go_level = sdbuf_level|(fetch_level<<(sdbuf_length*`JCBUF_OFF));\n\n\tassign                             check_num = mmbuf_check_rdnum;\n\tassign                          check_rdlist = mmbuf_check_rdlist;\n\n`ifndef TIMING_STYLE\n    assign                       rd_checklist[0] = check_rdlist;\n\tassign                       rs_checklist[0] = check_rdlist;\n`endif\t\n    assign                         mem_active[0] = {`MMBUF_LEN{1'b1}}>>(mmbuf_mem_num + exec_mem_num);     //membuf left space\n    assign                          rf_active[0] = {`RFBUF_LEN{1'b1}}>>(rfbuf_alu_num + exec_alu_num);     //rfbuf left space\n    assign                        exec_active[0] = {`EXEC_LEN{1'b1}};\t\n\tassign                           exec_num[0] = 0;\n\tassign                          sdbuf_num[0] = 0;\n\t\n\tassign                  chain_exec_direct[0] = 0;\n\tassign                 chain_exec_preload[0] = 0;\n\tassign                   chain_exec_instr[0] = 0;\n\tassign                      chain_exec_pc[0] = 0;\n\tassign                    chain_exec_para[0] = 0;\n\tassign                   chain_exec_order[0] = 0;\n\tassign                   chain_exec_level[0] = 0;   \n\t\n\tassign                 chain_sdbuf_direct[0] = 0;\n\tassign                chain_sdbuf_preload[0] = 0;\n\tassign                  chain_sdbuf_instr[0] = 0;\n\tassign                     chain_sdbuf_pc[0] = 0;\n\tassign                   chain_sdbuf_para[0] = 0;\n\tassign                  chain_sdbuf_order[0] = 0;\n\tassign                  chain_sdbuf_level[0] = 0;\t\t\n\t\n\tassign               chain_sdexec_mem_num[0] = 0;\n\tassign           chain_sdbuf_instr_rdlist[0] = 0;\n\t\n    assign                chain_exec_mem_num0[0] = 0;\n    assign                chain_exec_mem_num1[0] = 0;\t\n    assign                chain_exec_alu_num0[0] = 0;\n    assign                chain_exec_alu_num1[0] = 0;\t\t\n\t\n\tassign                     chain_find_mem[0] = 0;\n\tassign                      chain_find_pc[0] = 0;\t\n\n    generate \n\tfor (i=0;i<`SDBUF_LEN;i=i+1) begin:gen_sdbuf\n\t    //basic info\n\t\twire `N(`XLEN)                     instr = go_instr>>(i*`XLEN);\n\t\twire `N(`XLEN)                        pc = go_pc>>(i*`XLEN);\n\t\twire `N(`EXEC_PARA_LEN)             para = go_para>>(i*`EXEC_PARA_LEN);\n\t\twire                                 mem = para>>(1+3*`RGBIT);\n\t\twire                                 alu = para>>(3*`RGBIT);\n\t\twire `N(`RGBIT)                      rs0 = para;\n\t\twire `N(`RGBIT)                      rs1 = para>>`RGBIT;\n\t\twire `N(`RGBIT)                       rd = para>>(2*`RGBIT);\n\t\twire `N(`MMCMB_OFF)                order = go_order>>(i*`MMCMB_OFF);\n\t\twire `N(`MMCMB_OFF)               orderx = sub_order(order,mem_release);\t\n        wire `N(`JCBUF_OFF)                level = go_level>>(i*`JCBUF_OFF);\t\t\n\t\twire `N(`JCBUF_OFF)               levelx = sub_level(level,level_decrease);\n\t\twire                          level_zero = (level==0)|((level==1)&level_decrease);\n\n`ifdef TIMING_STYLE\n        wire                          hit_common = check_blacklist(para,check_rdlist,check_rdlist);\n\t\t\n        wire  hit_hard,hit_soft;\n\t\tif (i==0) begin:gen_hit_zero\n\t\t    assign                      hit_hard = 0;\n\t\t\tassign                      hit_soft = 0;\n\t\tend else begin:gen_hit_other\n\t\t    wire `N(i) bits_hard, bits_soft;\n\t\t\t\n\t\t\tfor (j=0;j<i;j=j+1) begin:gen_relation\n\t\t\t    assign              bits_hard[j] = go_vld[j] & check_hard(go_para[`IDX(j,`EXEC_PARA_LEN)],go_para[`IDX(i,`EXEC_PARA_LEN)]);\n\t\t\t\tassign              bits_soft[j] = go_stay[j] & check_soft(go_para[`IDX(j,`EXEC_PARA_LEN)],go_para[`IDX(i,`EXEC_PARA_LEN)]);\n\t\t\tend\n\t\t\t\n\t\t\tassign                      hit_hard = |bits_hard;\n\t\t\tassign                      hit_soft = |bits_soft;\n\t\tend\t\t\n\n        wire                              hit_rg = hit_common|hit_hard|hit_soft; \n`else\n        wire                              hit_rg = check_blacklist(para,rd_checklist[i],rs_checklist[i]);\n`endif\n\n        wire                           exec_idle = exec_active[i];\n\t\twire                            mem_idle = mem_active[i];\n\t\twire                             rf_idle = rf_active[i];\n\t\t\n\t\twire                                 hit = hit_rg|(~exec_idle)|(mem & ~mem_idle)|(alu & ~rf_idle);\n\t\twire                             preload = check_gray(para,check_num);\n\t\t\n\t\twire                            alu2exec = go_vld[i] & alu & ~hit;\n\t\twire                           alu2sdbuf = go_vld[i] & alu & (hit|preload);\n\t\twire                            mem2exec = go_vld[i] & mem & ~hit;\n\t\twire                           mem2sdbuf = go_vld[i] & mem & (hit|preload);\n\t\t\n\t\tassign                        go_stay[i] = alu2sdbuf|mem2sdbuf;\n\t\t\n        //variable update\n`ifndef TIMING_STYLE\t\t\n        assign                 rd_checklist[i+1] = rd_checklist[i]|(alu2sdbuf<<rd)|(alu2sdbuf<<rs0)|(alu2sdbuf<<rs1)|(mem2exec<<rd)|(mem2sdbuf<<rd)|(mem2sdbuf<<rs0)|(mem2sdbuf<<rs1);\n        assign                 rs_checklist[i+1] = rs_checklist[i]|(alu2exec<<rd)|(alu2sdbuf<<rd)|(mem2exec<<rd)|(mem2sdbuf<<rd);\n`endif\t\t\n        assign                  exec_active[i+1] = exec_active[i]>>( alu2exec|mem2exec );\n\t\tassign                   mem_active[i+1] = mem2sdbuf ? 0 : (mem_active[i]>>mem2exec);\n\t\tassign                    rf_active[i+1] = rf_active[i]>>alu2exec;\n\t\tassign                     exec_num[i+1] = exec_num[i] + ( alu2exec|mem2exec );\n\t\tassign                    sdbuf_num[i+1] = sdbuf_num[i] + ( alu2sdbuf|mem2sdbuf );\n\n        //clear is a flag to signal this instruction is invalid.\t\t\n\t\twire                               clear = (alu & (rd==0))|( clear_pipeline &  ~((orderx==0)&(level==0)) )|( level_clear & (level!=0) );\t\n        \n\t\t//special instruction should be assigned to the last exec ALU.\n        wire `N(`EXEC_OFF)            exec_shift = ( alu2exec|mem2exec ) ?  exec_num[i] : `EXEC_LEN;\n\n\t\tassign            chain_exec_direct[i+1] = chain_exec_direct[i]|( ((clear|preload) ? 1'b0 : 1'b1)<<exec_shift );\n        assign           chain_exec_preload[i+1] = chain_exec_preload[i]|( ( clear ? 1'b0 : preload )<<exec_shift );\t\n\t\tassign             chain_exec_instr[i+1] = chain_exec_instr[i]|( instr<<(exec_shift*`XLEN) );\n\t\tassign                chain_exec_pc[i+1] = chain_exec_pc[i]|( pc<<(exec_shift*`XLEN) );\n\t\tassign              chain_exec_para[i+1] = chain_exec_para[i]|( para<<(exec_shift*`EXEC_PARA_LEN) );\n\t\tassign             chain_exec_order[i+1] = chain_exec_order[i]|( orderx<<(exec_shift*`MMCMB_OFF) );\n\t\tassign             chain_exec_level[i+1] = chain_exec_level[i]|( levelx<<(exec_shift*`JCBUF_OFF) );\t\n\t\t\n\t\twire `N(`SDBUF_OFF)          sdbuf_shift = ( alu2sdbuf|mem2sdbuf ) ? sdbuf_num[i] : `SDBUF_LEN;\n\t\t\n\t\tassign           chain_sdbuf_direct[i+1] = chain_sdbuf_direct[i]|( (clear ? 1'b0 : hit)<<sdbuf_shift );\n\t\tassign          chain_sdbuf_preload[i+1] = chain_sdbuf_preload[i]|( ((clear|hit) ? 1'b0 : 1'b1)<<sdbuf_shift );\n\t\tassign            chain_sdbuf_instr[i+1] = chain_sdbuf_instr[i]|( instr<<(sdbuf_shift*`XLEN) );\n\t\tassign               chain_sdbuf_pc[i+1] = chain_sdbuf_pc[i]|( pc<<(sdbuf_shift*`XLEN) );\n\t\tassign             chain_sdbuf_para[i+1] = chain_sdbuf_para[i]|(para<<(sdbuf_shift*`EXEC_PARA_LEN));\n\t\tassign            chain_sdbuf_order[i+1] = chain_sdbuf_order[i]|(orderx<<(sdbuf_shift*`MMCMB_OFF));\n        assign            chain_sdbuf_level[i+1] = chain_sdbuf_level[i]|(levelx<<(sdbuf_shift*`JCBUF_OFF));\t\n\n        assign         chain_sdexec_mem_num[i+1] = chain_sdexec_mem_num[i] + ( go_vld[i] & mem & ~clear );\n\t\tassign     chain_sdbuf_instr_rdlist[i+1] = chain_sdbuf_instr_rdlist[i]|( ( go_vld[i] & level_zero & ~clear )<<rd );\t\t\n\t\t\n\t\twire                 mem_exclude_preload = mem2exec & ~preload & ~clear;\t\t\n\t\twire                 mem_include_preload = mem2exec & ~clear;\n\t\twire                 alu_exclude_preload = alu2exec & ~preload & ~clear;\t\t\t\n\t\twire                 alu_include_preload = alu2exec & ~clear"}
{"text": ";\t\n\t\t\n        assign          chain_exec_mem_num0[i+1] = chain_exec_mem_num0[i] + mem_exclude_preload;\n\t\tassign          chain_exec_mem_num1[i+1] = chain_exec_mem_num1[i] + mem_include_preload;\n        assign          chain_exec_alu_num0[i+1] = chain_exec_alu_num0[i] + alu_exclude_preload;\n\t\tassign          chain_exec_alu_num1[i+1] = chain_exec_alu_num1[i] + alu_include_preload;\n\t\t\n\t\tassign               chain_find_mem[i+1] = chain_find_mem[i]|( go_vld[i] & mem & (levelx==0) );\n\t\tassign                chain_find_pc[i+1] = chain_find_mem[i] ? chain_find_pc[i] : pc;\t\t\t\n\t\t\n    end\n\tendgenerate\t\t\n\n\t\n\t`FFx(exec_direct,0)\n\texec_direct <= chain_exec_direct[`SDBUF_LEN];\n\t\n\t`FFx(exec_preload,0)\n\texec_preload <= chain_exec_preload[`SDBUF_LEN];\n\t\n\tassign exec_vld = exec_direct|( exec_preload & {`EXEC_LEN{(mem_release!=0)} } );\n\t\n\t`FFx(exec_instr,0)\n\texec_instr <= chain_exec_instr[`SDBUF_LEN];\n\t\n\t`FFx(exec_pc,0)\n\texec_pc <= chain_exec_pc[`SDBUF_LEN];\n\t\n\t`FFx(exec_para,0)\n\texec_para <= chain_exec_para[`SDBUF_LEN];\n\t\n\t`FFx(exec_order,0)\n\texec_order <= chain_exec_order[`SDBUF_LEN];\n\t\n\t`FFx(exec_level,0)\n\texec_level <= chain_exec_level[`SDBUF_LEN];\n\n \n \n\t`FFx(sdbuf_direct,0)\n\tsdbuf_direct <= chain_sdbuf_direct[`SDBUF_LEN];\n\n\t`FFx(sdbuf_preload,0)\n\tsdbuf_preload <= chain_sdbuf_preload[`SDBUF_LEN];\n\n    assign sdbuf_vld = sdbuf_direct|( sdbuf_preload & ( (mem_release!=0) ? 0 : {`SDBUF_LEN{1'b1}} ) );\n\t\n\t`FFx(sdbuf_instr,0)\n\tsdbuf_instr <= chain_sdbuf_instr[`SDBUF_LEN];\n\t\n\t`FFx(sdbuf_pc,0)\n\tsdbuf_pc <= chain_sdbuf_pc[`SDBUF_LEN];\n\t\n\t`FFx(sdbuf_para,0)\n\tsdbuf_para <= chain_sdbuf_para[`SDBUF_LEN];\n\t\n\t`FFx(sdbuf_order,0)\n\tsdbuf_order <= chain_sdbuf_order[`SDBUF_LEN];\n\t\n\t`FFx(sdbuf_level,0)\n\tsdbuf_level <= chain_sdbuf_level[`SDBUF_LEN];\n\t\n\t`FFx(sdbuf_length,0)\n\tsdbuf_length <= sdbuf_num[`SDBUF_LEN];\n\t\n\t\n    `FFx(sdexec_mem_num,0)\n    sdexec_mem_num <= chain_sdexec_mem_num[`SDBUF_LEN];\n  \n \t`FFx(sdbuf_instr_rdlist,0)\n\tsdbuf_instr_rdlist <= chain_sdbuf_instr_rdlist[`SDBUF_LEN]; \n\t\n\t\n    `FFx(exec_mem_num0,0)\n    exec_mem_num0 <= chain_exec_mem_num0[`SDBUF_LEN];\n\t\n    `FFx(exec_mem_num1,0)\n    exec_mem_num1 <= chain_exec_mem_num1[`SDBUF_LEN];\t\n\t\n\tassign exec_mem_num = (mem_release!=0) ? exec_mem_num1 : exec_mem_num0;\n \n    `FFx(exec_alu_num0,0)\n    exec_alu_num0 <= chain_exec_alu_num0[`SDBUF_LEN];\t\n\t\n    `FFx(exec_alu_num1,0)\n    exec_alu_num1 <= chain_exec_alu_num1[`SDBUF_LEN];\t\t\n\t\n\tassign exec_alu_num = (mem_release!=0) ? exec_alu_num1 : exec_alu_num0;\n\t\n\tassign         sdbuf_left_num = `SDBUF_LEN - sdbuf_length;\n\t\n\tassign  pipeline_instr_rdlist = mmbuf_instr_rdlist|sdbuf_instr_rdlist;\n\t\n\tassign      pipeline_is_empty = (mmbuf_mem_num==0)&(rfbuf_alu_num==0)&(sdbuf_length==0)&(exec_direct==0);\n    \n\tassign           schd_intflag = chain_find_mem[`SDBUF_LEN];\n    \n\tassign             schd_intpc = chain_find_mem[`SDBUF_LEN] ? chain_find_pc[`SDBUF_LEN] : fetch_pc;\n\nendmodule\n\n"}
{"text": "/////////////////////////////////////////////////////////////////////////////////////\n//\n//Copyright 2019  Li Xinbing\n//\n//Licensed under the Apache License, Version 2.0 (the \"License\");\n//you may not use this file except in compliance with the License.\n//You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n//Unless required by applicable law or agreed to in writing, software\n//distributed under the License is distributed on an \"AS IS\" BASIS,\n//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//See the License for the specific language governing permissions and\n//limitations under the License.\n//\n/////////////////////////////////////////////////////////////////////////////////////\n\n`include \"define.v\"\nmodule ssrv_top(\n    input                                clk,\n\tinput                                rst,\n\t\n\toutput                               imem_req,\n\toutput `N(`XLEN)                     imem_addr,\n\tinput  `N(`BUS_WID)                  imem_rdata,\n\tinput                                imem_resp,\n\tinput                                imem_err,\n\t\n\toutput                               dmem_req,\n\toutput                               dmem_cmd,\n\toutput `N(2)                         dmem_width,\n\toutput `N(`XLEN)                     dmem_addr,\n\toutput `N(`XLEN)                     dmem_wdata,\n\tinput  `N(`XLEN)                     dmem_rdata,\n\tinput                                dmem_resp,\n    input                                dmem_err\t\n\n);\n\n    //instrman\n    wire                                 jump_vld;\n    wire `N(`XLEN)                       jump_pc;\n    wire                                 branch_vld;\n    wire `N(`XLEN)                       branch_pc;\t\n\twire                                 buffer_free;\t\n\t\n\twire                                 imem_vld;\n\twire `N(`BUS_WID)                    imem_instr;\n\twire                                 imem_status;\n\n    //predictor\n\twire `N(2*`BUS_LEN)                  imem_predict;\n\twire                                 jcond_vld;\n\twire `N(`XLEN)                       jcond_pc;\n\twire                                 jcond_hit;\n\twire                                 jcond_taken;\n\n\t//connection for instrbits\n\twire                                 sys_vld;\n\twire `N(`XLEN)                       sys_instr;\n\twire `N(`XLEN)                       sys_pc;\n\twire `N(4)                           sys_para;\n\t\n\twire                                 csr_vld;\n\twire `N(`XLEN)                       csr_instr;\n\twire `N(`XLEN)                       csr_rs;\n    wire `N(`RGBIT)                      csr_rd_sel;\t\n\n    wire `N(`RGBIT)                      extra_rs0_sel;\n\twire `N(`RGBIT)                      extra_rs1_sel;\n    wire `N(`XLEN)                       extra_rs0_word;\n\twire `N(`XLEN)                       extra_rs1_word;\t\n\n    wire `N(`SDBUF_OFF)                  sdbuf_left_num;\t\n\twire `N(`FETCH_LEN)                  fetch_vld;\t\t\n    wire `N(`FETCH_LEN*`XLEN)            fetch_instr;\n\twire `N(`FETCH_LEN*`XLEN)            fetch_pc;\n    wire `N(`FETCH_LEN*`EXEC_PARA_LEN)   fetch_para;\n\twire `N(`FETCH_LEN*`JCBUF_OFF)       fetch_level;\n\n\twire `N(`RGLEN)                      pipeline_instr_rdlist;\n    wire                                 pipeline_is_empty;\n\t\n\twire                                 level_decrease;\n\twire                                 level_clear;\t\n\n    //schedule\n\twire `N(`EXEC_LEN)                   exec_vld;\n    wire `N(`EXEC_LEN*`XLEN)             exec_instr;\n    wire `N(`EXEC_LEN*`EXEC_PARA_LEN)    exec_para;\n    wire `N(`EXEC_LEN*`XLEN)             exec_pc;\n    wire `N(`EXEC_LEN*`MMCMB_OFF)        exec_order;\n    wire `N(`EXEC_LEN*`JCBUF_OFF)        exec_level;\t\n\n\twire `N(`RGBIT)                      mmbuf_check_rdnum;\n\twire `N(`RGLEN)                      mmbuf_check_rdlist;\n    wire `N(`RGLEN)                      mmbuf_instr_rdlist;\t\n\twire `N(`MMBUF_OFF)                  mmbuf_mem_num;\t\n\twire `N(`RFBUF_OFF)                  rfbuf_alu_num;\t\n\twire `N(`MEM_OFF)                    mem_release;\t\n\twire                                 clear_pipeline;\t\n\n    //alu\n\twire `N(`EXEC_LEN*`RGBIT)            rs0_sel,rs1_sel;\n\twire `N(`EXEC_LEN*`XLEN)             rs0_word,rs1_word;\n\twire `N(`EXEC_LEN*`RGBIT)            rd_sel;\n\twire `N(`EXEC_LEN*`XLEN)             rd_data;\t\n\twire `N(`EXEC_LEN)                   mem_vld;\n\twire `N(`EXEC_LEN*`MMBUF_PARA_LEN)   mem_para;\n\twire `N(`EXEC_LEN*`XLEN)             mem_addr;\n\twire `N(`EXEC_LEN*`XLEN)             mem_wdata;\t\n\t\n\t//connection for mprf\n\twire `N(`MEM_LEN*`RGBIT)             mem_sel; \n\twire `N(`MEM_LEN*`XLEN)              mem_data;\n\twire `N(`XLEN)                       csr_data;\n\twire `N(`RGLEN)                      rfbuf_order_list;\n\t\n    //connection for membuf\n\twire `N(`MUL_LEN)                    mul_initial;\n\twire `N(`MUL_LEN*3)                  mul_para;\n\twire `N(`MUL_LEN*`XLEN)              mul_rs0,mul_rs1;\n    wire `N(`MUL_LEN)                    mul_ready;\n\twire `N(`MUL_LEN)                    mul_finished;    \n\twire `N(`MUL_LEN*`XLEN)              mul_data;\n    wire `N(`MUL_LEN)                    mul_ack;\n\t\n    wire                                 lsu_initial;\n\twire `N(`MMBUF_PARA_LEN)             lsu_para;\n\twire `N(`XLEN)                       lsu_addr;\n\twire `N(`XLEN)                       lsu_wdata;\n\twire                                 lsu_ready;\n\twire                                 lsu_finished;\n\twire                                 lsu_status;\n\twire `N(`XLEN)                       lsu_rdata;\n    wire                                 lsu_ack;\t\n\n  \n\t//connection for sys_csr\n    wire `N(`XLEN)                       mmbuf_int_pc;\n    wire `N(2)                           dmem_exception;\t\t\n    wire                                 mem_busy;\n\n\n\tgenvar i;\n\n\n    instrman i_man(\n    .clk                        (    clk                      ),\n    .rst                        (    rst                      ),\n   \n    .imem_req                   (    imem_req                 ),\n    .imem_addr                  (    imem_addr                ),\n    .imem_resp                  (    imem_resp                ),\n\t.imem_rdata                 (    imem_rdata               ),\n\t.imem_err                   (    imem_err                 ),\n\n    .jump_vld                   (    jump_vld                 ),\n    .jump_pc                    (    jump_pc                  ),\n\t.branch_vld                 (    branch_vld               ),\n\t.branch_pc                  (    branch_pc                ),\n\t.buffer_free                (    buffer_free              ),\n\t\n\t.imem_vld                   (    imem_vld                 ),\n\t.imem_instr                 (    imem_instr               ),\n\t.imem_status                (    imem_status              )\n\n    );\n\t\n    predictor i_pdt(\n    .clk                        (    clk                      ),\n    .rst                        (    rst                      ), \n\t\n    .imem_req                   (    imem_req                 ),\n    .imem_addr                  (    imem_addr                ),\n    .imem_predict               (    imem_predict             ),\n\n    .jcond_vld                  (    jcond_vld                ),\n    .jcond_pc                   (    jcond_pc                 ),\n    .jcond_hit                  (    jcond_hit                ),\n    .jcond_taken                (    jcond_taken              )\t\n\n    );\t\n\t\n\t\n    instrbits i_bits(\n    .clk                        (    clk                      ),\n    .rst                        (    rst                      ), \n\n    .jump_vld                   (    jump_vld                 ),\n    .jump_pc                    (    jump_pc                  ),\n    .branch_vld                 (    branch_vld               ),\n    .branch_pc                  (    branch_pc                ),\n    .buffer_free                (    buffer_free              ),\t\n\n    .instr_vld                  (    imem_vld                 ),\n    .instr_data                 (    imem_instr               ),\n\t.instr_err                  (    imem_status              ),\n\t.instr_predict              (    imem_predict             ),\t\n\n    .jcond_vld                  (    jcond_vld                ),\n    .jcond_pc                   (    jcond_pc                 ),\n    .jcond_hit                  (    jcond_hit                ),\n    .jcond_taken                (    jcond_taken              ),\t\n\n    .sys_vld                    (    sys_vld                  ),\n    .sys_instr                  (    sys_instr                ),\n    .sys_pc                     (    sys_pc                   ),\n    .sys_para                   (    sys_para                 ),\t\n\t\n\t.csr_vld                    (    csr_vld                  ),\n\t.csr_instr                  (    csr_instr                ),\n\t.csr_rs                     (    csr_rs                   ),\n\t.csr_rd_sel                 (    csr_rd_sel               ),\n\n    .rs0_sel                    (    extra_rs0_sel            ),\n    .rs1_sel                    (    extra_rs1_sel            ),\n    .rs0_word                   (    extra_rs0_word           ),\n    .rs1_word                   (    extra_rs1_word           ),\t\n\n\t.sdbuf_left_num             (    sdbuf_left_num           ),\n    .fetch_vld                  (    fetch_vld                ),\t\n    .fetch_instr                (    fetch_instr              ),\n    .fetch_pc                   (    fetch_pc                 ),\n    .fetch_para                 (    fetch_para               ),\n    .fetch_level                (    fetch_level              ),\n\n\t.pipeline_instr_rdlist      (    pipeline_instr_rdlist    ),\n\t.pipeline_is_empty          (    pipeline_is_empty        ),\n\t\n    .level_decrease             (    level_decrease           ),\n    .level_clear                (    level_clear              )\t\n\n    );                  \n\n    schedule i_sch (\n\t.clk                        (    clk                      ),\n\t.rst                        (    rst                      ),\n\n\t.sdbuf_left_num             (    sdbuf_left_num           ),\n    .fetch_vld                  (    fetch_vld                ),\n    .fetch_instr                (    fetch_instr              ),\n    .fetch_pc                   (    fetch_pc                 ),\n    .fetch_para                 (    fetch_para               ),\n\t.fetch_level                (    fetch_level              ),\n\n    .exec_vld                   (    exec_vld                 ),\n    .exec_instr                 (    exec_instr               ),\n    .exec_para                  (    exec_para                ),\n    .exec_pc                    (    exec_pc                  ),\n    .exec_level                 (    exec_level               ),\n    .exec_order                 (    exec_order               ),\n\t\n    .mmbuf_check_rdnum          (    mmbuf_check_rdnum        ),\t\n    .mmbuf_check_rdlist         (    mmbuf_check_rdlist       ),\n\t.mmbuf_instr_rdlist         (    mmbuf_instr_rdlist       ),\n\t.mmbuf_mem_num              (    mmbuf_mem_num            ),\t\n\t.rfbuf_alu_num              (    rfbuf_alu_num            ),\n\t.mem_release                (    mem_release              ),\n\t.clear_pipeline             (    clear_pipeline           ),\n\t.level_decrease             (    level_decrease           ),\n\t.level_clear                (    level_clear              ),\t\n    .pipeline_instr_rdlist      (    pipeline_instr_rdlist    ),\n\t.pipeline_is_empty          (    pipeline_is_empty        ),\n\t.schd_intflag               (                             ),\n    .schd_intpc                 (                             )\t\n\n\t);\n\n\tgenerate\n\tfor (i=0;i<`EXEC_LEN;i=i+1) begin:gen_alu\n\t        alu  i_alu (\n\t        .clk                (    clk                                  ),\n            .rst                (    rst                                  ),\n\t\t    \n            .vld                (    exec_vld[i]                          ),\n            .instr              (    exec_instr[`IDX(i,`XLEN)]            ),\n            .para               (    exec_para[`IDX(i,`EXEC_PARA_LEN)]    ),\n            .pc                 (    exec_pc[`IDX(i,`XLEN)]               ),\n\t\t    \n            .rs0_sel            (    rs0_sel[`IDX(i,`RGBIT)]              ),\n            .rs1_sel            (    rs1_sel[`IDX(i,`RGBIT)]              ),\n            .rs0_word           (    rs0_word[`IDX(i,`XLEN)]              ),\n            .rs1_word           (    rs1_word[`IDX(i,`XLEN)]              ),\n\t\t    \n            .rd_sel             (    rd_sel[`IDX(i,`RGBIT)]               ),\n            .rd_data            (    rd_data[`IDX(i,`XLEN)]               ),\n\n            .mem_vld            (    mem_vld[i]                           ),\n            .mem_para           (    mem_para[`IDX(i,`MMBUF_PARA_LEN)]    ),\n            .mem_addr           (    mem_addr[`IDX(i,`XLEN)]              ),\n            .mem_wdata          (    mem_wdata[`IDX(i,`XLEN)]             )\t\t\n\t\t    \n\t\t    );\n\tend\t\n\tendgenerate\n\n\n\tmprf i_mprf (\n\t.clk                        (    clk                      ),\n\t.rst                        (    rst                      ),\n\n\t.rd_sel                     (    rd_sel                   ),\n\t.rd_order                   (    exec_order               ),\n\t.rd_level                   (    exec_level               ),\n\t.rd_data                    (    rd_data                  ),\n\n\t.csr_vld                    (    csr_vld                  ),\n\t.csr_rd_sel                 (    csr_rd_sel               ),\n\t.csr_data                   (    csr_data                 ),\n\n\t.mem_sel                    (    mem_sel                  ),\n\t.mem_data                   (    mem_data                 ),\t\n    .mem_release                (    mem_release              ),\t\n\t\n\t.clear_pipeline             (    clear_pipeline           ),\n\t.level_decrease             (    level_decrease           ),\n\t.level_clear                (    level_clear              ),\n \n\t.rs0_sel                    (    rs0_sel                  ),\n\t.rs1_sel                    (    rs1_sel                  ),\n\t.rs0_word                   (    rs0_word                 ),\n\t.rs1_word                   (    rs1_word                 ),\n\t\n    .extra_rs0_sel              (    extra_rs0_sel            ),\n\t.extra_rs1_sel              (    extra_rs1_sel            ),\n\t.extra_rs0_word             (    extra_rs0_word           ),\n\t.extra_rs1_word             (    extra_rs1_word           ),\n\t\n\t.rfbuf_alu_num              (    rfbuf_alu_num            ),\n\t.rfbuf_order_list           (    rfbuf_order_list         )\n\t\n\t);\n\n    membuf i_membuf(\n\t.clk                        (    clk                      ),\n\t.rst                        (    rst                      ),\n   \n   \t.mul_initial                (    mul_initial              ),\n\t.mul_para                   (    mul_para                 ),\n\t.mul_rs0                    (    mul_rs0                  ),\n\t.mul_rs1                    (    mul_rs1                  ),\n\t.mul_ready                  (    mul_ready                ),\n\t.mul_finished               (    mul_finished             ),\n\t.mul_data                   (    mul_data                 ),\n\t.mul_ack                    (    mul_ack                  ),\n\t\n\t.lsu_initial                (    lsu_initial              ),\n\t.lsu_para                   (    lsu_para                 ),\n\t.lsu_addr                   (    lsu_addr                 ),\n\t.lsu_wdata                  (    lsu_wdata                ),\n\t.lsu_ready                  (    lsu_ready                ),\n\t.lsu_finished               (    lsu_finished             ),\n\t.lsu_status                 (    lsu_status               ),\n\t.lsu_rdata                  (    lsu_rdata                ),\n\t.lsu_ack                    (    lsu_ack                  ),\n   \n\t.mem_vld                    (    mem_vld                  ),\n\t.mem_para                   (    mem_para                 ),\n\t.mem_addr                   (    mem_addr                 ),\n\t.mem_wdata                  (    mem_wdata                ),\n\t.mem_pc                     (    exec_pc                  ),\n    .mem_level                  (    exec_level               ),\n    .mem_sel                    (    mem_sel                  ),\n    .mem_data                   (    mem_data                 ),\n\t.mem_release                (    mem_release              ),\n\t\n\t.clear_pipeline             (    clear_pipeline           ),\n    .level_decrease             (    level_decrease           ),\n    .level_clear                (    level_clear              ),\n\t.rfbuf_order_list           (    rfbuf_order_list         ),\t\n    .mmbuf_check_rdnum          (    mmbuf_check_rdnum        ),\t\n    .mmbuf_check_rdlist         (    mmbuf_check_rdlist       ),\n\t.mmbuf_instr_rdlist         (    mmbuf_instr_rdlist       ),\n\t.mmbuf_mem_num              (    mmbuf_mem_num            ),\n\t.mmbuf_intflag              (                             ),\n\t.mmbuf_intpc                (                             ),\n\t.dmem_exception             (    dmem_exception           ),\n\t.mem_busy                   (    mem_busy                 )\n\t\n\t);\n\n    generate\n\tfor (i=0;i<`MUL_LEN;i=i+1) begin:gen_mul\n        mul  i_mul(\n\t    .clk                        (    clk                      ),\n\t    .rst                        (    rst                      ),\n\t    \n\t    .mul_initial                (    mul_initial[i]           ),\n\t    .mul_para                   (    mul_para[`IDX(i,3)]      ),\n\t    .mul_rs0                    (    mul_rs0[`IDX(i,`XLEN)]   ),\n\t    .mul_rs1                    (    mul_rs1[`IDX(i,`XLEN)]   ),\n\t    .mul_ready                  (    mul_ready[i]             ),\n\t    \n\t    .clear_pipeline             (    clear_pipeline           ),\n\t    \n\t    .mul_finished               (    mul_finished[i]          ),\n\t    .mul_data                   (    mul_data[`IDX(i,`XLEN)]  ),\n\t    .mul_ack                    (    mul_ack[i]               )\n\t    \n        );\t\n\tend\n\tendgenerate\n\t\n\n    lsu i_lsu(\n\t.clk                        (    clk                      ),\n\t.rst                        (    rst                      ),\n    \n\t.dmem_req                   (    dmem_req                 ),\n\t.dmem_cmd                   (    dmem_cmd                 ),\n\t.dmem_width                 (    dmem_width               ),\n\t.dmem_addr                  (    dmem_addr                ),\n\t.dmem_wdata                 (    dmem_wdata               ),\n\t.dmem_rdata                 (    dmem_rdata               ),\n\t.dmem_resp                  (    dmem_resp                ),\n\t.dmem_err                   (    dmem_err                 ),\n\t\n\t.lsu_initial                (    lsu_initial              ),\n\t.lsu_para                   (    lsu_para                 ),\n\t.lsu_addr                   (    lsu_addr                 ),\n\t.lsu_wdata                  (    lsu_wdata                ),\n\t.lsu_ready                  (    lsu_ready                ),\n\t.lsu_finished               (    lsu_finished             ),\n\t.lsu_status                 (    lsu_status               ),\n\t.lsu_rdata                  (    lsu_rdata                ),\n\t.lsu_ack                    (    lsu_ack                  ),\n\t\n\t.clear_pipeline             (    clear_pipeline           )\t\t\n    );\n\n\n\tsys_csr i_sys (\t\n\t.clk                        (    clk                      ),\n\t.rst                        (    rst                      ),\t\t\n\t\n\t.sys_vld                    (    sys_vld                  ),\n\t.sys_instr                  (    sys_instr                ),\t\n\t.sys_pc                     (    sys_pc                   ),\n\t.sys_para                   (    sys_para                 ),\n\t\n\t.csr_vld                    (    csr_vld                  ),\n\t.csr_instr                  (    csr_instr                ),\n\t.csr_rs                     (    csr_rs                   ),\n\t.csr_data                   (    csr_data                 ),\n\t\n    .dmem_exception             (    dmem_exception           ),\n\t.int_pc                     (    mmbuf_"}
{"text": "int_pc             ),\n\t.mem_busy                   (    mem_busy                 ),\n\t\n\t.clear_pipeline             (    clear_pipeline           ),\n\t.jump_vld                   (    jump_vld                 ),\n\t.jump_pc                    (    jump_pc                  )\n\t\n\t);\n\t\nendmodule"}
{"text": "/////////////////////////////////////////////////////////////////////////////////////\n//\n//Copyright 2019  Li Xinbing\n//\n//Licensed under the Apache License, Version 2.0 (the \"License\");\n//you may not use this file except in compliance with the License.\n//You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n//Unless required by applicable law or agreed to in writing, software\n//distributed under the License is distributed on an \"AS IS\" BASIS,\n//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//See the License for the specific language governing permissions and\n//limitations under the License.\n//\n/////////////////////////////////////////////////////////////////////////////////////\n\n`include \"define.v\"\nmodule sys_csr\n#(\n    parameter START_ADDR = 'h200\n)\n(\n    input                                clk,\n\tinput                                rst,\n\t\n    input                                sys_vld,\n    input  `N(`XLEN)                     sys_instr,\n\tinput  `N(`XLEN)                     sys_pc,\n\tinput  `N(4)                         sys_para,\n\t\n\tinput                                csr_vld,\n\tinput  `N(`XLEN)                     csr_instr,\n    input  `N(`XLEN)                     csr_rs,\n\toutput `N(`XLEN)                     csr_data,\n\t\n\tinput  `N(2)                         dmem_exception,\n\tinput  `N(`XLEN)                     int_pc,\n\tinput                                mem_busy,\n\t\n\toutput                               clear_pipeline,\n\toutput                               jump_vld,\n\toutput reg `N(`XLEN)                 jump_pc\n\t\n);\n\n\t//csr function\n\t\n\twire `N(12) csr_addr = csr_instr[31:20];\n\t\n\tlocalparam ADDR_MHARTID = 12'hf14,\n\t           ADDR_MTVEC   = 12'h305,\n\t\t\t   ADDR_MEPC    = 12'h341,\n\t\t\t   ADDR_MCAUSE  = 12'h342,\n\t\t\t   ADDR_MCYCLE  = 12'hc00,\n\t\t\t   ADDR_MTIME   = 12'hc01,\n\t\t\t   ADDR_MCYCLEH = 12'hc80\n\t\t\t   ;\n\t\n\tlocalparam DATA_MHARTID = 32'h0,\n\t           DATA_MCAUSE  = 11\n\t\t\t   ;\n\n    reg `N(`XLEN) csr_out;\t\n\treg `N(`XLEN) csr_in;\n\t\n\twire `N(3)  csr_func = csr_instr[14:12];\n\t\n\t`COMB\n\tcase(csr_func)\n\t3'b001 : csr_in = csr_rs;\n\t3'b010 : csr_in = csr_rs|csr_out;\n\t3'b011 : csr_in = (~csr_rs)&csr_out;\n\t3'b101 : csr_in = csr_instr[19:15];\n\t3'b110 : csr_in = csr_instr[19:15]|csr_out;\n\t3'b111 : csr_in = (~csr_instr[19:15])&csr_out;\n\tdefault : csr_in = csr_out;\n\tendcase\n\t\n\treg `N(`XLEN) data_mtvec;\n\t`FFx(data_mtvec,0)\n\tif ( csr_vld & (csr_addr==ADDR_MTVEC) )\n\t    data_mtvec <= csr_in;\n\telse;\n\t\n\treg `N(`XLEN) data_mepc;\n\t`FFx(data_mepc,0)\n\tif ( csr_vld & (csr_addr==ADDR_MEPC) )\n\t    data_mepc <= csr_in;\n\telse;\n\n    reg `N(64) mcycle;\n    `FFx(mcycle,0)\n    mcycle <= mcycle + 1'b1;\t\n\n\treg `N(7) mtime_cnt;\n\t`FFx(mtime_cnt,0)\n\tif ( mtime_cnt==99 )\n\t    mtime_cnt <= 0;\n\telse \n\t    mtime_cnt <= mtime_cnt + 1'b1;\n\t\n\treg `N(64) mtime;\n\t`FFx(mtime,0)\n\tif ( mtime_cnt==99 )\n\t    mtime <= mtime + 1;\n\telse;\n\t\n\t`COMB\n\tif ( csr_addr==ADDR_MHARTID )\n\t    csr_out = DATA_MHARTID;\n\telse if ( csr_addr==ADDR_MTVEC )\n\t    csr_out = data_mtvec;\n\telse if ( csr_addr==ADDR_MEPC )\n\t    csr_out = data_mepc;\n\telse if ( csr_addr==ADDR_MCAUSE )\n\t    csr_out = DATA_MCAUSE;\n\telse if ( csr_addr==ADDR_MCYCLE)\n\t    csr_out = mcycle[31:0];\n\telse if ( csr_addr==ADDR_MTIME )\n\t    csr_out = mtime[31:0];\n\telse if ( csr_addr==ADDR_MCYCLEH )\n\t    csr_out = mcycle[63:32];\n\telse\n\t    csr_out = 0;\n\t\n\t\n\tassign csr_data = csr_out;\n\t\n\t\n\n\twire instr_is_ret    = sys_vld & ((sys_para>>2)==0) & ( (sys_instr[31:0]==32'b0000000_00010_00000_000_00000_1110011)|(sys_instr[31:0]==32'b0001000_00010_00000_000_00000_1110011)|(sys_instr[31:0]==32'b0011000_00010_00000_000_00000_1110011) );\n\twire instr_is_ecall  = sys_vld & ((sys_para>>2)==0) & (sys_instr[31:0]==32'b0000000_00000_00000_000_00000_1110011);\n\twire instr_is_fencei = sys_vld & ((sys_para>>2)==0) & (sys_instr[31:0]==32'b0000000_00000_00000_001_00000_0001111);\n\t\n\treg reset_state;\n\t`FFx(reset_state,1'b1)\n\treset_state <= 1'b0;\t\n\t\n\tassign jump_vld = reset_state|(instr_is_ret|instr_is_ecall|instr_is_fencei);\n\t\n    assign clear_pipeline = jump_vld;\n\n    `COMB\n\tif ( reset_state )\n\t    jump_pc = START_ADDR;\n\telse if ( instr_is_ret )\n\t    jump_pc = data_mepc;\n\telse if ( instr_is_ecall )\n\t    jump_pc = data_mtvec;\n\telse if ( instr_is_fencei )\n\t    jump_pc = sys_pc + 4;\n\telse\n\t    jump_pc = 0;\n\t\nendmodule"}
