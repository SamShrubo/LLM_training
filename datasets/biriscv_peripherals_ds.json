{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.6.0\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', '\\n', 'module dcache\\n', '//-----------------------------------------------------------------\\n', '// Params\\n', '//-----------------------------------------------------------------\\n', '#(\\n', '     parameter AXI_ID           = 0\\n', ')\\n', '//-----------------------------------------------------------------\\n', '// Ports\\n', '//-----------------------------------------------------------------\\n', '(\\n', '    // Inputs\\n', '     input           clk_i\\n', '    ,input           rst_i\\n', '    ,input  [ 31:0]  mem_addr_i\\n', '    ,input  [ 31:0]  mem_data_wr_i\\n', '    ,input           mem_rd_i\\n', '    ,input  [  3:0]  mem_wr_i\\n', '    ,input           mem_cacheable_i\\n', '    ,input  [ 10:0]  mem_req_tag_i\\n', '    ,input           mem_invalidate_i\\n', '    ,input           mem_writeback_i\\n', '    ,input           mem_flush_i\\n', '    ,input           axi_awready_i\\n', '    ,input           axi_wready_i\\n', '    ,input           axi_bvalid_i\\n', '    ,input  [  1:0]  axi_bresp_i\\n', '    ,input  [  3:0]  axi_bid_i\\n', '    ,input           axi_arready_i\\n', '    ,input           axi_rvalid_i\\n', '    ,input  [ 31:0]  axi_rdata_i\\n', '    ,input  [  1:0]  axi_rresp_i\\n', '    ,input  [  3:0]  axi_rid_i\\n', '    ,input           axi_rlast_i\\n', '\\n', '    // Outputs\\n', '    ,output [ 31:0]  mem_data_rd_o\\n', '    ,output          mem_accept_o\\n', '    ,output          mem_ack_o\\n', '    ,output          mem_error_o\\n', '    ,output [ 10:0]  mem_resp_tag_o\\n', '    ,output          axi_awvalid_o\\n', '    ,output [ 31:0]  axi_awaddr_o\\n', '    ,output [  3:0]  axi_awid_o\\n', '    ,output [  7:0]  axi_awlen_o\\n', '    ,output [  1:0]  axi_awburst_o\\n', '    ,output          axi_wvalid_o\\n', '    ,output [ 31:0]  axi_wdata_o\\n', '    ,output [  3:0]  axi_wstrb_o\\n', '    ,output          axi_wlast_o\\n', '    ,output          axi_bready_o\\n', '    ,output          axi_arvalid_o\\n', '    ,output [ 31:0]  axi_araddr_o\\n', '    ,output [  3:0]  axi_arid_o\\n', '    ,output [  7:0]  axi_arlen_o\\n', '    ,output [  1:0]  axi_arburst_o\\n', '    ,output          axi_rready_o\\n', ');\\n', '\\n', 'wire           mem_uncached_invalidate_w;\\n', 'wire           pmem_cache_accept_w;\\n', 'wire           mem_uncached_accept_w;\\n', 'wire  [  7:0]  pmem_cache_len_w;\\n', 'wire  [  3:0]  mem_cached_wr_w;\\n', 'wire  [ 31:0]  pmem_cache_read_data_w;\\n', 'wire           mem_cached_invalidate_w;\\n', 'wire           pmem_uncached_ack_w;\\n', 'wire  [  7:0]  pmem_len_w;\\n', 'wire           pmem_uncached_accept_w;\\n', 'wire           mem_cached_accept_w;\\n', 'wire           pmem_cache_ack_w;\\n', 'wire  [ 31:0]  pmem_cache_addr_w;\\n', 'wire           pmem_cache_rd_w;\\n', 'wire           pmem_error_w;\\n', 'wire  [ 31:0]  pmem_addr_w;\\n', 'wire  [ 10:0]  mem_cached_req_tag_w;\\n', 'wire           mem_uncached_ack_w;\\n', 'wire           pmem_ack_w;\\n', 'wire  [ 31:0]  mem_uncached_data_wr_w;\\n', 'wire  [ 31:0]  pmem_uncached_addr_w;\\n', 'wire  [ 31:0]  mem_cached_data_rd_w;\\n', 'wire  [ 31:0]  pmem_uncached_read_data_w;\\n', 'wire           mem_uncached_flush_w;\\n', 'wire           pmem_uncached_error_w;\\n', 'wire  [ 31:0]  mem_uncached_data_rd_w;\\n', 'wire  [ 31:0]  pmem_write_data_w;\\n', 'wire  [  3:0]  pmem_uncached_wr_w;\\n', 'wire           mem_cached_rd_w;\\n', 'wire  [ 10:0]  mem_cached_resp_tag_w;\\n', 'wire  [  7:0]  pmem_uncached_len_w;\\n', 'wire  [ 31:0]  mem_cached_data_wr_w;\\n', 'wire  [  3:0]  pmem_wr_w;\\n', 'wire           pmem_select_w;\\n', 'wire           mem_cached_flush_w;\\n', 'wire           mem_uncached_cacheable_w;\\n', 'wire  [ 31:0]  mem_cached_addr_w;\\n', 'wire           mem_uncached_writeback_w;\\n', 'wire  [  3:0]  pmem_cache_wr_w;\\n', 'wire           pmem_cache_error_w;\\n', 'wire  [ 10:0]  mem_uncached_req_tag_w;\\n', 'wire  [ 31:0]  pmem_uncached_write_data_w;\\n', 'wire  [ 10:0]  mem_uncached_resp_tag_w;\\n', 'wire           pmem_rd_w;\\n', 'wire           mem_cached_cacheable_w;\\n', 'wire  [  3:0]  mem_uncached_wr_w;\\n', 'wire           mem_uncached_error_w;\\n', 'wire           mem_uncached_rd_w;\\n', 'wire           pmem_accept_w;\\n', 'wire  [ 31:0]  pmem_cache_write_data_w;\\n', 'wire           mem_cached_error_w;\\n', 'wire  [ 31:0]  mem_uncached_addr_w;\\n', 'wire           pmem_uncached_rd_w;\\n', 'wire  [ 31:0]  pmem_read_data_w;\\n', 'wire           mem_cached_ack_w;\\n', 'wire           mem_cached_writeback_w;\\n', '\\n', '\\n', 'dcache_if_pmem\\n', 'u_uncached\\n', '(\\n', '    // Inputs\\n', '     .clk_i(clk_i)\\n', '    ,.rst_i(rst_i)\\n', '    ,.mem_addr_i(mem_uncached_addr_w)\\n', '    ,.mem_data_wr_i(mem_uncached_data_wr_w)\\n', '    ,.mem_rd_i(mem_uncached_rd_w)\\n', '    ,.mem_wr_i(mem_uncached_wr_w)\\n', '    ,.mem_cacheable_i(mem_uncached_cacheable_w)\\n', '    ,.mem_req_tag_i(mem_uncached_req_tag_w)\\n', '    ,.mem_invalidate_i(mem_uncached_invalidate_w)\\n', '    ,.mem_writeback_i(mem_uncached_writeback_w)\\n', '    ,.mem_flush_i(mem_uncached_flush_w)\\n', '    ,.outport_accept_i(pmem_uncached_accept_w)\\n', '    ,.outport_ack_i(pmem_uncached_ack_w)\\n', '    ,.outport_error_i(pmem_uncached_error_w)\\n', '    ,.outport_read_data_i(pmem_uncached_read_data_w)\\n', '\\n', '    // Outputs\\n', '    ,.mem_data_rd_o(mem_uncached_data_rd_w)\\n', '    ,.mem_accept_o(mem_uncached_accept_w)\\n', '    ,.mem_ack_o(mem_uncached_ack_w)\\n', '    ,.mem_error_o(mem_uncached_error_w)\\n', '    ,.mem_resp_tag_o(mem_uncached_resp_tag_w)\\n', '    ,.outport_wr_o(pmem_uncached_wr_w)\\n', '    ,.outport_rd_o(pmem_uncached_rd_w)\\n', '    ,.outport_len_o(pmem_uncached_len_w)\\n', '    ,.outport_addr_o(pmem_uncached_addr_w)\\n', '    ,.outport_write_data_o(pmem_uncached_write_data_w)\\n', ');\\n', '\\n', '\\n', 'dcache_pmem_mux\\n', 'u_pmem_mux\\n', '(\\n', '    // Inputs\\n', '     .clk_i(clk_i)\\n', '    ,.rst_i(rst_i)\\n', '    ,.outport_accept_i(pmem_accept_w)\\n', '    ,.outport_ack_i(pmem_ack_w)\\n', '    ,.outport_error_i(pmem_error_w)\\n', '    ,.outport_read_data_i(pmem_read_data_w)\\n', '    ,.select_i(pmem_select_w)\\n', '    ,.inport0_wr_i(pmem_uncached_wr_w)\\n', '    ,.inport0_rd_i(pmem_uncached_rd_w)\\n', '    ,.inport0_len_i(pmem_uncached_len_w)\\n', '    ,.inport0_addr_i(pmem_uncached_addr_w)\\n', '    ,.inport0_write_data_i(pmem_uncached_write_data_w)\\n', '    ,.inport1_wr_i(pmem_cache_wr_w)\\n', '    ,.inport1_rd_i(pmem_cache_rd_w)\\n', '    ,.inport1_len_i(pmem_cache_len_w)\\n', '    ,.inport1_addr_i(pmem_cache_addr_w)\\n', '    ,.inport1_write_data_i(pmem_cache_write_data_w)\\n', '\\n', '    // Outputs\\n', '    ,.outport_wr_o(pmem_wr_w)\\n', '    ,.outport_rd_o(pmem_rd_w)\\n', '    ,.outport_len_o(pmem_len_w)\\n', '    ,.outport_addr_o(pmem_addr_w)\\n', '    ,.outport_write_data_o(pmem_write_data_w)\\n', '    ,.inport0_accept_o(pmem_uncached_accept_w)\\n', '    ,.inport0_ack_o(pmem_uncached_ack_w)\\n', '    ,.inport0_error_o(pmem_uncached_error_w)\\n', '    ,.inport0_read_data_o(pmem_uncached_read_data_w)\\n', '    ,.inport1_accept_o(pmem_cache_accept_w)\\n', '    ,.inport1_ack_o(pmem_cache_ack_w)\\n', '    ,.inport1_error_o(pmem_cache_error_w)\\n', '    ,.inport1_read_data_o(pmem_cache_read_data_w)\\n', ');\\n', '\\n', '\\n', 'dcache_mux\\n', 'u_mux\\n', '(\\n', '    // Inputs\\n', '     .clk_i(clk_i)\\n', '    ,.rst_i(rst_i)\\n', '    ,.mem_addr_i(mem_addr_i)\\n', '    ,.mem_data_wr_i(mem_data_wr_i)\\n', '    ,.mem_rd_i(mem_rd_i)\\n', '    ,.mem_wr_i(mem_wr_i)\\n', '    ,.mem_cacheable_i(mem_cacheable_i)\\n', '    ,.mem_req_tag_i(mem_req_tag_i)\\n', '    ,.mem_invalidate_i(mem_invalidate_i)\\n', '    ,.mem_writeback_i(mem_writeback_i)\\n', '    ,.mem_flush_i(mem_flush_i)\\n', '    ,.mem_cached_data_rd_i(mem_cached_data_rd_w)\\n', '    ,.mem_cached_accept_i(mem_cached_accept_w)\\n', '    ,.mem_cached_ack_i(mem_cached_ack_w)\\n', '    ,.mem_cached_error_i(mem_cached_error_w)\\n', '    ,.mem_cached_resp_tag_i(mem_cached_resp_tag_w)\\n', '    ,.mem_uncached_data_rd_i(mem_uncached_data_rd_w)\\n', '    ,.mem_uncached_accept_i(mem_uncached_accept_w)\\n', '    ,.mem_uncached_ack_i(mem_uncached_ack_w)\\n', '    ,.mem_uncached_error_i(mem_uncached_error_w)\\n', '    ,.mem_uncached_resp_tag_i(mem_uncached_resp_tag_w)\\n', '\\n', '    // Outputs\\n', '    ,.mem_data_rd_o(mem_data_rd_o)\\n', '    ,.mem_accept_o(mem_accept_o)\\n', '    ,.mem_ack_o(mem_ack_o)\\n', '    ,.mem_error_o(mem_error_o)\\n', '    ,.mem_resp_tag_o(mem_resp_tag_o)\\n', '    ,.mem_cached_addr_o(mem_cached_addr_w)\\n', '    ,.mem_cached_data_wr_o(mem_cached_data_wr_w)\\n', '    ,.mem_cached_rd_o(mem_cached_rd_w)\\n', '    ,.mem_cached_wr_o(mem_cached_wr_w)\\n', '    ,.mem_cached_cacheable_o(mem_cached_cacheable_w)\\n', '    ,.mem_cached_req_tag_o(mem_cached_req_tag_w)\\n', '    ,.mem_cached_invalidate_o(mem_cached_invalidate_w)\\n', '    ,.mem_cached_writeback_o(mem_cached_writeback_w)\\n', '    ,.mem_cached_flush_o(mem_cached_flush_w)\\n', '    ,.mem_uncached_addr_o(mem_uncached_addr_w)\\n', '    ,.mem_uncached_data_wr_o(mem_uncached_data_wr_w)\\n', '    ,.mem_uncached_rd_o(mem_uncached_rd_w)\\n', '    ,.mem_uncached_wr_o(mem_uncached_wr_w)\\n', '    ,.mem_uncached_cacheable_o(mem_uncached_cacheable_w)\\n', '    ,.mem_uncached_req_tag_o(mem_uncached_req_tag_w)\\n', '    ,.mem_uncached_invalidate_o(mem_uncached_invalidate_w)\\n', '    ,.mem_uncached_writeback_o(mem_uncached_writeback_w)\\n', '    ,.mem_uncached_flush_o(mem_uncached_flush_w)\\n', '    ,.cache_active_o(pmem_select_w)\\n', ');\\n', '\\n', '\\n', 'dcache_core\\n', 'u_core\\n', '(\\n', '    // Inputs\\n', '     .clk_i(clk_i)\\n', '    ,.rst_i(rst_i)\\n', '    ,.mem_addr_i(mem_cached_addr_w)\\n', '    ,.mem_data_wr_i(mem_cached_data_wr_w)\\n', '    ,.mem_rd_i(mem_cached_rd_w)\\n', '    ,.mem_wr_i(mem_cached_wr_w)\\n', '    ,.mem_cacheable_i(mem_cached_cacheable_w)\\n', '    ,.mem_req_tag_i(mem_cached_req_tag_w)\\n', '    ,.mem_invalidate_i(mem_cached_invalidate_w)\\n', '    ,.mem_writeback_i(mem_cached_writeback_w)\\n', '    ,.mem_flush_i(mem_cached_flush_w)\\n', '    ,.outport_accept_i(pmem_cache_accept_w)\\n', '    ,.outport_ack_i(pmem_cache_ack_w)\\n', '    ,.outport_error_i(pmem_cache_error_w)\\n', '    ,.outport_read_data_i(pmem_cache_read_data_w)\\n', '\\n', '    // Outputs\\n', '    ,.mem_data_rd_o(mem_cached_data_rd_w)\\n', '    ,.mem_accept_o(mem_cached_accept_w)\\n', '    ,.mem_ack_o(mem_cached_ack_w)\\n', '    ,.mem_error_o(mem_cached_error_w)\\n', '    ,.mem_resp_tag_o(mem_cached_resp_tag_w)\\n', '    ,.outport_wr_o(pmem_cache_wr_w)\\n', '    ,.outport_rd_o(pmem_cache_rd_w)\\n', '    ,.outport_len_o(pmem_cache_len_w)\\n', '    ,.outport_addr_o(pmem_cache_addr_w)\\n', '    ,.outport_write_data_o(pmem_cache_write_data_w)\\n', ');\\n', '\\n', '\\n', 'dcache_axi\\n', '#(\\n', '     .AXI_ID(AXI_ID)\\n', ')\\n', 'u_axi\\n', '(\\n', '    // Inputs\\n', '     .clk_i(clk_i)\\n', '    ,.rst_i(rst_i)\\n', '    ,.outport_awready_i(axi_awready_i)\\n', '    ,.outport_wready_i(axi_wready_i)\\n', '    ,.outport_bvalid_i(axi_bvalid_i)\\n', '    ,.outport_bresp_i(axi_bresp_i)\\n', '    ,.outport_bid_i(axi_bid_i)\\n', '    ,.outport_arready_i(axi_arready_i)\\n', '    ,.outport_rvalid_i(axi_rvalid_i)\\n', '    ,.outport_rdata_i(axi_rdata_i)\\n', '    ,.outport_rresp_i(axi_rresp_i)\\n', '    ,.outport_rid_i(axi_rid_i)\\n', '    ,.outport_rlast_i(axi_rlast_i)\\n', '    ,.inport_wr_i(pmem_wr_w)\\n', '    ,.inport_rd_i(pmem_rd_w)\\n', '    ,.inport_len_i(pmem_len_w)\\n', '    ,.inport_addr_i(pmem_addr_w)\\n', '    ,.inport_write_data_i(pmem_write_data_w)\\n', '\\n', '    // Outputs\\n', '    ,.outport_awvalid_o(axi_awvalid_o)\\n', '    ,.outport_awaddr_o(axi_awaddr_o)\\n', '    ,.outport_awid_o(axi_awid_o)\\n', '    ,.outport_awlen_o(axi_awlen_o)\\n', '    ,.outport_awburst_o(axi_awburst_o)\\n', '    ,.outport_wvalid_o(axi_wvalid_o)\\n', '    ,.outport_wdata_o(axi_wdata_o)\\n', '    ,.outport_wstrb_o(axi_wstrb_o)\\n', '    ,.outport_wlast_o(axi_wlast_o)\\n', '    ,.outport_bready_o(axi_bready_o)\\n', '    ,.outport_arvalid_o(axi_arvalid_o)\\n', '    ,.outport_araddr_o(axi_araddr_o)\\n', '    ,.outport_arid_o(axi_arid_o)\\n', '    ,.outport_arlen_o(axi_arlen_o)\\n', '    ,.outport_arburst_o(axi_arburst_o)\\n', '    ,.outport_rready_o(axi_rready_o)\\n', '    ,.inport_accept_o(pmem_accept_w)\\n', '    ,.inport_ack_o(pmem_ack_w)\\n', '    ,.inport_error_o(pmem_error_w)\\n', '    ,.inport_read_data_o(pmem_read_data_w)\\n', ');\\n', '\\n', '\\n', '\\n', 'endmodule\\n']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.6.0\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', '\\n', 'module dcache_axi\\n', '//-----------------------------------------------------------------\\n', '// Params\\n', '//-----------------------------------------------------------------\\n', '#(\\n', '     parameter AXI_ID           = 0\\n', ')\\n', '//-----------------------------------------------------------------\\n', '// Ports\\n', '//-----------------------------------------------------------------\\n', '(\\n', '    // Inputs\\n', '     input           clk_i\\n', '    ,input           rst_i\\n', '    ,input           outport_awready_i\\n', '    ,input           outport_wready_i\\n', '    ,input           outport_bvalid_i\\n', '    ,input  [  1:0]  outport_bresp_i\\n', '    ,input  [  3:0]  outport_bid_i\\n', '    ,input           outport_arready_i\\n', '    ,input           outport_rvalid_i\\n', '    ,input  [ 31:0]  outport_rdata_i\\n', '    ,input  [  1:0]  outport_rresp_i\\n', '    ,input  [  3:0]  outport_rid_i\\n', '    ,input           outport_rlast_i\\n', '    ,input  [  3:0]  inport_wr_i\\n', '    ,input           inport_rd_i\\n', '    ,input  [  7:0]  inport_len_i\\n', '    ,input  [ 31:0]  inport_addr_i\\n', '    ,input  [ 31:0]  inport_write_data_i\\n', '\\n', '    // Outputs\\n', '    ,output          outport_awvalid_o\\n', '    ,output [ 31:0]  outport_awaddr_o\\n', '    ,output [  3:0]  outport_awid_o\\n', '    ,output [  7:0]  outport_awlen_o\\n', '    ,output [  1:0]  outport_awburst_o\\n', '    ,output          outport_wvalid_o\\n', '    ,output [ 31:0]  outport_wdata_o\\n', '    ,output [  3:0]  outport_wstrb_o\\n', '    ,output          outport_wlast_o\\n', '    ,output          outport_bready_o\\n', '    ,output          outport_arvalid_o\\n', '    ,output [ 31:0]  outport_araddr_o\\n', '    ,output [  3:0]  outport_arid_o\\n', '    ,output [  7:0]  outport_arlen_o\\n', '    ,output [  1:0]  outport_arburst_o\\n', '    ,output          outport_rready_o\\n', '    ,output          inport_accept_o\\n', '    ,output          inport_ack_o\\n', '    ,output          inport_error_o\\n', '    ,output [ 31:0]  inport_read_data_o\\n', ');\\n', '\\n', '\\n', '\\n', '\\n', '//-------------------------------------------------------------\\n', '// Request FIFO\\n', '//-------------------------------------------------------------\\n', 'wire          bvalid_w;\\n', 'wire          rvalid_w;\\n', 'wire [1:0]    bresp_w;\\n', 'wire [1:0]    rresp_w;\\n', 'wire          accept_w;\\n', '\\n', '// Accepts from both FIFOs\\n', 'wire          res_accept_w;\\n', 'wire          req_accept_w;\\n', '\\n', 'wire          res_valid_w;\\n', 'wire          req_valid_w;\\n', 'wire [77-1:0] req_w;\\n', '\\n', '// Push on transaction and other FIFO not full\\n', \"wire          req_push_w    = (inport_rd_i || inport_wr_i != 4'b0);\\n\", 'wire [77-1:0] req_data_in_w = {inport_len_i, inport_rd_i, inport_wr_i, inport_write_data_i, inport_addr_i};\\n', '\\n', 'dcache_axi_fifo\\n', '#( \\n', '    .ADDR_W(1),\\n', '    .DEPTH(2),\\n', '    .WIDTH(32+32+8+4+1)\\n', ')\\n', 'u_req\\n', '(\\n', '    .clk_i(clk_i),\\n', '    .rst_i(rst_i),\\n', '\\n', '    // Input side\\n', '    .data_in_i(req_data_in_w),\\n', '    .push_i(req_push_w),\\n', '    .accept_o(req_accept_w),\\n', '\\n', '    // Outputs\\n', '    .valid_o(req_valid_w),\\n', '    .data_out_o(req_w),\\n', '    .pop_i(accept_w)\\n', ');\\n', '\\n', 'wire       req_can_issue_w = req_valid_w & res_accept_w;\\n', \"wire       req_is_read_w   = (req_can_issue_w ? req_w[68] : 1'b0);\\n\", \"wire       req_is_write_w  = (req_can_issue_w ? ~req_w[68] : 1'b0);\\n\", 'wire [7:0] req_len_w       = req_w[76:69];\\n', '\\n', 'assign inport_accept_o = req_accept_w;\\n', 'assign inport_ack_o    = bvalid_w || rvalid_w;\\n', \"assign inport_error_o  = bvalid_w ? (bresp_w != 2'b0) : (rresp_w != 2'b0);\\n\", '\\n', '//-------------------------------------------------------------\\n', '// Write burst tracking\\n', '//-------------------------------------------------------------\\n', 'reg  [7:0] req_cnt_q;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    req_cnt_q <= 8'b0;\\n\", '// First cycle of write burst\\n', \"else if (req_is_write_w && req_cnt_q == 8'd0 && req_len_w != 8'd0 && accept_w)\\n\", \"    req_cnt_q <= req_len_w - 8'd1;\\n\", \"else if (req_cnt_q != 8'd0 && req_is_write_w && accept_w)\\n\", \"    req_cnt_q <= req_cnt_q - 8'd1;\\n\", '\\n', \"wire req_last_w = (req_is_write_w && req_len_w == 8'd0 && req_cnt_q == 8'd0);\\n\", '\\n', '//-------------------------------------------------------------\\n', '// Response tracking\\n', '//-------------------------------------------------------------\\n', '// Push on transaction and other FIFO not full\\n', 'wire res_push_w = (req_is_write_w && req_last_w && accept_w) || (req_is_read_w && accept_w);\\n', '\\n', '// Pop on last tick of burst\\n', \"wire resp_pop_w = outport_bvalid_i || (outport_rvalid_i ? outport_rlast_i : 1'b0);\\n\", '\\n', 'reg  [1:0] resp_outstanding_q;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    resp_outstanding_q <= 2'b0;\\n\", '// Count up\\n', 'else if ((res_push_w & res_accept_w) & ~(resp_pop_w & res_valid_w))\\n', \"    resp_outstanding_q <= resp_outstanding_q + 2'd1;\\n\", '// Count down\\n', 'else if (~(res_push_w & res_accept_w) & (resp_pop_w & res_valid_w))\\n', \"    resp_outstanding_q <= resp_outstanding_q - 2'd1;\\n\", '\\n', \"assign res_valid_w   = (resp_outstanding_q != 2'd0);\\n\", \"assign res_accept_w  = (resp_outstanding_q != 2'd2);\\n\", '\\n', '//-------------------------------------------------------------\\n', '// AXI widget\\n', '//-------------------------------------------------------------\\n', 'dcache_axi_axi\\n', 'u_axi\\n', '(\\n', '    .clk_i(clk_i),\\n', '    .rst_i(rst_i),\\n', '\\n', '    .inport_valid_i(req_can_issue_w),\\n', '    .inport_write_i(req_is_write_w),\\n', '    .inport_wdata_i(req_w[63:32]),\\n', '    .inport_wstrb_i(req_w[67:64]),    \\n', \"    .inport_addr_i({req_w[31:2], 2'b0}),\\n\", '    .inport_id_i(AXI_ID),\\n', '    .inport_len_i(req_len_w),\\n', \"    .inport_burst_i(2'b01),\\n\", '    .inport_accept_o(accept_w),\\n', '\\n', \"    .inport_bready_i(1'b1),\\n\", \"    .inport_rready_i(1'b1),\\n\", '    .inport_bvalid_o(bvalid_w),\\n', '    .inport_bresp_o(bresp_w),\\n', '    .inport_bid_o(),\\n', '    .inport_rvalid_o(rvalid_w),\\n', '    .inport_rdata_o(inport_read_data_o),\\n', '    .inport_rresp_o(rresp_w),\\n', '    .inport_rid_o(),\\n', '    .inport_rlast_o(),\\n', '\\n', '    .outport_awvalid_o(outport_awvalid_o),\\n', '    .outport_awaddr_o(outport_awaddr_o),\\n', '    .outport_awid_o(outport_awid_o),\\n', '    .outport_awlen_o(outport_awlen_o),\\n', '    .outport_awburst_o(outport_awburst_o),\\n', '    .outport_wvalid_o(outport_wvalid_o),\\n', '    .outport_wdata_o(outport_wdata_o),\\n', '    .outport_wstrb_o(outport_wstrb_o),\\n', '    .outport_wlast_o(outport_wlast_o),\\n', '    .outport_bready_o(outport_bready_o),\\n', '    .outport_arvalid_o(outport_arvalid_o),\\n', '    .outport_araddr_o(outport_araddr_o),\\n', '    .outport_arid_o(outport_arid_o),\\n', '    .outport_arlen_o(outport_arlen_o),\\n', '    .outport_arburst_o(outport_arburst_o),\\n', '    .outport_rready_o(outport_rready_o),\\n', '    .outport_awready_i(outport_awready_i),\\n', '    .outport_wready_i(outport_wready_i),\\n', '    .outport_bvalid_i(outport_bvalid_i),\\n', '    .outport_bresp_i(outport_bresp_i),\\n', '    .outport_bid_i(outport_bid_i),\\n', '    .outport_arready_i(outport_arready_i),\\n', '    .outport_rvalid_i(outport_rvalid_i),\\n', '    .outport_rdata_i(outport_rdata_i),\\n', '    .outport_rresp_i(outport_rresp_i),\\n', '    .outport_rid_i(outport_rid_i),\\n', '    .outport_rlast_i(outport_rlast_i)\\n', ');\\n', '\\n', 'endmodule\\n', '\\n', '\\n', 'module dcache_axi_fifo\\n', '//-----------------------------------------------------------------\\n', '// Params\\n', '//-----------------------------------------------------------------\\n', '#(\\n', '    parameter WIDTH   = 8,\\n', '    parameter DEPTH   = 4,\\n', '    parameter ADDR_W  = 2\\n', ')\\n', '//-----------------------------------------------------------------\\n', '// Ports\\n', '//-----------------------------------------------------------------\\n', '(\\n', '    // Inputs\\n', '     input               clk_i\\n', '    ,input               rst_i\\n', '    ,input  [WIDTH-1:0]  data_in_i\\n', '    ,input               push_i\\n', '    ,input               pop_i\\n', '\\n', '    // Outputs\\n', '    ,output [WIDTH-1:0]  data_out_o\\n', '    ,output              accept_o\\n', '    ,output              valid_o\\n', ');\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Local Params\\n', '//-----------------------------------------------------------------\\n', 'localparam COUNT_W = ADDR_W + 1;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Registers\\n', '//-----------------------------------------------------------------\\n', 'reg [WIDTH-1:0]   ram_q[DEPTH-1:0];\\n', 'reg [ADDR_W-1:0]  rd_ptr_q;\\n', 'reg [ADDR_W-1:0]  wr_ptr_q;\\n', 'reg [COUNT_W-1:0] count_q;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Sequential\\n', '//-----------------------------------------------------------------\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', 'begin\\n', \"    count_q   <= {(COUNT_W) {1'b0}};\\n\", \"    rd_ptr_q  <= {(ADDR_W) {1'b0}};\\n\", \"    wr_ptr_q  <= {(ADDR_W) {1'b0}};\\n\", 'end\\n', 'else\\n', 'begin\\n', '    // Push\\n', '    if (push_i & accept_o)\\n', '    begin\\n', '        ram_q[wr_ptr_q] <= data_in_i;\\n', '        wr_ptr_q        <= wr_ptr_q + 1;\\n', '    end\\n', '\\n', '    // Pop\\n', '    if (pop_i & valid_o)\\n', '        rd_ptr_q      <= rd_ptr_q + 1;\\n', '\\n', '    // Count up\\n', '    if ((push_i & accept_o) & ~(pop_i & valid_o))\\n', '        count_q <= count_q + 1;\\n', '    // Count down\\n', '    else if (~(push_i & accept_o) & (pop_i & valid_o))\\n', '        count_q <= count_q - 1;\\n', 'end\\n', '\\n', '//-------------------------------------------------------------------\\n', '// Combinatorial\\n', '//-------------------------------------------------------------------\\n', '/* verilator lint_off WIDTH */\\n', 'assign valid_o       = (count_q != 0);\\n', 'assign accept_o      = (count_q != DEPTH);\\n', '/* verilator lint_on WIDTH */\\n', '\\n', 'assign data_out_o    = ram_q[rd_ptr_q];\\n', '\\n', '\\n', '\\n', 'endmodule\\n']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.6.0\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', '\\n', 'module dcache_axi_axi\\n', '(\\n', '    // Inputs\\n', '     input           clk_i\\n', '    ,input           rst_i\\n', '    ,input           inport_valid_i\\n', '    ,input           inport_write_i\\n', '    ,input  [ 31:0]  inport_addr_i\\n', '    ,input  [  3:0]  inport_id_i\\n', '    ,input  [  7:0]  inport_len_i\\n', '    ,input  [  1:0]  inport_burst_i\\n', '    ,input  [ 31:0]  inport_wdata_i\\n', '    ,input  [  3:0]  inport_wstrb_i\\n', '    ,input           inport_bready_i\\n', '    ,input           inport_rready_i\\n', '    ,input           outport_awready_i\\n', '    ,input           outport_wready_i\\n', '    ,input           outport_bvalid_i\\n', '    ,input  [  1:0]  outport_bresp_i\\n', '    ,input  [  3:0]  outport_bid_i\\n', '    ,input           outport_arready_i\\n', '    ,input           outport_rvalid_i\\n', '    ,input  [ 31:0]  outport_rdata_i\\n', '    ,input  [  1:0]  outport_rresp_i\\n', '    ,input  [  3:0]  outport_rid_i\\n', '    ,input           outport_rlast_i\\n', '\\n', '    // Outputs\\n', '    ,output          inport_accept_o\\n', '    ,output          inport_bvalid_o\\n', '    ,output [  1:0]  inport_bresp_o\\n', '    ,output [  3:0]  inport_bid_o\\n', '    ,output          inport_rvalid_o\\n', '    ,output [ 31:0]  inport_rdata_o\\n', '    ,output [  1:0]  inport_rresp_o\\n', '    ,output [  3:0]  inport_rid_o\\n', '    ,output          inport_rlast_o\\n', '    ,output          outport_awvalid_o\\n', '    ,output [ 31:0]  outport_awaddr_o\\n', '    ,output [  3:0]  outport_awid_o\\n', '    ,output [  7:0]  outport_awlen_o\\n', '    ,output [  1:0]  outport_awburst_o\\n', '    ,output          outport_wvalid_o\\n', '    ,output [ 31:0]  outport_wdata_o\\n', '    ,output [  3:0]  outport_wstrb_o\\n', '    ,output          outport_wlast_o\\n', '    ,output          outport_bready_o\\n', '    ,output          outport_arvalid_o\\n', '    ,output [ 31:0]  outport_araddr_o\\n', '    ,output [  3:0]  outport_arid_o\\n', '    ,output [  7:0]  outport_arlen_o\\n', '    ,output [  1:0]  outport_arburst_o\\n', '    ,output          outport_rready_o\\n', ');\\n', '\\n', '\\n', '\\n', '//-------------------------------------------------------------\\n', '// Write Request\\n', '//-------------------------------------------------------------\\n', 'reg awvalid_inhibit_q;\\n', 'reg wvalid_inhibit_q;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    awvalid_inhibit_q <= 1'b0;\\n\", 'else if (outport_awvalid_o && outport_awready_i && outport_wvalid_o && !outport_wready_i)\\n', \"    awvalid_inhibit_q <= 1'b1;\\n\", \"else if (outport_awvalid_o && outport_awready_i && outport_awlen_o != 8'b0)\\n\", \"    awvalid_inhibit_q <= 1'b1;\\n\", 'else if (outport_wvalid_o && outport_wready_i && outport_wlast_o)\\n', \"    awvalid_inhibit_q <= 1'b0;\\n\", '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    wvalid_inhibit_q <= 1'b0;\\n\", 'else if (outport_wvalid_o && outport_wready_i && outport_awvalid_o && !outport_awready_i)\\n', \"    wvalid_inhibit_q <= 1'b1;\\n\", 'else if (outport_awvalid_o && outport_awready_i)\\n', \"    wvalid_inhibit_q <= 1'b0;\\n\", '\\n', 'assign outport_awvalid_o = (inport_valid_i & inport_write_i & ~awvalid_inhibit_q);\\n', 'assign outport_awaddr_o  = inport_addr_i;\\n', 'assign outport_awid_o    = inport_id_i;\\n', 'assign outport_awlen_o   = inport_len_i;\\n', 'assign outport_awburst_o = inport_burst_i;\\n', '\\n', '//-------------------------------------------------------------\\n', '// Write burst tracking\\n', '//-------------------------------------------------------------\\n', 'reg  [7:0] req_cnt_q;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    req_cnt_q <= 8'b0;\\n\", 'else if (outport_awvalid_o && outport_awready_i)\\n', 'begin\\n', '    // First data not accepted yet\\n', '    if (!outport_wready_i && !wvalid_inhibit_q)\\n', \"        req_cnt_q <= (outport_awlen_o + 8'd1);\\n\", '    // First data already accepted\\n', '    else\\n', '        req_cnt_q <= outport_awlen_o;\\n', 'end\\n', \"else if (req_cnt_q != 8'd0 && outport_wvalid_o && outport_wready_i)\\n\", \"    req_cnt_q <= req_cnt_q - 8'd1;\\n\", '\\n', \"wire wlast_w = (outport_awvalid_o && outport_awlen_o == 8'b0) || (req_cnt_q == 8'd1);\\n\", '\\n', '//-------------------------------------------------------------\\n', '// Write data skid buffer\\n', '//-------------------------------------------------------------\\n', 'reg buf_valid_q;\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    buf_valid_q <= 1'b0;\\n\", 'else if (outport_wvalid_o && !outport_wready_i && outport_awvalid_o && outport_awready_i)\\n', \"    buf_valid_q <= 1'b1;\\n\", 'else if (outport_wready_i)\\n', \"    buf_valid_q <= 1'b0;\\n\", '\\n', 'reg [36:0] buf_q;\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    buf_q <= 37'b0;\\n\", 'else\\n', '    buf_q <= {outport_wlast_o, outport_wstrb_o, outport_wdata_o};\\n', '\\n', \"assign outport_wvalid_o  = buf_valid_q ? 1'b1 : (inport_valid_i & inport_write_i & ~wvalid_inhibit_q);\\n\", 'assign outport_wdata_o   = buf_valid_q ? buf_q[31:0]  : inport_wdata_i;\\n', 'assign outport_wstrb_o   = buf_valid_q ? buf_q[35:32] : inport_wstrb_i;\\n', 'assign outport_wlast_o   = buf_valid_q ? buf_q[36:36] : wlast_w;\\n', '\\n', 'assign inport_bvalid_o   = outport_bvalid_i;\\n', 'assign inport_bresp_o    = outport_bresp_i;\\n', 'assign inport_bid_o      = outport_bid_i;\\n', 'assign outport_bready_o  = inport_bready_i;\\n', '\\n', '//-------------------------------------------------------------\\n', '// Read Request\\n', '//-------------------------------------------------------------\\n', 'assign outport_arvalid_o = inport_valid_i & ~inport_write_i;\\n', 'assign outport_araddr_o  = inport_addr_i;\\n', 'assign outport_arid_o    = inport_id_i;\\n', 'assign outport_arlen_o   = inport_len_i;\\n', 'assign outport_arburst_o = inport_burst_i;\\n', 'assign outport_rready_o  = inport_rready_i;\\n', '\\n', 'assign inport_rvalid_o   = outport_rvalid_i;\\n', 'assign inport_rdata_o    = outport_rdata_i;\\n', 'assign inport_rresp_o    = outport_rresp_i;\\n', 'assign inport_rid_o      = outport_rid_i;\\n', 'assign inport_rlast_o    = outport_rlast_i;\\n', '\\n', '//-------------------------------------------------------------\\n', '// Accept logic\\n', '//-------------------------------------------------------------\\n', 'assign inport_accept_o   = (outport_awvalid_o && outport_awready_i) || \\n', '                           (outport_wvalid_o  && outport_wready_i && !buf_valid_q)  ||\\n', '                           (outport_arvalid_o && outport_arready_i);\\n', '\\n', '\\n', 'endmodule\\n']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.6.0\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', '\\n', 'module dcache_core\\n', '(\\n', '    // Inputs\\n', '     input           clk_i\\n', '    ,input           rst_i\\n', '    ,input  [ 31:0]  mem_addr_i\\n', '    ,input  [ 31:0]  mem_data_wr_i\\n', '    ,input           mem_rd_i\\n', '    ,input  [  3:0]  mem_wr_i\\n', '    ,input           mem_cacheable_i\\n', '    ,input  [ 10:0]  mem_req_tag_i\\n', '    ,input           mem_invalidate_i\\n', '    ,input           mem_writeback_i\\n', '    ,input           mem_flush_i\\n', '    ,input           outport_accept_i\\n', '    ,input           outport_ack_i\\n', '    ,input           outport_error_i\\n', '    ,input  [ 31:0]  outport_read_data_i\\n', '\\n', '    // Outputs\\n', '    ,output [ 31:0]  mem_data_rd_o\\n', '    ,output          mem_accept_o\\n', '    ,output          mem_ack_o\\n', '    ,output          mem_error_o\\n', '    ,output [ 10:0]  mem_resp_tag_o\\n', '    ,output [  3:0]  outport_wr_o\\n', '    ,output          outport_rd_o\\n', '    ,output [  7:0]  outport_len_o\\n', '    ,output [ 31:0]  outport_addr_o\\n', '    ,output [ 31:0]  outport_write_data_o\\n', ');\\n', '\\n', '\\n', '\\n', '//-----------------------------------------------------------------\\n', '// This cache instance is 2 way set associative.\\n', '// The total size is 16KB.\\n', '// The replacement policy is a limited pseudo random scheme\\n', '// (between lines, toggling on line thrashing).\\n', '// The cache is a write back cache, with allocate on read and write.\\n', '//-----------------------------------------------------------------\\n', '// Number of ways\\n', 'localparam DCACHE_NUM_WAYS           = 2;\\n', '\\n', '// Number of cache lines\\n', 'localparam DCACHE_NUM_LINES          = 256;\\n', 'localparam DCACHE_LINE_ADDR_W        = 8;\\n', '\\n', '// Line size (e.g. 32-bytes)\\n', 'localparam DCACHE_LINE_SIZE_W        = 5;\\n', 'localparam DCACHE_LINE_SIZE          = 32;\\n', 'localparam DCACHE_LINE_WORDS         = 8;\\n', '\\n', '// Request -> tag address mapping\\n', 'localparam DCACHE_TAG_REQ_LINE_L     = 5;  // DCACHE_LINE_SIZE_W\\n', 'localparam DCACHE_TAG_REQ_LINE_H     = 12; // DCACHE_LINE_ADDR_W+DCACHE_LINE_SIZE_W-1\\n', 'localparam DCACHE_TAG_REQ_LINE_W     = 8;  // DCACHE_LINE_ADDR_W\\n', '`define DCACHE_TAG_REQ_RNG          DCACHE_TAG_REQ_LINE_H:DCACHE_TAG_REQ_LINE_L\\n', '\\n', '// Tag fields\\n', '`define CACHE_TAG_ADDR_RNG          18:0\\n', 'localparam CACHE_TAG_ADDR_BITS       = 19;\\n', 'localparam CACHE_TAG_DIRTY_BIT       = CACHE_TAG_ADDR_BITS + 0;\\n', 'localparam CACHE_TAG_VALID_BIT       = CACHE_TAG_ADDR_BITS + 1;\\n', 'localparam CACHE_TAG_DATA_W          = CACHE_TAG_ADDR_BITS + 2;\\n', '\\n', '// Tag compare bits\\n', 'localparam DCACHE_TAG_CMP_ADDR_L     = DCACHE_TAG_REQ_LINE_H + 1;\\n', 'localparam DCACHE_TAG_CMP_ADDR_H     = 32-1;\\n', 'localparam DCACHE_TAG_CMP_ADDR_W     = DCACHE_TAG_CMP_ADDR_H - DCACHE_TAG_CMP_ADDR_L + 1;\\n', '`define   DCACHE_TAG_CMP_ADDR_RNG   31:13\\n', '\\n', '// Address mapping example:\\n', '//  31          16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00\\n', '// |--------------|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |\\n', '//  +--------------------+  +--------------------+   +------------+\\n', '//  |  Tag address.      |  |   Line address     |      Address \\n', '//  |                    |  |                    |      within line\\n', '//  |                    |  |                    |\\n', '//  |                    |  |                    |- DCACHE_TAG_REQ_LINE_L\\n', '//  |                    |  |- DCACHE_TAG_REQ_LINE_H\\n', '//  |                    |- DCACHE_TAG_CMP_ADDR_L\\n', '//  |- DCACHE_TAG_CMP_ADDR_H\\n', '\\n', '//-----------------------------------------------------------------\\n', '// States\\n', '//-----------------------------------------------------------------\\n', 'localparam STATE_W           = 4;\\n', \"localparam STATE_RESET       = 4'd0;\\n\", \"localparam STATE_FLUSH_ADDR  = 4'd1;\\n\", \"localparam STATE_FLUSH       = 4'd2;\\n\", \"localparam STATE_LOOKUP      = 4'd3;\\n\", \"localparam STATE_READ        = 4'd4;\\n\", \"localparam STATE_WRITE       = 4'd5;\\n\", \"localparam STATE_REFILL      = 4'd6;\\n\", \"localparam STATE_EVICT       = 4'd7;\\n\", \"localparam STATE_EVICT_WAIT  = 4'd8;\\n\", \"localparam STATE_INVALIDATE  = 4'd9;\\n\", \"localparam STATE_WRITEBACK   = 4'd10;\\n\", '\\n', '// States\\n', 'reg [STATE_W-1:0]           next_state_r;\\n', 'reg [STATE_W-1:0]           state_q;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Request buffer\\n', '//-----------------------------------------------------------------\\n', 'reg [31:0] mem_addr_m_q;\\n', 'reg [31:0] mem_data_m_q;\\n', 'reg [3:0]  mem_wr_m_q;\\n', 'reg        mem_rd_m_q;\\n', 'reg [10:0] mem_tag_m_q;\\n', 'reg        mem_inval_m_q;\\n', 'reg        mem_writeback_m_q;\\n', 'reg        mem_flush_m_q;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', 'begin\\n', \"    mem_addr_m_q      <= 32'b0;\\n\", \"    mem_data_m_q      <= 32'b0;\\n\", \"    mem_wr_m_q        <= 4'b0;\\n\", \"    mem_rd_m_q        <= 1'b0;\\n\", \"    mem_tag_m_q       <= 11'b0;\\n\", \"    mem_inval_m_q     <= 1'b0;\\n\", \"    mem_writeback_m_q <= 1'b0;\\n\", \"    mem_flush_m_q     <= 1'b0;\\n\", 'end\\n', 'else if (mem_accept_o)\\n', 'begin\\n', '    mem_addr_m_q      <= mem_addr_i;\\n', '    mem_data_m_q      <= mem_data_wr_i;\\n', '    mem_wr_m_q        <= mem_wr_i;\\n', '    mem_rd_m_q        <= mem_rd_i;\\n', '    mem_tag_m_q       <= mem_req_tag_i;\\n', '    mem_inval_m_q     <= mem_invalidate_i;\\n', '    mem_writeback_m_q <= mem_writeback_i;\\n', '    mem_flush_m_q     <= mem_flush_i;\\n', 'end\\n', 'else if (mem_ack_o)\\n', 'begin\\n', \"    mem_addr_m_q      <= 32'b0;\\n\", \"    mem_data_m_q      <= 32'b0;\\n\", \"    mem_wr_m_q        <= 4'b0;\\n\", \"    mem_rd_m_q        <= 1'b0;\\n\", \"    mem_tag_m_q       <= 11'b0;\\n\", \"    mem_inval_m_q     <= 1'b0;\\n\", \"    mem_writeback_m_q <= 1'b0;\\n\", \"    mem_flush_m_q     <= 1'b0;\\n\", 'end\\n', '\\n', 'reg mem_accept_r;\\n', '\\n', 'always @ *\\n', 'begin\\n', \"    mem_accept_r = 1'b0;\\n\", '\\n', '    if (state_q == STATE_LOOKUP)\\n', '    begin\\n', '        // Previous access missed - do not accept new requests\\n', \"        if ((mem_rd_m_q || (mem_wr_m_q != 4'b0)) && !tag_hit_any_m_w)\\n\", \"            mem_accept_r = 1'b0;\\n\", '        // Write followed by read - detect writes to the same line, or addresses which alias in tag lookups\\n', '        else if ((|mem_wr_m_q) && mem_rd_i && mem_addr_i[31:2] == mem_addr_m_q[31:2])\\n', \"            mem_accept_r = 1'b0;\\n\", '        else\\n', \"            mem_accept_r = 1'b1;\\n\", '    end\\n', 'end\\n', '\\n', 'assign mem_accept_o = mem_accept_r;\\n', '\\n', '// Tag comparison address\\n', 'wire [DCACHE_TAG_CMP_ADDR_W-1:0] req_addr_tag_cmp_m_w = mem_addr_m_q[`DCACHE_TAG_CMP_ADDR_RNG];\\n', '\\n', 'assign mem_resp_tag_o = mem_tag_m_q;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Registers / Wires\\n', '//-----------------------------------------------------------------\\n', 'reg [0:0]  replace_way_q;\\n', '\\n', 'wire  [  3:0]  pmem_wr_w;\\n', 'wire           pmem_rd_w;\\n', 'wire  [  7:0]  pmem_len_w;\\n', 'wire           pmem_last_w;\\n', 'wire  [ 31:0]  pmem_addr_w;\\n', 'wire  [ 31:0]  pmem_write_data_w;\\n', 'wire           pmem_accept_w;\\n', 'wire           pmem_ack_w;\\n', 'wire           pmem_error_w;\\n', 'wire [ 31:0]   pmem_read_data_w;\\n', '\\n', 'wire           evict_way_w;\\n', 'wire           tag_dirty_any_m_w;\\n', 'wire           tag_hit_and_dirty_m_w;\\n', '\\n', 'reg            flushing_q;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// TAG RAMS\\n', '//-----------------------------------------------------------------\\n', 'reg [DCACHE_TAG_REQ_LINE_W-1:0] tag_addr_x_r;\\n', 'reg [DCACHE_TAG_REQ_LINE_W-1:0] tag_addr_m_r;\\n', '\\n', '// Tag RAM address\\n', 'always @ *\\n', 'begin\\n', '    // Read Port\\n', '    tag_addr_x_r = mem_addr_i[`DCACHE_TAG_REQ_RNG];\\n', '\\n', '    // Lookup\\n', '    if (state_q == STATE_LOOKUP && (next_state_r == STATE_LOOKUP || next_state_r == STATE_WRITEBACK))\\n', '        tag_addr_x_r = mem_addr_i[`DCACHE_TAG_REQ_RNG];\\n', '    // Cache flush\\n', '    else if (flushing_q)\\n', '        tag_addr_x_r = flush_addr_q;\\n', '    else\\n', '        tag_addr_x_r = mem_addr_m_q[`DCACHE_TAG_REQ_RNG];        \\n', '\\n', '    // Write Port\\n', '    tag_addr_m_r = flush_addr_q;\\n', '\\n', '    // Cache flush\\n', '    if (flushing_q || state_q == STATE_RESET)\\n', '        tag_addr_m_r = flush_addr_q;\\n', '    // Line refill / write\\n', '    else\\n', '        tag_addr_m_r = mem_addr_m_q[`DCACHE_TAG_REQ_RNG];\\n', 'end\\n', '\\n', '// Tag RAM write data\\n', 'reg [CACHE_TAG_DATA_W-1:0] tag_data_in_m_r;\\n', 'always @ *\\n', 'begin\\n', \"    tag_data_in_m_r = {(CACHE_TAG_DATA_W){1'b0}};\\n\", '\\n', '    // Cache flush\\n', '    if (state_q == STATE_FLUSH || state_q == STATE_RESET || flushing_q)\\n', \"        tag_data_in_m_r = {(CACHE_TAG_DATA_W){1'b0}};\\n\", '    // Line refill\\n', '    else if (state_q == STATE_REFILL)\\n', '    begin\\n', \"        tag_data_in_m_r[CACHE_TAG_VALID_BIT] = 1'b1;\\n\", \"        tag_data_in_m_r[CACHE_TAG_DIRTY_BIT] = 1'b0;\\n\", '        tag_data_in_m_r[`CACHE_TAG_ADDR_RNG] = mem_addr_m_q[`DCACHE_TAG_CMP_ADDR_RNG];\\n', '    end\\n', '    // Invalidate - mark entry (if matching line) not valid (even if dirty...)\\n', '    else if (state_q == STATE_INVALIDATE)\\n', '    begin\\n', \"        tag_data_in_m_r[CACHE_TAG_VALID_BIT] = 1'b0;\\n\", \"        tag_data_in_m_r[CACHE_TAG_DIRTY_BIT] = 1'b0;\\n\", '        tag_data_in_m_r[`CACHE_TAG_ADDR_RNG] = mem_addr_m_q[`DCACHE_TAG_CMP_ADDR_RNG];\\n', '    end\\n', '    // Evict completion\\n', '    else if (state_q == STATE_EVICT_WAIT)\\n', '    begin\\n', \"        tag_data_in_m_r[CACHE_TAG_VALID_BIT] = 1'b1;\\n\", \"        tag_data_in_m_r[CACHE_TAG_DIRTY_BIT] = 1'b0;\\n\", '        tag_data_in_m_r[`CACHE_TAG_ADDR_RNG] = mem_addr_m_q[`DCACHE_TAG_CMP_ADDR_RNG];\\n', '    end\\n', '    // Write - mark entry as dirty\\n', '    else if (state_q == STATE_WRITE || (state_q == STATE_LOOKUP && (|mem_wr_m_q)))\\n', '    begin\\n', \"        tag_data_in_m_r[CACHE_TAG_VALID_BIT] = 1'b1;\\n\", \"        tag_data_in_m_r[CACHE_TAG_DIRTY_BIT] = 1'b1;\\n\", '        tag_data_in_m_r[`CACHE_TAG_ADDR_RNG] = mem_addr_m_q[`DCACHE_TAG_CMP_ADDR_RNG];\\n', '    end\\n', 'end\\n', '\\n', '// Tag RAM write enable (way 0)\\n', 'reg tag0_write_m_r;\\n', 'always @ *\\n', 'begin\\n', \"    tag0_write_m_r = 1'b0;\\n\", '\\n', '    // Cache flush (reset)\\n', '    if (state_q == STATE_RESET)\\n', \"        tag0_write_m_r = 1'b1;\\n\", '    // Cache flush\\n', '    else if (state_q == STATE_FLUSH)\\n', '        tag0_write_m_r = !tag_dirty_any_m_w;\\n', '    // Write - hit, mark as dirty\\n', '    else if (state_q == STATE_LOOKUP && (|mem_wr_m_q))\\n', '        tag0_write_m_r = tag0_hit_m_w;\\n', '    // Write - write after refill\\n', '    else if (state_q == STATE_WRITE)\\n', '        tag0_write_m_r = (replace_way_q == 0);\\n', '    // Write - mark entry as dirty\\n', '    else if (state_q == STATE_EVICT_WAIT && pmem_ack_w)\\n', '        tag0_write_m_r = (replace_way_q == 0);\\n', '    // Line refill\\n', '    else if (state_q == STATE_REFILL)\\n', '        tag0_write_m_r = pmem_ack_w && pmem_last_w && (replace_way_q == 0);\\n', '    // Invalidate - line matches address - invalidate\\n', '    else if (state_q == STATE_INVALIDATE)\\n', '        tag0_write_m_r = tag0_hit_m_w;\\n', 'end\\n', '\\n', 'wire [CACHE_TAG_DATA_W-1:0] tag0_data_out_m_w;\\n', '\\n', 'dcache_core_tag_ram\\n', 'u_tag0\\n', '(\\n', '  .clk0_i(clk_i),\\n', '  .rst0_i(rst_i),\\n', '  .clk1_i(clk_i),\\n', '  .rst1_i(rst_i),\\n', '\\n', '  // Read\\n', '  .addr0_i(tag_addr_x_r),\\n', '  .data0_o(tag0_data_out_m_w),\\n', '\\n', '  // Write\\n', '  .addr1_i(tag_addr_m_r),\\n', '  .data1_i(tag_data_in_m_r),\\n', '  .wr1_i(tag0_write_m_r)\\n', ');\\n', '\\n', 'wire                           tag0_valid_m_w     = tag0_data_out_m_w[CACHE_TAG_VALID_BIT];\\n', 'wire                           tag0_dirty_m_w     = tag0_data_out_m_w[CACHE_TAG_DIRTY_BIT];\\n', 'wire [CACHE_TAG_ADDR_BITS-1:0] tag0_addr_bits_m_w = tag0_data_out_m_w[`CACHE_TAG_ADDR_RNG];\\n', '\\n', '// Tag hit?\\n', \"wire                           tag0_hit_m_w = tag0_valid_m_w ? (tag0_addr_bits_m_w == req_addr_tag_cmp_m_w) : 1'b0;\\n\", '\\n', '// Tag RAM write enable (way 1)\\n', 'reg tag1_write_m_r;\\n', 'always @ *\\n', 'begin\\n', \"    tag1_write_m_r = 1'b0;\\n\", '\\n', '    // Cache flush (reset)\\n', '    if (state_q == STATE_RESET)\\n', \"        tag1_write_m_r = 1'b1;\\n\", '    // Cache flush\\n', '    else if (state_q == STATE_FLUSH)\\n', '        tag1_write_m_r = !tag_dirty_any_m_w;\\n', '    // Write - hit, mark as dirty\\n', '    else if (state_q == STATE_LOOKUP && (|mem_wr_m_q))\\n', '        tag1_write_m_r = tag1_hit_m_w;\\n', '    // Write - write after refill\\n', '    else if (state_q == STATE_WRITE)\\n', '        tag1_write_m_r = (replace_way_q == 1);\\n', '    // Write - mark entry as dirty\\n', '    else if (state_q == STATE_EVICT_WAIT && pmem_ack_w)\\n', '        tag1_write_m_r = (replace_way_q == 1);\\n', '    // Line refill\\n', '    else if (state_q == STATE_REFILL)\\n', '        tag1_write_m_r = pmem_ack_w && pmem_last_w && (replace_way_q == 1);\\n', '    // Invalidate - line matches address - invalidate\\n', '    else if (state_q == STATE_INVALIDATE)\\n', '        tag1_write_m_r = tag1_hit_m_w;\\n', 'end\\n', '\\n', 'wire [CACHE_TAG_DATA_W-1:0] tag1_data_out_m_w;\\n', '\\n', 'dcache_core_tag_ram\\n', 'u_tag1\\n', '(\\n', '  .clk0_i(clk_i),\\n', '  .rst0_i(rst_i),\\n', '  .clk1_i(clk_i),\\n', '  .rst1_i(rst_i),\\n', '\\n', '  // Read\\n', '  .addr0_i(tag_addr_x_r),\\n', '  .data0_o(tag1_data_out_m_w),\\n', '\\n', '  // Write\\n', '  .addr1_i(tag_addr_m_r),\\n', '  .data1_i(tag_data_in_m_r),\\n', '  .wr1_i(tag1_write_m_r)\\n', ');\\n', '\\n', 'wire                           tag1_valid_m_w     = tag1_data_out_m_w[CACHE_TAG_VALID_BIT];\\n', 'wire                           tag1_dirty_m_w     = tag1_data_out_m_w[CACHE_TAG_DIRTY_BIT];\\n', 'wire [CACHE_TAG_ADDR_BITS-1:0] tag1_addr_bits_m_w = tag1_data_out_m_w[`CACHE_TAG_ADDR_RNG];\\n', '\\n', '// Tag hit?\\n', \"wire                           tag1_hit_m_w = tag1_valid_m_w ? (tag1_addr_bits_m_w == req_addr_tag_cmp_m_w) : 1'b0;\\n\", '\\n', '\\n', \"wire tag_hit_any_m_w = 1'b0\\n\", '                   | tag0_hit_m_w\\n', '                   | tag1_hit_m_w\\n', '                    ;\\n', '\\n', \"assign tag_hit_and_dirty_m_w = 1'b0\\n\", '                   | (tag0_hit_m_w & tag0_dirty_m_w)\\n', '                   | (tag1_hit_m_w & tag1_dirty_m_w)\\n', '                    ;\\n', '\\n', \"assign tag_dirty_any_m_w = 1'b0\\n\", '                   | (tag0_valid_m_w & tag0_dirty_m_w)\\n', '                   | (tag1_valid_m_w & tag1_dirty_m_w)\\n', '                    ;\\n', '\\n', 'localparam EVICT_ADDR_W = 32 - DCACHE_LINE_SIZE_W;\\n', 'reg        evict_way_r;\\n', 'reg [31:0] evict_data_r;\\n', 'reg [EVICT_ADDR_W-1:0] evict_addr_r;\\n', 'always @ *\\n', 'begin\\n', \"    evict_way_r  = 1'b0;\\n\", '    evict_addr_r = flushing_q ? {tag0_addr_bits_m_w, flush_addr_q} :\\n', '                                {tag0_addr_bits_m_w, mem_addr_m_q[`DCACHE_TAG_REQ_RNG]};\\n', '    evict_data_r = data0_data_out_m_w;\\n', '\\n', '    case (replace_way_q)\\n', \"        1'd0:\\n\", '        begin\\n', '            evict_way_r  = tag0_valid_m_w && tag0_dirty_m_w;\\n', '            evict_addr_r = flushing_q ? {tag0_addr_bits_m_w, flush_addr_q} :\\n', '                                        {tag0_addr_bits_m_w, mem_addr_m_q[`DCACHE_TAG_REQ_RNG]};\\n', '            evict_data_r = data0_data_out_m_w;\\n', '        end\\n', \"        1'd1:\\n\", '        begin\\n', '            evict_way_r  = tag1_valid_m_w && tag1_dirty_m_w;\\n', '            evict_addr_r = flushing_q ? {tag1_addr_bits_m_w, flush_addr_q} :\\n', '                                        {tag1_addr_bits_m_w, mem_addr_m_q[`DCACHE_TAG_REQ_RNG]};\\n', '            evict_data_r = data1_data_out_m_w;\\n', '        end\\n', '    endcase\\n', 'end\\n', 'assign                  evict_way_w  = (flushing_q || !tag_hit_any_m_w) && evict_way_r;\\n', 'wire [EVICT_ADDR_W-1:0] evict_addr_w = evict_addr_r;\\n', 'wire [31:0]             evict_data_w = evict_data_r;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// DATA RAMS\\n', '//-----------------------------------------------------------------\\n', '// Data addressing\\n', 'localparam CACHE_DATA_ADDR_W = DCACHE_LINE_ADDR_W+DCACHE_LINE_SIZE_W-2;\\n', '\\n', '\\n', 'reg [CACHE_DATA_ADDR_W-1:0] data_addr_x_r;\\n', 'reg [CACHE_DATA_ADDR_W-1:0] data_addr_m_r;\\n', 'reg [CACHE_DATA_ADDR_W-1:0] data_write_addr_q;\\n', '\\n', '// Data RAM refill write address\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    data_write_addr_q <= {(CACHE_DATA_ADDR_W){1'b0}};\\n\", 'else if (state_q != STATE_REFILL && next_state_r == STATE_REFILL)\\n', '    data_write_addr_q <= pmem_addr_w[CACHE_DATA_ADDR_W+2-1:2];\\n', 'else if (state_q != STATE_EVICT && next_state_r == STATE_EVICT)\\n', '    data_write_addr_q <= data_addr_m_r + 1;\\n', 'else if (state_q == STATE_REFILL && pmem_ack_w)\\n', '    data_write_addr_q <= data_write_addr_q + 1;\\n', 'else if (state_q == STATE_EVICT && pmem_accept_w)\\n', '    data_write_addr_q <= data_write_addr_q + 1;\\n', '\\n', '// Data RAM address\\n', 'always @ *\\n', 'begin\\n', '    data_addr_x_r = mem_addr_i[CACHE_DATA_ADDR_W+2-1:2];\\n', '    data_addr_m_r = mem_addr_m_q[CACHE_DATA_ADDR_W+2-1:2];\\n', '\\n', '    // Line refill / evict\\n', '    if (state_q == STATE_REFILL || state_q == STATE_EVICT)\\n', '    begin\\n', '        data_addr_x_r = data_write_addr_q;\\n', '        data_addr_m_r = data_addr_x_r;\\n', '    end\\n', '    else if (state_q == STATE_FLUSH || state_q == STATE_RESET)\\n', '    begin\\n', \"        data_addr_x_r = {flush_addr_q, {(DCACHE_LINE_SIZE_W-2){1'b0}}};\\n\", '        data_addr_m_r = data_addr_x_r;\\n', '    end\\n', '    else if (state_q != STATE_EVICT && next_state_r == STATE_EVICT)\\n', '    begin\\n', \"        data_addr_x_r = {mem_addr_m_q[`DCACHE_TAG_REQ_RNG], {(DCACHE_LINE_SIZE_W-2){1'b0}}};\\n\", '        data_addr_m_r = data_addr_x_r;\\n', '    end\\n', '    // Lookup post refill\\n', '    else if (state_q == STATE_READ)\\n', '    begin\\n', '        data_addr_x_r = mem_addr_m_q[CACHE_DATA_ADDR_W+2-1:2];\\n', '    end\\n', '    // Possible line update on write\\n', '    else\\n', '        data_addr_m_r = mem_addr_m_q[CACHE_DATA_ADDR_W+2-1:2];\\n', 'end\\n', '\\n', '\\n', '// Data RAM write enable (way 0)\\n', 'reg [3:0] data0_write_m_r;\\n', 'always @ *\\n', 'begin\\n', \"    data0_write_m_r = 4'b0;\\n\", '\\n', '    if (state_q == STATE_REFILL)\\n', \"        data0_write_m_r = (pmem_ack_w && replace_way_q == 0) ? 4'b1111 : 4'b0000;\\n\", '    else if (state_q == STATE_WRITE || state_q == STATE_LOOKUP)\\n', '        data0_write_m_r = mem_wr_m_q & {4{tag0_hit_m_w}};\\n', 'end\\n', '\\n', 'wire [31:0] data0_data_out_m_w;\\n', 'wire [31:0] data0_data_in_m_w = (state_q == STATE_REFILL) ? pmem_read_data_w : mem_data_m_q;\\n', '\\n', 'dcache_core_data_ram\\n', 'u_data0\\n', '(\\n', '  .clk0_i(clk_i),\\n', '  .rst0_i(rst_i),\\n', '  .clk1_i(clk_i),\\n', '  .rst1_i(rst_i),\\n', '\\n', '  // Read\\n', '  .addr0_i(data_addr_x_r),\\n', \"  .data0_i(32'b0),\\n\", \"  .wr0_i(4'b0),\\n\", '  .data0_o(data0_data_out_m_w),\\n', '\\n', '  // Write\\n', '  .addr1_i(data_addr_m_r),\\n', '  .data1_i(data0_data_in_m_w),\\n', '  .wr1_i(data0_write_m_r),\\n', '  .data1_o()\\n', ');\\n', '\\n', '\\n', '// Data RAM write enable (way 1)\\n', 'reg [3:0] data1_write_m_r;\\n', 'always @ *\\n', 'begin\\n', \"    data1_write_m_r = 4'b0;\\n\", '\\n', '    if (state_q == STATE_REFILL)\\n', \"        data1_write_m_r = (pmem_ack_w && replace_way_q == 1) ? 4'b1111 : 4'b0000;\\n\", '    else if (state_q == STATE_WRITE || state_q == STATE_LOOKUP)\\n', '        data1_write_m_r = mem_wr_m_q & {4{tag1_hit_m_w}};\\n', 'end\\n', '\\n', 'wire [31:0] data1_data_out_m_w;\\n', 'wire [31:0] data1_data_in_m_w = (state_q == STATE_REFILL) ? pmem_read_data_w : mem_data_m_q;\\n', '\\n', 'dcache_core_data_ram\\n', 'u_data1\\n', '(\\n', '  .clk0_i(clk_i),\\n', '  .rst0_i(rst_i),\\n', '  .clk1_i(clk_i),\\n', '  .rst1_i(rst_i),\\n', '\\n', '  // Read\\n', '  .addr0_i(data_addr_x_r),\\n', \"  .data0_i(32'b0),\\n\", \"  .wr0_i(4'b0),\\n\", '  .data0_o(data1_data_out_m_w),\\n', '\\n', '  // Write\\n', '  .addr1_i(data_addr_m_r),\\n', '  .data1_i(data1_data_in_m_w),\\n', '  .wr1_i(data1_write_m_r),\\n', '  .data1_o()\\n', ');\\n', '\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Flush counter\\n', '//-----------------------------------------------------------------\\n', 'reg [DCACHE_TAG_REQ_LINE_W-1:0] flush_addr_q;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    flush_addr_q <= {(DCACHE_TAG_REQ_LINE_W){1'b0}};\\n\", 'else if ((state_q == STATE_RESET) || (state_q == STATE_FLUSH && next_state_r == STATE_FLUSH_ADDR))\\n', '    flush_addr_q <= flush_addr_q + 1;\\n', 'else if (state_q == STATE_LOOKUP)\\n', \"    flush_addr_q <= {(DCACHE_TAG_REQ_LINE_W){1'b0}};\\n\", '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    flushing_q <= 1'b0;\\n\", 'else if (state_q == STATE_LOOKUP && next_state_r == STATE_FLUSH_ADDR)\\n', \"    flushing_q <= 1'b1;\\n\", 'else if (state_q == STATE_FLUSH && next_state_r == STATE_LOOKUP)\\n', \"    flushing_q <= 1'b0;\\n\", '\\n', 'reg flush_last_q;\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    flush_last_q <= 1'b0;\\n\", 'else if (state_q == STATE_LOOKUP)\\n', \"    flush_last_q <= 1'b0;\\n\", \"else if (flush_addr_q == {(DCACHE_TAG_REQ_LINE_W){1'b1}})\\n\", \"    flush_last_q <= 1'b1;\\n\", '\\n', '//-----------------------------------------------------------------\\n', '// Replacement Policy\\n', '//----------------------------------------------------------------- \\n', '// Using random replacement policy - this way we cycle through the ways\\n', '// when needing to replace a line.\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', '    replace_way_q <= 0;\\n', 'else if (state_q == STATE_WRITE || state_q == STATE_READ)\\n', '    replace_way_q <= replace_way_q + 1;\\n', 'else if (flushing_q && tag_dirty_any_m_w && !evict_way_w && state_q != STATE_FLUSH_ADDR)\\n', '    replace_way_q <= replace_way_q + 1;\\n', 'else if (state_q == STATE_EVICT_WAIT && next_state_r == STATE_FLUSH_ADDR)\\n', '    replace_way_q <= 0;\\n', 'else if (state_q == STATE_FLUSH && next_state_r == STATE_LOOKUP)\\n', '    replace_way_q <= 0;\\n', 'else if (state_q == STATE_LOOKUP && next_state_r == STATE_FLUSH_ADDR)\\n', '    replace_way_q <= 0;\\n', 'else if (state_q == STATE_WRITEBACK)\\n', 'begin\\n', \"    case (1'b1)\\n\", '    tag0_hit_m_w: replace_way_q <= 0;\\n', '    tag1_hit_m_w: replace_way_q <= 1;\\n', '    endcase\\n', 'end\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Output Result\\n', '//-----------------------------------------------------------------\\n', '// Data output mux\\n', 'reg [31:0] data_r;\\n', 'always @ *\\n', 'begin\\n', '    data_r = data0_data_out_m_w;\\n', '\\n', \"    case (1'b1)\\n\", '    tag0_hit_m_w: data_r = data0_data_out_m_w;\\n', '    tag1_hit_m_w: data_r = data1_data_out_m_w;\\n', '    endcase\\n', 'end\\n', '\\n', 'assign mem_data_rd_o  = data_r;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Next State Logic\\n', '//-----------------------------------------------------------------\\n', 'always @ *\\n', 'begin\\n', '    next_state_r = state_q;\\n', '\\n', '    case (state_q)\\n', '    //-----------------------------------------\\n', '    // STATE_RESET\\n', '    //-----------------------------------------\\n', '    STATE_RESET :\\n', '    begin\\n', '        // Final line checked\\n', '        if (flush_last_q)\\n', '            next_state_r = STATE_LOOKUP;\\n', '    end\\n', '    //-----------------------------------------\\n', '    // STATE_FLUSH_ADDR\\n', '    //-----------------------------------------\\n', '    STATE_FLUSH_ADDR : next_state_r = STATE_FLUSH;\\n', '    //-----------------------------------------\\n', '    // STATE_FLUSH\\n', '    //-----------------------------------------\\n', '    STATE_FLUSH :\\n', '    begin\\n', '        // Dirty line detected - evict unless initial cache reset cycle\\n', '        if (tag_dirty_any_m_w)\\n', '        begin\\n', '            // Evict dirty line - else wait for dirty way to be selected\\n', '            if (evict_way_w)\\n', '                next_state_r = STATE_EVICT;\\n', '        end\\n', '        // Final line checked, nothing dirty\\n', '        else if (flush_last_q)\\n', '            next_state_r = STATE_LOOKUP;\\n', '        else\\n', '            next_state_r = STATE_FLUSH_ADDR;\\n', '    end\\n', '    //-----------------------------------------\\n', '    // STATE_LOOKUP\\n', '    //-----------------------------------------\\n', '    STATE_LOOKUP :\\n', '    begin\\n', '        // Previous access missed in the cache\\n', \"        if ((mem_rd_m_q || (mem_wr_m_q != 4'b0)) && !tag_hit_any_m_w)\\n\", '        begin\\n', '            // Evict dirty line first\\n', '            if (evict_way_w)\\n', '                next_state_r = STATE_EVICT;\\n', '            // Allocate line and fill\\n', '            else\\n', '                next_state_r = STATE_REFILL;\\n', '        end\\n', '        // Writeback a single line\\n', '        else if (mem_writeback_i && mem_accept_o)\\n', '            next_state_r = STATE_WRITEBACK;\\n', '        // Flush whole cache\\n', '        else if (mem_flush_i && mem_accept_o)\\n', '            next_state_r = STATE_FLUSH_ADDR;\\n', '        // Invalidate line (even if dirty)\\n', '        else if (mem_invalidate_i && mem_accept_o)\\n', '            next_state_r = STATE_INVALIDATE;\\n', '    end\\n', '    //-----------------------------------------\\n', '    // STATE_REFILL\\n', '    //-----------------------------------------\\n', '    STATE_REFILL :\\n', '    begin\\n', '        // End of refill\\n', '        if (pmem_ack_w && pmem_last_w)\\n', '        begin\\n', '            // Refill reason was write\\n', \"            if (mem_wr_m_q != 4'b0)\\n\", '                next_state_r = STATE_WRITE;\\n', '            // Refill reason was read\\n', '            else\\n', '                next_state_r = STATE_READ;\\n', '        end\\n', '    end\\n', '    //-----------------------------------------\\n', '    // STATE_WRITE/READ\\n', '    //-----------------------------------------\\n', '    STATE_WRITE, STATE_READ :\\n', '    begin\\n', '        next_state_r = STATE_LOOKUP;\\n', '    end\\n', '    //-----------------------------------------\\n', '    // STATE_EVICT\\n', '    //-----------------------------------------\\n', '    STATE_EVICT :\\n', '    begin\\n', '        // End of evict, wait for write completion\\n', '        if (pmem_accept_w && pmem_last_w)\\n', '            next_state_r = STATE_EVICT_WAIT;\\n', '    end\\n', '    //-----------------------------------------\\n', '    // STATE_EVICT_WAIT\\n', '    //-----------------------------------------\\n', '    STATE_EVICT_WAIT :\\n', '    begin\\n', '        // Single line writeback\\n', '        if (pmem_ack_w && mem_writeback_m_q)\\n', '            next_state_r = STATE_LOOKUP;\\n', '        // Evict due to flush\\n', '        else if (pmem_ack_w && flushing_q)\\n', '            next_state_r = STATE_FLUSH_ADDR;\\n', '        // Write ack, start re-fill now\\n', '        else if (pmem_ack_w)\\n', '            next_state_r = STATE_REFILL;\\n', '    end\\n', '    //-----------------------------------------\\n', '    // STATE_WRITEBACK: Writeback a cache line\\n', '    //-----------------------------------------\\n', '    STATE_WRITEBACK:\\n', '    begin\\n', '        // Line is dirty - write back to memory\\n', '        if (tag_hit_and_dirty_m_w)\\n', '            next_state_r = STATE_EVICT;\\n', '        // Line not dirty, carry on\\n', '        else\\n', '            next_state_r = STATE_LOOKUP;\\n', '    end\\n', '    //-----------------------------------------\\n', '    // STATE_INVALIDATE: Invalidate a cache line\\n', '    //-----------------------------------------\\n', '    STATE_INVALIDATE:\\n', '    begin\\n', '        next_state_r = STATE_LOOKUP;\\n', '    end\\n', '    default:\\n', '        ;\\n', '   endcase\\n', 'end\\n', '\\n', '// Update state\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', '    state_q   <= STATE_RESET;\\n', 'else\\n', '    state_q   <= next_state_r;\\n', '\\n', 'reg mem_ack_r;\\n', '\\n', 'always @ *\\n', 'begin\\n', \"    mem_ack_r = 1'b0;\\n\", '\\n', '    if (state_q == STATE_LOOKUP)\\n', '    begin\\n', '        // Normal hit - read or write\\n', \"        if ((mem_rd_m_q || (mem_wr_m_q != 4'b0)) && tag_hit_any_m_w)\\n\", \"            mem_ack_r = 1'b1;\\n\", '        // Flush, invalidate or writeback\\n', '        else if (mem_flush_m_q || mem_inval_m_q || mem_writeback_m_q)\\n', \"            mem_ack_r = 1'b1;\\n\", '    end\\n', 'end\\n', '\\n', 'assign mem_ack_o = mem_ack_r;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// AXI Request\\n', '//-----------------------------------------------------------------\\n', 'reg pmem_rd_q;\\n', 'reg pmem_wr0_q;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    pmem_rd_q   <= 1'b0;\\n\", 'else if (pmem_rd_w)\\n', '    pmem_rd_q   <= ~pmem_accept_w;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    pmem_wr0_q   <= 1'b0;\\n\", 'else if (state_q != STATE_EVICT && next_state_r == STATE_EVICT)\\n', \"    pmem_wr0_q   <= 1'b1;\\n\", 'else if (pmem_accept_w)\\n', \"    pmem_wr0_q   <= 1'b0;\\n\", '\\n', 'reg [7:0] pmem_len_q;\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    pmem_len_q   <= 8'b0;\\n\", 'else if (state_q != STATE_EVICT && next_state_r == STATE_EVICT)\\n', \"    pmem_len_q   <= 8'd7;\\n\", 'else if (pmem_rd_w && pmem_accept_w)\\n', '    pmem_len_q   <= pmem_len_w;\\n', 'else if (state_q == STATE_REFILL && pmem_ack_w)\\n', \"    pmem_len_q   <= pmem_len_q - 8'd1;\\n\", 'else if (state_q == STATE_EVICT && pmem_accept_w)\\n', \"    pmem_len_q   <= pmem_len_q - 8'd1;\\n\", '\\n', \"assign pmem_last_w = (pmem_len_q == 8'd0);\\n\", '\\n', 'reg [31:0] pmem_addr_q;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    pmem_addr_q   <= 32'b0;\\n\", 'else if (|pmem_len_w && pmem_accept_w)\\n', \"    pmem_addr_q   <= pmem_addr_w + 32'd4;\\n\", 'else if (pmem_accept_w)\\n', \"    pmem_addr_q   <= pmem_addr_q + 32'd4;\\n\", '\\n', '//-----------------------------------------------------------------\\n', '// Skid buffer for write data\\n', '//-----------------------------------------------------------------\\n', 'reg [3:0]  pmem_wr_q;\\n', 'reg [31:0] pmem_write_data_q;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    pmem_wr_q <= 4'b0;\\n\", 'else if ((|pmem_wr_w) && !pmem_accept_w)\\n', '    pmem_wr_q <= pmem_wr_w;\\n', 'else if (pmem_accept_w)\\n', \"    pmem_wr_q <= 4'b0;\\n\", '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    pmem_write_data_q <= 32'b0;\\n\", 'else if (!pmem_accept_w)\\n', '    pmem_write_data_q <= pmem_write_data_w;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// AXI Error Handling\\n', '//-----------------------------------------------------------------\\n', 'reg error_q;\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    error_q   <= 1'b0;\\n\", 'else if (pmem_ack_w && pmem_error_w)\\n', \"    error_q   <= 1'b1;\\n\", 'else if (mem_ack_o)\\n', \"    error_q   <= 1'b0;\\n\", '\\n', 'assign mem_error_o = error_q;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Outport\\n', '//-----------------------------------------------------------------\\n', 'wire refill_request_w   = (state_q != STATE_REFILL && next_state_r == STATE_REFILL);\\n', 'wire evict_request_w    = (state_q == STATE_EVICT) && (evict_way_w || mem_writeback_m_q);\\n', '\\n', '// AXI Read channel\\n', 'assign pmem_rd_w         = (refill_request_w || pmem_rd_q);\\n', \"assign pmem_wr_w         = (evict_request_w || (|pmem_wr_q)) ? 4'hF : 4'b0;\\n\", 'assign pmem_addr_w       = (|pmem_len_w) ? \\n', \"                           pmem_rd_w ? {mem_addr_m_q[31:DCACHE_LINE_SIZE_W], {(DCACHE_LINE_SIZE_W){1'b0}}} :\\n\", \"                           {evict_addr_w, {(DCACHE_LINE_SIZE_W){1'b0}}} :\\n\", '                           pmem_addr_q;\\n', '\\n', \"assign pmem_len_w        = (refill_request_w || pmem_rd_q || (state_q == STATE_EVICT && pmem_wr0_q)) ? 8'd7 : 8'd0;\\n\", 'assign pmem_write_data_w = (|pmem_wr_q) ? pmem_write_data_q : evict_data_w;\\n', '\\n', 'assign outport_wr_o         = pmem_wr_w;\\n', 'assign outport_rd_o         = pmem_rd_w;\\n', 'assign outport_len_o        = pmem_len_w;\\n', 'assign outport_addr_o       = pmem_addr_w;\\n', 'assign outport_write_data_o = pmem_write_data_w;\\n', '\\n', 'assign pmem_accept_w        = outport_accept_i;\\n', 'assign pmem_ack_w           = outport_ack_i;\\n', 'assign pmem_error_w         = outport_error_i;\\n', 'assign pmem_read_data_w     = outport_read_data_i;\\n', '\\n', '//-------------------------------------------------------------------\\n', '// Debug\\n', '//-------------------------------------------------------------------\\n', '`ifdef verilator\\n', '/* verilator lint_off WIDTH */\\n', 'reg [79:0] dbg_state;\\n', 'always @ *\\n', 'begin\\n', '    dbg_state = \"-\";\\n', '\\n', '    case (state_q)\\n', '    STATE_RESET:\\n', '        dbg_state = \"RESET\";\\n', '    STATE_FLUSH_ADDR:\\n', '        dbg_state = \"FLUSH_ADDR\";\\n', '    STATE_FLUSH:\\n', '        dbg_state = \"FLUSH\";\\n', '    STATE_LOOKUP:\\n', '        dbg_state = \"LOOKUP\";\\n', '    STATE_READ:\\n', '        dbg_state = \"READ\";\\n', '    STATE_WRITE:\\n', '        dbg_state = \"WRITE\";\\n', '    STATE_REFILL:\\n', '        dbg_state = \"REFILL\";\\n', '    STATE_EVICT:\\n', '        dbg_state = \"EVICT\";\\n', '    STATE_EVICT_WAIT:\\n', '        dbg_state = \"EVICT_WAIT\";\\n', '    STATE_INVALIDATE:\\n', '        dbg_state = \"INVAL\";\\n', '    STATE_WRITEBACK:\\n', '        dbg_state = \"WRITEBACK\";\\n', '    default:\\n', '        ;\\n', '    endcase\\n', 'end\\n', '/* verilator lint_on WIDTH */\\n', '`endif\\n', '\\n', '\\n', 'endmodule\\n']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.6.0\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', '\\n', 'module dcache_core_data_ram\\n', '(\\n', '    // Inputs\\n', '     input           clk0_i\\n', '    ,input           rst0_i\\n', '    ,input  [ 10:0]  addr0_i\\n', '    ,input  [ 31:0]  data0_i\\n', '    ,input  [  3:0]  wr0_i\\n', '    ,input           clk1_i\\n', '    ,input           rst1_i\\n', '    ,input  [ 10:0]  addr1_i\\n', '    ,input  [ 31:0]  data1_i\\n', '    ,input  [  3:0]  wr1_i\\n', '\\n', '    // Outputs\\n', '    ,output [ 31:0]  data0_o\\n', '    ,output [ 31:0]  data1_o\\n', ');\\n', '\\n', '\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Dual Port RAM 8KB\\n', '// Mode: Read First\\n', '//-----------------------------------------------------------------\\n', '/* verilator lint_off MULTIDRIVEN */\\n', 'reg [31:0]   ram [2047:0] /*verilator public*/;\\n', '/* verilator lint_on MULTIDRIVEN */\\n', '\\n', 'reg [31:0] ram_read0_q;\\n', 'reg [31:0] ram_read1_q;\\n', '\\n', '\\n', '// Synchronous write\\n', 'always @ (posedge clk0_i)\\n', 'begin\\n', '    if (wr0_i[0])\\n', '        ram[addr0_i][7:0] <= data0_i[7:0];\\n', '    if (wr0_i[1])\\n', '        ram[addr0_i][15:8] <= data0_i[15:8];\\n', '    if (wr0_i[2])\\n', '        ram[addr0_i][23:16] <= data0_i[23:16];\\n', '    if (wr0_i[3])\\n', '        ram[addr0_i][31:24] <= data0_i[31:24];\\n', '\\n', '    ram_read0_q <= ram[addr0_i];\\n', 'end\\n', '\\n', 'always @ (posedge clk1_i)\\n', 'begin\\n', '    if (wr1_i[0])\\n', '        ram[addr1_i][7:0] <= data1_i[7:0];\\n', '    if (wr1_i[1])\\n', '        ram[addr1_i][15:8] <= data1_i[15:8];\\n', '    if (wr1_i[2])\\n', '        ram[addr1_i][23:16] <= data1_i[23:16];\\n', '    if (wr1_i[3])\\n', '        ram[addr1_i][31:24] <= data1_i[31:24];\\n', '\\n', '    ram_read1_q <= ram[addr1_i];\\n', 'end\\n', '\\n', 'assign data0_o = ram_read0_q;\\n', 'assign data1_o = ram_read1_q;\\n', '\\n', '\\n', '\\n', 'endmodule\\n']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.6.0\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', '\\n', 'module dcache_core_tag_ram\\n', '(\\n', '    // Inputs\\n', '     input           clk0_i\\n', '    ,input           rst0_i\\n', '    ,input  [  7:0]  addr0_i\\n', '    ,input           clk1_i\\n', '    ,input           rst1_i\\n', '    ,input  [  7:0]  addr1_i\\n', '    ,input  [ 20:0]  data1_i\\n', '    ,input           wr1_i\\n', '\\n', '    // Outputs\\n', '    ,output [ 20:0]  data0_o\\n', ');\\n', '\\n', '\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Tag RAM 0KB (256 x 21)\\n', '// Mode: Write First\\n', '//-----------------------------------------------------------------\\n', '/* verilator lint_off MULTIDRIVEN */\\n', 'reg [20:0]   ram [255:0] /*verilator public*/;\\n', '/* verilator lint_on MULTIDRIVEN */\\n', '\\n', 'reg [20:0] ram_read0_q;\\n', '\\n', 'always @ (posedge clk1_i)\\n', 'begin\\n', '    if (wr1_i)\\n', '        ram[addr1_i] = data1_i;\\n', '\\n', '    ram_read0_q = ram[addr0_i];\\n', 'end\\n', '\\n', 'assign data0_o = ram_read0_q;\\n', '\\n', '\\n', 'endmodule\\n']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.6.0\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', '\\n', 'module dcache_if_pmem\\n', '(\\n', '    // Inputs\\n', '     input           clk_i\\n', '    ,input           rst_i\\n', '    ,input  [ 31:0]  mem_addr_i\\n', '    ,input  [ 31:0]  mem_data_wr_i\\n', '    ,input           mem_rd_i\\n', '    ,input  [  3:0]  mem_wr_i\\n', '    ,input           mem_cacheable_i\\n', '    ,input  [ 10:0]  mem_req_tag_i\\n', '    ,input           mem_invalidate_i\\n', '    ,input           mem_writeback_i\\n', '    ,input           mem_flush_i\\n', '    ,input           outport_accept_i\\n', '    ,input           outport_ack_i\\n', '    ,input           outport_error_i\\n', '    ,input  [ 31:0]  outport_read_data_i\\n', '\\n', '    // Outputs\\n', '    ,output [ 31:0]  mem_data_rd_o\\n', '    ,output          mem_accept_o\\n', '    ,output          mem_ack_o\\n', '    ,output          mem_error_o\\n', '    ,output [ 10:0]  mem_resp_tag_o\\n', '    ,output [  3:0]  outport_wr_o\\n', '    ,output          outport_rd_o\\n', '    ,output [  7:0]  outport_len_o\\n', '    ,output [ 31:0]  outport_addr_o\\n', '    ,output [ 31:0]  outport_write_data_o\\n', ');\\n', '\\n', '\\n', '\\n', '\\n', '\\n', '//-------------------------------------------------------------\\n', '// Description:\\n', '// Bridges between dcache_if -> AXI4/AXI4-Lite.\\n', '// Allows 1 outstanding transaction, but can buffer upto \\n', '// REQUEST_BUFFER dcache_if requests before back-pressuring.\\n', '//-------------------------------------------------------------\\n', '\\n', '//-------------------------------------------------------------\\n', '// Request FIFO\\n', '//-------------------------------------------------------------\\n', '// Accepts from both FIFOs\\n', 'wire          res_accept_w;\\n', 'wire          req_accept_w;\\n', '\\n', '// Output accept\\n', 'wire          request_complete_w;\\n', '\\n', 'wire          req_pop_w   = request_complete_w;\\n', 'wire          req_valid_w;\\n', 'wire [70-1:0] req_w;\\n', '\\n', '// Cache requests are dropped\\n', '// NOTE: Should not actually end up here if configured correctly.\\n', 'wire          drop_req_w   = mem_invalidate_i || mem_writeback_i || mem_flush_i;\\n', \"wire          request_w    = drop_req_w || mem_rd_i || mem_wr_i != 4'b0;\\n\", '\\n', '// Push on transaction and other FIFO not full\\n', 'wire          req_push_w   = request_w && res_accept_w;\\n', '\\n', 'dcache_if_pmem_fifo\\n', '#( \\n', '    .WIDTH(32+32+4+1+1),\\n', '    .DEPTH(2),\\n', '    .ADDR_W(1)\\n', ')\\n', 'u_req\\n', '(\\n', '    .clk_i(clk_i),\\n', '    .rst_i(rst_i),\\n', '\\n', '    // Input side\\n', '    .data_in_i({drop_req_w, mem_rd_i, mem_wr_i, mem_data_wr_i, mem_addr_i}),\\n', '    .push_i(req_push_w),\\n', '    .accept_o(req_accept_w),\\n', '\\n', '    // Outputs\\n', '    .valid_o(req_valid_w),\\n', '    .data_out_o(req_w),\\n', '    .pop_i(req_pop_w)\\n', ');\\n', '\\n', 'assign mem_accept_o = req_accept_w & res_accept_w;\\n', '\\n', '//-------------------------------------------------------------\\n', '// Response Tracking FIFO\\n', '//-------------------------------------------------------------\\n', '// Push on transaction and other FIFO not full\\n', 'wire res_push_w = request_w && req_accept_w;\\n', '\\n', 'dcache_if_pmem_fifo\\n', '#( \\n', '    .WIDTH(11),\\n', '    .DEPTH(2),\\n', '    .ADDR_W(1)\\n', ')\\n', 'u_resp\\n', '(\\n', '    .clk_i(clk_i),\\n', '    .rst_i(rst_i),\\n', '\\n', '    // Input side\\n', '    .data_in_i(mem_req_tag_i),\\n', '    .push_i(res_push_w),\\n', '    .accept_o(res_accept_w),\\n', '\\n', '    // Outputs\\n', '    .valid_o(), // UNUSED\\n', '    .data_out_o(mem_resp_tag_o),\\n', '    .pop_i(mem_ack_o)\\n', ');\\n', '\\n', '//-------------------------------------------------------------\\n', '// Request\\n', '//-------------------------------------------------------------\\n', 'reg  request_pending_q;\\n', 'wire request_in_progress_w  = request_pending_q & !mem_ack_o;\\n', '\\n', \"wire req_is_read_w          = ((req_valid_w & !request_in_progress_w) ? req_w[68] : 1'b0);\\n\", \"wire req_is_write_w         = ((req_valid_w & !request_in_progress_w) ? ~req_w[68] : 1'b0);\\n\", \"wire req_is_drop_w          = ((req_valid_w & !request_in_progress_w) ? req_w[69] : 1'b0);\\n\", '\\n', \"assign outport_wr_o         = req_is_write_w ? req_w[67:64] : 4'b0;\\n\", 'assign outport_rd_o         = req_is_read_w;\\n', \"assign outport_len_o        = 8'd0;\\n\", \"assign outport_addr_o       = {req_w[31:2], 2'b0};\\n\", 'assign outport_write_data_o = req_w[63:32];\\n', '\\n', \"assign request_complete_w   = req_is_drop_w || ((outport_rd_o || outport_wr_o != 4'b0) && outport_accept_i);\\n\", '\\n', '// Outstanding Request Tracking\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    request_pending_q <= 1'b0;\\n\", 'else if (request_complete_w)\\n', \"    request_pending_q <= 1'b1;\\n\", 'else if (mem_ack_o)\\n', \"    request_pending_q <= 1'b0;\\n\", '\\n', '//-------------------------------------------------------------\\n', '// Response\\n', '//-------------------------------------------------------------\\n', 'reg dropped_q;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    dropped_q <= 1'b0;\\n\", 'else if (req_is_drop_w)\\n', \"    dropped_q <= 1'b1;\\n\", 'else\\n', \"    dropped_q <= 1'b0;\\n\", '\\n', 'assign mem_ack_o     = dropped_q || outport_ack_i;\\n', 'assign mem_data_rd_o = outport_read_data_i;\\n', 'assign mem_error_o   = outport_error_i;\\n', '\\n', '\\n', 'endmodule\\n', '\\n', 'module dcache_if_pmem_fifo\\n', '//-----------------------------------------------------------------\\n', '// Params\\n', '//-----------------------------------------------------------------\\n', '#(\\n', '    parameter WIDTH   = 8,\\n', '    parameter DEPTH   = 4,\\n', '    parameter ADDR_W  = 2\\n', ')\\n', '//-----------------------------------------------------------------\\n', '// Ports\\n', '//-----------------------------------------------------------------\\n', '(\\n', '    // Inputs\\n', '     input               clk_i\\n', '    ,input               rst_i\\n', '    ,input  [WIDTH-1:0]  data_in_i\\n', '    ,input               push_i\\n', '    ,input               pop_i\\n', '\\n', '    // Outputs\\n', '    ,output [WIDTH-1:0]  data_out_o\\n', '    ,output              accept_o\\n', '    ,output              valid_o\\n', ');\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Local Params\\n', '//-----------------------------------------------------------------\\n', 'localparam COUNT_W = ADDR_W + 1;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Registers\\n', '//-----------------------------------------------------------------\\n', 'reg [WIDTH-1:0]   ram_q[DEPTH-1:0];\\n', 'reg [ADDR_W-1:0]  rd_ptr_q;\\n', 'reg [ADDR_W-1:0]  wr_ptr_q;\\n', 'reg [COUNT_W-1:0] count_q;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Sequential\\n', '//-----------------------------------------------------------------\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', 'begin\\n', \"    count_q   <= {(COUNT_W) {1'b0}};\\n\", \"    rd_ptr_q  <= {(ADDR_W) {1'b0}};\\n\", \"    wr_ptr_q  <= {(ADDR_W) {1'b0}};\\n\", 'end\\n', 'else\\n', 'begin\\n', '    // Push\\n', '    if (push_i & accept_o)\\n', '    begin\\n', '        ram_q[wr_ptr_q] <= data_in_i;\\n', '        wr_ptr_q        <= wr_ptr_q + 1;\\n', '    end\\n', '\\n', '    // Pop\\n', '    if (pop_i & valid_o)\\n', '        rd_ptr_q      <= rd_ptr_q + 1;\\n', '\\n', '    // Count up\\n', '    if ((push_i & accept_o) & ~(pop_i & valid_o))\\n', '        count_q <= count_q + 1;\\n', '    // Count down\\n', '    else if (~(push_i & accept_o) & (pop_i & valid_o))\\n', '        count_q <= count_q - 1;\\n', 'end\\n', '\\n', '//-------------------------------------------------------------------\\n', '// Combinatorial\\n', '//-------------------------------------------------------------------\\n', '/* verilator lint_off WIDTH */\\n', 'assign valid_o       = (count_q != 0);\\n', 'assign accept_o      = (count_q != DEPTH);\\n', '/* verilator lint_on WIDTH */\\n', '\\n', 'assign data_out_o    = ram_q[rd_ptr_q];\\n', '\\n', '\\n', '\\n', 'endmodule\\n']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.6.0\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', '\\n', 'module dcache_mux\\n', '(\\n', '    // Inputs\\n', '     input           clk_i\\n', '    ,input           rst_i\\n', '    ,input  [ 31:0]  mem_addr_i\\n', '    ,input  [ 31:0]  mem_data_wr_i\\n', '    ,input           mem_rd_i\\n', '    ,input  [  3:0]  mem_wr_i\\n', '    ,input           mem_cacheable_i\\n', '    ,input  [ 10:0]  mem_req_tag_i\\n', '    ,input           mem_invalidate_i\\n', '    ,input           mem_writeback_i\\n', '    ,input           mem_flush_i\\n', '    ,input  [ 31:0]  mem_cached_data_rd_i\\n', '    ,input           mem_cached_accept_i\\n', '    ,input           mem_cached_ack_i\\n', '    ,input           mem_cached_error_i\\n', '    ,input  [ 10:0]  mem_cached_resp_tag_i\\n', '    ,input  [ 31:0]  mem_uncached_data_rd_i\\n', '    ,input           mem_uncached_accept_i\\n', '    ,input           mem_uncached_ack_i\\n', '    ,input           mem_uncached_error_i\\n', '    ,input  [ 10:0]  mem_uncached_resp_tag_i\\n', '\\n', '    // Outputs\\n', '    ,output [ 31:0]  mem_data_rd_o\\n', '    ,output          mem_accept_o\\n', '    ,output          mem_ack_o\\n', '    ,output          mem_error_o\\n', '    ,output [ 10:0]  mem_resp_tag_o\\n', '    ,output [ 31:0]  mem_cached_addr_o\\n', '    ,output [ 31:0]  mem_cached_data_wr_o\\n', '    ,output          mem_cached_rd_o\\n', '    ,output [  3:0]  mem_cached_wr_o\\n', '    ,output          mem_cached_cacheable_o\\n', '    ,output [ 10:0]  mem_cached_req_tag_o\\n', '    ,output          mem_cached_invalidate_o\\n', '    ,output          mem_cached_writeback_o\\n', '    ,output          mem_cached_flush_o\\n', '    ,output [ 31:0]  mem_uncached_addr_o\\n', '    ,output [ 31:0]  mem_uncached_data_wr_o\\n', '    ,output          mem_uncached_rd_o\\n', '    ,output [  3:0]  mem_uncached_wr_o\\n', '    ,output          mem_uncached_cacheable_o\\n', '    ,output [ 10:0]  mem_uncached_req_tag_o\\n', '    ,output          mem_uncached_invalidate_o\\n', '    ,output          mem_uncached_writeback_o\\n', '    ,output          mem_uncached_flush_o\\n', '    ,output          cache_active_o\\n', ');\\n', '\\n', '\\n', '\\n', 'wire hold_w;\\n', 'reg  cache_access_q;\\n', '\\n', 'assign mem_cached_addr_o         = mem_addr_i;\\n', 'assign mem_cached_data_wr_o      = mem_data_wr_i;\\n', \"assign mem_cached_rd_o           = (mem_cacheable_i & ~hold_w) ? mem_rd_i : 1'b0;\\n\", \"assign mem_cached_wr_o           = (mem_cacheable_i & ~hold_w) ? mem_wr_i : 4'b0;\\n\", 'assign mem_cached_cacheable_o    = mem_cacheable_i;\\n', 'assign mem_cached_req_tag_o      = mem_req_tag_i;\\n', \"assign mem_cached_invalidate_o   = (mem_cacheable_i & ~hold_w) ? mem_invalidate_i : 1'b0;\\n\", \"assign mem_cached_writeback_o    = (mem_cacheable_i & ~hold_w) ? mem_writeback_i : 1'b0;\\n\", \"assign mem_cached_flush_o        = (mem_cacheable_i & ~hold_w) ? mem_flush_i : 1'b0;\\n\", '\\n', 'assign mem_uncached_addr_o       = mem_addr_i;\\n', 'assign mem_uncached_data_wr_o    = mem_data_wr_i;\\n', \"assign mem_uncached_rd_o         = (~mem_cacheable_i & ~hold_w) ? mem_rd_i : 1'b0;\\n\", \"assign mem_uncached_wr_o         = (~mem_cacheable_i & ~hold_w) ? mem_wr_i : 4'b0;\\n\", 'assign mem_uncached_cacheable_o  = mem_cacheable_i;\\n', 'assign mem_uncached_req_tag_o    = mem_req_tag_i;\\n', \"assign mem_uncached_invalidate_o = (~mem_cacheable_i & ~hold_w) ? mem_invalidate_i : 1'b0;\\n\", \"assign mem_uncached_writeback_o  = (~mem_cacheable_i & ~hold_w) ? mem_writeback_i : 1'b0;\\n\", \"assign mem_uncached_flush_o      = (~mem_cacheable_i & ~hold_w) ? mem_flush_i : 1'b0;\\n\", '\\n', 'assign mem_accept_o              =(mem_cacheable_i ? mem_cached_accept_i  : mem_uncached_accept_i) & !hold_w;\\n', 'assign mem_data_rd_o             = cache_access_q ? mem_cached_data_rd_i  : mem_uncached_data_rd_i;\\n', 'assign mem_ack_o                 = cache_access_q ? mem_cached_ack_i      : mem_uncached_ack_i;\\n', 'assign mem_error_o               = cache_access_q ? mem_cached_error_i    : mem_uncached_error_i;\\n', 'assign mem_resp_tag_o            = cache_access_q ? mem_cached_resp_tag_i : mem_uncached_resp_tag_i;\\n', '\\n', \"wire      request_w              = mem_rd_i | mem_wr_i != 4'b0 | mem_flush_i | mem_invalidate_i | mem_writeback_i;\\n\", '\\n', 'reg [4:0] pending_r;\\n', 'reg [4:0] pending_q;\\n', 'always @ *\\n', 'begin\\n', '    pending_r = pending_q;\\n', '\\n', '    if ((request_w && mem_accept_o) && !mem_ack_o)\\n', \"        pending_r = pending_r + 5'd1;\\n\", '    else if (!(request_w && mem_accept_o) && mem_ack_o)\\n', \"        pending_r = pending_r - 5'd1;\\n\", 'end\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    pending_q <= 5'b0;\\n\", 'else\\n', '    pending_q <= pending_r;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    cache_access_q <= 1'b0;\\n\", 'else if (request_w && mem_accept_o)\\n', '    cache_access_q <= mem_cacheable_i;\\n', '\\n', 'assign hold_w = (|pending_q) && (cache_access_q != mem_cacheable_i);\\n', '\\n', 'assign cache_active_o = (|pending_q) ? cache_access_q : mem_cacheable_i;\\n', '\\n', '\\n', 'endmodule\\n']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.6.0\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', '\\n', 'module dcache_pmem_mux\\n', '(\\n', '    // Inputs\\n', '     input           clk_i\\n', '    ,input           rst_i\\n', '    ,input           outport_accept_i\\n', '    ,input           outport_ack_i\\n', '    ,input           outport_error_i\\n', '    ,input  [ 31:0]  outport_read_data_i\\n', '    ,input           select_i\\n', '    ,input  [  3:0]  inport0_wr_i\\n', '    ,input           inport0_rd_i\\n', '    ,input  [  7:0]  inport0_len_i\\n', '    ,input  [ 31:0]  inport0_addr_i\\n', '    ,input  [ 31:0]  inport0_write_data_i\\n', '    ,input  [  3:0]  inport1_wr_i\\n', '    ,input           inport1_rd_i\\n', '    ,input  [  7:0]  inport1_len_i\\n', '    ,input  [ 31:0]  inport1_addr_i\\n', '    ,input  [ 31:0]  inport1_write_data_i\\n', '\\n', '    // Outputs\\n', '    ,output [  3:0]  outport_wr_o\\n', '    ,output          outport_rd_o\\n', '    ,output [  7:0]  outport_len_o\\n', '    ,output [ 31:0]  outport_addr_o\\n', '    ,output [ 31:0]  outport_write_data_o\\n', '    ,output          inport0_accept_o\\n', '    ,output          inport0_ack_o\\n', '    ,output          inport0_error_o\\n', '    ,output [ 31:0]  inport0_read_data_o\\n', '    ,output          inport1_accept_o\\n', '    ,output          inport1_ack_o\\n', '    ,output          inport1_error_o\\n', '    ,output [ 31:0]  inport1_read_data_o\\n', ');\\n', '\\n', '\\n', '\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Output Mux\\n', '//-----------------------------------------------------------------\\n', 'reg [  3:0]  outport_wr_r;\\n', 'reg          outport_rd_r;\\n', 'reg [  7:0]  outport_len_r;\\n', 'reg [ 31:0]  outport_addr_r;\\n', 'reg [ 31:0]  outport_write_data_r;\\n', 'reg          select_q;\\n', '\\n', 'always @ *\\n', 'begin\\n', '    case (select_i)\\n', \"    1'd1:\\n\", '    begin\\n', '        outport_wr_r          = inport1_wr_i;\\n', '        outport_rd_r          = inport1_rd_i;\\n', '        outport_len_r         = inport1_len_i;\\n', '        outport_addr_r        = inport1_addr_i;\\n', '        outport_write_data_r  = inport1_write_data_i;\\n', '    end\\n', '    default:\\n', '    begin\\n', '        outport_wr_r          = inport0_wr_i;\\n', '        outport_rd_r          = inport0_rd_i;\\n', '        outport_len_r         = inport0_len_i;\\n', '        outport_addr_r        = inport0_addr_i;\\n', '        outport_write_data_r  = inport0_write_data_i;\\n', '    end\\n', '    endcase\\n', 'end\\n', '\\n', 'assign outport_wr_o         = outport_wr_r;\\n', 'assign outport_rd_o         = outport_rd_r;\\n', 'assign outport_len_o        = outport_len_r;\\n', 'assign outport_addr_o       = outport_addr_r;\\n', 'assign outport_write_data_o = outport_write_data_r;\\n', '\\n', '// Delayed version of selector to match phase of response signals\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    select_q <= 1'b0;\\n\", 'else\\n', '    select_q <= select_i;\\n', '\\n', \"assign inport0_ack_o       = (select_q == 1'd0) && outport_ack_i;\\n\", \"assign inport0_error_o     = (select_q == 1'd0) && outport_error_i;\\n\", 'assign inport0_read_data_o = outport_read_data_i;\\n', \"assign inport0_accept_o    = (select_i == 1'd0) && outport_accept_i;\\n\", \"assign inport1_ack_o       = (select_q == 1'd1) && outport_ack_i;\\n\", \"assign inport1_error_o     = (select_q == 1'd1) && outport_error_i;\\n\", 'assign inport1_read_data_o = outport_read_data_i;\\n', \"assign inport1_accept_o    = (select_i == 1'd1) && outport_accept_i;\\n\", '\\n', '\\n', 'endmodule\\n']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.6.0\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', '\\n', 'module dport_axi\\n', '(\\n', '    // Inputs\\n', '     input           clk_i\\n', '    ,input           rst_i\\n', '    ,input  [ 31:0]  mem_addr_i\\n', '    ,input  [ 31:0]  mem_data_wr_i\\n', '    ,input           mem_rd_i\\n', '    ,input  [  3:0]  mem_wr_i\\n', '    ,input           mem_cacheable_i\\n', '    ,input  [ 10:0]  mem_req_tag_i\\n', '    ,input           mem_invalidate_i\\n', '    ,input           mem_writeback_i\\n', '    ,input           mem_flush_i\\n', '    ,input           axi_awready_i\\n', '    ,input           axi_wready_i\\n', '    ,input           axi_bvalid_i\\n', '    ,input  [  1:0]  axi_bresp_i\\n', '    ,input           axi_arready_i\\n', '    ,input           axi_rvalid_i\\n', '    ,input  [ 31:0]  axi_rdata_i\\n', '    ,input  [  1:0]  axi_rresp_i\\n', '\\n', '    // Outputs\\n', '    ,output [ 31:0]  mem_data_rd_o\\n', '    ,output          mem_accept_o\\n', '    ,output          mem_ack_o\\n', '    ,output          mem_error_o\\n', '    ,output [ 10:0]  mem_resp_tag_o\\n', '    ,output          axi_awvalid_o\\n', '    ,output [ 31:0]  axi_awaddr_o\\n', '    ,output          axi_wvalid_o\\n', '    ,output [ 31:0]  axi_wdata_o\\n', '    ,output [  3:0]  axi_wstrb_o\\n', '    ,output          axi_bready_o\\n', '    ,output          axi_arvalid_o\\n', '    ,output [ 31:0]  axi_araddr_o\\n', '    ,output          axi_rready_o\\n', ');\\n', '\\n', '\\n', '\\n', '\\n', '\\n', '//-------------------------------------------------------------\\n', '// Description:\\n', '// Bridges between dcache_if -> AXI4/AXI4-Lite.\\n', '// Allows 1 outstanding transaction, but can buffer upto \\n', '// REQUEST_BUFFER dache_if requests before back-pressuring.\\n', '//-------------------------------------------------------------\\n', '\\n', '//-------------------------------------------------------------\\n', '// Request FIFO\\n', '//-------------------------------------------------------------\\n', '// Accepts from both FIFOs\\n', 'wire          res_accept_w;\\n', 'wire          req_accept_w;\\n', '\\n', '// Output accept\\n', 'wire          write_complete_w;\\n', 'wire          read_complete_w;\\n', '\\n', 'reg           request_pending_q;\\n', '\\n', 'wire          req_pop_w   = read_complete_w | write_complete_w;\\n', 'wire          req_valid_w;\\n', 'wire [69-1:0] req_w;\\n', '\\n', '// Push on transaction and other FIFO not full\\n', \"wire          req_push_w   = (mem_rd_i || mem_wr_i != 4'b0) && res_accept_w;\\n\", '\\n', 'dport_axi_fifo\\n', '#( \\n', '    .WIDTH(32+32+4+1),\\n', '    .DEPTH(2),\\n', '    .ADDR_W(1)\\n', ')\\n', 'u_req\\n', '(\\n', '    .clk_i(clk_i),\\n', '    .rst_i(rst_i),\\n', '\\n', '    // Input side\\n', '    .data_in_i({mem_rd_i, mem_wr_i, mem_data_wr_i, mem_addr_i}),\\n', '    .push_i(req_push_w),\\n', '    .accept_o(req_accept_w),\\n', '\\n', '    // Outputs\\n', '    .valid_o(req_valid_w),\\n', '    .data_out_o(req_w),\\n', '    .pop_i(req_pop_w)\\n', ');\\n', '\\n', 'assign mem_accept_o = req_accept_w & res_accept_w;\\n', '\\n', '//-------------------------------------------------------------\\n', '// Response Tracking FIFO\\n', '//-------------------------------------------------------------\\n', '// Push on transaction and other FIFO not full\\n', \"wire res_push_w = (mem_rd_i || mem_wr_i != 4'b0) && req_accept_w;\\n\", '\\n', 'dport_axi_fifo\\n', '#( \\n', '    .WIDTH(11),\\n', '    .DEPTH(2),\\n', '    .ADDR_W(1)\\n', ')\\n', 'u_resp\\n', '(\\n', '    .clk_i(clk_i),\\n', '    .rst_i(rst_i),\\n', '\\n', '    // Input side\\n', '    .data_in_i(mem_req_tag_i),\\n', '    .push_i(res_push_w),\\n', '    .accept_o(res_accept_w),\\n', '\\n', '    // Outputs\\n', '    .valid_o(), // UNUSED\\n', '    .data_out_o(mem_resp_tag_o),\\n', '    .pop_i(mem_ack_o)\\n', ');\\n', '\\n', 'assign mem_ack_o   = axi_bvalid_i || axi_rvalid_i;\\n', \"assign mem_error_o = axi_bvalid_i ? (axi_bresp_i != 2'b0) : (axi_rresp_i != 2'b0);\\n\", '\\n', 'wire request_in_progress_w = request_pending_q & !mem_ack_o;\\n', '\\n', '//-------------------------------------------------------------\\n', '// Write Request\\n', '//-------------------------------------------------------------\\n', \"wire req_is_read_w  = ((req_valid_w & !request_in_progress_w) ? req_w[68] : 1'b0);\\n\", \"wire req_is_write_w = ((req_valid_w & !request_in_progress_w) ? ~req_w[68] : 1'b0);\\n\", '\\n', 'reg awvalid_inhibit_q;\\n', 'reg wvalid_inhibit_q;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    awvalid_inhibit_q <= 1'b0;\\n\", 'else if (axi_awvalid_o && axi_awready_i && axi_wvalid_o && !axi_wready_i)\\n', \"    awvalid_inhibit_q <= 1'b1;\\n\", 'else if (axi_wvalid_o && axi_wready_i)\\n', \"    awvalid_inhibit_q <= 1'b0;\\n\", '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    wvalid_inhibit_q <= 1'b0;\\n\", 'else if (axi_wvalid_o && axi_wready_i && axi_awvalid_o && !axi_awready_i)\\n', \"    wvalid_inhibit_q <= 1'b1;\\n\", 'else if (axi_awvalid_o && axi_awready_i)\\n', \"    wvalid_inhibit_q <= 1'b0;\\n\", '\\n', 'assign axi_awvalid_o = req_is_write_w && !awvalid_inhibit_q;\\n', \"assign axi_awaddr_o  = {req_w[31:2], 2'b0};\\n\", 'assign axi_wvalid_o  = req_is_write_w && !wvalid_inhibit_q;\\n', 'assign axi_wdata_o   = req_w[63:32];\\n', 'assign axi_wstrb_o   = req_w[67:64];\\n', '\\n', \"assign axi_bready_o  = 1'b1;\\n\", '\\n', 'assign write_complete_w = (awvalid_inhibit_q || axi_awready_i) &&\\n', '                          (wvalid_inhibit_q || axi_wready_i) && req_is_write_w;\\n', '\\n', '//-------------------------------------------------------------\\n', '// Read Request\\n', '//-------------------------------------------------------------\\n', 'assign axi_arvalid_o = req_is_read_w;\\n', \"assign axi_araddr_o  = {req_w[31:2], 2'b0};\\n\", '\\n', \"assign axi_rready_o  = 1'b1;\\n\", '\\n', 'assign mem_data_rd_o = axi_rdata_i;\\n', '\\n', 'assign read_complete_w = axi_arvalid_o && axi_arready_i;\\n', '\\n', '//-------------------------------------------------------------\\n', '// Outstanding Request Tracking\\n', '//-------------------------------------------------------------\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    request_pending_q <= 1'b0;\\n\", 'else if (write_complete_w || read_complete_w)\\n', \"    request_pending_q <= 1'b1;\\n\", 'else if (mem_ack_o)\\n', \"    request_pending_q <= 1'b0;\\n\", '\\n', 'endmodule\\n', '\\n', '//-----------------------------------------------------------------\\n', '// dport_axi_fifo: FIFO\\n', '//-----------------------------------------------------------------\\n', 'module dport_axi_fifo\\n', '//-----------------------------------------------------------------\\n', '// Params\\n', '//-----------------------------------------------------------------\\n', '#(\\n', '    parameter WIDTH   = 8,\\n', '    parameter DEPTH   = 2,\\n', '    parameter ADDR_W  = 1\\n', ')\\n', '//-----------------------------------------------------------------\\n', '// Ports\\n', '//-----------------------------------------------------------------\\n', '(\\n', '    // Inputs\\n', '     input               clk_i\\n', '    ,input               rst_i\\n', '    ,input  [WIDTH-1:0]  data_in_i\\n', '    ,input               push_i\\n', '    ,input               pop_i\\n', '\\n', '    // Outputs\\n', '    ,output [WIDTH-1:0]  data_out_o\\n', '    ,output              accept_o\\n', '    ,output              valid_o\\n', ');\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Local Params\\n', '//-----------------------------------------------------------------\\n', 'localparam COUNT_W = ADDR_W + 1;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Registers\\n', '//-----------------------------------------------------------------\\n', 'reg [WIDTH-1:0]   ram_q[DEPTH-1:0];\\n', 'reg [ADDR_W-1:0]  rd_ptr_q;\\n', 'reg [ADDR_W-1:0]  wr_ptr_q;\\n', 'reg [COUNT_W-1:0] count_q;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Sequential\\n', '//-----------------------------------------------------------------\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', 'begin\\n', \"    count_q   <= {(COUNT_W) {1'b0}};\\n\", \"    rd_ptr_q  <= {(ADDR_W) {1'b0}};\\n\", \"    wr_ptr_q  <= {(ADDR_W) {1'b0}};\\n\", 'end\\n', 'else\\n', 'begin\\n', '    // Push\\n', '    if (push_i & accept_o)\\n', '    begin\\n', '        ram_q[wr_ptr_q] <= data_in_i;\\n', '        wr_ptr_q        <= wr_ptr_q + 1;\\n', '    end\\n', '\\n', '    // Pop\\n', '    if (pop_i & valid_o)\\n', '        rd_ptr_q      <= rd_ptr_q + 1;\\n', '\\n', '    // Count up\\n', '    if ((push_i & accept_o) & ~(pop_i & valid_o))\\n', '        count_q <= count_q + 1;\\n', '    // Count down\\n', '    else if (~(push_i & accept_o) & (pop_i & valid_o))\\n', '        count_q <= count_q - 1;\\n', 'end\\n', '\\n', '//-------------------------------------------------------------------\\n', '// Combinatorial\\n', '//-------------------------------------------------------------------\\n', '/* verilator lint_off WIDTH */\\n', 'assign valid_o       = (count_q != 0);\\n', 'assign accept_o      = (count_q != DEPTH);\\n', '/* verilator lint_on WIDTH */\\n', '\\n', 'assign data_out_o    = ram_q[rd_ptr_q];\\n', '\\n', '\\n', '\\n', 'endmodule\\n']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.6.0\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', '\\n', 'module dport_mux\\n', '//-----------------------------------------------------------------\\n', '// Params\\n', '//-----------------------------------------------------------------\\n', '#(\\n', '     parameter TCM_MEM_BASE     = 0\\n', ')\\n', '//-----------------------------------------------------------------\\n', '// Ports\\n', '//-----------------------------------------------------------------\\n', '(\\n', '    // Inputs\\n', '     input           clk_i\\n', '    ,input           rst_i\\n', '    ,input  [ 31:0]  mem_addr_i\\n', '    ,input  [ 31:0]  mem_data_wr_i\\n', '    ,input           mem_rd_i\\n', '    ,input  [  3:0]  mem_wr_i\\n', '    ,input           mem_cacheable_i\\n', '    ,input  [ 10:0]  mem_req_tag_i\\n', '    ,input           mem_invalidate_i\\n', '    ,input           mem_writeback_i\\n', '    ,input           mem_flush_i\\n', '    ,input  [ 31:0]  mem_tcm_data_rd_i\\n', '    ,input           mem_tcm_accept_i\\n', '    ,input           mem_tcm_ack_i\\n', '    ,input           mem_tcm_error_i\\n', '    ,input  [ 10:0]  mem_tcm_resp_tag_i\\n', '    ,input  [ 31:0]  mem_ext_data_rd_i\\n', '    ,input           mem_ext_accept_i\\n', '    ,input           mem_ext_ack_i\\n', '    ,input           mem_ext_error_i\\n', '    ,input  [ 10:0]  mem_ext_resp_tag_i\\n', '\\n', '    // Outputs\\n', '    ,output [ 31:0]  mem_data_rd_o\\n', '    ,output          mem_accept_o\\n', '    ,output          mem_ack_o\\n', '    ,output          mem_error_o\\n', '    ,output [ 10:0]  mem_resp_tag_o\\n', '    ,output [ 31:0]  mem_tcm_addr_o\\n', '    ,output [ 31:0]  mem_tcm_data_wr_o\\n', '    ,output          mem_tcm_rd_o\\n', '    ,output [  3:0]  mem_tcm_wr_o\\n', '    ,output          mem_tcm_cacheable_o\\n', '    ,output [ 10:0]  mem_tcm_req_tag_o\\n', '    ,output          mem_tcm_invalidate_o\\n', '    ,output          mem_tcm_writeback_o\\n', '    ,output          mem_tcm_flush_o\\n', '    ,output [ 31:0]  mem_ext_addr_o\\n', '    ,output [ 31:0]  mem_ext_data_wr_o\\n', '    ,output          mem_ext_rd_o\\n', '    ,output [  3:0]  mem_ext_wr_o\\n', '    ,output          mem_ext_cacheable_o\\n', '    ,output [ 10:0]  mem_ext_req_tag_o\\n', '    ,output          mem_ext_invalidate_o\\n', '    ,output          mem_ext_writeback_o\\n', '    ,output          mem_ext_flush_o\\n', ');\\n', '\\n', '\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Dcache_if mux\\n', '//-----------------------------------------------------------------\\n', 'wire hold_w;\\n', '\\n', '/* verilator lint_off UNSIGNED */\\n', \"wire tcm_access_w = (mem_addr_i >= TCM_MEM_BASE && mem_addr_i < (TCM_MEM_BASE + 32'd65536));\\n\", '/* verilator lint_on UNSIGNED */\\n', '\\n', 'reg       tcm_access_q;\\n', 'reg [4:0] pending_q;\\n', '\\n', 'assign mem_tcm_addr_o       = mem_addr_i;\\n', 'assign mem_tcm_data_wr_o    = mem_data_wr_i;\\n', \"assign mem_tcm_rd_o         = (tcm_access_w & ~hold_w) ? mem_rd_i : 1'b0;\\n\", \"assign mem_tcm_wr_o         = (tcm_access_w & ~hold_w) ? mem_wr_i : 4'b0;\\n\", 'assign mem_tcm_cacheable_o  = mem_cacheable_i;\\n', 'assign mem_tcm_req_tag_o    = mem_req_tag_i;\\n', \"assign mem_tcm_invalidate_o = (tcm_access_w & ~hold_w) ? mem_invalidate_i : 1'b0;\\n\", \"assign mem_tcm_writeback_o  = (tcm_access_w & ~hold_w) ? mem_writeback_i : 1'b0;\\n\", \"assign mem_tcm_flush_o      = (tcm_access_w & ~hold_w) ? mem_flush_i : 1'b0;\\n\", '\\n', 'assign mem_ext_addr_o       = mem_addr_i;\\n', 'assign mem_ext_data_wr_o    = mem_data_wr_i;\\n', \"assign mem_ext_rd_o         = (~tcm_access_w & ~hold_w) ? mem_rd_i : 1'b0;\\n\", \"assign mem_ext_wr_o         = (~tcm_access_w & ~hold_w) ? mem_wr_i : 4'b0;\\n\", 'assign mem_ext_cacheable_o  = mem_cacheable_i;\\n', 'assign mem_ext_req_tag_o    = mem_req_tag_i;\\n', \"assign mem_ext_invalidate_o = (~tcm_access_w & ~hold_w) ? mem_invalidate_i : 1'b0;\\n\", \"assign mem_ext_writeback_o  = (~tcm_access_w & ~hold_w) ? mem_writeback_i : 1'b0;\\n\", \"assign mem_ext_flush_o      = (~tcm_access_w & ~hold_w) ? mem_flush_i : 1'b0;\\n\", '\\n', 'assign mem_accept_o         =(tcm_access_w ? mem_tcm_accept_i   : mem_ext_accept_i) & !hold_w;\\n', 'assign mem_data_rd_o        = tcm_access_q ? mem_tcm_data_rd_i  : mem_ext_data_rd_i;\\n', 'assign mem_ack_o            = tcm_access_q ? mem_tcm_ack_i      : mem_ext_ack_i;\\n', 'assign mem_error_o          = tcm_access_q ? mem_tcm_error_i    : mem_ext_error_i;\\n', 'assign mem_resp_tag_o       = tcm_access_q ? mem_tcm_resp_tag_i : mem_ext_resp_tag_i;\\n', '\\n', \"wire   request_w            = mem_rd_i || mem_wr_i != 4'b0 || mem_flush_i || mem_invalidate_i || mem_writeback_i;\\n\", '\\n', 'reg [4:0] pending_r;\\n', 'always @ *\\n', 'begin\\n', '    pending_r = pending_q;\\n', '\\n', '    if ((request_w && mem_accept_o) && !mem_ack_o)\\n', \"        pending_r = pending_r + 5'd1;\\n\", '    else if (!(request_w && mem_accept_o) && mem_ack_o)\\n', \"        pending_r = pending_r - 5'd1;\\n\", 'end\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    pending_q <= 5'b0;\\n\", 'else\\n', '    pending_q <= pending_r;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    tcm_access_q <= 1'b0;\\n\", 'else if (request_w && mem_accept_o)\\n', '    tcm_access_q <= tcm_access_w;\\n', '\\n', 'assign hold_w = (|pending_q) && (tcm_access_q != tcm_access_w);\\n', '\\n', '\\n', '\\n', 'endmodule\\n']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.6.0\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', '\\n', 'module icache\\n', '//-----------------------------------------------------------------\\n', '// Params\\n', '//-----------------------------------------------------------------\\n', '#(\\n', '     parameter AXI_ID           = 0\\n', ')\\n', '//-----------------------------------------------------------------\\n', '// Ports\\n', '//-----------------------------------------------------------------\\n', '(\\n', '    // Inputs\\n', '     input           clk_i\\n', '    ,input           rst_i\\n', '    ,input           req_rd_i\\n', '    ,input           req_flush_i\\n', '    ,input           req_invalidate_i\\n', '    ,input  [ 31:0]  req_pc_i\\n', '    ,input           axi_awready_i\\n', '    ,input           axi_wready_i\\n', '    ,input           axi_bvalid_i\\n', '    ,input  [  1:0]  axi_bresp_i\\n', '    ,input  [  3:0]  axi_bid_i\\n', '    ,input           axi_arready_i\\n', '    ,input           axi_rvalid_i\\n', '    ,input  [ 31:0]  axi_rdata_i\\n', '    ,input  [  1:0]  axi_rresp_i\\n', '    ,input  [  3:0]  axi_rid_i\\n', '    ,input           axi_rlast_i\\n', '\\n', '    // Outputs\\n', '    ,output          req_accept_o\\n', '    ,output          req_valid_o\\n', '    ,output          req_error_o\\n', '    ,output [ 63:0]  req_inst_o\\n', '    ,output          axi_awvalid_o\\n', '    ,output [ 31:0]  axi_awaddr_o\\n', '    ,output [  3:0]  axi_awid_o\\n', '    ,output [  7:0]  axi_awlen_o\\n', '    ,output [  1:0]  axi_awburst_o\\n', '    ,output          axi_wvalid_o\\n', '    ,output [ 31:0]  axi_wdata_o\\n', '    ,output [  3:0]  axi_wstrb_o\\n', '    ,output          axi_wlast_o\\n', '    ,output          axi_bready_o\\n', '    ,output          axi_arvalid_o\\n', '    ,output [ 31:0]  axi_araddr_o\\n', '    ,output [  3:0]  axi_arid_o\\n', '    ,output [  7:0]  axi_arlen_o\\n', '    ,output [  1:0]  axi_arburst_o\\n', '    ,output          axi_rready_o\\n', ');\\n', '\\n', '\\n', '\\n', '//-----------------------------------------------------------------\\n', '// This cache instance is 2 way set associative.\\n', '// The total size is 16KB.\\n', '// The replacement policy is a limited pseudo random scheme\\n', '// (between lines, toggling on line thrashing).\\n', '//-----------------------------------------------------------------\\n', '// Number of ways\\n', 'localparam ICACHE_NUM_WAYS           = 2;\\n', '\\n', '// Number of cache lines\\n', 'localparam ICACHE_NUM_LINES          = 256;\\n', 'localparam ICACHE_LINE_ADDR_W        = 8;\\n', '\\n', '// Line size (e.g. 32-bytes)\\n', 'localparam ICACHE_LINE_SIZE_W        = 5;\\n', 'localparam ICACHE_LINE_SIZE          = 32;\\n', 'localparam ICACHE_LINE_WORDS         = 8;\\n', '\\n', 'localparam ICACHE_DATA_W             = 64;\\n', '\\n', '// Request -> tag address mapping\\n', 'localparam ICACHE_TAG_REQ_LINE_L     = 5;  // ICACHE_LINE_SIZE_W\\n', 'localparam ICACHE_TAG_REQ_LINE_H     = 12; // ICACHE_LINE_ADDR_W+ICACHE_LINE_SIZE_W-1\\n', 'localparam ICACHE_TAG_REQ_LINE_W     = 8;  // ICACHE_LINE_ADDR_W\\n', '`define ICACHE_TAG_REQ_RNG          ICACHE_TAG_REQ_LINE_H:ICACHE_TAG_REQ_LINE_L\\n', '\\n', '// Tag fields\\n', '`define CACHE_TAG_ADDR_RNG          18:0\\n', 'localparam CACHE_TAG_ADDR_BITS       = 19;\\n', 'localparam CACHE_TAG_VALID_BIT       = CACHE_TAG_ADDR_BITS;\\n', 'localparam CACHE_TAG_DATA_W          = CACHE_TAG_VALID_BIT + 1;\\n', '\\n', '// Tag compare bits\\n', 'localparam ICACHE_TAG_CMP_ADDR_L     = ICACHE_TAG_REQ_LINE_H + 1;\\n', 'localparam ICACHE_TAG_CMP_ADDR_H     = 32-1;\\n', 'localparam ICACHE_TAG_CMP_ADDR_W     = ICACHE_TAG_CMP_ADDR_H - ICACHE_TAG_CMP_ADDR_L + 1;\\n', '`define   ICACHE_TAG_CMP_ADDR_RNG   31:13\\n', '\\n', '// Address mapping example:\\n', '//  31          16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00\\n', '// |--------------|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |\\n', '//  +--------------------+  +--------------------+   +------------+\\n', '//  |  Tag address.      |  |   Line address     |      Address \\n', '//  |                    |  |                    |      within line\\n', '//  |                    |  |                    |\\n', '//  |                    |  |                    |- ICACHE_TAG_REQ_LINE_L\\n', '//  |                    |  |- ICACHE_TAG_REQ_LINE_H\\n', '//  |                    |- ICACHE_TAG_CMP_ADDR_L\\n', '//  |- ICACHE_TAG_CMP_ADDR_H\\n', '\\n', '// Tag addressing and match value\\n', 'wire [ICACHE_TAG_REQ_LINE_W-1:0] req_line_addr_w  = req_pc_i[`ICACHE_TAG_REQ_RNG];\\n', '\\n', '// Data addressing\\n', 'localparam CACHE_DATA_ADDR_W = ICACHE_LINE_ADDR_W+ICACHE_LINE_SIZE_W-3;\\n', 'wire [CACHE_DATA_ADDR_W-1:0] req_data_addr_w = req_pc_i[CACHE_DATA_ADDR_W+3-1:3];\\n', '\\n', '//-----------------------------------------------------------------\\n', '// States\\n', '//-----------------------------------------------------------------\\n', 'localparam STATE_W           = 2;\\n', \"localparam STATE_FLUSH       = 2'd0;\\n\", \"localparam STATE_LOOKUP      = 2'd1;\\n\", \"localparam STATE_REFILL      = 2'd2;\\n\", \"localparam STATE_RELOOKUP    = 2'd3;\\n\", '\\n', '//-----------------------------------------------------------------\\n', '// Registers / Wires\\n', '//-----------------------------------------------------------------\\n', '\\n', '// States\\n', 'reg [STATE_W-1:0]           next_state_r;\\n', 'reg [STATE_W-1:0]           state_q;\\n', '\\n', 'reg                         invalidate_q;\\n', '\\n', 'reg [0:0]  replace_way_q;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Lookup validation\\n', '//-----------------------------------------------------------------\\n', 'reg lookup_valid_q;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    lookup_valid_q <= 1'b0;\\n\", 'else if (req_rd_i && req_accept_o)\\n', \"    lookup_valid_q <= 1'b1;\\n\", 'else if (req_valid_o)\\n', \"    lookup_valid_q <= 1'b0;\\n\", '\\n', '//-----------------------------------------------------------------\\n', '// Lookup address\\n', '//-----------------------------------------------------------------\\n', 'reg [31:0] lookup_addr_q;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    lookup_addr_q <= 32'b0;\\n\", 'else if (req_rd_i && req_accept_o)\\n', '    lookup_addr_q <= req_pc_i;\\n', '\\n', 'wire [ICACHE_TAG_CMP_ADDR_W-1:0] req_pc_tag_cmp_w = lookup_addr_q[`ICACHE_TAG_CMP_ADDR_RNG];\\n', '\\n', '//-----------------------------------------------------------------\\n', '// TAG RAMS\\n', '//-----------------------------------------------------------------\\n', 'reg [ICACHE_TAG_REQ_LINE_W-1:0] tag_addr_r;\\n', '\\n', '// Tag RAM address\\n', 'always @ *\\n', 'begin\\n', '    tag_addr_r = flush_addr_q;\\n', '\\n', '    // Cache flush\\n', '    if (state_q == STATE_FLUSH)\\n', '        tag_addr_r = flush_addr_q;\\n', '    // Line refill\\n', '    else if (state_q == STATE_REFILL || state_q == STATE_RELOOKUP)\\n', '        tag_addr_r = lookup_addr_q[`ICACHE_TAG_REQ_RNG];\\n', '    // Lookup\\n', '    else\\n', '        tag_addr_r = req_line_addr_w;\\n', 'end\\n', '\\n', '// Tag RAM write data\\n', 'reg [CACHE_TAG_DATA_W-1:0] tag_data_in_r;\\n', 'always @ *\\n', 'begin\\n', \"    tag_data_in_r = {(CACHE_TAG_DATA_W){1'b0}};\\n\", '\\n', '    // Cache flush\\n', '    if (state_q == STATE_FLUSH)\\n', \"        tag_data_in_r = {(CACHE_TAG_DATA_W){1'b0}};\\n\", '    // Line refill\\n', '    else if (state_q == STATE_REFILL)\\n', '    begin\\n', \"        tag_data_in_r[CACHE_TAG_VALID_BIT] = 1'b1;\\n\", '        tag_data_in_r[`CACHE_TAG_ADDR_RNG] = lookup_addr_q[`ICACHE_TAG_CMP_ADDR_RNG];\\n', '    end\\n', 'end\\n', '\\n', '// Tag RAM write enable (way 0)\\n', 'reg tag0_write_r;\\n', 'always @ *\\n', 'begin\\n', \"    tag0_write_r = 1'b0;\\n\", '\\n', '    // Cache flush\\n', '    if (state_q == STATE_FLUSH)\\n', \"        tag0_write_r = 1'b1;\\n\", '    // Line refill\\n', '    else if (state_q == STATE_REFILL)\\n', '        tag0_write_r = axi_rvalid_i && axi_rlast_i && (replace_way_q == 0);\\n', 'end\\n', '\\n', 'wire [CACHE_TAG_DATA_W-1:0] tag0_data_out_w;\\n', '\\n', 'icache_tag_ram\\n', 'u_tag0\\n', '(\\n', '  .clk_i(clk_i),\\n', '  .rst_i(rst_i),\\n', '  .addr_i(tag_addr_r),\\n', '  .data_i(tag_data_in_r),\\n', '  .wr_i(tag0_write_r),\\n', '  .data_o(tag0_data_out_w)\\n', ');\\n', '\\n', 'wire                           tag0_valid_w     = tag0_data_out_w[CACHE_TAG_VALID_BIT];\\n', 'wire [CACHE_TAG_ADDR_BITS-1:0] tag0_addr_bits_w = tag0_data_out_w[`CACHE_TAG_ADDR_RNG];\\n', '\\n', '// Tag hit?\\n', \"wire                           tag0_hit_w = tag0_valid_w ? (tag0_addr_bits_w == req_pc_tag_cmp_w) : 1'b0;\\n\", '\\n', '// Tag RAM write enable (way 1)\\n', 'reg tag1_write_r;\\n', 'always @ *\\n', 'begin\\n', \"    tag1_write_r = 1'b0;\\n\", '\\n', '    // Cache flush\\n', '    if (state_q == STATE_FLUSH)\\n', \"        tag1_write_r = 1'b1;\\n\", '    // Line refill\\n', '    else if (state_q == STATE_REFILL)\\n', '        tag1_write_r = axi_rvalid_i && axi_rlast_i && (replace_way_q == 1);\\n', 'end\\n', '\\n', 'wire [CACHE_TAG_DATA_W-1:0] tag1_data_out_w;\\n', '\\n', 'icache_tag_ram\\n', 'u_tag1\\n', '(\\n', '  .clk_i(clk_i),\\n', '  .rst_i(rst_i),\\n', '  .addr_i(tag_addr_r),\\n', '  .data_i(tag_data_in_r),\\n', '  .wr_i(tag1_write_r),\\n', '  .data_o(tag1_data_out_w)\\n', ');\\n', '\\n', 'wire                           tag1_valid_w     = tag1_data_out_w[CACHE_TAG_VALID_BIT];\\n', 'wire [CACHE_TAG_ADDR_BITS-1:0] tag1_addr_bits_w = tag1_data_out_w[`CACHE_TAG_ADDR_RNG];\\n', '\\n', '// Tag hit?\\n', \"wire                           tag1_hit_w = tag1_valid_w ? (tag1_addr_bits_w == req_pc_tag_cmp_w) : 1'b0;\\n\", '\\n', '\\n', \"wire tag_hit_any_w = 1'b0\\n\", '                   | tag0_hit_w\\n', '                   | tag1_hit_w\\n', '                    ;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// DATA RAMS\\n', '//-----------------------------------------------------------------\\n', 'reg [CACHE_DATA_ADDR_W-1:0] data_addr_r;\\n', 'reg [CACHE_DATA_ADDR_W-1:0] data_write_addr_q;\\n', 'reg [2:0]  refill_word_idx_q;\\n', 'reg [31:0] refill_lower_q;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    refill_word_idx_q <= 3'b0;\\n\", 'else if (axi_rvalid_i && axi_rlast_i)\\n', \"    refill_word_idx_q <= 3'b0;\\n\", 'else if (axi_rvalid_i)\\n', \"    refill_word_idx_q <= refill_word_idx_q + 3'd1;\\n\", '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    refill_lower_q <= 32'b0;\\n\", 'else if (axi_rvalid_i)\\n', '    refill_lower_q <= axi_rdata_i;\\n', '\\n', '// Data RAM refill write address\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    data_write_addr_q <= {(CACHE_DATA_ADDR_W){1'b0}};\\n\", 'else if (state_q == STATE_LOOKUP && next_state_r == STATE_REFILL)\\n', '    data_write_addr_q <= axi_araddr_o[CACHE_DATA_ADDR_W+3-1:3];\\n', 'else if (state_q == STATE_REFILL && axi_rvalid_i && refill_word_idx_q[0])\\n', '    data_write_addr_q <= data_write_addr_q + 1;\\n', '\\n', '// Data RAM address\\n', 'always @ *\\n', 'begin\\n', '    data_addr_r = req_data_addr_w;\\n', '\\n', '    // Line refill\\n', '    if (state_q == STATE_REFILL)\\n', '        data_addr_r = data_write_addr_q;\\n', '    // Lookup after refill\\n', '    else if (state_q == STATE_RELOOKUP)\\n', '        data_addr_r = lookup_addr_q[CACHE_DATA_ADDR_W+3-1:3];\\n', '    // Lookup\\n', '    else\\n', '        data_addr_r = req_data_addr_w;\\n', 'end\\n', '\\n', '\\n', '// Data RAM write enable (way 0)\\n', 'reg data0_write_r;\\n', 'always @ *\\n', 'begin\\n', '    data0_write_r = axi_rvalid_i && replace_way_q == 0;\\n', 'end\\n', '\\n', 'wire [ICACHE_DATA_W-1:0] data0_data_out_w;\\n', '\\n', 'icache_data_ram\\n', 'u_data0\\n', '(\\n', '  .clk_i(clk_i),\\n', '  .rst_i(rst_i),\\n', '  .addr_i(data_addr_r),\\n', '  .data_i({axi_rdata_i, refill_lower_q}),\\n', '  .wr_i(data0_write_r),\\n', '  .data_o(data0_data_out_w)\\n', ');\\n', '\\n', '// Data RAM write enable (way 1)\\n', 'reg data1_write_r;\\n', 'always @ *\\n', 'begin\\n', '    data1_write_r = axi_rvalid_i && replace_way_q == 1;\\n', 'end\\n', '\\n', 'wire [ICACHE_DATA_W-1:0] data1_data_out_w;\\n', '\\n', 'icache_data_ram\\n', 'u_data1\\n', '(\\n', '  .clk_i(clk_i),\\n', '  .rst_i(rst_i),\\n', '  .addr_i(data_addr_r),\\n', '  .data_i({axi_rdata_i, refill_lower_q}),\\n', '  .wr_i(data1_write_r),\\n', '  .data_o(data1_data_out_w)\\n', ');\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Flush counter\\n', '//-----------------------------------------------------------------\\n', 'reg [ICACHE_TAG_REQ_LINE_W-1:0] flush_addr_q;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    flush_addr_q <= {(ICACHE_TAG_REQ_LINE_W){1'b0}};\\n\", 'else if (state_q == STATE_FLUSH)\\n', '    flush_addr_q <= flush_addr_q + 1;\\n', '// Invalidate specified line\\n', 'else if (req_invalidate_i && req_accept_o)\\n', '    flush_addr_q <= req_line_addr_w;\\n', 'else\\n', \"    flush_addr_q <= {(ICACHE_TAG_REQ_LINE_W){1'b0}};\\n\", '\\n', '//-----------------------------------------------------------------\\n', '// Replacement Policy\\n', '//----------------------------------------------------------------- \\n', '// Using random replacement policy - this way we cycle through the ways\\n', '// when needing to replace a line.\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', '    replace_way_q <= 0;\\n', 'else if (axi_rvalid_i && axi_rlast_i)\\n', '    replace_way_q <= replace_way_q + 1;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Instruction Output\\n', '//-----------------------------------------------------------------\\n', \"assign req_valid_o = lookup_valid_q && ((state_q == STATE_LOOKUP) ? tag_hit_any_w : 1'b0);\\n\", '\\n', '// Data output mux\\n', 'reg [ICACHE_DATA_W-1:0] inst_r;\\n', 'always @ *\\n', 'begin\\n', '    inst_r = data0_data_out_w;\\n', '\\n', \"    case (1'b1)\\n\", '    tag0_hit_w: inst_r = data0_data_out_w;\\n', '    tag1_hit_w: inst_r = data1_data_out_w;\\n', '    endcase\\n', 'end\\n', '\\n', 'assign req_inst_o    = inst_r;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Next State Logic\\n', '//-----------------------------------------------------------------\\n', 'always @ *\\n', 'begin\\n', '    next_state_r = state_q;\\n', '\\n', '    case (state_q)\\n', '    //-----------------------------------------\\n', '    // STATE_FLUSH\\n', '    //-----------------------------------------\\n', '    STATE_FLUSH :\\n', '    begin\\n', '        if (invalidate_q)\\n', '            next_state_r = STATE_LOOKUP;\\n', \"        else if (flush_addr_q == {(ICACHE_TAG_REQ_LINE_W){1'b1}})\\n\", '            next_state_r = STATE_LOOKUP;\\n', '    end\\n', '    //-----------------------------------------\\n', '    // STATE_LOOKUP\\n', '    //-----------------------------------------\\n', '    STATE_LOOKUP :\\n', '    begin\\n', '        // Tried a lookup but no match found\\n', '        if (lookup_valid_q && !tag_hit_any_w)\\n', '            next_state_r = STATE_REFILL;\\n', '        // Invalidate a line / flush cache\\n', '        else if (req_invalidate_i || req_flush_i)\\n', '            next_state_r = STATE_FLUSH;\\n', '    end\\n', '    //-----------------------------------------\\n', '    // STATE_REFILL\\n', '    //-----------------------------------------\\n', '    STATE_REFILL :\\n', '    begin\\n', '        // End of refill\\n', '        if (axi_rvalid_i && axi_rlast_i)\\n', '            next_state_r = STATE_RELOOKUP;\\n', '    end\\n', '    //-----------------------------------------\\n', '    // STATE_RELOOKUP\\n', '    //-----------------------------------------\\n', '    STATE_RELOOKUP :\\n', '    begin\\n', '        next_state_r = STATE_LOOKUP;\\n', '    end\\n', '    default:\\n', '        ;\\n', '   endcase\\n', 'end\\n', '\\n', '// Update state\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', '    state_q   <= STATE_FLUSH;\\n', 'else\\n', '    state_q   <= next_state_r;\\n', '\\n', 'assign req_accept_o = (state_q == STATE_LOOKUP && next_state_r != STATE_REFILL);\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Invalidate\\n', '//-----------------------------------------------------------------\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    invalidate_q   <= 1'b0;\\n\", 'else if (req_invalidate_i && req_accept_o)\\n', \"    invalidate_q   <= 1'b1;\\n\", 'else\\n', \"    invalidate_q   <= 1'b0;\\n\", '\\n', '//-----------------------------------------------------------------\\n', '// AXI Request Hold\\n', '//-----------------------------------------------------------------\\n', 'reg axi_arvalid_q;\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    axi_arvalid_q   <= 1'b0;\\n\", 'else if (axi_arvalid_o && !axi_arready_i)\\n', \"    axi_arvalid_q   <= 1'b1;\\n\", 'else\\n', \"    axi_arvalid_q   <= 1'b0;\\n\", '\\n', '//-----------------------------------------------------------------\\n', '// AXI Error Handling\\n', '//-----------------------------------------------------------------\\n', 'reg axi_error_q;\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    axi_error_q   <= 1'b0;\\n\", \"else if (axi_rvalid_i && axi_rready_o && axi_rresp_i != 2'b0)\\n\", \"    axi_error_q   <= 1'b1;\\n\", 'else if (req_valid_o)\\n', \"    axi_error_q   <= 1'b0;\\n\", '\\n', 'assign req_error_o = axi_error_q;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// AXI\\n', '//-----------------------------------------------------------------\\n', '// AXI Write channel (unused)\\n', \"assign axi_awvalid_o = 1'b0;\\n\", \"assign axi_awaddr_o  = 32'b0;\\n\", \"assign axi_awid_o    = 4'b0;\\n\", \"assign axi_awlen_o   = 8'b0;\\n\", \"assign axi_awburst_o = 2'b0;\\n\", \"assign axi_wvalid_o  = 1'b0;\\n\", \"assign axi_wdata_o   = 32'b0;\\n\", \"assign axi_wstrb_o   = 4'b0;\\n\", \"assign axi_wlast_o   = 1'b0;\\n\", \"assign axi_bready_o  = 1'b0;\\n\", '\\n', '// AXI Read channel\\n', 'assign axi_arvalid_o = (state_q == STATE_LOOKUP && next_state_r == STATE_REFILL) || axi_arvalid_q;\\n', \"assign axi_araddr_o  = {lookup_addr_q[31:ICACHE_LINE_SIZE_W], {(ICACHE_LINE_SIZE_W){1'b0}}};\\n\", \"assign axi_arburst_o = 2'd1; // INCR\\n\", 'assign axi_arid_o    = AXI_ID;\\n', \"assign axi_arlen_o   = 8'd7;\\n\", \"assign axi_rready_o  = 1'b1;\\n\", '\\n', '\\n', '\\n', 'endmodule\\n']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.6.0\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', '\\n', 'module icache_data_ram\\n', '(\\n', '    // Inputs\\n', '     input           clk_i\\n', '    ,input           rst_i\\n', '    ,input  [  9:0]  addr_i\\n', '    ,input  [ 63:0]  data_i\\n', '    ,input           wr_i\\n', '\\n', '    // Outputs\\n', '    ,output [ 63:0]  data_o\\n', ');\\n', '\\n', '\\n', '\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Single Port RAM 8KB\\n', '// Mode: Read First\\n', '//-----------------------------------------------------------------\\n', 'reg [63:0]   ram [1023:0] /*verilator public*/;\\n', 'reg [63:0]   ram_read_q;\\n', '\\n', '// Synchronous write\\n', 'always @ (posedge clk_i)\\n', 'begin\\n', '    if (wr_i)\\n', '        ram[addr_i] <= data_i;\\n', '    ram_read_q <= ram[addr_i];\\n', 'end\\n', '\\n', 'assign data_o = ram_read_q;\\n', '\\n', '\\n', '\\n', 'endmodule\\n']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.6.0\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', '\\n', 'module icache_tag_ram\\n', '(\\n', '    // Inputs\\n', '     input           clk_i\\n', '    ,input           rst_i\\n', '    ,input  [  7:0]  addr_i\\n', '    ,input  [ 19:0]  data_i\\n', '    ,input           wr_i\\n', '\\n', '    // Outputs\\n', '    ,output [ 19:0]  data_o\\n', ');\\n', '\\n', '\\n', '\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Single Port RAM 0KB\\n', '// Mode: Read First\\n', '//-----------------------------------------------------------------\\n', 'reg [19:0]   ram [255:0] /*verilator public*/;\\n', 'reg [19:0]   ram_read_q;\\n', '\\n', '// Synchronous write\\n', 'always @ (posedge clk_i)\\n', 'begin\\n', '    if (wr_i)\\n', '        ram[addr_i] <= data_i;\\n', '    ram_read_q <= ram[addr_i];\\n', 'end\\n', '\\n', 'assign data_o = ram_read_q;\\n', '\\n', '\\n', '\\n', 'endmodule\\n']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.6.0\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', '\\n', 'module riscv_tcm_top\\n', '//-----------------------------------------------------------------\\n', '// Params\\n', '//-----------------------------------------------------------------\\n', '#(\\n', \"     parameter BOOT_VECTOR      = 32'h00000000\\n\", '    ,parameter CORE_ID          = 0\\n', \"    ,parameter TCM_MEM_BASE     = 32'h00000000\\n\", '    ,parameter SUPPORT_BRANCH_PREDICTION = 1\\n', '    ,parameter SUPPORT_MULDIV   = 1\\n', '    ,parameter SUPPORT_SUPER    = 0\\n', '    ,parameter SUPPORT_MMU      = 0\\n', '    ,parameter SUPPORT_DUAL_ISSUE = 1\\n', '    ,parameter SUPPORT_LOAD_BYPASS = 1\\n', '    ,parameter SUPPORT_MUL_BYPASS = 1\\n', '    ,parameter SUPPORT_REGFILE_XILINX = 0\\n', '    ,parameter EXTRA_DECODE_STAGE = 0\\n', \"    ,parameter MEM_CACHE_ADDR_MIN = 32'h80000000\\n\", \"    ,parameter MEM_CACHE_ADDR_MAX = 32'h8fffffff\\n\", '    ,parameter NUM_BTB_ENTRIES  = 32\\n', '    ,parameter NUM_BTB_ENTRIES_W = 5\\n', '    ,parameter NUM_BHT_ENTRIES  = 512\\n', '    ,parameter NUM_BHT_ENTRIES_W = 9\\n', '    ,parameter RAS_ENABLE       = 1\\n', '    ,parameter GSHARE_ENABLE    = 0\\n', '    ,parameter BHT_ENABLE       = 1\\n', '    ,parameter NUM_RAS_ENTRIES  = 8\\n', '    ,parameter NUM_RAS_ENTRIES_W = 3\\n', ')\\n', '//-----------------------------------------------------------------\\n', '// Ports\\n', '//-----------------------------------------------------------------\\n', '(\\n', '    // Inputs\\n', '     input           clk_i\\n', '    ,input           rst_i\\n', '    ,input           rst_cpu_i\\n', '    ,input           axi_i_awready_i\\n', '    ,input           axi_i_wready_i\\n', '    ,input           axi_i_bvalid_i\\n', '    ,input  [  1:0]  axi_i_bresp_i\\n', '    ,input           axi_i_arready_i\\n', '    ,input           axi_i_rvalid_i\\n', '    ,input  [ 31:0]  axi_i_rdata_i\\n', '    ,input  [  1:0]  axi_i_rresp_i\\n', '    ,input           axi_t_awvalid_i\\n', '    ,input  [ 31:0]  axi_t_awaddr_i\\n', '    ,input  [  3:0]  axi_t_awid_i\\n', '    ,input  [  7:0]  axi_t_awlen_i\\n', '    ,input  [  1:0]  axi_t_awburst_i\\n', '    ,input           axi_t_wvalid_i\\n', '    ,input  [ 31:0]  axi_t_wdata_i\\n', '    ,input  [  3:0]  axi_t_wstrb_i\\n', '    ,input           axi_t_wlast_i\\n', '    ,input           axi_t_bready_i\\n', '    ,input           axi_t_arvalid_i\\n', '    ,input  [ 31:0]  axi_t_araddr_i\\n', '    ,input  [  3:0]  axi_t_arid_i\\n', '    ,input  [  7:0]  axi_t_arlen_i\\n', '    ,input  [  1:0]  axi_t_arburst_i\\n', '    ,input           axi_t_rready_i\\n', '    ,input  [ 31:0]  intr_i\\n', '\\n', '    // Outputs\\n', '    ,output          axi_i_awvalid_o\\n', '    ,output [ 31:0]  axi_i_awaddr_o\\n', '    ,output          axi_i_wvalid_o\\n', '    ,output [ 31:0]  axi_i_wdata_o\\n', '    ,output [  3:0]  axi_i_wstrb_o\\n', '    ,output          axi_i_bready_o\\n', '    ,output          axi_i_arvalid_o\\n', '    ,output [ 31:0]  axi_i_araddr_o\\n', '    ,output          axi_i_rready_o\\n', '    ,output          axi_t_awready_o\\n', '    ,output          axi_t_wready_o\\n', '    ,output          axi_t_bvalid_o\\n', '    ,output [  1:0]  axi_t_bresp_o\\n', '    ,output [  3:0]  axi_t_bid_o\\n', '    ,output          axi_t_arready_o\\n', '    ,output          axi_t_rvalid_o\\n', '    ,output [ 31:0]  axi_t_rdata_o\\n', '    ,output [  1:0]  axi_t_rresp_o\\n', '    ,output [  3:0]  axi_t_rid_o\\n', '    ,output          axi_t_rlast_o\\n', ');\\n', '\\n', 'wire  [ 31:0]  ifetch_pc_w;\\n', 'wire  [ 31:0]  dport_tcm_data_rd_w;\\n', 'wire           dport_tcm_cacheable_w;\\n', 'wire           dport_flush_w;\\n', 'wire  [  3:0]  dport_tcm_wr_w;\\n', 'wire           ifetch_rd_w;\\n', 'wire           dport_axi_accept_w;\\n', 'wire           dport_cacheable_w;\\n', 'wire           dport_tcm_flush_w;\\n', 'wire  [ 10:0]  dport_resp_tag_w;\\n', 'wire  [ 10:0]  dport_axi_resp_tag_w;\\n', 'wire           ifetch_accept_w;\\n', 'wire  [ 31:0]  dport_data_rd_w;\\n', 'wire           dport_tcm_invalidate_w;\\n', 'wire           dport_ack_w;\\n', 'wire  [ 10:0]  dport_axi_req_tag_w;\\n', 'wire  [ 31:0]  dport_data_wr_w;\\n', 'wire           dport_invalidate_w;\\n', 'wire  [ 10:0]  dport_tcm_req_tag_w;\\n', 'wire  [ 31:0]  dport_tcm_addr_w;\\n', 'wire           dport_axi_error_w;\\n', 'wire           dport_tcm_ack_w;\\n', 'wire           dport_tcm_rd_w;\\n', 'wire  [ 10:0]  dport_tcm_resp_tag_w;\\n', 'wire           dport_writeback_w;\\n', 'wire  [ 31:0]  cpu_id_w = CORE_ID;\\n', 'wire           dport_rd_w;\\n', 'wire           dport_axi_ack_w;\\n', 'wire           dport_axi_rd_w;\\n', 'wire  [ 31:0]  dport_axi_data_rd_w;\\n', 'wire           dport_axi_invalidate_w;\\n', 'wire  [ 31:0]  boot_vector_w = BOOT_VECTOR;\\n', 'wire  [ 31:0]  dport_addr_w;\\n', 'wire           ifetch_error_w;\\n', 'wire  [ 31:0]  dport_tcm_data_wr_w;\\n', 'wire           ifetch_flush_w;\\n', 'wire  [ 31:0]  dport_axi_addr_w;\\n', 'wire           dport_error_w;\\n', 'wire           dport_tcm_accept_w;\\n', 'wire           ifetch_invalidate_w;\\n', 'wire           dport_axi_writeback_w;\\n', 'wire  [  3:0]  dport_wr_w;\\n', 'wire           ifetch_valid_w;\\n', 'wire  [ 31:0]  dport_axi_data_wr_w;\\n', 'wire  [ 10:0]  dport_req_tag_w;\\n', 'wire  [ 63:0]  ifetch_inst_w;\\n', 'wire           dport_axi_cacheable_w;\\n', 'wire           dport_tcm_writeback_w;\\n', 'wire  [  3:0]  dport_axi_wr_w;\\n', 'wire           dport_axi_flush_w;\\n', 'wire           dport_tcm_error_w;\\n', 'wire           dport_accept_w;\\n', '\\n', '\\n', 'riscv_core\\n', '#(\\n', '     .MEM_CACHE_ADDR_MIN(MEM_CACHE_ADDR_MIN)\\n', '    ,.MEM_CACHE_ADDR_MAX(MEM_CACHE_ADDR_MAX)\\n', '    ,.SUPPORT_BRANCH_PREDICTION(SUPPORT_BRANCH_PREDICTION)\\n', '    ,.SUPPORT_MULDIV(SUPPORT_MULDIV)\\n', '    ,.SUPPORT_SUPER(SUPPORT_SUPER)\\n', '    ,.SUPPORT_MMU(SUPPORT_MMU)\\n', '    ,.SUPPORT_DUAL_ISSUE(SUPPORT_DUAL_ISSUE)\\n', '    ,.SUPPORT_LOAD_BYPASS(SUPPORT_LOAD_BYPASS)\\n', '    ,.SUPPORT_MUL_BYPASS(SUPPORT_MUL_BYPASS)\\n', '    ,.SUPPORT_REGFILE_XILINX(SUPPORT_REGFILE_XILINX)\\n', '    ,.EXTRA_DECODE_STAGE(EXTRA_DECODE_STAGE)\\n', '    ,.NUM_BTB_ENTRIES(NUM_BTB_ENTRIES)\\n', '    ,.NUM_BTB_ENTRIES_W(NUM_BTB_ENTRIES_W)\\n', '    ,.NUM_BHT_ENTRIES(NUM_BHT_ENTRIES)\\n', '    ,.NUM_BHT_ENTRIES_W(NUM_BHT_ENTRIES_W)\\n', '    ,.RAS_ENABLE(RAS_ENABLE)\\n', '    ,.GSHARE_ENABLE(GSHARE_ENABLE)\\n', '    ,.BHT_ENABLE(BHT_ENABLE)\\n', '    ,.NUM_RAS_ENTRIES(NUM_RAS_ENTRIES)\\n', '    ,.NUM_RAS_ENTRIES_W(NUM_RAS_ENTRIES_W)\\n', ')\\n', 'u_core\\n', '(\\n', '    // Inputs\\n', '     .clk_i(clk_i)\\n', '    ,.rst_i(rst_cpu_i)\\n', '    ,.mem_d_data_rd_i(dport_data_rd_w)\\n', '    ,.mem_d_accept_i(dport_accept_w)\\n', '    ,.mem_d_ack_i(dport_ack_w)\\n', '    ,.mem_d_error_i(dport_error_w)\\n', '    ,.mem_d_resp_tag_i(dport_resp_tag_w)\\n', '    ,.mem_i_accept_i(ifetch_accept_w)\\n', '    ,.mem_i_valid_i(ifetch_valid_w)\\n', '    ,.mem_i_error_i(ifetch_error_w)\\n', '    ,.mem_i_inst_i(ifetch_inst_w)\\n', '    ,.intr_i(|intr_i)\\n', '    ,.reset_vector_i(boot_vector_w)\\n', '    ,.cpu_id_i(cpu_id_w)\\n', '\\n', '    // Outputs\\n', '    ,.mem_d_addr_o(dport_addr_w)\\n', '    ,.mem_d_data_wr_o(dport_data_wr_w)\\n', '    ,.mem_d_rd_o(dport_rd_w)\\n', '    ,.mem_d_wr_o(dport_wr_w)\\n', '    ,.mem_d_cacheable_o(dport_cacheable_w)\\n', '    ,.mem_d_req_tag_o(dport_req_tag_w)\\n', '    ,.mem_d_invalidate_o(dport_invalidate_w)\\n', '    ,.mem_d_writeback_o(dport_writeback_w)\\n', '    ,.mem_d_flush_o(dport_flush_w)\\n', '    ,.mem_i_rd_o(ifetch_rd_w)\\n', '    ,.mem_i_flush_o(ifetch_flush_w)\\n', '    ,.mem_i_invalidate_o(ifetch_invalidate_w)\\n', '    ,.mem_i_pc_o(ifetch_pc_w)\\n', ');\\n', '\\n', '\\n', 'dport_mux\\n', '#(\\n', '     .TCM_MEM_BASE(TCM_MEM_BASE)\\n', ')\\n', 'u_dmux\\n', '(\\n', '    // Inputs\\n', '     .clk_i(clk_i)\\n', '    ,.rst_i(rst_i)\\n', '    ,.mem_addr_i(dport_addr_w)\\n', '    ,.mem_data_wr_i(dport_data_wr_w)\\n', '    ,.mem_rd_i(dport_rd_w)\\n', '    ,.mem_wr_i(dport_wr_w)\\n', '    ,.mem_cacheable_i(dport_cacheable_w)\\n', '    ,.mem_req_tag_i(dport_req_tag_w)\\n', '    ,.mem_invalidate_i(dport_invalidate_w)\\n', '    ,.mem_writeback_i(dport_writeback_w)\\n', '    ,.mem_flush_i(dport_flush_w)\\n', '    ,.mem_tcm_data_rd_i(dport_tcm_data_rd_w)\\n', '    ,.mem_tcm_accept_i(dport_tcm_accept_w)\\n', '    ,.mem_tcm_ack_i(dport_tcm_ack_w)\\n', '    ,.mem_tcm_error_i(dport_tcm_error_w)\\n', '    ,.mem_tcm_resp_tag_i(dport_tcm_resp_tag_w)\\n', '    ,.mem_ext_data_rd_i(dport_axi_data_rd_w)\\n', '    ,.mem_ext_accept_i(dport_axi_accept_w)\\n', '    ,.mem_ext_ack_i(dport_axi_ack_w)\\n', '    ,.mem_ext_error_i(dport_axi_error_w)\\n', '    ,.mem_ext_resp_tag_i(dport_axi_resp_tag_w)\\n', '\\n', '    // Outputs\\n', '    ,.mem_data_rd_o(dport_data_rd_w)\\n', '    ,.mem_accept_o(dport_accept_w)\\n', '    ,.mem_ack_o(dport_ack_w)\\n', '    ,.mem_error_o(dport_error_w)\\n', '    ,.mem_resp_tag_o(dport_resp_tag_w)\\n', '    ,.mem_tcm_addr_o(dport_tcm_addr_w)\\n', '    ,.mem_tcm_data_wr_o(dport_tcm_data_wr_w)\\n', '    ,.mem_tcm_rd_o(dport_tcm_rd_w)\\n', '    ,.mem_tcm_wr_o(dport_tcm_wr_w)\\n', '    ,.mem_tcm_cacheable_o(dport_tcm_cacheable_w)\\n', '    ,.mem_tcm_req_tag_o(dport_tcm_req_tag_w)\\n', '    ,.mem_tcm_invalidate_o(dport_tcm_invalidate_w)\\n', '    ,.mem_tcm_writeback_o(dport_tcm_writeback_w)\\n', '    ,.mem_tcm_flush_o(dport_tcm_flush_w)\\n', '    ,.mem_ext_addr_o(dport_axi_addr_w)\\n', '    ,.mem_ext_data_wr_o(dport_axi_data_wr_w)\\n', '    ,.mem_ext_rd_o(dport_axi_rd_w)\\n', '    ,.mem_ext_wr_o(dport_axi_wr_w)\\n', '    ,.mem_ext_cacheable_o(dport_axi_cacheable_w)\\n', '    ,.mem_ext_req_tag_o(dport_axi_req_tag_w)\\n', '    ,.mem_ext_invalidate_o(dport_axi_invalidate_w)\\n', '    ,.mem_ext_writeback_o(dport_axi_writeback_w)\\n', '    ,.mem_ext_flush_o(dport_axi_flush_w)\\n', ');\\n', '\\n', '\\n', 'tcm_mem\\n', 'u_tcm\\n', '(\\n', '    // Inputs\\n', '     .clk_i(clk_i)\\n', '    ,.rst_i(rst_i)\\n', '    ,.mem_i_rd_i(ifetch_rd_w)\\n', '    ,.mem_i_flush_i(ifetch_flush_w)\\n', '    ,.mem_i_invalidate_i(ifetch_invalidate_w)\\n', '    ,.mem_i_pc_i(ifetch_pc_w)\\n', '    ,.mem_d_addr_i(dport_tcm_addr_w)\\n', '    ,.mem_d_data_wr_i(dport_tcm_data_wr_w)\\n', '    ,.mem_d_rd_i(dport_tcm_rd_w)\\n', '    ,.mem_d_wr_i(dport_tcm_wr_w)\\n', '    ,.mem_d_cacheable_i(dport_tcm_cacheable_w)\\n', '    ,.mem_d_req_tag_i(dport_tcm_req_tag_w)\\n', '    ,.mem_d_invalidate_i(dport_tcm_invalidate_w)\\n', '    ,.mem_d_writeback_i(dport_tcm_writeback_w)\\n', '    ,.mem_d_flush_i(dport_tcm_flush_w)\\n', '    ,.axi_awvalid_i(axi_t_awvalid_i)\\n', '    ,.axi_awaddr_i(axi_t_awaddr_i)\\n', '    ,.axi_awid_i(axi_t_awid_i)\\n', '    ,.axi_awlen_i(axi_t_awlen_i)\\n', '    ,.axi_awburst_i(axi_t_awburst_i)\\n', '    ,.axi_wvalid_i(axi_t_wvalid_i)\\n', '    ,.axi_wdata_i(axi_t_wdata_i)\\n', '    ,.axi_wstrb_i(axi_t_wstrb_i)\\n', '    ,.axi_wlast_i(axi_t_wlast_i)\\n', '    ,.axi_bready_i(axi_t_bready_i)\\n', '    ,.axi_arvalid_i(axi_t_arvalid_i)\\n', '    ,.axi_araddr_i(axi_t_araddr_i)\\n', '    ,.axi_arid_i(axi_t_arid_i)\\n', '    ,.axi_arlen_i(axi_t_arlen_i)\\n', '    ,.axi_arburst_i(axi_t_arburst_i)\\n', '    ,.axi_rready_i(axi_t_rready_i)\\n', '\\n', '    // Outputs\\n', '    ,.mem_i_accept_o(ifetch_accept_w)\\n', '    ,.mem_i_valid_o(ifetch_valid_w)\\n', '    ,.mem_i_error_o(ifetch_error_w)\\n', '    ,.mem_i_inst_o(ifetch_inst_w)\\n', '    ,.mem_d_data_rd_o(dport_tcm_data_rd_w)\\n', '    ,.mem_d_accept_o(dport_tcm_accept_w)\\n', '    ,.mem_d_ack_o(dport_tcm_ack_w)\\n', '    ,.mem_d_error_o(dport_tcm_error_w)\\n', '    ,.mem_d_resp_tag_o(dport_tcm_resp_tag_w)\\n', '    ,.axi_awready_o(axi_t_awready_o)\\n', '    ,.axi_wready_o(axi_t_wready_o)\\n', '    ,.axi_bvalid_o(axi_t_bvalid_o)\\n', '    ,.axi_bresp_o(axi_t_bresp_o)\\n', '    ,.axi_bid_o(axi_t_bid_o)\\n', '    ,.axi_arready_o(axi_t_arready_o)\\n', '    ,.axi_rvalid_o(axi_t_rvalid_o)\\n', '    ,.axi_rdata_o(axi_t_rdata_o)\\n', '    ,.axi_rresp_o(axi_t_rresp_o)\\n', '    ,.axi_rid_o(axi_t_rid_o)\\n', '    ,.axi_rlast_o(axi_t_rlast_o)\\n', ');\\n', '\\n', '\\n', 'dport_axi\\n', 'u_axi\\n', '(\\n', '    // Inputs\\n', '     .clk_i(clk_i)\\n', '    ,.rst_i(rst_i)\\n', '    ,.mem_addr_i(dport_axi_addr_w)\\n', '    ,.mem_data_wr_i(dport_axi_data_wr_w)\\n', '    ,.mem_rd_i(dport_axi_rd_w)\\n', '    ,.mem_wr_i(dport_axi_wr_w)\\n', '    ,.mem_cacheable_i(dport_axi_cacheable_w)\\n', '    ,.mem_req_tag_i(dport_axi_req_tag_w)\\n', '    ,.mem_invalidate_i(dport_axi_invalidate_w)\\n', '    ,.mem_writeback_i(dport_axi_writeback_w)\\n', '    ,.mem_flush_i(dport_axi_flush_w)\\n', '    ,.axi_awready_i(axi_i_awready_i)\\n', '    ,.axi_wready_i(axi_i_wready_i)\\n', '    ,.axi_bvalid_i(axi_i_bvalid_i)\\n', '    ,.axi_bresp_i(axi_i_bresp_i)\\n', '    ,.axi_arready_i(axi_i_arready_i)\\n', '    ,.axi_rvalid_i(axi_i_rvalid_i)\\n', '    ,.axi_rdata_i(axi_i_rdata_i)\\n', '    ,.axi_rresp_i(axi_i_rresp_i)\\n', '\\n', '    // Outputs\\n', '    ,.mem_data_rd_o(dport_axi_data_rd_w)\\n', '    ,.mem_accept_o(dport_axi_accept_w)\\n', '    ,.mem_ack_o(dport_axi_ack_w)\\n', '    ,.mem_error_o(dport_axi_error_w)\\n', '    ,.mem_resp_tag_o(dport_axi_resp_tag_w)\\n', '    ,.axi_awvalid_o(axi_i_awvalid_o)\\n', '    ,.axi_awaddr_o(axi_i_awaddr_o)\\n', '    ,.axi_wvalid_o(axi_i_wvalid_o)\\n', '    ,.axi_wdata_o(axi_i_wdata_o)\\n', '    ,.axi_wstrb_o(axi_i_wstrb_o)\\n', '    ,.axi_bready_o(axi_i_bready_o)\\n', '    ,.axi_arvalid_o(axi_i_arvalid_o)\\n', '    ,.axi_araddr_o(axi_i_araddr_o)\\n', '    ,.axi_rready_o(axi_i_rready_o)\\n', ');\\n', '\\n', '\\n', '\\n', 'endmodule\\n']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.6.0\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', '\\n', 'module riscv_top\\n', '//-----------------------------------------------------------------\\n', '// Params\\n', '//-----------------------------------------------------------------\\n', '#(\\n', '     parameter CORE_ID          = 0\\n', '    ,parameter ICACHE_AXI_ID    = 0\\n', '    ,parameter DCACHE_AXI_ID    = 0\\n', '    ,parameter SUPPORT_BRANCH_PREDICTION = 1\\n', '    ,parameter SUPPORT_MULDIV   = 1\\n', '    ,parameter SUPPORT_SUPER    = 0\\n', '    ,parameter SUPPORT_MMU      = 0\\n', '    ,parameter SUPPORT_DUAL_ISSUE = 1\\n', '    ,parameter SUPPORT_LOAD_BYPASS = 1\\n', '    ,parameter SUPPORT_MUL_BYPASS = 1\\n', '    ,parameter SUPPORT_REGFILE_XILINX = 0\\n', '    ,parameter EXTRA_DECODE_STAGE = 0\\n', \"    ,parameter MEM_CACHE_ADDR_MIN = 32'h80000000\\n\", \"    ,parameter MEM_CACHE_ADDR_MAX = 32'h8fffffff\\n\", '    ,parameter NUM_BTB_ENTRIES  = 32\\n', '    ,parameter NUM_BTB_ENTRIES_W = 5\\n', '    ,parameter NUM_BHT_ENTRIES  = 512\\n', '    ,parameter NUM_BHT_ENTRIES_W = 9\\n', '    ,parameter RAS_ENABLE       = 1\\n', '    ,parameter GSHARE_ENABLE    = 0\\n', '    ,parameter BHT_ENABLE       = 1\\n', '    ,parameter NUM_RAS_ENTRIES  = 8\\n', '    ,parameter NUM_RAS_ENTRIES_W = 3\\n', ')\\n', '//-----------------------------------------------------------------\\n', '// Ports\\n', '//-----------------------------------------------------------------\\n', '(\\n', '    // Inputs\\n', '     input           clk_i\\n', '    ,input           rst_i\\n', '    ,input           axi_i_awready_i\\n', '    ,input           axi_i_wready_i\\n', '    ,input           axi_i_bvalid_i\\n', '    ,input  [  1:0]  axi_i_bresp_i\\n', '    ,input  [  3:0]  axi_i_bid_i\\n', '    ,input           axi_i_arready_i\\n', '    ,input           axi_i_rvalid_i\\n', '    ,input  [ 31:0]  axi_i_rdata_i\\n', '    ,input  [  1:0]  axi_i_rresp_i\\n', '    ,input  [  3:0]  axi_i_rid_i\\n', '    ,input           axi_i_rlast_i\\n', '    ,input           axi_d_awready_i\\n', '    ,input           axi_d_wready_i\\n', '    ,input           axi_d_bvalid_i\\n', '    ,input  [  1:0]  axi_d_bresp_i\\n', '    ,input  [  3:0]  axi_d_bid_i\\n', '    ,input           axi_d_arready_i\\n', '    ,input           axi_d_rvalid_i\\n', '    ,input  [ 31:0]  axi_d_rdata_i\\n', '    ,input  [  1:0]  axi_d_rresp_i\\n', '    ,input  [  3:0]  axi_d_rid_i\\n', '    ,input           axi_d_rlast_i\\n', '    ,input           intr_i\\n', '    ,input  [ 31:0]  reset_vector_i\\n', '\\n', '    // Outputs\\n', '    ,output          axi_i_awvalid_o\\n', '    ,output [ 31:0]  axi_i_awaddr_o\\n', '    ,output [  3:0]  axi_i_awid_o\\n', '    ,output [  7:0]  axi_i_awlen_o\\n', '    ,output [  1:0]  axi_i_awburst_o\\n', '    ,output          axi_i_wvalid_o\\n', '    ,output [ 31:0]  axi_i_wdata_o\\n', '    ,output [  3:0]  axi_i_wstrb_o\\n', '    ,output          axi_i_wlast_o\\n', '    ,output          axi_i_bready_o\\n', '    ,output          axi_i_arvalid_o\\n', '    ,output [ 31:0]  axi_i_araddr_o\\n', '    ,output [  3:0]  axi_i_arid_o\\n', '    ,output [  7:0]  axi_i_arlen_o\\n', '    ,output [  1:0]  axi_i_arburst_o\\n', '    ,output          axi_i_rready_o\\n', '    ,output          axi_d_awvalid_o\\n', '    ,output [ 31:0]  axi_d_awaddr_o\\n', '    ,output [  3:0]  axi_d_awid_o\\n', '    ,output [  7:0]  axi_d_awlen_o\\n', '    ,output [  1:0]  axi_d_awburst_o\\n', '    ,output          axi_d_wvalid_o\\n', '    ,output [ 31:0]  axi_d_wdata_o\\n', '    ,output [  3:0]  axi_d_wstrb_o\\n', '    ,output          axi_d_wlast_o\\n', '    ,output          axi_d_bready_o\\n', '    ,output          axi_d_arvalid_o\\n', '    ,output [ 31:0]  axi_d_araddr_o\\n', '    ,output [  3:0]  axi_d_arid_o\\n', '    ,output [  7:0]  axi_d_arlen_o\\n', '    ,output [  1:0]  axi_d_arburst_o\\n', '    ,output          axi_d_rready_o\\n', ');\\n', '\\n', 'wire           icache_valid_w;\\n', 'wire           icache_flush_w;\\n', 'wire           dcache_flush_w;\\n', 'wire           dcache_invalidate_w;\\n', 'wire           dcache_ack_w;\\n', 'wire  [ 10:0]  dcache_resp_tag_w;\\n', 'wire  [ 63:0]  icache_inst_w;\\n', 'wire  [ 31:0]  cpu_id_w = CORE_ID;\\n', 'wire           dcache_rd_w;\\n', 'wire  [ 31:0]  dcache_addr_w;\\n', 'wire           dcache_accept_w;\\n', 'wire           icache_invalidate_w;\\n', 'wire           dcache_writeback_w;\\n', 'wire  [ 10:0]  dcache_req_tag_w;\\n', 'wire           dcache_cacheable_w;\\n', 'wire           icache_error_w;\\n', 'wire  [ 31:0]  dcache_data_rd_w;\\n', 'wire           icache_accept_w;\\n', 'wire  [  3:0]  dcache_wr_w;\\n', 'wire  [ 31:0]  icache_pc_w;\\n', 'wire           icache_rd_w;\\n', 'wire           dcache_error_w;\\n', 'wire  [ 31:0]  dcache_data_wr_w;\\n', '\\n', '\\n', 'dcache\\n', '#(.AXI_ID(DCACHE_AXI_ID))\\n', 'u_dcache\\n', '(\\n', '    // Inputs\\n', '     .clk_i(clk_i)\\n', '    ,.rst_i(rst_i)\\n', '    ,.mem_addr_i(dcache_addr_w)\\n', '    ,.mem_data_wr_i(dcache_data_wr_w)\\n', '    ,.mem_rd_i(dcache_rd_w)\\n', '    ,.mem_wr_i(dcache_wr_w)\\n', '    ,.mem_cacheable_i(dcache_cacheable_w)\\n', '    ,.mem_req_tag_i(dcache_req_tag_w)\\n', '    ,.mem_invalidate_i(dcache_invalidate_w)\\n', '    ,.mem_writeback_i(dcache_writeback_w)\\n', '    ,.mem_flush_i(dcache_flush_w)\\n', '    ,.axi_awready_i(axi_d_awready_i)\\n', '    ,.axi_wready_i(axi_d_wready_i)\\n', '    ,.axi_bvalid_i(axi_d_bvalid_i)\\n', '    ,.axi_bresp_i(axi_d_bresp_i)\\n', '    ,.axi_bid_i(axi_d_bid_i)\\n', '    ,.axi_arready_i(axi_d_arready_i)\\n', '    ,.axi_rvalid_i(axi_d_rvalid_i)\\n', '    ,.axi_rdata_i(axi_d_rdata_i)\\n', '    ,.axi_rresp_i(axi_d_rresp_i)\\n', '    ,.axi_rid_i(axi_d_rid_i)\\n', '    ,.axi_rlast_i(axi_d_rlast_i)\\n', '\\n', '    // Outputs\\n', '    ,.mem_data_rd_o(dcache_data_rd_w)\\n', '    ,.mem_accept_o(dcache_accept_w)\\n', '    ,.mem_ack_o(dcache_ack_w)\\n', '    ,.mem_error_o(dcache_error_w)\\n', '    ,.mem_resp_tag_o(dcache_resp_tag_w)\\n', '    ,.axi_awvalid_o(axi_d_awvalid_o)\\n', '    ,.axi_awaddr_o(axi_d_awaddr_o)\\n', '    ,.axi_awid_o(axi_d_awid_o)\\n', '    ,.axi_awlen_o(axi_d_awlen_o)\\n', '    ,.axi_awburst_o(axi_d_awburst_o)\\n', '    ,.axi_wvalid_o(axi_d_wvalid_o)\\n', '    ,.axi_wdata_o(axi_d_wdata_o)\\n', '    ,.axi_wstrb_o(axi_d_wstrb_o)\\n', '    ,.axi_wlast_o(axi_d_wlast_o)\\n', '    ,.axi_bready_o(axi_d_bready_o)\\n', '    ,.axi_arvalid_o(axi_d_arvalid_o)\\n', '    ,.axi_araddr_o(axi_d_araddr_o)\\n', '    ,.axi_arid_o(axi_d_arid_o)\\n', '    ,.axi_arlen_o(axi_d_arlen_o)\\n', '    ,.axi_arburst_o(axi_d_arburst_o)\\n', '    ,.axi_rready_o(axi_d_rready_o)\\n', ');\\n', '\\n', '\\n', 'riscv_core\\n', '#(\\n', '     .MEM_CACHE_ADDR_MIN(MEM_CACHE_ADDR_MIN)\\n', '    ,.MEM_CACHE_ADDR_MAX(MEM_CACHE_ADDR_MAX)\\n', '    ,.SUPPORT_BRANCH_PREDICTION(SUPPORT_BRANCH_PREDICTION)\\n', '    ,.SUPPORT_MULDIV(SUPPORT_MULDIV)\\n', '    ,.SUPPORT_SUPER(SUPPORT_SUPER)\\n', '    ,.SUPPORT_MMU(SUPPORT_MMU)\\n', '    ,.SUPPORT_DUAL_ISSUE(SUPPORT_DUAL_ISSUE)\\n', '    ,.SUPPORT_LOAD_BYPASS(SUPPORT_LOAD_BYPASS)\\n', '    ,.SUPPORT_MUL_BYPASS(SUPPORT_MUL_BYPASS)\\n', '    ,.SUPPORT_REGFILE_XILINX(SUPPORT_REGFILE_XILINX)\\n', '    ,.EXTRA_DECODE_STAGE(EXTRA_DECODE_STAGE)\\n', '    ,.NUM_BTB_ENTRIES(NUM_BTB_ENTRIES)\\n', '    ,.NUM_BTB_ENTRIES_W(NUM_BTB_ENTRIES_W)\\n', '    ,.NUM_BHT_ENTRIES(NUM_BHT_ENTRIES)\\n', '    ,.NUM_BHT_ENTRIES_W(NUM_BHT_ENTRIES_W)\\n', '    ,.RAS_ENABLE(RAS_ENABLE)\\n', '    ,.GSHARE_ENABLE(GSHARE_ENABLE)\\n', '    ,.BHT_ENABLE(BHT_ENABLE)\\n', '    ,.NUM_RAS_ENTRIES(NUM_RAS_ENTRIES)\\n', '    ,.NUM_RAS_ENTRIES_W(NUM_RAS_ENTRIES_W)\\n', ')\\n', 'u_core\\n', '(\\n', '    // Inputs\\n', '     .clk_i(clk_i)\\n', '    ,.rst_i(rst_i)\\n', '    ,.mem_d_data_rd_i(dcache_data_rd_w)\\n', '    ,.mem_d_accept_i(dcache_accept_w)\\n', '    ,.mem_d_ack_i(dcache_ack_w)\\n', '    ,.mem_d_error_i(dcache_error_w)\\n', '    ,.mem_d_resp_tag_i(dcache_resp_tag_w)\\n', '    ,.mem_i_accept_i(icache_accept_w)\\n', '    ,.mem_i_valid_i(icache_valid_w)\\n', '    ,.mem_i_error_i(icache_error_w)\\n', '    ,.mem_i_inst_i(icache_inst_w)\\n', '    ,.intr_i(intr_i)\\n', '    ,.reset_vector_i(reset_vector_i)\\n', '    ,.cpu_id_i(cpu_id_w)\\n', '\\n', '    // Outputs\\n', '    ,.mem_d_addr_o(dcache_addr_w)\\n', '    ,.mem_d_data_wr_o(dcache_data_wr_w)\\n', '    ,.mem_d_rd_o(dcache_rd_w)\\n', '    ,.mem_d_wr_o(dcache_wr_w)\\n', '    ,.mem_d_cacheable_o(dcache_cacheable_w)\\n', '    ,.mem_d_req_tag_o(dcache_req_tag_w)\\n', '    ,.mem_d_invalidate_o(dcache_invalidate_w)\\n', '    ,.mem_d_writeback_o(dcache_writeback_w)\\n', '    ,.mem_d_flush_o(dcache_flush_w)\\n', '    ,.mem_i_rd_o(icache_rd_w)\\n', '    ,.mem_i_flush_o(icache_flush_w)\\n', '    ,.mem_i_invalidate_o(icache_invalidate_w)\\n', '    ,.mem_i_pc_o(icache_pc_w)\\n', ');\\n', '\\n', '\\n', 'icache\\n', '#(.AXI_ID(ICACHE_AXI_ID))\\n', 'u_icache\\n', '(\\n', '    // Inputs\\n', '     .clk_i(clk_i)\\n', '    ,.rst_i(rst_i)\\n', '    ,.req_rd_i(icache_rd_w)\\n', '    ,.req_flush_i(icache_flush_w)\\n', '    ,.req_invalidate_i(icache_invalidate_w)\\n', '    ,.req_pc_i(icache_pc_w)\\n', '    ,.axi_awready_i(axi_i_awready_i)\\n', '    ,.axi_wready_i(axi_i_wready_i)\\n', '    ,.axi_bvalid_i(axi_i_bvalid_i)\\n', '    ,.axi_bresp_i(axi_i_bresp_i)\\n', '    ,.axi_bid_i(axi_i_bid_i)\\n', '    ,.axi_arready_i(axi_i_arready_i)\\n', '    ,.axi_rvalid_i(axi_i_rvalid_i)\\n', '    ,.axi_rdata_i(axi_i_rdata_i)\\n', '    ,.axi_rresp_i(axi_i_rresp_i)\\n', '    ,.axi_rid_i(axi_i_rid_i)\\n', '    ,.axi_rlast_i(axi_i_rlast_i)\\n', '\\n', '    // Outputs\\n', '    ,.req_accept_o(icache_accept_w)\\n', '    ,.req_valid_o(icache_valid_w)\\n', '    ,.req_error_o(icache_error_w)\\n', '    ,.req_inst_o(icache_inst_w)\\n', '    ,.axi_awvalid_o(axi_i_awvalid_o)\\n', '    ,.axi_awaddr_o(axi_i_awaddr_o)\\n', '    ,.axi_awid_o(axi_i_awid_o)\\n', '    ,.axi_awlen_o(axi_i_awlen_o)\\n', '    ,.axi_awburst_o(axi_i_awburst_o)\\n', '    ,.axi_wvalid_o(axi_i_wvalid_o)\\n', '    ,.axi_wdata_o(axi_i_wdata_o)\\n', '    ,.axi_wstrb_o(axi_i_wstrb_o)\\n', '    ,.axi_wlast_o(axi_i_wlast_o)\\n', '    ,.axi_bready_o(axi_i_bready_o)\\n', '    ,.axi_arvalid_o(axi_i_arvalid_o)\\n', '    ,.axi_araddr_o(axi_i_araddr_o)\\n', '    ,.axi_arid_o(axi_i_arid_o)\\n', '    ,.axi_arlen_o(axi_i_arlen_o)\\n', '    ,.axi_arburst_o(axi_i_arburst_o)\\n', '    ,.axi_rready_o(axi_i_rready_o)\\n', ');\\n', '\\n', '\\n', '\\n', 'endmodule\\n']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.6.0\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', '\\n', 'module tcm_mem\\n', '(\\n', '    // Inputs\\n', '     input           clk_i\\n', '    ,input           rst_i\\n', '    ,input           mem_i_rd_i\\n', '    ,input           mem_i_flush_i\\n', '    ,input           mem_i_invalidate_i\\n', '    ,input  [ 31:0]  mem_i_pc_i\\n', '    ,input  [ 31:0]  mem_d_addr_i\\n', '    ,input  [ 31:0]  mem_d_data_wr_i\\n', '    ,input           mem_d_rd_i\\n', '    ,input  [  3:0]  mem_d_wr_i\\n', '    ,input           mem_d_cacheable_i\\n', '    ,input  [ 10:0]  mem_d_req_tag_i\\n', '    ,input           mem_d_invalidate_i\\n', '    ,input           mem_d_writeback_i\\n', '    ,input           mem_d_flush_i\\n', '    ,input           axi_awvalid_i\\n', '    ,input  [ 31:0]  axi_awaddr_i\\n', '    ,input  [  3:0]  axi_awid_i\\n', '    ,input  [  7:0]  axi_awlen_i\\n', '    ,input  [  1:0]  axi_awburst_i\\n', '    ,input           axi_wvalid_i\\n', '    ,input  [ 31:0]  axi_wdata_i\\n', '    ,input  [  3:0]  axi_wstrb_i\\n', '    ,input           axi_wlast_i\\n', '    ,input           axi_bready_i\\n', '    ,input           axi_arvalid_i\\n', '    ,input  [ 31:0]  axi_araddr_i\\n', '    ,input  [  3:0]  axi_arid_i\\n', '    ,input  [  7:0]  axi_arlen_i\\n', '    ,input  [  1:0]  axi_arburst_i\\n', '    ,input           axi_rready_i\\n', '\\n', '    // Outputs\\n', '    ,output          mem_i_accept_o\\n', '    ,output          mem_i_valid_o\\n', '    ,output          mem_i_error_o\\n', '    ,output [ 63:0]  mem_i_inst_o\\n', '    ,output [ 31:0]  mem_d_data_rd_o\\n', '    ,output          mem_d_accept_o\\n', '    ,output          mem_d_ack_o\\n', '    ,output          mem_d_error_o\\n', '    ,output [ 10:0]  mem_d_resp_tag_o\\n', '    ,output          axi_awready_o\\n', '    ,output          axi_wready_o\\n', '    ,output          axi_bvalid_o\\n', '    ,output [  1:0]  axi_bresp_o\\n', '    ,output [  3:0]  axi_bid_o\\n', '    ,output          axi_arready_o\\n', '    ,output          axi_rvalid_o\\n', '    ,output [ 31:0]  axi_rdata_o\\n', '    ,output [  1:0]  axi_rresp_o\\n', '    ,output [  3:0]  axi_rid_o\\n', '    ,output          axi_rlast_o\\n', ');\\n', '\\n', '\\n', '\\n', '//-------------------------------------------------------------\\n', '// AXI -> PMEM Interface\\n', '//-------------------------------------------------------------\\n', 'wire          ext_accept_w;\\n', 'wire          ext_ack_w;\\n', 'wire [ 31:0]  ext_read_data_w;\\n', 'wire [  3:0]  ext_wr_w;\\n', 'wire          ext_rd_w;\\n', 'wire [  7:0]  ext_len_w;\\n', 'wire [ 31:0]  ext_addr_w;\\n', 'wire [ 31:0]  ext_write_data_w;\\n', '\\n', 'tcm_mem_pmem\\n', 'u_conv\\n', '(\\n', '    // Inputs\\n', '    .clk_i(clk_i),\\n', '    .rst_i(rst_i),\\n', '    .axi_awvalid_i(axi_awvalid_i),\\n', '    .axi_awaddr_i(axi_awaddr_i),\\n', '    .axi_awid_i(axi_awid_i),\\n', '    .axi_awlen_i(axi_awlen_i),\\n', '    .axi_awburst_i(axi_awburst_i),\\n', '    .axi_wvalid_i(axi_wvalid_i),\\n', '    .axi_wdata_i(axi_wdata_i),\\n', '    .axi_wstrb_i(axi_wstrb_i),\\n', '    .axi_wlast_i(axi_wlast_i),\\n', '    .axi_bready_i(axi_bready_i),\\n', '    .axi_arvalid_i(axi_arvalid_i),\\n', '    .axi_araddr_i(axi_araddr_i),\\n', '    .axi_arid_i(axi_arid_i),\\n', '    .axi_arlen_i(axi_arlen_i),\\n', '    .axi_arburst_i(axi_arburst_i),\\n', '    .axi_rready_i(axi_rready_i),\\n', '    .ram_accept_i(ext_accept_w),\\n', '    .ram_ack_i(ext_ack_w),\\n', \"    .ram_error_i(1'b0),\\n\", '    .ram_read_data_i(ext_read_data_w),\\n', '\\n', '    // Outputs\\n', '    .axi_awready_o(axi_awready_o),\\n', '    .axi_wready_o(axi_wready_o),\\n', '    .axi_bvalid_o(axi_bvalid_o),\\n', '    .axi_bresp_o(axi_bresp_o),\\n', '    .axi_bid_o(axi_bid_o),\\n', '    .axi_arready_o(axi_arready_o),\\n', '    .axi_rvalid_o(axi_rvalid_o),\\n', '    .axi_rdata_o(axi_rdata_o),\\n', '    .axi_rresp_o(axi_rresp_o),\\n', '    .axi_rid_o(axi_rid_o),\\n', '    .axi_rlast_o(axi_rlast_o),\\n', '    .ram_wr_o(ext_wr_w),\\n', '    .ram_rd_o(ext_rd_w),\\n', '    .ram_len_o(ext_len_w),\\n', '    .ram_addr_o(ext_addr_w),\\n', '    .ram_write_data_o(ext_write_data_w)\\n', ');\\n', '\\n', '//-------------------------------------------------------------\\n', '// Dual Port RAM\\n', '//-------------------------------------------------------------\\n', '\\n', '// Mux access to the 2nd port between external access and CPU data access\\n', 'wire                 muxed_hi_w   = ext_accept_w ? ext_addr_w[2] : mem_d_addr_i[2];\\n', 'wire [12:0] muxed_addr_w = ext_accept_w ? ext_addr_w[15:3] : mem_d_addr_i[15:3];\\n', 'wire [31:0] muxed_data_w = ext_accept_w ? ext_write_data_w : mem_d_data_wr_i;\\n', 'wire [3:0]  muxed_wr_w   = ext_accept_w ? ext_wr_w         : mem_d_wr_i;\\n', 'wire [63:0] data_r_w;\\n', '\\n', 'tcm_mem_ram\\n', 'u_ram\\n', '(\\n', '    // Instruction fetch\\n', '     .clk0_i(clk_i)\\n', '    ,.rst0_i(rst_i)\\n', '    ,.addr0_i(mem_i_pc_i[15:3])\\n', \"    ,.data0_i(64'b0)\\n\", \"    ,.wr0_i(8'b0)\\n\", '\\n', '    // External access / Data access\\n', '    ,.clk1_i(clk_i)\\n', '    ,.rst1_i(rst_i)\\n', '    ,.addr1_i(muxed_addr_w)\\n', \"    ,.data1_i(muxed_hi_w ? {muxed_data_w, 32'b0} : {32'b0, muxed_data_w})\\n\", \"    ,.wr1_i(muxed_hi_w ? {muxed_wr_w, 4'b0} : {4'b0, muxed_wr_w})\\n\", '\\n', '    // Outputs\\n', '    ,.data0_o(mem_i_inst_o)\\n', '    ,.data1_o(data_r_w)\\n', ');\\n', '\\n', 'reg muxed_hi_q;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    muxed_hi_q <= 1'b0;\\n\", 'else\\n', '    muxed_hi_q <= muxed_hi_w;\\n', '\\n', 'assign ext_read_data_w = muxed_hi_q ? data_r_w[63:32] : data_r_w[31:0];\\n', '\\n', '//-------------------------------------------------------------\\n', '// Instruction Fetch\\n', '//-------------------------------------------------------------\\n', 'reg        mem_i_valid_q;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    mem_i_valid_q <= 1'b0;\\n\", 'else\\n', '    mem_i_valid_q <= mem_i_rd_i;\\n', '\\n', \"assign mem_i_accept_o  = 1'b1;\\n\", 'assign mem_i_valid_o   = mem_i_valid_q;\\n', \"assign mem_i_error_o   = 1'b0;\\n\", '\\n', '//-------------------------------------------------------------\\n', '// Data Access / Incoming external access\\n', '//-------------------------------------------------------------\\n', 'reg        mem_d_accept_q;\\n', 'reg [10:0] mem_d_tag_q;\\n', 'reg        mem_d_ack_q;\\n', 'reg        ext_ack_q;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    mem_d_accept_q <= 1'b1;\\n\", '// External request, do not accept internal requests in next cycle\\n', \"else if (ext_rd_w || ext_wr_w != 4'b0)\\n\", \"    mem_d_accept_q <= 1'b0;\\n\", 'else\\n', \"    mem_d_accept_q <= 1'b1;\\n\", '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', 'begin\\n', \"    mem_d_ack_q    <= 1'b0;\\n\", \"    mem_d_tag_q    <= 11'b0;\\n\", 'end\\n', \"else if ((mem_d_rd_i || mem_d_wr_i != 4'b0 || mem_d_flush_i || mem_d_invalidate_i || mem_d_writeback_i) && mem_d_accept_o)\\n\", 'begin\\n', \"    mem_d_ack_q    <= 1'b1;\\n\", '    mem_d_tag_q    <= mem_d_req_tag_i;\\n', 'end\\n', 'else\\n', \"    mem_d_ack_q    <= 1'b0;\\n\", '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    ext_ack_q <= 1'b0;\\n\", '// External request accepted\\n', \"else if ((ext_rd_w || ext_wr_w != 4'b0) && ext_accept_w)\\n\", \"    ext_ack_q <= 1'b1;\\n\", 'else\\n', \"    ext_ack_q <= 1'b0;\\n\", '\\n', 'assign mem_d_ack_o          = mem_d_ack_q;\\n', 'assign mem_d_resp_tag_o     = mem_d_tag_q;\\n', 'assign mem_d_data_rd_o      = muxed_hi_q ? data_r_w[63:32] : data_r_w[31:0];\\n', \"assign mem_d_error_o        = 1'b0;\\n\", '\\n', 'assign mem_d_accept_o       = mem_d_accept_q;\\n', 'assign ext_accept_w         = !mem_d_accept_q;\\n', 'assign ext_ack_w            = ext_ack_q;\\n', '\\n', '`ifdef verilator\\n', '//-------------------------------------------------------------\\n', '// write: Write byte into memory\\n', '//-------------------------------------------------------------\\n', 'function write; /*verilator public*/\\n', '    input [31:0] addr;\\n', '    input [7:0]  data;\\n', 'begin\\n', '    case (addr[2:0])\\n', \"    3'd0: u_ram.ram[addr/8][7:0]   = data;\\n\", \"    3'd1: u_ram.ram[addr/8][15:8]  = data;\\n\", \"    3'd2: u_ram.ram[addr/8][23:16] = data;\\n\", \"    3'd3: u_ram.ram[addr/8][31:24] = data;\\n\", \"    3'd4: u_ram.ram[addr/8][39:32] = data;\\n\", \"    3'd5: u_ram.ram[addr/8][47:40] = data;\\n\", \"    3'd6: u_ram.ram[addr/8][55:48] = data;\\n\", \"    3'd7: u_ram.ram[addr/8][63:56] = data;\\n\", '    endcase\\n', 'end\\n', 'endfunction\\n', '//-------------------------------------------------------------\\n', '// read: Read byte from memory\\n', '//-------------------------------------------------------------\\n', 'function [7:0] read; /*verilator public*/\\n', '    input [31:0] addr;\\n', 'begin\\n', '    case (addr[2:0])\\n', \"    3'd0: read = u_ram.ram[addr/8][7:0];\\n\", \"    3'd1: read = u_ram.ram[addr/8][15:8];\\n\", \"    3'd2: read = u_ram.ram[addr/8][23:16];\\n\", \"    3'd3: read = u_ram.ram[addr/8][31:24];\\n\", \"    3'd4: read = u_ram.ram[addr/8][39:32];\\n\", \"    3'd5: read = u_ram.ram[addr/8][47:40];\\n\", \"    3'd6: read = u_ram.ram[addr/8][55:48];\\n\", \"    3'd7: read = u_ram.ram[addr/8][63:56];\\n\", '    endcase\\n', 'end\\n', 'endfunction\\n', '`endif\\n', '\\n', '\\n', '\\n', 'endmodule\\n']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.6.0\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', '\\n', 'module tcm_mem_pmem\\n', '(\\n', '    // Inputs\\n', '     input           clk_i\\n', '    ,input           rst_i\\n', '    ,input           axi_awvalid_i\\n', '    ,input  [ 31:0]  axi_awaddr_i\\n', '    ,input  [  3:0]  axi_awid_i\\n', '    ,input  [  7:0]  axi_awlen_i\\n', '    ,input  [  1:0]  axi_awburst_i\\n', '    ,input           axi_wvalid_i\\n', '    ,input  [ 31:0]  axi_wdata_i\\n', '    ,input  [  3:0]  axi_wstrb_i\\n', '    ,input           axi_wlast_i\\n', '    ,input           axi_bready_i\\n', '    ,input           axi_arvalid_i\\n', '    ,input  [ 31:0]  axi_araddr_i\\n', '    ,input  [  3:0]  axi_arid_i\\n', '    ,input  [  7:0]  axi_arlen_i\\n', '    ,input  [  1:0]  axi_arburst_i\\n', '    ,input           axi_rready_i\\n', '    ,input           ram_accept_i\\n', '    ,input           ram_ack_i\\n', '    ,input           ram_error_i\\n', '    ,input  [ 31:0]  ram_read_data_i\\n', '\\n', '    // Outputs\\n', '    ,output          axi_awready_o\\n', '    ,output          axi_wready_o\\n', '    ,output          axi_bvalid_o\\n', '    ,output [  1:0]  axi_bresp_o\\n', '    ,output [  3:0]  axi_bid_o\\n', '    ,output          axi_arready_o\\n', '    ,output          axi_rvalid_o\\n', '    ,output [ 31:0]  axi_rdata_o\\n', '    ,output [  1:0]  axi_rresp_o\\n', '    ,output [  3:0]  axi_rid_o\\n', '    ,output          axi_rlast_o\\n', '    ,output [  3:0]  ram_wr_o\\n', '    ,output          ram_rd_o\\n', '    ,output [  7:0]  ram_len_o\\n', '    ,output [ 31:0]  ram_addr_o\\n', '    ,output [ 31:0]  ram_write_data_o\\n', ');\\n', '\\n', '\\n', '\\n', '//-------------------------------------------------------------\\n', '// calculate_addr_next\\n', '//-------------------------------------------------------------\\n', 'function [31:0] calculate_addr_next;\\n', '    input [31:0] addr;\\n', '    input [1:0]  axtype;\\n', '    input [7:0]  axlen;\\n', '\\n', '    reg [31:0]   mask;\\n', 'begin\\n', '    mask = 0;\\n', '\\n', '    case (axtype)\\n', '`ifdef SUPPORT_FIXED_BURST\\n', \"    2'd0: // AXI4_BURST_FIXED\\n\", '    begin\\n', '        calculate_addr_next = addr;\\n', '    end\\n', '`endif\\n', '`ifdef SUPPORT_WRAP_BURST\\n', \"    2'd2: // AXI4_BURST_WRAP\\n\", '    begin\\n', '        case (axlen)\\n', \"        8'd0:      mask = 32'h03;\\n\", \"        8'd1:      mask = 32'h07;\\n\", \"        8'd3:      mask = 32'h0F;\\n\", \"        8'd7:      mask = 32'h1F;\\n\", \"        8'd15:     mask = 32'h3F;\\n\", \"        default:   mask = 32'h3F;\\n\", '        endcase\\n', '\\n', '        calculate_addr_next = (addr & ~mask) | ((addr + 4) & mask);\\n', '    end\\n', '`endif\\n', '    default: // AXI4_BURST_INCR\\n', '        calculate_addr_next = addr + 4;\\n', '    endcase\\n', 'end\\n', 'endfunction\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Registers / Wires\\n', '//-----------------------------------------------------------------\\n', 'reg [7:0]   req_len_q;\\n', 'reg [31:0]  req_addr_q;\\n', 'reg         req_rd_q;\\n', 'reg         req_wr_q;\\n', 'reg [3:0]   req_id_q;\\n', 'reg [1:0]   req_axburst_q;\\n', 'reg [7:0]   req_axlen_q;\\n', 'reg         req_prio_q;\\n', 'reg         req_hold_rd_q;\\n', 'reg         req_hold_wr_q;\\n', '\\n', 'wire        req_fifo_accept_w;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Sequential\\n', '//-----------------------------------------------------------------\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', 'begin\\n', \"    req_len_q     <= 8'b0;\\n\", \"    req_addr_q    <= 32'b0;\\n\", \"    req_wr_q      <= 1'b0;\\n\", \"    req_rd_q      <= 1'b0;\\n\", \"    req_id_q      <= 4'b0;\\n\", \"    req_axburst_q <= 2'b0;\\n\", \"    req_axlen_q   <= 8'b0;\\n\", \"    req_prio_q    <= 1'b0;\\n\", 'end\\n', 'else\\n', 'begin\\n', '    // Burst continuation\\n', \"    if ((ram_wr_o != 4'b0 || ram_rd_o) && ram_accept_i)\\n\", '    begin\\n', \"        if (req_len_q == 8'd0)\\n\", '        begin\\n', \"            req_rd_q   <= 1'b0;\\n\", \"            req_wr_q   <= 1'b0;\\n\", '        end\\n', '        else\\n', '        begin\\n', '            req_addr_q <= calculate_addr_next(req_addr_q, req_axburst_q, req_axlen_q);\\n', \"            req_len_q  <= req_len_q - 8'd1;\\n\", '        end\\n', '    end\\n', '\\n', '    // Write command accepted\\n', '    if (axi_awvalid_i && axi_awready_o)\\n', '    begin\\n', '        // Data ready?\\n', '        if (axi_wvalid_i && axi_wready_o)\\n', '        begin\\n', '            req_wr_q      <= !axi_wlast_i;\\n', \"            req_len_q     <= axi_awlen_i - 8'd1;\\n\", '            req_id_q      <= axi_awid_i;\\n', '            req_axburst_q <= axi_awburst_i;\\n', '            req_axlen_q   <= axi_awlen_i;\\n', '            req_addr_q    <= calculate_addr_next(axi_awaddr_i, axi_awburst_i, axi_awlen_i);\\n', '        end\\n', '        // Data not ready\\n', '        else\\n', '        begin\\n', \"            req_wr_q      <= 1'b1;\\n\", '            req_len_q     <= axi_awlen_i;\\n', '            req_id_q      <= axi_awid_i;\\n', '            req_axburst_q <= axi_awburst_i;\\n', '            req_axlen_q   <= axi_awlen_i;\\n', '            req_addr_q    <= axi_awaddr_i;\\n', '        end\\n', '        req_prio_q    <= !req_prio_q;\\n', '    end\\n', '    // Read command accepted\\n', '    else if (axi_arvalid_i && axi_arready_o)\\n', '    begin\\n', '        req_rd_q      <= (axi_arlen_i != 0);\\n', \"        req_len_q     <= axi_arlen_i - 8'd1;\\n\", '        req_addr_q    <= calculate_addr_next(axi_araddr_i, axi_arburst_i, axi_arlen_i);\\n', '        req_id_q      <= axi_arid_i;\\n', '        req_axburst_q <= axi_arburst_i;\\n', '        req_axlen_q   <= axi_arlen_i;\\n', '        req_prio_q    <= !req_prio_q;\\n', '    end\\n', 'end\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', 'begin\\n', \"    req_hold_rd_q   <= 1'b0;\\n\", \"    req_hold_wr_q   <= 1'b0;\\n\", 'end\\n', 'else\\n', 'begin\\n', '    if (ram_rd_o && !ram_accept_i)\\n', \"        req_hold_rd_q   <= 1'b1;\\n\", '    else if (ram_accept_i)\\n', \"        req_hold_rd_q   <= 1'b0;\\n\", '\\n', '    if ((|ram_wr_o) && !ram_accept_i)\\n', \"        req_hold_wr_q   <= 1'b1;\\n\", '    else if (ram_accept_i)\\n', \"        req_hold_wr_q   <= 1'b0;\\n\", 'end\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Request tracking\\n', '//-----------------------------------------------------------------\\n', \"wire       req_push_w = (ram_rd_o || (ram_wr_o != 4'b0)) && ram_accept_i;\\n\", 'reg [5:0]  req_in_r;\\n', '\\n', 'wire       req_out_valid_w;\\n', 'wire [5:0] req_out_w;\\n', 'wire       resp_accept_w;\\n', '\\n', '\\n', 'always @ *\\n', 'begin\\n', \"    req_in_r = 6'b0;\\n\", '\\n', '    // First cycle of read burst\\n', '    if (axi_arvalid_i && axi_arready_o)\\n', \"        req_in_r = {1'b1, (axi_arlen_i == 8'd0), axi_arid_i};\\n\", '    // First cycle of write burst\\n', '    else if (axi_awvalid_i && axi_awready_o)\\n', \"        req_in_r = {1'b0, (axi_awlen_i == 8'd0), axi_awid_i};\\n\", '    // In burst\\n', '    else\\n', \"        req_in_r = {ram_rd_o, (req_len_q == 8'd0), req_id_q};\\n\", 'end\\n', '\\n', 'tcm_mem_pmem_fifo2\\n', '#( .WIDTH(1 + 1 + 4) )\\n', 'u_requests\\n', '(\\n', '    .clk_i(clk_i),\\n', '    .rst_i(rst_i),\\n', '\\n', '    // Input\\n', '    .data_in_i(req_in_r),\\n', '    .push_i(req_push_w),\\n', '    .accept_o(req_fifo_accept_w),\\n', '\\n', '    // Output\\n', '    .pop_i(resp_accept_w),\\n', '    .data_out_o(req_out_w),\\n', '    .valid_o(req_out_valid_w)\\n', ');\\n', '\\n', \"wire resp_is_write_w = req_out_valid_w ? ~req_out_w[5] : 1'b0;\\n\", \"wire resp_is_read_w  = req_out_valid_w ? req_out_w[5]  : 1'b0;\\n\", 'wire resp_is_last_w  = req_out_w[4];\\n', 'wire [3:0] resp_id_w = req_out_w[3:0];\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Response buffering\\n', '//-----------------------------------------------------------------\\n', 'wire resp_valid_w;\\n', '\\n', 'tcm_mem_pmem_fifo2\\n', '#( .WIDTH(32) )\\n', 'u_response\\n', '(\\n', '    .clk_i(clk_i),\\n', '    .rst_i(rst_i),\\n', '\\n', '    // Input\\n', '    .data_in_i(ram_read_data_i),\\n', '    .push_i(ram_ack_i),\\n', '    .accept_o(),\\n', '\\n', '    // Output\\n', '    .pop_i(resp_accept_w),\\n', '    .data_out_o(axi_rdata_o),\\n', '    .valid_o(resp_valid_w)\\n', ');\\n', '\\n', '//-----------------------------------------------------------------\\n', '// RAM Request\\n', '//-----------------------------------------------------------------\\n', '\\n', '// Round robin priority between read and write\\n', 'wire write_prio_w   = ((req_prio_q  & !req_hold_rd_q) | req_hold_wr_q);\\n', 'wire read_prio_w    = ((!req_prio_q & !req_hold_wr_q) | req_hold_rd_q);\\n', '\\n', 'wire write_active_w  = (axi_awvalid_i || req_wr_q) && !req_rd_q && req_fifo_accept_w && (write_prio_w || req_wr_q || !axi_arvalid_i);\\n', 'wire read_active_w   = (axi_arvalid_i || req_rd_q) && !req_wr_q && req_fifo_accept_w && (read_prio_w || req_rd_q || !axi_awvalid_i);\\n', '\\n', 'assign axi_awready_o = write_active_w && !req_wr_q && ram_accept_i && req_fifo_accept_w;\\n', 'assign axi_wready_o  = write_active_w &&              ram_accept_i && req_fifo_accept_w;\\n', 'assign axi_arready_o = read_active_w  && !req_rd_q && ram_accept_i && req_fifo_accept_w;\\n', '\\n', 'wire [31:0] addr_w   = ((req_wr_q || req_rd_q) ? req_addr_q:\\n', '                        write_active_w ? axi_awaddr_i : axi_araddr_i);\\n', '\\n', 'wire wr_w    = write_active_w && axi_wvalid_i;\\n', 'wire rd_w    = read_active_w;\\n', '\\n', '// RAM if\\n', 'assign ram_addr_o       = addr_w;\\n', 'assign ram_write_data_o = axi_wdata_i;\\n', 'assign ram_rd_o         = rd_w;\\n', \"assign ram_wr_o         = wr_w ? axi_wstrb_i : 4'b0;\\n\", \"assign ram_len_o        = 8'b0;\\n\", '\\n', '//-----------------------------------------------------------------\\n', '// Response\\n', '//-----------------------------------------------------------------\\n', 'assign axi_bvalid_o  = resp_valid_w & resp_is_write_w & resp_is_last_w;\\n', \"assign axi_bresp_o   = 2'b0;\\n\", 'assign axi_bid_o     = resp_id_w;\\n', '\\n', 'assign axi_rvalid_o  = resp_valid_w & resp_is_read_w;\\n', \"assign axi_rresp_o   = 2'b0;\\n\", 'assign axi_rid_o     = resp_id_w;\\n', 'assign axi_rlast_o   = resp_is_last_w;\\n', '\\n', 'assign resp_accept_w    = (axi_rvalid_o & axi_rready_i) | \\n', '                          (axi_bvalid_o & axi_bready_i) |\\n', '                          (resp_valid_w & resp_is_write_w & !resp_is_last_w); // Ignore write resps mid burst\\n', '\\n', 'endmodule\\n', '\\n', '//-----------------------------------------------------------------\\n', '// FIFO\\n', '//-----------------------------------------------------------------\\n', 'module tcm_mem_pmem_fifo2\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Params\\n', '//-----------------------------------------------------------------\\n', '#(\\n', '    parameter WIDTH   = 8,\\n', '    parameter DEPTH   = 4,\\n', '    parameter ADDR_W  = 2\\n', ')\\n', '//-----------------------------------------------------------------\\n', '// Ports\\n', '//-----------------------------------------------------------------\\n', '(\\n', '    // Inputs\\n', '     input               clk_i\\n', '    ,input               rst_i\\n', '    ,input  [WIDTH-1:0]  data_in_i\\n', '    ,input               push_i\\n', '    ,input               pop_i\\n', '\\n', '    // Outputs\\n', '    ,output [WIDTH-1:0]  data_out_o\\n', '    ,output              accept_o\\n', '    ,output              valid_o\\n', ');\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Local Params\\n', '//-----------------------------------------------------------------\\n', 'localparam COUNT_W = ADDR_W + 1;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Registers\\n', '//-----------------------------------------------------------------\\n', 'reg [WIDTH-1:0]         ram [DEPTH-1:0];\\n', 'reg [ADDR_W-1:0]        rd_ptr;\\n', 'reg [ADDR_W-1:0]        wr_ptr;\\n', 'reg [COUNT_W-1:0]       count;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Sequential\\n', '//-----------------------------------------------------------------\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', 'begin\\n', \"    count   <= {(COUNT_W) {1'b0}};\\n\", \"    rd_ptr  <= {(ADDR_W) {1'b0}};\\n\", \"    wr_ptr  <= {(ADDR_W) {1'b0}};\\n\", 'end\\n', 'else\\n', 'begin\\n', '    // Push\\n', '    if (push_i & accept_o)\\n', '    begin\\n', '        ram[wr_ptr] <= data_in_i;\\n', '        wr_ptr      <= wr_ptr + 1;\\n', '    end\\n', '\\n', '    // Pop\\n', '    if (pop_i & valid_o)\\n', '        rd_ptr      <= rd_ptr + 1;\\n', '\\n', '    // Count up\\n', '    if ((push_i & accept_o) & ~(pop_i & valid_o))\\n', '        count <= count + 1;\\n', '    // Count down\\n', '    else if (~(push_i & accept_o) & (pop_i & valid_o))\\n', '        count <= count - 1;\\n', 'end\\n', '\\n', '//-------------------------------------------------------------------\\n', '// Combinatorial\\n', '//-------------------------------------------------------------------\\n', '/* verilator lint_off WIDTH */\\n', 'assign accept_o   = (count != DEPTH);\\n', 'assign valid_o    = (count != 0);\\n', '/* verilator lint_on WIDTH */\\n', '\\n', 'assign data_out_o = ram[rd_ptr];\\n', '\\n', '\\n', '\\n', 'endmodule\\n']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.6.0\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', '\\n', 'module tcm_mem_ram\\n', '(\\n', '    // Inputs\\n', '     input           clk0_i\\n', '    ,input           rst0_i\\n', '    ,input  [ 12:0]  addr0_i\\n', '    ,input  [ 63:0]  data0_i\\n', '    ,input  [  7:0]  wr0_i\\n', '    ,input           clk1_i\\n', '    ,input           rst1_i\\n', '    ,input  [ 12:0]  addr1_i\\n', '    ,input  [ 63:0]  data1_i\\n', '    ,input  [  7:0]  wr1_i\\n', '\\n', '    // Outputs\\n', '    ,output [ 63:0]  data0_o\\n', '    ,output [ 63:0]  data1_o\\n', ');\\n', '\\n', '\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Dual Port RAM 64KB\\n', '// Mode: Read First\\n', '//-----------------------------------------------------------------\\n', '/* verilator lint_off MULTIDRIVEN */\\n', 'reg [63:0]   ram [8191:0] /*verilator public*/;\\n', '/* verilator lint_on MULTIDRIVEN */\\n', '\\n', 'reg [63:0] ram_read0_q;\\n', 'reg [63:0] ram_read1_q;\\n', '\\n', '\\n', '// Synchronous write\\n', 'always @ (posedge clk0_i)\\n', 'begin\\n', '    if (wr0_i[0])\\n', '        ram[addr0_i][7:0] <= data0_i[7:0];\\n', '    if (wr0_i[1])\\n', '        ram[addr0_i][15:8] <= data0_i[15:8];\\n', '    if (wr0_i[2])\\n', '        ram[addr0_i][23:16] <= data0_i[23:16];\\n', '    if (wr0_i[3])\\n', '        ram[addr0_i][31:24] <= data0_i[31:24];\\n', '    if (wr0_i[4])\\n', '        ram[addr0_i][39:32] <= data0_i[39:32];\\n', '    if (wr0_i[5])\\n', '        ram[addr0_i][47:40] <= data0_i[47:40];\\n', '    if (wr0_i[6])\\n', '        ram[addr0_i][55:48] <= data0_i[55:48];\\n', '    if (wr0_i[7])\\n', '        ram[addr0_i][63:56] <= data0_i[63:56];\\n', '\\n', '    ram_read0_q <= ram[addr0_i];\\n', 'end\\n', '\\n', 'always @ (posedge clk1_i)\\n', 'begin\\n', '    if (wr1_i[0])\\n', '        ram[addr1_i][7:0] <= data1_i[7:0];\\n', '    if (wr1_i[1])\\n', '        ram[addr1_i][15:8] <= data1_i[15:8];\\n', '    if (wr1_i[2])\\n', '        ram[addr1_i][23:16] <= data1_i[23:16];\\n', '    if (wr1_i[3])\\n', '        ram[addr1_i][31:24] <= data1_i[31:24];\\n', '    if (wr1_i[4])\\n', '        ram[addr1_i][39:32] <= data1_i[39:32];\\n', '    if (wr1_i[5])\\n', '        ram[addr1_i][47:40] <= data1_i[47:40];\\n', '    if (wr1_i[6])\\n', '        ram[addr1_i][55:48] <= data1_i[55:48];\\n', '    if (wr1_i[7])\\n', '        ram[addr1_i][63:56] <= data1_i[63:56];\\n', '\\n', '    ram_read1_q <= ram[addr1_i];\\n', 'end\\n', '\\n', 'assign data0_o = ram_read0_q;\\n', 'assign data1_o = ram_read1_q;\\n', '\\n', '\\n', '\\n', 'endmodule\\n']"}
