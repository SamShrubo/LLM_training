{"text": "// Copyright (c) 2020 Sonal Pinto\n// SPDX-License-Identifier: Apache-2.0\n\n/*\nKronos Address Generation Unit\n  - Fancy name for a 32b adder\n*/\n\nmodule kronos_agu\n  import kronos_types::*;\n#(\n  parameter CATCH_MISALIGNED_JMP = 1,\n  parameter CATCH_MISALIGNED_LDST = 1\n)(\n  input  logic [31:0] instr,\n  input  logic [31:0] base,\n  input  logic [31:0] offset,\n  output logic [31:0] addr,\n  output logic        misaligned_jmp,\n  output logic        misaligned_ldst\n);\n\nlogic [4:0] OP;\nlogic [1:0] data_size;\n\nlogic align;\nlogic [31:0] addr_raw;\nlogic [1:0] byte_addr;\n\n// ============================================================\n// IR segments\nassign OP = instr[6:2];\nassign data_size = instr[13:12];\n\n// ============================================================\n// Adder\nassign align = OP == INSTR_JALR;\n\nalways_comb begin\n  addr_raw = base + offset;\n  addr[31:1] = addr_raw[31:1];\n  // blank the LSB for aligned add (JALR)\n  addr[0] = ~align & addr_raw[0];\nend\n\n// Tap the lowest 2b of the adder chain to detect misaligned access\n// based on instruction.\nassign byte_addr = addr[1:0];\n\n// ============================================================\n// Misaligned Detect\n\ngenerate\n  if (CATCH_MISALIGNED_JMP) begin\n    assign misaligned_jmp = (OP == INSTR_JAL || OP == INSTR_JALR || OP == INSTR_BR)\n                        && byte_addr != 2'b00;\n  end\n  else begin\n    assign misaligned_jmp = 1'b0;\n  end\nendgenerate\n\ngenerate\n  if (CATCH_MISALIGNED_LDST) begin\n    always_comb begin\n      if (OP == INSTR_LOAD || OP == INSTR_STORE) begin\n        // Memory access is misaligned if the access size\n        // doesn't land on a boundary divisible by that size.\n        if (data_size == WORD && byte_addr != 2'b00) misaligned_ldst = 1'b1;\n        else if (data_size == HALF && byte_addr[0] != 1'b0) misaligned_ldst = 1'b1;\n        else misaligned_ldst = 1'b0;\n      end\n      else misaligned_ldst = 1'b0;\n    end\n  end\n  else begin\n    assign misaligned_ldst = 1'b0;\n  end\nendgenerate\n\n// ------------------------------------------------------------\n`ifdef verilator\nlogic _unused = &{1'b0\n  , instr[31:14]\n  , instr[11:7]\n  , instr[1:0]\n};\n`endif\n\nendmodule\n"}
{"text": "// Copyright (c) 2020 Sonal Pinto\n// SPDX-License-Identifier: Apache-2.0\n\n/*\nKronos ALU\n\nThe ALU takes two operands OP1 and OP2 to generate a RESULT,\nas per the ALUOP\n\nFunctions\n  ADD     : r[0] = op1 + op2\n  SUB     : r[0] = op1 - op2\n  AND     : r[1] = op1 & op2\n  OR      : r[2] = op1 | op2\n  XOR     : r[3] = op1 ^ op2\n  LT      : r[4] = op1 < op2\n  LTU     : r[4] = op1 <u op2\n  SHL     : r[5] = op1 << op2[4:0]\n  SHR     : r[5] = op1 >> op2[4:0]\n  SHRA    : r[5] = op1 >>> op2[4:0]\n\nWhere r[0-5] are the intermediate results of these major functions\n  0: ADDER\n  1: AND\n  2: OR\n  3: XOR\n  4: COMPARATOR\n  5: BARREL SHIFTER\n*/\n\nmodule kronos_alu\n  import kronos_types::*;\n(\n  input  logic [31:0] op1,\n  input  logic [31:0] op2,\n  input  logic [3:0]  aluop,\n  output logic [31:0] result\n);\n\nlogic cin, rev, uns;\n\nlogic [31:0] r_adder, r_and, r_or, r_xor, r_shift;\n\nlogic [31:0] adder_A, adder_B;\nlogic cout;\n\nlogic A_sign, B_sign, R_sign;\nlogic r_lt, r_ltu, r_comp;\n\nlogic [31:0] data;\nlogic [4:0] shamt;\nlogic shift_in;\nlogic [31:0] p0, p1, p2, p3, p4;\n\n// ============================================================\n//  Operation Decode\nassign cin = aluop[3] || aluop[1];\nassign rev = ~aluop[2];\nassign uns = aluop[0];\n\n// ============================================================\n// Operation Execution\n\n// ADDER\nalways_comb begin\n  // OP2 can be negated for subtraction\n  adder_A = op1;\n  adder_B = cin ? ~op2 : op2;\n\n  // Add Operation\n  /* verilator lint_off WIDTH */\n  {cout, r_adder} = {1'b0, adder_A} + {1'b0, adder_B} + cin;\n  /* verilator lint_on WIDTH */\nend\n\n// LOGIC\nalways_comb begin\n  r_and = op1 & op2;\n  r_or  = op1 | op2;\n  r_xor = op1 ^ op2;\nend\n\n// COMPARATOR\nalways_comb begin\n  // Use adder to subtract operands: op1(A) - op2(B), \n  //  and obtain the sign of the result\n  A_sign = op1[31];\n  B_sign = op2[31];\n  R_sign = r_adder[31];\n\n  // Signed Less Than (LT)\n  // \n  // If the operands have the same sign, we use r_sign\n  // The result is negative if op1<op2\n  // Subtraction of two positive or two negative signed integers (2's complement)\n  //  will _never_ overflow\n  case({A_sign, B_sign})\n    2'b00: r_lt = R_sign; // Check subtraction result\n    2'b01: r_lt = 1'b0;   // op1 is positive, and op2 is negative\n    2'b10: r_lt = 1'b1;   // op1 is negative, and op2 is positive\n    2'b11: r_lt = R_sign; // Check subtraction result\n  endcase\n\n  // Unsigned Less Than (LTU)\n  // Check the carry out on op1-op2\n  r_ltu = ~cout;\n\n  // Aggregate comparator results as per ALUOP\n  r_comp = (uns) ? r_ltu : r_lt;\nend\n\n// BARREL SHIFTER\nalways_comb begin\n  // Reverse data to the shifter for SHL operations\n  data = rev ? {<<{op1}} : op1;\n  shift_in = cin & op1[31];\n  shamt = op2[4:0];\n\n  // The barrel shifter is formed by a 5-level fixed RIGHT-shifter\n  // that pipes in the value of the last stage\n\n  p0 = shamt[0] ? {    shift_in  , data[31:1]} : data;\n  p1 = shamt[1] ? {{ 2{shift_in}}, p0[31:2]}   : p0;\n  p2 = shamt[2] ? {{ 4{shift_in}}, p1[31:4]}   : p1;\n  p3 = shamt[3] ? {{ 8{shift_in}}, p2[31:8]}   : p2;\n  p4 = shamt[4] ? {{16{shift_in}}, p3[31:16]}  : p3;\n\n  // Reverse last to get SHL result\n  r_shift = rev ? {<<{p4}} : p4;\nend\n\n// ============================================================\n// Result Mux\nalways_comb begin\n  unique case(aluop)\n    SLT,\n    SLTU        : result = {31'b0, r_comp};\n    XOR         : result = r_xor;\n    OR          : result = r_or;\n    AND         : result = r_and;\n    SLL,\n    SRL,\n    SRA         : result = r_shift;\n    default     : result = r_adder; // ADD, SUB\n  endcase\nend\n\nendmodule\n"}
{"text": "// Copyright (c) 2020 Sonal Pinto\n// SPDX-License-Identifier: Apache-2.0\n\n/*\nKronos Branch Comparator\n*/\n\nmodule kronos_branch \n  import kronos_types::*;\n(\n  input  logic [2:0]  op,\n  input  logic [31:0] rs1,\n  input  logic [31:0] rs2,\n  output logic        branch\n);\n\nlogic uns;\nlogic eq, lt;\n\nassign uns = op[1];\nassign eq = rs1 == rs2;\nassign lt = uns ? (rs1 < rs2) : ($signed(rs1) < $signed(rs2));\n\nalways_comb begin\n  unique case (op)\n    BEQ: branch = eq;\n    BNE: branch = ~eq;\n    BGE,\n    BGEU: branch = ~lt;\n    default: branch = lt; // BLT, BLTU\n  endcase // op\nend\n\nendmodule\n"}
{"text": "// Copyright (c) 2020 Sonal Pinto\n// SPDX-License-Identifier: Apache-2.0\n\n/*\nKronos \n  3-stage RISC-V RV32I_Zicsr_Zifencei Core\n*/\n\nmodule kronos_core \n  import kronos_types::*;\n#(\n  parameter logic [31:0]  BOOT_ADDR = 32'h0,\n  parameter FAST_BRANCH = 1,\n  parameter EN_COUNTERS = 1,\n  parameter EN_COUNTERS64B = 1,\n  parameter CATCH_ILLEGAL_INSTR = 1,\n  parameter CATCH_MISALIGNED_JMP = 1,\n  parameter CATCH_MISALIGNED_LDST = 1\n)(\n  input  logic        clk,\n  input  logic        rstz,\n  // Instruction interface\n  output logic [31:0] instr_addr,\n  input  logic [31:0] instr_data,\n  output logic        instr_req,\n  input  logic        instr_ack,\n  // Data interface\n  output logic [31:0] data_addr,\n  input  logic [31:0] data_rd_data,\n  output logic [31:0] data_wr_data,\n  output logic [3:0]  data_mask,\n  output logic        data_wr_en,\n  output logic        data_req,\n  input  logic        data_ack,\n  // Interrupt sources\n  input  logic        software_interrupt,\n  input  logic        timer_interrupt,\n  input  logic        external_interrupt\n);\n\nlogic [31:0] immediate;\nlogic [31:0] regrd_rs1;\nlogic [31:0] regrd_rs2;\nlogic regrd_rs1_en;\nlogic regrd_rs2_en;\n\nlogic [31:0] branch_target;\nlogic branch;\n\nlogic [31:0] regwr_data;\nlogic [4:0] regwr_sel;\nlogic regwr_en;\n\nlogic flush;\n\npipeIFID_t fetch;\npipeIDEX_t decode;\n\nlogic fetch_vld, fetch_rdy;\nlogic decode_vld, decode_rdy;\n\n// ============================================================\n// Fetch\n// ============================================================\nkronos_IF #(\n  .BOOT_ADDR(BOOT_ADDR),\n  .FAST_BRANCH(FAST_BRANCH)\n) u_if (\n  .clk          (clk          ),\n  .rstz         (rstz         ),\n  .instr_addr   (instr_addr   ),\n  .instr_data   (instr_data   ),\n  .instr_req    (instr_req    ),\n  .instr_ack    (instr_ack    ),\n  .fetch        (fetch        ),\n  .immediate    (immediate    ),\n  .regrd_rs1    (regrd_rs1    ),\n  .regrd_rs2    (regrd_rs2    ),\n  .regrd_rs1_en (regrd_rs1_en ),\n  .regrd_rs2_en (regrd_rs2_en ),\n  .fetch_vld    (fetch_vld    ),\n  .fetch_rdy    (fetch_rdy    ),\n  .branch_target(branch_target),\n  .branch       (branch       ),\n  .regwr_data   (regwr_data   ),\n  .regwr_sel    (regwr_sel    ),\n  .regwr_en     (regwr_en     )\n);\n\n// ============================================================\n// Decode\n// ============================================================\nkronos_ID #(\n  .CATCH_ILLEGAL_INSTR(CATCH_ILLEGAL_INSTR),\n  .CATCH_MISALIGNED_JMP(CATCH_MISALIGNED_JMP),\n  .CATCH_MISALIGNED_LDST(CATCH_MISALIGNED_LDST)\n) u_id (\n  .clk         (clk         ),\n  .rstz        (rstz        ),\n  .flush       (flush       ),\n  .fetch       (fetch       ),\n  .immediate   (immediate   ),\n  .regrd_rs1   (regrd_rs1   ),\n  .regrd_rs2   (regrd_rs2   ),\n  .regrd_rs1_en(regrd_rs1_en),\n  .regrd_rs2_en(regrd_rs2_en),\n  .fetch_vld   (fetch_vld   ),\n  .fetch_rdy   (fetch_rdy   ),\n  .decode      (decode      ),\n  .decode_vld  (decode_vld  ),\n  .decode_rdy  (decode_rdy  ),\n  .regwr_data  (regwr_data  ),\n  .regwr_sel   (regwr_sel   ),\n  .regwr_en    (regwr_en    )\n);\n\n// ============================================================\n// Execute\n// ============================================================\nkronos_EX #(\n  .BOOT_ADDR     (BOOT_ADDR),\n  .EN_COUNTERS   (EN_COUNTERS),\n  .EN_COUNTERS64B(EN_COUNTERS64B)\n) u_ex (\n  .clk               (clk               ),\n  .rstz              (rstz              ),\n  .decode            (decode            ),\n  .decode_vld        (decode_vld        ),\n  .decode_rdy        (decode_rdy        ),\n  .regwr_data        (regwr_data        ),\n  .regwr_sel         (regwr_sel         ),\n  .regwr_en          (regwr_en          ),\n  .branch_target     (branch_target     ),\n  .branch            (branch            ),\n  .data_addr         (data_addr         ),\n  .data_rd_data      (data_rd_data      ),\n  .data_wr_data      (data_wr_data      ),\n  .data_mask         (data_mask         ),\n  .data_wr_en        (data_wr_en        ),\n  .data_req          (data_req          ),\n  .data_ack          (data_ack          ),\n  .software_interrupt(software_interrupt),\n  .timer_interrupt   (timer_interrupt   ),\n  .external_interrupt(external_interrupt)\n);\n\n// Flush pipeline on branch\nassign flush = branch;\n\nendmodule\n"}
{"text": "// Copyright (c) 2020 Sonal Pinto\n// SPDX-License-Identifier: Apache-2.0\n\n/*\nStaggered 64b counter for Kronos RISC-V\n\nThe counter is made of two 32b counters splitting the critical path\nfor lower-end implementations (ex: Lattice iCE40UP)\nThe upper word update is delayed by a cycle\n*/\n\nmodule kronos_counter64 #(\n  parameter EN_COUNTERS = 1,\n  parameter EN_COUNTERS64B = 1\n)(\n  input  logic        clk,\n  input  logic        rstz,\n  input  logic        incr,\n  input  logic [31:0] load_data,\n  input  logic        load_low,\n  input  logic        load_high,\n  output logic [63:0] count,\n  output logic        count_vld\n);\n\nlogic [31:0] count_low, count_high;\nlogic incr_high;\n\nalways_ff @(posedge clk or negedge rstz) begin\n  if (~rstz) begin\n    count_low <= '0;\n    count_high <= '0;\n    incr_high <= 1'b0;\n  end\n  else begin\n    incr_high <= 1'b0;\n\n    // during a load (any segment), the count is paused\n    if (load_low) count_low <= load_data;\n    else if (load_high) count_high <= load_data;\n    else begin\n      if (incr) begin\n        count_low <= count_low + 1'b1;\n        // indicate that the upper word needs to increment\n        incr_high <= count_low == '1;\n      end\n\n      if (incr_high) count_high <= count_high + 1'b1;\n    end\n  end\nend\n\ngenerate\n  if (EN_COUNTERS) begin\n    if (EN_COUNTERS64B) begin\n      // the output 64b count is valid when the upper word update has settled\n      assign count = {count_high, count_low};\n      assign count_vld = ~incr_high;\n    end\n    else begin\n      // the upper word will be optimized out\n      assign count = {32'b0, count_low};\n      assign count_vld = 1'b1;\n    end\n  end\n  else begin\n    assign count = '0;\n    assign count_vld = 1'b1;\n  end\nendgenerate\n\nendmodule\n"}
{"text": "// Copyright (c) 2020 Sonal Pinto\n// SPDX-License-Identifier: Apache-2.0\n\n/*\nKronos RISC-V Machine-Level CSRs v1.11\n\nThis is a partial implementation with the following CSRs:\n- Machine Trap Setup\n  * mstatus: mie, mpie, mpp\n  * mie: msie, mtie, meie\n  * mtvec\n- Machine Trap Handling\n  * mscratch\n  * mepc\n  * mcause\n  * mtval\n  * mip\n- Machine Hardware Performance Counters\n  * mcycle/mcycleh\n  * minstret/minstreth\n\nmtvec takes only Direct mode (mtvec.mode = 2'b00) for trap handler jumps\n\nThe module also acts as an interruptor funneling the various interrupt source\nspec'd in the privileged machine-level architecture. Namely, External, Timer \nand Software interrupts\n*/\n\nmodule kronos_csr\n  import kronos_types::*;\n#(\n  parameter logic [31:0]  BOOT_ADDR = 32'h0,\n  parameter EN_COUNTERS = 1,\n  parameter EN_COUNTERS64B = 1\n)(\n  input  logic        clk,\n  input  logic        rstz,\n  // CSR\n  input  pipeIDEX_t   decode,\n  input  logic        csr_vld,\n  output logic        csr_rdy,\n  output logic [31:0] csr_data,\n  output logic        regwr_csr,\n  // Trackers\n  input  logic        instret,\n  // trap handling\n  input  logic        activate_trap,\n  input  logic        return_trap,\n  input  logic [31:0] trap_cause,\n  input  logic [31:0] trap_value,\n  output logic [31:0] trap_handle,\n  output logic        trap_jump,\n  // interrupts\n  input  logic        software_interrupt,\n  input  logic        timer_interrupt,\n  input  logic        external_interrupt,\n  output logic        core_interrupt,\n  output logic [3:0]  core_interrupt_cause\n);\n\nlogic [2:0] funct3;\nlogic [11:0] addr;\nlogic [4:0] zimm, rd;\nlogic [31:0] wr_data;\n\nlogic [31:0] csr_rd_data, csr_wr_data;\nlogic csr_rd_vld, csr_wr_vld;\nlogic csr_rd_en, csr_wr_en;\n\nstruct packed {\n  logic [1:0] mpp;\n  logic mpie;\n  logic mie;\n} mstatus;\n\nstruct packed {\n  logic meie;\n  logic mtie;\n  logic msie;\n} mie;\n\nstruct packed {\n  logic meip;\n  logic mtip;\n  logic msip;\n} mip;\n\nstruct packed {\n  logic [29:0] base;\n  logic [1:0] mode;\n} mtvec;\n\nlogic [31:0] mscratch, mepc, mcause, mtval;\n\nlogic mcycle_wrenl, mcycle_wrenh;\nlogic mcycle_rd_vld;\nlogic [63:0] mcycle;\n\nlogic minstret_wrenl, minstret_wrenh;\nlogic minstret_rd_vld;\nlogic [63:0] minstret;\n\nenum logic [1:0] {\n  IDLE,\n  READ,\n  WRITE\n} state, next_state;\n\n// ============================================================\n// Extract decoded segments\n\n// IR segments\nassign addr = decode.ir[31-:12];\nassign funct3 = decode.ir[14:12];\nassign rd = decode.ir[11:7];\nassign zimm = decode.ir[19:15];\n\n// CSR Write data - either zero-extended 5b immediate or REG[rs1]\nassign wr_data = funct3[2] ? {27'b0, zimm} : decode.op1;\n\n// ============================================================\n// CSR Sequencer\nassign csr_rdy = state == WRITE;\n\nalways_ff @(posedge clk or negedge rstz) begin\n  if (~rstz) state <= IDLE;\n  else state <= next_state;\nend\n\nalways_comb begin\n  next_state = state;\n  /* verilator lint_off CASEINCOMPLETE */\n  unique case (state)\n    // Atomic Read/Modify/Write\n    IDLE: if (csr_vld && decode.csr) next_state = READ;\n    READ: if (csr_rd_vld) next_state = WRITE;\n    WRITE: next_state = IDLE;\n  endcase // state\n  /* verilator lint_on CASEINCOMPLETE */\nend\n\nalways_ff @(posedge clk or negedge rstz) begin\n  if (~rstz) begin\n    csr_wr_vld <= 1'b0;\n    regwr_csr <= 1'b0;\n  end\n  else if (state == IDLE && csr_vld && decode.csr) begin\n    // Cancel the CSR write for csrrc/rs if rs1(zimm)=0\n    csr_wr_vld <= ~((funct3 == 3'b010 || funct3 == 3'b011) && zimm == '0);\n\n    // Cancel the CSR register writeback for rd == 0\n    regwr_csr <= rd != '0;\n  end\nend\n\n// CSR R/W ----------------------------------------------------\n// aggregate all read-valid sources\nassign csr_rd_vld = mcycle_rd_vld && minstret_rd_vld;\n\n// CSR read/write access\nassign csr_rd_en = state == READ && csr_rd_vld;\nassign csr_wr_en = state == WRITE && csr_wr_vld;\n\n// Register write back\nalways_ff @(posedge clk) begin\n  if (csr_rd_en) csr_data <= csr_rd_data;\nend\n\n// Trap Handling ----------------------------------------------\nalways_ff @(posedge clk or negedge rstz) begin\n  if (~rstz) trap_jump <= 1'b0;\n  else if (activate_trap) begin\n    trap_jump <= 1'b1;\n    trap_handle <= mtvec; // Direct Mode\n  end\n  else if (return_trap) begin\n    trap_jump <= 1'b1;\n    trap_handle <= mepc;\n  end\n  else trap_jump <= 1'b0;\nend\n\n// ============================================================\n// CSR Read\nalways_comb begin\n  csr_rd_data  = '0;\n  /* verilator lint_off CASEINCOMPLETE */\n  case(addr)\n    MSTATUS : begin\n      csr_rd_data[3]    = mstatus.mie; \n      csr_rd_data[7]    = mstatus.mpie;\n      csr_rd_data[12:11]= mstatus.mpp;\n    end\n\n    MIE : begin\n      csr_rd_data[3]  = mie.msie; \n      csr_rd_data[7]  = mie.mtie;\n      csr_rd_data[11] = mie.meie;\n    end\n\n    MTVEC     : csr_rd_data = mtvec;\n    MSCRATCH  : csr_rd_data = mscratch;\n    MEPC      : csr_rd_data = mepc;\n    MCAUSE    : csr_rd_data = mcause;\n    MTVAL     : csr_rd_data = mtval;\n\n    MIP : begin\n      csr_rd_data[3]  = mip.msip; \n      csr_rd_data[7]  = mip.mtip;\n      csr_rd_data[11] = mip.meip;\n    end\n\n    MCYCLE    : csr_rd_data = mcycle[31:0];\n    MINSTRET  : csr_rd_data = minstret[31:0];\n    MCYCLEH   : csr_rd_data = mcycle[63:32];\n    MINSTRETH : csr_rd_data = minstret[63:32];\n  endcase // addr\n  /* verilator lint_on CASEINCOMPLETE */\nend\n\n// ============================================================\n// CSR Write\nalways_comb begin\n  // Modify latched rd_data as per operation\n  // RS: Set - wr_data as a set mask\n  // RC: Clear - wr_data as a clear mask\n  // RW/Default: wr_data as write data\n  case (funct3[1:0])\n    CSR_RS: csr_wr_data = csr_data | wr_data;\n    CSR_RC: csr_wr_data = csr_data & ~wr_data;\n    default: csr_wr_data = wr_data;\n  endcase\nend\n\nalways_ff @(posedge clk or negedge rstz) begin\n  if (~rstz) begin\n    mstatus.mie <= 1'b0;\n    mstatus.mpie <= 1'b0;\n    mstatus.mpp <= PRIVILEGE_MACHINE; // Machine Mode\n    mip <= '0;\n    mie <= '0;\n    mtvec.base <= BOOT_ADDR[31:2];\n    mtvec.mode <= DIRECT_MODE; // Direct Mode\n  end\n  else begin\n    // Machine-mode writable registers\n    if (csr_wr_en) begin\n      /* verilator lint_off CASEINCOMPLETE */\n      case (addr)\n\n        MSTATUS: begin\n          // Global Interrupt enable\n          mstatus.mie <= csr_wr_data[3];\n          // Previous mie, used as a stack for mie when jumping/returning from traps\n          mstatus.mpie <= csr_wr_data[7];\n        end\n\n        MIE: begin\n          // Interrupt Enables: Software, Timer and External\n          mie.msie <= csr_wr_data[3];\n          mie.mtie <= csr_wr_data[7];\n          mie.meie <= csr_wr_data[11];\n        end\n\n        MTVEC: begin\n          // Trap vector, only Direct Mode is supported\n          mtvec.base <= csr_wr_data[31:2];\n        end\n\n        // Scratch register\n        MSCRATCH: mscratch <= csr_wr_data;\n\n        // Exception Program Counter\n        // IALIGN=32, word aligned\n        MEPC: mepc <= {csr_wr_data[31:2], 2'b00};\n\n        // Trap cause register\n        MCAUSE: mcause <= csr_wr_data;\n\n        // Trap value register\n        MTVAL: mtval <= csr_wr_data;\n\n      endcase // addr\n      /* verilator lint_on CASEINCOMPLETE */\n    end\n    else if (activate_trap) begin\n      mstatus.mie <= 1'b0;\n      mstatus.mpie <= mstatus.mie;\n      mepc <= {decode.pc[31:2], 2'b00};\n      mcause <= trap_cause;\n      mtval <= trap_value;\n    end\n    else if (return_trap) begin\n      mstatus.mie <= mstatus.mpie;\n      mstatus.mpie <= 1'b1;\n    end\n\n    // MIP: Machine Interrupt Pending is merely a aggregator for interrupt sources\n    // The interrupt is cleared by addressing the interrupt\n    // msip: clear the memory mapped software interrupt register\n    // mtip: cleared by writing to mtimecmp\n    // meip: cleared by addressing external interrupt handler (PLIC)\n    mip.msip <= software_interrupt & mstatus.mie & mie.msie;\n    mip.mtip <= timer_interrupt    & mstatus.mie & mie.mtie;\n    mip.meip <= external_interrupt & mstatus.mie & mie.meie;\n  end\nend\n\n// ============================================================\n// Core Interrupter\n\nalways_ff @(posedge clk or negedge rstz) begin\n  if (~rstz) begin\n    core_interrupt <= 1'b0;\n  end\n  else begin\n    // Inform the WB stage about pending interrupts\n    core_interrupt <= |{mip};\n\n    // core_interrupt_cause maps the interrupt cause according to priority\n    if (mip.meip)\n      core_interrupt_cause <= EXTERNAL_INTERRUPT;\n    else if (mip.msip) \n      core_interrupt_cause <= SOFTWARE_INTERRUPT;\n    else if (mip.mtip) \n      core_interrupt_cause <= TIMER_INTERRUPT;\n  end\nend\n\n// ============================================================\n// Hardware Performance Monitors\n\n// mcycle, 64b Machine cycle counter\nassign mcycle_wrenl = csr_wr_en && addr == MCYCLE;\nassign mcycle_wrenh = csr_wr_en && addr == MCYCLEH;\n\nkronos_counter64 #(\n  .EN_COUNTERS   (EN_COUNTERS),\n  .EN_COUNTERS64B(EN_COUNTERS64B)\n) u_hpmcounter0 (\n  .clk      (clk          ),\n  .rstz     (rstz         ),\n  .incr     (1'b1         ),\n  .load_data(csr_wr_data  ),\n  .load_low (mcycle_wrenl ),\n  .load_high(mcycle_wrenh ),\n  .count    (mcycle       ),\n  .count_vld(mcycle_rd_vld)\n);\n\n// minstret, 64b Machine instructions-retired counter\nassign minstret_wrenl = csr_wr_en && addr == MINSTRET;\nassign minstret_wrenh = csr_wr_en && addr == MINSTRETH;\n\nkronos_counter64 #(\n  .EN_COUNTERS   (EN_COUNTERS),\n  .EN_COUNTERS64B(EN_COUNTERS64B)\n) u_hpmcounter1 (\n  .clk      (clk            ),\n  .rstz     (rstz           ),\n  .incr     (instret        ),\n  .load_data(csr_wr_data    ),\n  .load_low (minstret_wrenl ),\n  .load_high(minstret_wrenh ),\n  .count    (minstret       ),\n  .count_vld(minstret_rd_vld)\n);\n\n// ------------------------------------------------------------\n`ifdef verilator\nlogic _unused = &{1'b0\n  , decode\n};\n`endif\n\nendmodule\n"}
{"text": "// Copyright (c) 2020 Sonal Pinto\n// SPDX-License-Identifier: Apache-2.0\n\n/*\nKronos Execution Unit\n*/\n\nmodule kronos_EX\n  import kronos_types::*;\n#(\n  parameter logic [31:0]  BOOT_ADDR = 32'h0,\n  parameter EN_COUNTERS = 1,\n  parameter EN_COUNTERS64B = 1\n)(\n  input  logic        clk,\n  input  logic        rstz,\n  // ID/EX\n  input  pipeIDEX_t   decode,\n  input  logic        decode_vld,\n  output logic        decode_rdy,\n  // REG Write\n  output logic [31:0] regwr_data,\n  output logic [4:0]  regwr_sel,\n  output logic        regwr_en,\n  // Branch\n  output logic [31:0] branch_target,\n  output logic        branch,\n  // Data interface\n  output logic [31:0] data_addr,\n  input  logic [31:0] data_rd_data,\n  output logic [31:0] data_wr_data,\n  output logic [3:0]  data_mask,\n  output logic        data_wr_en,\n  output logic        data_req,\n  input  logic        data_ack,\n  // Interrupt sources\n  input  logic        software_interrupt,\n  input  logic        timer_interrupt,\n  input  logic        external_interrupt\n);\n\nlogic [31:0] result;\nlogic [4:0] rd;\n\nlogic instr_vld;\nlogic instr_jump;\nlogic basic_rdy;\n\nlogic lsu_vld, lsu_rdy;\nlogic [31:0] load_data;\nlogic regwr_lsu;\n\nlogic csr_vld,csr_rdy;\nlogic [31:0] csr_data;\nlogic regwr_csr;\nlogic instret;\nlogic core_interrupt;\nlogic [3:0] core_interrupt_cause;\n\nlogic exception;\n\nlogic activate_trap, return_trap;\nlogic [31:0] trap_cause, trap_handle, trap_value;\nlogic trap_jump;\n\nenum logic [2:0] {\n  STEADY,\n  LSU,\n  CSR,\n  TRAP,\n  RETURN,\n  WFINTR,\n  JUMP\n} state, next_state;\n\n\n// ============================================================\n// IR Segments\nassign rd  = decode.ir[11:7];\n\n// ============================================================\n// EX Sequencer\nalways_ff @(posedge clk or negedge rstz) begin\n  if (~rstz) state <= STEADY;\n  else state <= next_state;\nend\n\nalways_comb begin\n  next_state = state;\n  /* verilator lint_off CASEINCOMPLETE */\n  unique case (state)\n    STEADY: if (decode_vld) begin\n      if (core_interrupt) next_state = TRAP;\n      else if (exception) next_state = TRAP;\n      else if (decode.system) begin\n        unique case (decode.sysop)\n          ECALL,\n          EBREAK: next_state = TRAP;\n          MRET  : next_state = RETURN;\n          WFI   : next_state = WFINTR;\n        endcase\n      end\n      else if (decode.load || decode.store) next_state = LSU;\n      else if (decode.csr) next_state = CSR;\n    end\n\n    LSU: if (lsu_rdy) next_state = STEADY;\n\n    CSR: if (csr_rdy) next_state = STEADY;\n\n    WFINTR: if (core_interrupt) next_state = TRAP;\n\n    TRAP: next_state = JUMP;\n\n    RETURN: next_state = JUMP;\n\n    JUMP: if (trap_jump) next_state = STEADY;\n\n  endcase // state\n  /* verilator lint_on CASEINCOMPLETE */\nend\n\n// Decoded instruction valid\nassign instr_vld = decode_vld && state == STEADY && ~exception && ~core_interrupt;\n\n// Basic instructions\nassign basic_rdy = instr_vld && decode.basic;\n\n// Next instructions\nassign decode_rdy = |{basic_rdy, lsu_rdy, csr_rdy};\n\n// ============================================================\n// ALU\nkronos_alu u_alu (\n  .op1   (decode.op1  ),\n  .op2   (decode.op2  ),\n  .aluop (decode.aluop),\n  .result(result      )\n);\n\n// ============================================================\n// LSU\nassign lsu_vld = instr_vld || state == LSU;\n\nkronos_lsu u_lsu (\n  .decode      (decode      ),\n  .lsu_vld     (lsu_vld     ),\n  .lsu_rdy     (lsu_rdy     ),\n  .load_data   (load_data   ),\n  .regwr_lsu   (regwr_lsu   ),\n  .data_addr   (data_addr   ),\n  .data_rd_data(data_rd_data),\n  .data_wr_data(data_wr_data),\n  .data_mask   (data_mask   ),\n  .data_wr_en  (data_wr_en  ),\n  .data_req    (data_req    ),\n  .data_ack    (data_ack    )\n);\n\n// ============================================================\n// Register Write Back\n\nalways_ff @(posedge clk or negedge rstz) begin\n  if (~rstz) begin\n    regwr_en <= 1'b0;\n  end\n  else begin\n    regwr_sel <= rd;\n\n    if (instr_vld && decode.regwr_alu) begin\n      // Write back ALU result\n      regwr_en <= 1'b1;\n      regwr_data <= result;\n    end\n    else if (lsu_rdy && regwr_lsu) begin\n      // Write back Load Data\n      regwr_en <= 1'b1;\n      regwr_data <= load_data;\n    end\n    else if (csr_rdy && regwr_csr) begin\n      // Write back CSR Read Data\n      regwr_en <= 1'b1;\n      regwr_data <= csr_data;\n    end\n    else begin\n      regwr_en <= 1'b0;\n    end\n  end\nend\n\n// ============================================================\n// Jump and Branch\nassign branch_target = trap_jump ? trap_handle : decode.addr;\nassign instr_jump =  decode.jump || decode.branch;\nassign branch = (instr_vld && instr_jump) || trap_jump;\n\n// ============================================================\n// Trap Handling\n\nassign exception = decode.illegal || decode.misaligned_ldst || (instr_jump && decode.misaligned_jmp);\n\n// setup for trap\nalways_ff @(posedge clk) begin\n  if (decode_vld && state == STEADY) begin\n    if (core_interrupt) begin\n      trap_cause <= {1'b1, 27'b0, core_interrupt_cause};\n      trap_value <= '0;\n    end\n    else if (decode.illegal) begin\n      trap_cause <= {28'b0, ILLEGAL_INSTR};\n      trap_value <= decode.ir;\n    end\n    else if (decode.misaligned_jmp && instr_jump) begin\n      trap_cause <= {28'b0, INSTR_ADDR_MISALIGNED};\n      trap_value <= decode.addr;\n    end\n    else if (decode.misaligned_ldst && decode.load) begin\n      trap_cause <= {28'b0, LOAD_ADDR_MISALIGNED};\n      trap_value <= decode.addr;\n    end\n    else if (decode.misaligned_ldst && decode.store) begin\n      trap_cause <= {28'b0, STORE_ADDR_MISALIGNED};\n      trap_value <= decode.addr;\n    end\n    else if (decode.sysop == ECALL) begin\n      trap_cause <= {28'b0, ECALL_MACHINE};\n      trap_value <= '0;\n    end\n    else if (decode.sysop == EBREAK) begin\n      trap_cause <= {28'b0, BREAKPOINT};\n      trap_value <= decode.pc;\n    end\n  end\n  else if (state == WFINTR) begin\n    if (core_interrupt) begin\n      trap_cause <= {1'b1, 27'b0, core_interrupt_cause};\n      trap_value <= '0;\n    end\n  end\nend\n\n// ============================================================\n// CSR\nassign csr_vld = instr_vld || state == CSR;\n\nkronos_csr #(\n  .BOOT_ADDR     (BOOT_ADDR     ),\n  .EN_COUNTERS   (EN_COUNTERS   ),\n  .EN_COUNTERS64B(EN_COUNTERS64B)\n) u_csr (\n  .clk                 (clk                 ),\n  .rstz                (rstz                ),\n  .decode              (decode              ),\n  .csr_vld             (csr_vld             ),\n  .csr_rdy             (csr_rdy             ),\n  .csr_data            (csr_data            ),\n  .regwr_csr           (regwr_csr           ),\n  .instret             (instret             ),\n  .activate_trap       (activate_trap       ),\n  .return_trap         (return_trap         ),\n  .trap_cause          (trap_cause          ),\n  .trap_value          (trap_value          ),\n  .trap_handle         (trap_handle         ),\n  .trap_jump           (trap_jump           ),\n  .software_interrupt  (software_interrupt  ),\n  .timer_interrupt     (timer_interrupt     ),\n  .external_interrupt  (external_interrupt  ),\n  .core_interrupt      (core_interrupt      ),\n  .core_interrupt_cause(core_interrupt_cause)\n);\n\nassign activate_trap = state == TRAP;\nassign return_trap = state == RETURN;\n\n// instruction retired event\nalways_ff @(posedge clk or negedge rstz) begin\n  if (~rstz) instret <= 1'b0;\n  else instret <= (decode_vld && decode_rdy)\n              || (decode.system && trap_jump);\nend\n\nendmodule\n"}
{"text": "// Copyright (c) 2020 Sonal Pinto\n// SPDX-License-Identifier: Apache-2.0\n\n/*\nKronos Hazard Control Unit\n\nMinimalist HCU to detect pending writes on an operand and assert a STALL\ncondition that halts the pipeline.\n*/\n\nmodule kronos_hcu \n  import kronos_types::*;\n(\n  input  logic        clk,\n  input  logic        rstz,\n  input  logic        flush,\n  // Instruction\n  input  logic [31:0] instr,\n  input  logic        regrd_rs1_en,\n  input  logic        regrd_rs2_en,\n  input  logic        fetch_vld,\n  input  logic        fetch_rdy,\n  // REG Write\n  input  logic [4:0]  regwr_sel,\n  input  logic        regwr_en,\n  // Stall\n  output logic        stall\n);\n\nlogic [4:0] OP;\nlogic [4:0] rs1, rs2, rd;\nlogic [2:0] funct3;\n\n// Hazard controls\nlogic is_reg_write, csr_regwr;\nlogic regwr_pending;\nlogic rs1_hazard, rs2_hazard;\nlogic [4:0] rpend;\n\n// ============================================================\n// Hazard Tracking and Control\n\n// Aliases to IR segments\nassign OP = instr[6:2];\nassign rs1 = instr[19:15];\nassign rs2 = instr[24:20];\nassign rd  = instr[11: 7];\nassign funct3 = instr[14:12];\n\n// Indicates a register will be written by this instructions\n// regardless of source. This is useful for hazard tracking\nassign is_reg_write = (rd != '0) &&  (OP == INSTR_LUI\n                    || OP == INSTR_AUIPC\n                    || OP == INSTR_JAL\n                    || OP == INSTR_JALR\n                    || OP == INSTR_OPIMM \n                    || OP == INSTR_OP\n                    || OP == INSTR_LOAD\n                    || csr_regwr);\n\nassign csr_regwr = OP == INSTR_SYS && (funct3 == 3'b001\n                    || funct3 == 3'b010\n                    || funct3 == 3'b011\n                    || funct3 == 3'b101\n                    || funct3 == 3'b110\n                    || funct3 == 3'b111);\n\n// Hazard on register operands\nassign rs1_hazard = regrd_rs1_en & regwr_pending & rpend == rs1;\nassign rs2_hazard = regrd_rs2_en & regwr_pending & rpend == rs2;\n\n// Stall condition if either operand has a hazard,\n// and register write back isn't ready\nassign stall = (rs1_hazard | rs2_hazard) & ~(regwr_en & rpend == regwr_sel);\n\nalways_ff @(posedge clk or negedge rstz) begin\n  if (~rstz) begin\n    regwr_pending <= 1'b0;\n  end\n  else begin\n    if (flush) begin\n      regwr_pending <= 1'b0;\n    end\n    else if(fetch_vld && fetch_rdy) begin\n      regwr_pending <= is_reg_write;\n      rpend <= rd;\n    end\n    else if(regwr_pending) begin\n      regwr_pending <= ~(regwr_en & rpend == regwr_sel);\n    end\n  end\nend\n\n// ------------------------------------------------------------\n`ifdef verilator\nlogic _unused = &{1'b0\n    , instr[1:0]\n    , instr[31:25]\n};\n`endif\n\nendmodule\n"}
{"text": "// Copyright (c) 2020 Sonal Pinto\n// SPDX-License-Identifier: Apache-2.0\n\n/*\nKronos RV32I Decoder\n  - Arranges operands (OP1/OP2) and ALUOP for the alu in the EX stage.\n  - Evaluates branch condition for branch instructions.\n  - Generates branch target or memory access address.\n  - Generates store data and mask.\n  - Detects misaligned jumps and memory access\n  - Tracks hazards on register operands and stalls if necessary.\n*/\n\nmodule kronos_ID\n  import kronos_types::*;\n#(\n  parameter CATCH_ILLEGAL_INSTR = 1,\n  parameter CATCH_MISALIGNED_JMP = 1,\n  parameter CATCH_MISALIGNED_LDST = 1\n)(\n  input  logic        clk,\n  input  logic        rstz,\n  input  logic        flush,\n  // IF/ID\n  input  pipeIFID_t   fetch,\n  input  logic [31:0] immediate,\n  input  logic [31:0] regrd_rs1,\n  input  logic [31:0] regrd_rs2,\n  input  logic        regrd_rs1_en,\n  input  logic        regrd_rs2_en,\n  input  logic        fetch_vld,\n  output logic        fetch_rdy,\n  // ID/EX\n  output pipeIDEX_t   decode,\n  output logic        decode_vld,\n  input  logic        decode_rdy,\n  // REG Write\n  input  logic [31:0] regwr_data,\n  input  logic [4:0]  regwr_sel,\n  input  logic        regwr_en\n);\n\nlogic [31:0] IR, PC;\nlogic [4:0] OP;\nlogic [6:0] opcode;\nlogic [4:0] rs1, rs2, rd;\nlogic [2:0] funct3;\nlogic [6:0] funct7;\nlogic [1:0] data_size;\n\nlogic [31:0] op1, op2;\nlogic [3:0] aluop;\nlogic regwr_alu;\nlogic branch;\nlogic csr;\nlogic [1:0] sysop;\nlogic is_fencei;\n\nlogic illegal;\nlogic instr_valid;\nlogic illegal_opcode;\n\n// Address generation\nlogic [31:0] addr, base, offset;\nlogic misaligned_jmp;\nlogic misaligned_ldst;\n\n// Memory Access\nlogic [3:0] mask;\nlogic [1:0] byte_addr;\nlogic [3:0][7:0] sdata, store_data;\n\n// Register forwarding\nlogic rs1_forward, rs2_forward;\nlogic [31:0] rs1_data, rs2_data;\n\n// Stall Condition\nlogic stall;\n\n// ============================================================\n// Instruction Decoder\n\nassign IR = fetch.ir;\nassign PC = fetch.pc;\n\n// Aliases to IR segments\nassign opcode = IR[6:0];\nassign OP = opcode[6:2];\nassign rs1 = IR[19:15];\nassign rs2 = IR[24:20];\nassign rd  = IR[11: 7];\nassign funct3 = IR[14:12];\nassign funct7 = IR[31:25];\nassign data_size = funct3[1:0];\n\n// opcode is illegal if LSB 2b are not 2'b11\nassign illegal_opcode = opcode[1:0] != 2'b11;\n\n// ============================================================\n// Register Write\n// Write the result of the ALU back into the Registers\nassign regwr_alu = (rd != '0) && (OP == INSTR_LUI\n                    || OP == INSTR_AUIPC\n                    || OP == INSTR_JAL\n                    || OP == INSTR_JALR\n                    || OP == INSTR_OPIMM \n                    || OP == INSTR_OP);\n\n// ============================================================\n// Register Forwarding\nassign rs1_forward = regwr_en & (regwr_sel == rs1);\nassign rs2_forward = regwr_en & (regwr_sel == rs2);\n\nassign rs1_data = rs1_forward ? regwr_data : regrd_rs1;\nassign rs2_data = rs2_forward ? regwr_data : regrd_rs2;\n\n// ============================================================\n// Operation Decoder\nalways_comb begin\n  instr_valid = 1'b0;\n  is_fencei = 1'b0;\n  sysop = 2'b0;\n  csr = 1'b0;\n\n  // Default ALU Operation is ADD\n  aluop = ADD;\n\n  // Default ALU Operands\n  op1 = PC;\n  op2 = FOUR;\n\n  // Default addressGen operands\n  base = PC;\n  offset = FOUR;\n\n  // Memory Access\n  byte_addr = addr[1:0];\n\n  // Memory access\n  sdata = rs2_data;\n\n  // setup write data\n  // Barrel Rotate Left store_data bytes as per offset\n  case(byte_addr)\n    2'b00: store_data = sdata;\n    2'b01: store_data = {sdata[2:0], sdata[3]};\n    2'b10: store_data = {sdata[1:0], sdata[3:2]};\n    2'b11: store_data = {sdata[0]  , sdata[3:1]};\n  endcase\n\n  if (OP == INSTR_STORE) begin\n    if (data_size == BYTE) mask = 4'h1 << byte_addr;\n    else if (data_size == HALF) mask = byte_addr[1] ? 4'hC : 4'h3;\n    else mask = 4'hF;\n  end\n  else begin\n    mask = 4'hF;\n  end\n\n  /* verilator lint_off CASEINCOMPLETE */\n  unique case(OP)\n    // --------------------------------\n    INSTR_LUI: begin\n      op1 = ZERO;\n      op2 = immediate;\n      instr_valid = 1'b1;\n    end\n    // --------------------------------\n    INSTR_AUIPC: begin\n      op2 = immediate;\n      instr_valid = 1'b1;\n    end\n    // --------------------------------\n    INSTR_JAL: begin\n      op2 = FOUR;\n      offset = immediate;\n      instr_valid = 1'b1;\n    end\n    // --------------------------------\n    INSTR_JALR: begin\n      op2 = FOUR;\n      base = rs1_data;\n      offset = immediate;\n      instr_valid = funct3 == 3'b000;\n    end\n    // --------------------------------\n    INSTR_BR: begin\n      offset = immediate;\n\n      case(funct3)\n        BEQ,\n        BNE,\n        BLT,\n        BGE,\n        BLTU,\n        BGEU:\n          instr_valid  = 1'b1;\n      endcase // funct3\n    end\n    // --------------------------------\n    INSTR_LOAD: begin\n      base = rs1_data;\n      offset = immediate;\n\n      case(funct3)\n        3'b000, // LB\n        3'b001, // LH\n        3'b010, // LW\n        3'b100, // LBU\n        3'b101: // LHU \n          instr_valid = 1'b1;\n      endcase // funct3\n    end\n    // --------------------------------\n    INSTR_STORE: begin\n      op2 = store_data;\n      base = rs1_data;\n      offset = immediate;\n\n      case(funct3)\n        3'b000, // SB\n        3'b001, // SH\n        3'b010: // SW\n          instr_valid = 1'b1;\n      endcase // funct3\n    end\n    // --------------------------------\n    INSTR_OPIMM: begin\n      if (funct3 == 3'b001 || funct3 == 3'b101) aluop = {funct7[5], funct3};\n      else aluop = {1'b0, funct3};\n\n      op1 = rs1_data;\n      op2 = immediate;\n\n      case(funct3)\n        3'b000, // ADDI\n        3'b010, // SLTI\n        3'b011, // SLTIU\n        3'b100, // XORI\n        3'b110, // ORI\n        3'b111: // ANDI\n          instr_valid = 1'b1;\n        3'b001: begin // SLLI\n          if (funct7 == 7'd0) instr_valid = 1'b1;\n        end\n        3'b101: begin // SRLI/SRAI\n          if (funct7 == 7'd0) instr_valid = 1'b1;\n          else if (funct7 == 7'd32) instr_valid = 1'b1;\n        end\n      endcase // funct3\n    end\n    // --------------------------------\n    INSTR_OP: begin\n      aluop = {funct7[5], funct3};\n      op1 = rs1_data;\n      op2 = rs2_data;\n\n      case(funct3)\n        3'b000: begin // ADD/SUB\n          if (funct7 == 7'd0) instr_valid = 1'b1;\n          else if (funct7 == 7'd32) instr_valid = 1'b1;\n        end\n        3'b001: begin // SLL\n          if (funct7 == 7'd0) instr_valid = 1'b1;\n        end\n        3'b010: begin // SLT\n          if (funct7 == 7'd0) instr_valid = 1'b1;\n        end\n        3'b011: begin // SLTU\n          if (funct7 == 7'd0) instr_valid = 1'b1;\n        end\n        3'b100: begin // XOR\n          if (funct7 == 7'd0) instr_valid = 1'b1;\n        end\n        3'b101: begin // SRL/SRA\n          if (funct7 == 7'd0) instr_valid = 1'b1;\n          else if (funct7 == 7'd32) instr_valid = 1'b1;\n        end\n        3'b110: begin // OR\n          if (funct7 == 7'd0) instr_valid = 1'b1;\n        end\n        3'b111: begin // AND\n          if (funct7 == 7'd0) instr_valid = 1'b1;\n        end\n      endcase // funct3\n    end\n    // --------------------------------\n    INSTR_MISC: begin\n      case(funct3)\n        3'b000: begin // FENCE\n          // This is a NOP\n          instr_valid = 1'b1;\n        end\n        3'b001: begin // FENCE.I\n          // implementing fence.i as `j f1` (jump to pc+4) \n          // as this will flush the pipeline and cause a fresh \n          // fetch of the instructions after the fence.i instruction\n          is_fencei = 1'b1;\n          instr_valid = 1'b1;\n        end\n      endcase // funct3\n    end\n    // --------------------------------\n    INSTR_SYS: begin\n      unique case(funct3)\n        3'b000: begin\n          if (rs1 == '0 && rd =='0) begin\n            if (IR[31:20] == 12'h000) begin // ECALL\n              sysop = ECALL;\n              instr_valid = 1'b1;\n            end\n            else if (IR[31:20] == 12'h001) begin // EBREAK\n              sysop = EBREAK;\n              instr_valid = 1'b1;\n            end\n            else if (IR[31:20] == 12'h302) begin // MRET\n              sysop = MRET;\n              instr_valid = 1'b1;\n            end\n            else if (IR[31:20] == 12'h105) begin // WFI\n              sysop = WFI;\n              instr_valid = 1'b1;\n            end\n          end\n        end\n        3'b001,       // CSRRW\n        3'b010,       // CSRRS\n        3'b011: begin // CSRRC\n          op1 = rs1_data;\n          csr = 1'b1;\n          instr_valid = 1'b1;\n        end\n        3'b101,       // CSRRWI\n        3'b110,       // CSRRSI\n        3'b111: begin // CSRRCI\n          csr = 1'b1;\n          instr_valid = 1'b1;\n        end\n      endcase // funct3\n    end\n    // --------------------------------\n    default: begin\n    end\n  endcase // OP\n  /* verilator lint_on CASEINCOMPLETE */\nend\n\n// Consolidate factors that deem an instruction as illegal\nassign illegal = CATCH_ILLEGAL_INSTR ? (~instr_valid | illegal_opcode) : 1'b0;\n\n// ============================================================\n// Address Generation Unit\nkronos_agu #(\n  .CATCH_MISALIGNED_JMP (CATCH_MISALIGNED_JMP),\n  .CATCH_MISALIGNED_LDST(CATCH_MISALIGNED_LDST)\n) u_agu (\n  .instr          (IR             ),\n  .base           (base           ),\n  .offset         (offset         ),\n  .addr           (addr           ),\n  .misaligned_jmp (misaligned_jmp ),\n  .misaligned_ldst(misaligned_ldst)\n);\n\n// ============================================================\n// Branch Comparator\nkronos_branch u_branch (\n  .op    (funct3  ),\n  .rs1   (rs1_data),\n  .rs2   (rs2_data),\n  .branch(branch  )\n);\n\n// ============================================================\n// Hazard Control\nkronos_hcu u_hcu (\n  .clk         (clk         ),\n  .rstz        (rstz        ),\n  .flush       (flush       ),\n  .instr       (IR          ),\n  .regrd_rs1_en(regrd_rs1_en),\n  .regrd_rs2_en(regrd_rs2_en),\n  .fetch_vld   (fetch_vld   ),\n  .fetch_rdy   (fetch_rdy   ),\n  .regwr_sel   (regwr_sel   ),\n  .regwr_en    (regwr_en    ),\n  .stall       (stall       )\n);\n\n// ============================================================\n// Instruction Decode Output\nalways_ff @(posedge clk or negedge rstz) begin\n  if (~rstz) begin\n    decode_vld <= 1'b0;\n  end\n  else begin\n    if (flush) begin\n      decode_vld <= 1'b0;\n    end\n    else if(fetch_vld && fetch_rdy) begin\n\n      decode_vld <= 1'b1;\n\n      decode.pc <= PC;\n      decode.ir <= IR;\n\n      decode.basic <= OP == INSTR_LUI\n                    || OP == INSTR_AUIPC\n                    || OP == INSTR_OPIMM\n                    || OP == INSTR_OP\n                    || OP == INSTR_BR\n                    || OP == INSTR_JAL\n                    || OP == INSTR_JALR\n                    || OP == INSTR_MISC;\n\n      decode.aluop <= aluop;\n      decode.regwr_alu <= regwr_alu;\n      decode.op1 <= op1;\n      decode.op2 <= op2;\n\n      decode.addr <= addr;\n      decode.jump <= OP == INSTR_JAL || OP == INSTR_JALR || is_fencei;\n      decode.branch <= branch && OP == INSTR_BR;\n      decode.load <= OP == INSTR_LOAD; \n      decode.store <= OP == INSTR_STORE;\n      decode.mask  <= mask;\n\n      decode.csr <= csr;\n      decode.system <= OP == INSTR_SYS && ~csr;\n      decode.sysop <= sysop;\n\n      decode.illegal <= illegal;\n      decode.misaligned_jmp <= misaligned_jmp;\n      decode.misaligned_ldst <= misaligned_ldst;\n\n    end\n    else if (decode_vld && decode_rdy) begin\n      decode_vld <= 1'b0;\n    end\n  end\nend\n\nassign fetch_rdy = (~decode_vld | decode_rdy) & ~stall;\n\nendmodule\n"}
{"text": "// Copyright (c) 2020 Sonal Pinto\n// SPDX-License-Identifier: Apache-2.0\n\n/*\nKronos Instruction Fetch\n  - Instruction Skid Buffer to avoid re-fetch on stalls.\n  - One Block Lookahead.\n    * Attempt to fetch next instruction after setting up fetch for the current instr_addr\n    * If instr_ack doesn't appear in one cycle, then seamlessly revert instr_addr.\n  - Ideal Throughput.\n  - Designed to work well with Synchronous Single-Port SRAM.\n    * Synchronous SPSRAM is the most common form of FPGA memory.\n    * If instr_req/addr is asserted in the current cycle, then the instr_ack/data may\n      be leisurely driven valid next cycle. No need to clock the SPSRAM on the off-edge\n      to get the ack on the same cycle as the req. You could if you wanted to, but not\n      required.\n  - Houses the Kronos Register File\n\nFAST_BRANCH\n  - Branch instructions take 2 cycles because the PC is set first. But, with FAST_BRANCH,\n    the branch_target is forwarded for instruction fetch. Costs an extra adder, \n    but jumps are 1 cycle faster.\n*/\n\nmodule kronos_IF\n  import kronos_types::*;\n#(\n  parameter logic [31:0] BOOT_ADDR = 32'h0,\n  parameter FAST_BRANCH = 0\n)(\n  input  logic        clk,\n  input  logic        rstz,\n  // Instruction interface\n  output logic [31:0] instr_addr,\n  input  logic [31:0] instr_data,\n  output logic        instr_req,\n  input  logic        instr_ack,\n  // IF/ID interface\n  output pipeIFID_t   fetch,\n  output logic [31:0] immediate,\n  output logic [31:0] regrd_rs1,\n  output logic [31:0] regrd_rs2,\n  output logic        regrd_rs1_en,\n  output logic        regrd_rs2_en,\n  output logic        fetch_vld,\n  input  logic        fetch_rdy,\n  // BRANCH\n  input logic [31:0]  branch_target,\n  input logic         branch,\n  // Write back\n  input  logic [31:0] regwr_data,\n  input  logic [4:0]  regwr_sel,\n  input  logic        regwr_en\n);\n\nlogic [31:0] pc, pc_last;\nlogic [31:0] skid_buffer;\nlogic pipe_rdy;\nlogic instr_vld;\nlogic [31:0] next_instr;\n\nenum logic [1:0] {\n  INIT,\n  FETCH,\n  MISS,\n  STALL\n} state, next_state;\n\n\n// ============================================================\n// Program Counter (PC) Generation\nalways_ff @(posedge clk or negedge rstz) begin\n  if (~rstz) begin\n    pc <= BOOT_ADDR;\n    pc_last <= '0;\n  end\n  else if (branch) begin\n    if (FAST_BRANCH) begin\n      pc <= branch_target + 32'h4;\n      pc_last <= branch_target;\n    end\n    else begin\n      pc <= branch_target;\n    end\n  end\n  else if (next_state == FETCH) begin\n    pc <= pc + 32'h4;\n    pc_last <= pc;\n  end\nend\n\n\n// ============================================================\n// Instruction Fetch\nalways_ff @(posedge clk or negedge rstz) begin\n  if (~rstz) state <= INIT;\n  else if (branch) state <= FAST_BRANCH ? FETCH : INIT;\n  else state <= next_state;\nend\n\nalways_comb begin\n  next_state = state;\n  /* verilator lint_off CASEINCOMPLETE */\n  unique case (state)\n    INIT: next_state = FETCH;\n\n    FETCH:\n      if (instr_ack) begin\n        if (pipe_rdy) next_state = FETCH;\n        else next_state = STALL;\n      end\n      else next_state = MISS;\n\n    MISS: if (instr_ack) begin\n      if (pipe_rdy) next_state = FETCH;\n      else next_state = STALL;\n    end\n\n    STALL: if (fetch_rdy) next_state = FETCH;\n\n  endcase // state\n  /* verilator lint_on CASEINCOMPLETE */\nend\n\nalways_ff @(posedge clk or negedge rstz) begin\n  if (~rstz) begin\n    fetch_vld <= '0;\n  end\n  else begin\n    if (branch) begin\n      fetch_vld <= 1'b0;\n    end\n    else if ((state == FETCH || state == MISS) && instr_ack) begin\n      if (pipe_rdy) begin\n        // Successful fetch if instruction is read and the pipeline can accept it\n        fetch.pc <= pc_last;\n        fetch.ir <= instr_data;\n        fetch_vld <= 1'b1;\n      end\n      else begin\n        // Instruction fetch is good, but pipeline is stalling, hence stow\n        // fetched instruction in a skid buffer\n        skid_buffer <= instr_data;\n      end\n    end\n    else if (state == STALL && fetch_rdy) begin\n      // Flush the skid buffer when the pipeline is ready\n      fetch.pc <= pc_last;\n      fetch.ir <= skid_buffer;\n      fetch_vld <= 1'b1;\n    end\n    else if (fetch_vld && fetch_rdy) begin\n      fetch_vld <= 1'b0;\n    end\n  end\nend\n\nassign pipe_rdy = ~fetch_vld || fetch_rdy;\n\n\n// ============================================================\n// Instruction Memory Interface\n\nalways_comb begin\n  if (FAST_BRANCH & branch) instr_addr = branch_target;\n  else instr_addr = ((state == FETCH || state == MISS) && ~instr_ack) ? pc_last : pc;\nend\nassign instr_req = 1'b1;\n\n// ============================================================\n// Register File\n\nalways_comb begin\n  if ((state == FETCH || state == MISS) && instr_ack && pipe_rdy) begin\n    instr_vld = 1'b1;\n    next_instr = instr_data;\n  end\n  else if (state == STALL && fetch_rdy) begin\n    instr_vld = 1'b1;\n    next_instr = skid_buffer;\n  end\n  else begin\n    instr_vld = 1'b0;\n    next_instr = instr_data;\n  end\nend\n\nkronos_RF u_rf (\n  .clk         (clk         ),\n  .rstz        (rstz        ),\n  .instr_data  (next_instr  ),\n  .instr_vld   (instr_vld   ),\n  .fetch_rdy   (fetch_rdy   ),\n  .immediate   (immediate   ),\n  .regrd_rs1   (regrd_rs1   ),\n  .regrd_rs2   (regrd_rs2   ),\n  .regrd_rs1_en(regrd_rs1_en),\n  .regrd_rs2_en(regrd_rs2_en),\n  .regwr_data  (regwr_data  ),\n  .regwr_sel   (regwr_sel   ),\n  .regwr_en    (regwr_en    )\n);\n\nendmodule\n"}
{"text": "// Copyright (c) 2020 Sonal Pinto\n// SPDX-License-Identifier: Apache-2.0\n\n/*\nKronos Load Store Unit\n\nControl unit that interfaces with \"Data\" memory and fulfills\nLoad/Store instructions\n\nMemory Access needs to be aligned.\n\n*/\n\nmodule kronos_lsu\n  import kronos_types::*;\n(\n  // ID/EX\n  input  pipeIDEX_t   decode,\n  input  logic        lsu_vld,\n  output logic        lsu_rdy,\n  // Register write-back\n  output logic [31:0] load_data,\n  output logic        regwr_lsu,\n  // Memory interface\n  output logic [31:0] data_addr,\n  input  logic [31:0] data_rd_data,\n  output logic [31:0] data_wr_data,\n  output logic [3:0]  data_mask,\n  output logic        data_wr_en,\n  output logic        data_req,\n  input  logic        data_ack\n);\n\nlogic [4:0] rd;\nlogic [1:0] byte_addr;\nlogic [1:0] data_size;\nlogic load_uns;\n\nlogic [3:0][7:0] ldata;\nlogic [31:0] word_data, half_data, byte_data;\n\n// ============================================================\n// IR Segments\nassign byte_addr = decode.addr[1:0];\nassign data_size = decode.ir[13:12];\nassign load_uns = decode.ir[14];\nassign rd  = decode.ir[11:7];\n\n// ============================================================\n// Memory interface\nassign data_addr = {decode.addr[31:2], 2'b0};\nassign data_wr_data = decode.op2;\nassign data_mask = decode.mask;\nassign data_wr_en = lsu_vld && decode.store && ~data_ack;\nassign data_req = lsu_vld && (decode.load | decode.store) && ~data_ack;\n\n// response controls\nassign lsu_rdy = data_ack;\nassign regwr_lsu = decode.load && rd != '0;\n\n// ============================================================\n// Load\n\n// byte cast read data\nassign ldata = data_rd_data;\n\nalways_comb begin\n  // Barrel Rotate Right read data bytes as per offset\n  case(byte_addr)\n    2'b00: word_data = ldata;\n    2'b01: word_data = {ldata[0]  , ldata[3:1]};\n    2'b10: word_data = {ldata[1:0], ldata[3:2]};\n    2'b11: word_data = {ldata[2:0], ldata[3]};\n  endcase\nend\n\nalways_comb begin\n  // select BYTE data, sign extend if needed\n  if (load_uns) byte_data = {24'b0, word_data[7:0]};\n  else byte_data = {{24{word_data[7]}}, word_data[7:0]};\n\n  // Select HALF data, sign extend if needed\n  if (load_uns) half_data = {16'b0, word_data[15:0]};\n  else half_data = {{16{word_data[15]}}, word_data[15:0]};\nend\n\n// Finally, mux load data\nalways_comb begin\n  if (data_size == BYTE) load_data = byte_data;\n  else if (data_size == HALF) load_data = half_data;\n  else load_data = word_data;\nend\n\n\n// ------------------------------------------------------------\n`ifdef verilator\nlogic _unused = &{1'b0\n  , decode\n};\n`endif\n\nendmodule\n"}
{"text": "// Copyright (c) 2020 Sonal Pinto\n// SPDX-License-Identifier: Apache-2.0\n\n/*\nKronos Integer Register File\n\n  - Decodes 32b Immediate and Register Operands for the Decode stage.\n  - Operates in parallel to the Fetch stage, such that when the fetch is valid, \n  so are the outputs of this block. \n*/\n\nmodule kronos_RF\n  import kronos_types::*;\n(\n  input  logic        clk,\n  input  logic        rstz,\n  // Fetch\n  input  logic [31:0] instr_data,\n  input  logic        instr_vld,\n  input  logic        fetch_rdy,\n  // Decode\n  output logic [31:0] immediate,\n  output logic [31:0] regrd_rs1,\n  output logic [31:0] regrd_rs2,\n  output logic        regrd_rs1_en,\n  output logic        regrd_rs2_en,\n  // Write back\n  input  logic [31:0] regwr_data,\n  input  logic [4:0]  regwr_sel,\n  input  logic        regwr_en\n);\n\nlogic reg_vld, instr_rdy;\nlogic [4:0] reg_rs1, reg_rs2;\n\nlogic [31:0] IR;\nlogic [4:0] OP;\nlogic [4:0] rs1, rs2;\nlogic [2:0] funct3;\n\n// Immediate Operand segments\n// A: [0]\n// B: [4:1]\n// C: [10:5]\n// D: [11]\n// E: [19:12]\n// F: [31:20]\nlogic           ImmA;\nlogic [3:0]     ImmB;\nlogic [5:0]     ImmC;\nlogic           ImmD;\nlogic [7:0]     ImmE;\nlogic [11:0]    ImmF;\nlogic [31:0]    Imm;\n\nlogic sign;\nlogic format_I;\nlogic format_J;\nlogic format_S;\nlogic format_B;\nlogic format_U;\n\nlogic csr_regrd;\nlogic is_regrd_rs1_en;\nlogic is_regrd_rs2_en;\n\n\n// ============================================================\n// Instruction Decoder\n\nassign IR = instr_data;\n\n// Aliases to IR segments\nassign OP = IR[6:2];\nassign rs1 = IR[19:15];\nassign rs2 = IR[24:20];\nassign funct3 = IR[14:12];\n\n// ============================================================\n// Immediate Decoder\n\nassign sign = IR[31];\n\nalways_comb begin\n  // Instruction format --- used to decode Immediate \n  format_I = OP == INSTR_OPIMM || OP == INSTR_JALR || OP == INSTR_LOAD;\n  format_J = OP == INSTR_JAL;\n  format_S = OP == INSTR_STORE;\n  format_B = OP == INSTR_BR;\n  format_U = OP == INSTR_LUI || OP == INSTR_AUIPC;\n\n  // Immediate Segment A - [0]\n  if (format_I) ImmA = IR[20];\n  else if (format_S) ImmA = IR[7];\n  else ImmA = 1'b0; // B/J/U\n  \n  // Immediate Segment B - [4:1]\n  if (format_U) ImmB = 4'b0;\n  else if (format_I || format_J) ImmB = IR[24:21];\n  else ImmB = IR[11:8]; // S/B\n\n  // Immediate Segment C - [10:5]\n  if (format_U) ImmC = 6'b0;\n  else ImmC = IR[30:25];\n\n  // Immediate Segment D - [11]\n  if (format_U) ImmD = 1'b0;\n  else if (format_B) ImmD = IR[7];\n  else if (format_J) ImmD = IR[20];\n  else ImmD = sign;\n\n  // Immediate Segment E - [19:12]\n  if (format_U || format_J) ImmE = IR[19:12];\n  else ImmE = {8{sign}};\n  \n  // Immediate Segment F - [31:20]\n  if (format_U) ImmF = IR[31:20];\n  else ImmF = {12{sign}};\nend\n\n// As A-Team's Hannibal would say, \"I love it when a plan comes together\"\nassign Imm = {ImmF, ImmE, ImmD, ImmC, ImmB, ImmA};\n\n// ============================================================\n// Hazard tracking\n\nassign csr_regrd = OP == INSTR_SYS && (funct3 == 3'b001\n                                    || funct3 == 3'b010\n                                    || funct3 == 3'b011);\n\n// RS1/RS2 register read conditions\nassign is_regrd_rs1_en = OP == INSTR_OPIMM \n                || OP == INSTR_OP \n                || OP == INSTR_JALR \n                || OP == INSTR_BR\n                || OP == INSTR_LOAD\n                || OP == INSTR_STORE\n                || csr_regrd;\n\nassign is_regrd_rs2_en = OP == INSTR_OP \n                || OP == INSTR_BR\n                || OP == INSTR_STORE;\n\n\n// ============================================================\n// Integer Registers\n\nlogic [31:0] REG [32] /* synthesis syn_ramstyle = \"no_rw_check\" */;\n\n// REG Read\nalways_ff @(posedge clk or negedge rstz) begin\n  if (~rstz) begin\n    reg_vld <= 1'b0;\n  end\n  else begin\n    if (instr_vld && instr_rdy) begin\n      reg_vld <= 1'b1;\n\n      // Load next operands for instruction,\n      // Ensuring write-bypass for rs1/rs2\n      immediate <= Imm;\n      \n      if (rs1 == 0) regrd_rs1 <= '0;\n      else if (regwr_en && rs1 == regwr_sel) regrd_rs1 <= regwr_data;\n      else regrd_rs1 <= REG[rs1];\n\n      if (rs2 == 0) regrd_rs2 <= '0;\n      else if (regwr_en && rs2 == regwr_sel) regrd_rs2 <= regwr_data;\n      else regrd_rs2 <= REG[rs2];\n\n      regrd_rs1_en <= is_regrd_rs1_en;\n      regrd_rs2_en <= is_regrd_rs2_en;\n\n      reg_rs1 <= rs1;\n      reg_rs2 <= rs2;\n    end\n    else if (reg_vld && regwr_en) begin\n      // Update register operands with latest data when stalling\n      // i.e. latched register forwarding\n      if (reg_rs1 == regwr_sel) regrd_rs1 <= regwr_data;\n      if (reg_rs2 == regwr_sel) regrd_rs2 <= regwr_data;\n    end\n    else if (reg_vld && fetch_rdy) begin\n      // drain\n      reg_vld <= 1'b0;\n    end\n  end\nend\n\nassign instr_rdy = ~reg_vld | fetch_rdy;\n\n// REG Write\nalways_ff @(posedge clk) begin\n  if (regwr_en) REG[regwr_sel] <= regwr_data;\nend\n\n// ------------------------------------------------------------\n`ifdef verilator\nlogic _unused = &{1'b0\n    , IR[1:0]\n};\n`endif\n\n\nendmodule\n"}
{"text": "// Copyright (c) 2020 Sonal Pinto\n// SPDX-License-Identifier: Apache-2.0\n\npackage kronos_types;\n\n// ============================================================\n// Types\ntypedef logic [31:0] instr_t;\n\ntypedef struct packed {\n    logic [31:0] pc;\n    logic [31:0] ir;\n} pipeIFID_t;\n\ntypedef struct packed {\n    logic [31:0] pc;\n    logic [31:0] ir;\n    logic [31:0] op1;\n    logic [31:0] op2;\n    logic [31:0] addr;\n    // ------------------------\n    // EX controls\n    logic        basic;\n    logic [3:0]  aluop;\n    logic        regwr_alu;\n    logic        jump;\n    logic        branch;\n    logic        load;\n    logic        store;\n    logic [3:0]  mask;\n    logic        csr;\n    logic        system;\n    logic [1:0]  sysop;\n    logic        illegal;\n    logic        misaligned_jmp;\n    logic        misaligned_ldst;\n} pipeIDEX_t;\n\n// ============================================================\n// Instruction Types: {opcode[6:2]}\nparameter logic [4:0] INSTR_LOAD  = 5'b00_000;\nparameter logic [4:0] INSTR_STORE = 5'b01_000;\nparameter logic [4:0] INSTR_BR    = 5'b11_000;\n\nparameter logic [4:0] INSTR_JALR  = 5'b11_001;\n\nparameter logic [4:0] INSTR_MISC  = 5'b00_011;\nparameter logic [4:0] INSTR_JAL   = 5'b11_011;\n\nparameter logic [4:0] INSTR_OPIMM = 5'b00_100;\nparameter logic [4:0] INSTR_OP    = 5'b01_100;\nparameter logic [4:0] INSTR_SYS   = 5'b11_100;\n\nparameter logic [4:0] INSTR_AUIPC = 5'b00_101;\nparameter logic [4:0] INSTR_LUI   = 5'b01_101;\n\n// ============================================================\n// ALU Operations\nparameter logic [3:0] ADD       = 4'b0000;\nparameter logic [3:0] SUB       = 4'b1000;\nparameter logic [3:0] SLT       = 4'b0010;\nparameter logic [3:0] SLTU      = 4'b0011;\nparameter logic [3:0] XOR       = 4'b0100;\nparameter logic [3:0] OR        = 4'b0110;\nparameter logic [3:0] AND       = 4'b0111;\nparameter logic [3:0] SLL       = 4'b0001;\nparameter logic [3:0] SRL       = 4'b0101;\nparameter logic [3:0] SRA       = 4'b1101;\n\n// ============================================================\n// Branch Operations\nparameter logic [2:0] BEQ       = 3'b000;\nparameter logic [2:0] BNE       = 3'b001;\nparameter logic [2:0] BLT       = 3'b100;\nparameter logic [2:0] BGE       = 3'b101;\nparameter logic [2:0] BLTU      = 3'b110;\nparameter logic [2:0] BGEU      = 3'b111;\n\nparameter logic [1:0] EQ        = 2'b00;\nparameter logic [1:0] LT        = 2'b01;\nparameter logic [1:0] GT        = 2'b10;\n\n// ============================================================\n// Memory Access Size\nparameter logic [1:0] BYTE      = 2'b00;\nparameter logic [1:0] HALF      = 2'b01;\nparameter logic [1:0] WORD      = 2'b10;\n\n// ============================================================\n// System Operations\nparameter logic [1:0] ECALL     = 2'b00;\nparameter logic [1:0] EBREAK    = 2'b01;\nparameter logic [1:0] MRET      = 2'b10;\nparameter logic [1:0] WFI       = 2'b11;\n\n// ============================================================\n// Constants\nparameter logic [31:0] ZERO   = 32'h0;\nparameter logic [31:0] FOUR   = 32'h4;\n\n// ============================================================\n// Interrupts\nparameter logic [3:0] SOFTWARE_INTERRUPT    = 4'd3;\nparameter logic [3:0] TIMER_INTERRUPT       = 4'd7;\nparameter logic [3:0] EXTERNAL_INTERRUPT    = 4'd11;\n\n// ============================================================\n// Exceptions\nparameter logic [3:0] INSTR_ADDR_MISALIGNED = 4'd0;\nparameter logic [3:0] ILLEGAL_INSTR         = 4'd2;\nparameter logic [3:0] BREAKPOINT            = 4'd3;\nparameter logic [3:0] LOAD_ADDR_MISALIGNED  = 4'd4;\nparameter logic [3:0] STORE_ADDR_MISALIGNED = 4'd6;\nparameter logic [3:0] ECALL_MACHINE         = 4'd11;\n\n// ============================================================\n// Control Status Register\n\n// CSR operations\nparameter logic [1:0]  CSR_RW       = 2'b01;\nparameter logic [1:0]  CSR_RS       = 2'b10;\nparameter logic [1:0]  CSR_RC       = 2'b11;\n\n// CSR Address\nparameter logic [11:0] MSTATUS      = 12'h300;\nparameter logic [11:0] MIE          = 12'h304;\nparameter logic [11:0] MTVEC        = 12'h305;\n\nparameter logic [11:0] MSCRATCH     = 12'h340;\nparameter logic [11:0] MEPC         = 12'h341;\nparameter logic [11:0] MCAUSE       = 12'h342;\nparameter logic [11:0] MTVAL        = 12'h343;\nparameter logic [11:0] MIP          = 12'h344;\n\nparameter logic [11:0] MCYCLE       = 12'hB00;\nparameter logic [11:0] MINSTRET     = 12'hB02;\nparameter logic [11:0] MCYCLEH      = 12'hB80;\nparameter logic [11:0] MINSTRETH    = 12'hB82;\n\n// Privilege levels\nparameter logic [1:0] PRIVILEGE_MACHINE = 2'b11;\n// mtvec modes\nparameter logic [1:0] DIRECT_MODE   = 2'b00;\n \nendpackage\n"}
