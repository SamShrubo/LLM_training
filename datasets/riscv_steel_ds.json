{"text": "// ----------------------------------------------------------------------------\n// Copyright (c) 2020-2024 RISC-V Steel contributors\n//\n// This work is licensed under the MIT License, see LICENSE file for details.\n// SPDX-License-Identifier: MIT\n// ----------------------------------------------------------------------------\n\nmodule rvsteel_core #(\n\n  parameter     [31:0]  BOOT_ADDRESS = 32'h00000000\n\n  ) (\n\n  // Global signals\n\n  input  wire           clock,\n  input  wire           reset,\n  input  wire           halt,\n\n  // IO interface\n\n  output wire   [31:0]  rw_address,\n  input  wire   [31:0]  read_data,\n  output wire           read_request,\n  input  wire           read_response,\n  output wire   [31:0]  write_data,\n  output wire   [3:0 ]  write_strobe,\n  output wire           write_request,\n  input  wire           write_response,\n\n  // Interrupt signals (hardwire inputs to zero if unused)\n\n  input  wire           irq_external,\n  output wire           irq_external_response,\n  input  wire           irq_timer,\n  output wire           irq_timer_response,\n  input  wire           irq_software,\n  output wire           irq_software_response,\n  input  wire   [15:0]  irq_fast,\n  output wire   [15:0]  irq_fast_response,\n\n  // Real Time Clock (hardwire to zero if unused)\n\n  input  wire   [63:0]  real_time_clock\n\n  );\n\n  //-----------------------------------------------------------------------------------------------//\n  // Constants                                                                                     //\n  //-----------------------------------------------------------------------------------------------//\n\n  // Address of Machine Information CSRs\n\n  localparam MARCHID              = 12'hF12;\n  localparam MIMPID               = 12'hF13;\n\n  // Address of Performance Counters CSRs\n\n  localparam CYCLE                = 12'hC00;\n  localparam TIME                 = 12'hC01;\n  localparam INSTRET              = 12'hC02;\n  localparam CYCLEH               = 12'hC80;\n  localparam TIMEH                = 12'hC81;\n  localparam INSTRETH             = 12'hC82;\n\n  // Address of Machine Trap Setup CSRs\n\n  localparam MSTATUS              = 12'h300;\n  localparam MSTATUSH             = 12'h310;\n  localparam MISA                 = 12'h301;\n  localparam MIE                  = 12'h304;\n  localparam MTVEC                = 12'h305;\n\n  // Address of Machine Trap Handling CSRs\n\n  localparam MSCRATCH             = 12'h340;\n  localparam MEPC                 = 12'h341;\n  localparam MCAUSE               = 12'h342;\n  localparam MTVAL                = 12'h343;\n  localparam MIP                  = 12'h344;\n\n  // Address of Machine Performance Counters CSRs\n\n  localparam MCYCLE               = 12'hB00;\n  localparam MINSTRET             = 12'hB02;\n  localparam MCYCLEH              = 12'hB80;\n  localparam MINSTRETH            = 12'hB82;\n\n  // Writeback Mux selection\n\n  localparam WB_ALU               = 3'b000;\n  localparam WB_LOAD_UNIT         = 3'b001;\n  localparam WB_UPPER_IMM         = 3'b010;\n  localparam WB_TARGET_ADDER      = 3'b011;\n  localparam WB_CSR               = 3'b100;\n  localparam WB_PC_PLUS_4         = 3'b101;\n\n  // Immediate format selection\n\n  localparam I_TYPE_IMMEDIATE     = 3'b001;\n  localparam S_TYPE_IMMEDIATE     = 3'b010;\n  localparam B_TYPE_IMMEDIATE     = 3'b011;\n  localparam U_TYPE_IMMEDIATE     = 3'b100;\n  localparam J_TYPE_IMMEDIATE     = 3'b101;\n  localparam CSR_TYPE_IMMEDIATE   = 3'b110;\n\n  // Program Counter source selection\n\n  localparam PC_BOOT              = 2'b00;\n  localparam PC_EPC               = 2'b01;\n  localparam PC_TRAP              = 2'b10;\n  localparam PC_NEXT              = 2'b11;\n\n  // Load size encoding\n\n  localparam LOAD_SIZE_BYTE       = 2'b00;\n  localparam LOAD_SIZE_HALF       = 2'b01;\n  localparam LOAD_SIZE_WORD       = 2'b10;\n\n  // CSR File operation encoding\n\n  localparam CSR_RWX              = 2'b01;\n  localparam CSR_RSX              = 2'b10;\n  localparam CSR_RCX              = 2'b11;\n\n  // States in M-mode\n\n  localparam STATE_RESET          = 4'b0001;\n  localparam STATE_OPERATING      = 4'b0010;\n  localparam STATE_TRAP_TAKEN     = 4'b0100;\n  localparam STATE_TRAP_RETURN    = 4'b1000;\n\n  // No operation\n\n  localparam NOP_INSTRUCTION      = 32'h00000013;\n\n  // Opcodes\n\n  localparam OPCODE_OP            = 7'b0110011;\n  localparam OPCODE_OP_IMM        = 7'b0010011;\n  localparam OPCODE_LOAD          = 7'b0000011;\n  localparam OPCODE_STORE         = 7'b0100011;\n  localparam OPCODE_BRANCH        = 7'b1100011;\n  localparam OPCODE_JAL           = 7'b1101111;\n  localparam OPCODE_JALR          = 7'b1100111;\n  localparam OPCODE_LUI           = 7'b0110111;\n  localparam OPCODE_AUIPC         = 7'b0010111;\n  localparam OPCODE_MISC_MEM      = 7'b0001111;\n  localparam OPCODE_SYSTEM        = 7'b1110011;\n\n  // Funct3\n\n  localparam FUNCT3_ADD           = 3'b000;\n  localparam FUNCT3_SUB           = 3'b000;\n  localparam FUNCT3_SLT           = 3'b010;\n  localparam FUNCT3_SLTU          = 3'b011;\n  localparam FUNCT3_AND           = 3'b111;\n  localparam FUNCT3_OR            = 3'b110;\n  localparam FUNCT3_XOR           = 3'b100;\n  localparam FUNCT3_SLL           = 3'b001;\n  localparam FUNCT3_SRL           = 3'b101;\n  localparam FUNCT3_SRA           = 3'b101;\n  localparam FUNCT3_ADDI          = 3'b000;\n  localparam FUNCT3_SLTI          = 3'b010;\n  localparam FUNCT3_SLTIU         = 3'b011;\n  localparam FUNCT3_ANDI          = 3'b111;\n  localparam FUNCT3_ORI           = 3'b110;\n  localparam FUNCT3_XORI          = 3'b100;\n  localparam FUNCT3_SLLI          = 3'b001;\n  localparam FUNCT3_SRLI          = 3'b101;\n  localparam FUNCT3_SRAI          = 3'b101;\n  localparam FUNCT3_BEQ           = 3'b000;\n  localparam FUNCT3_BNE           = 3'b001;\n  localparam FUNCT3_BLT           = 3'b100;\n  localparam FUNCT3_BGE           = 3'b101;\n  localparam FUNCT3_BLTU          = 3'b110;\n  localparam FUNCT3_BGEU          = 3'b111;\n  // localparam FUNCT3_JALR          = 3'b000;\n  localparam FUNCT3_SB            = 3'b000;\n  localparam FUNCT3_SH            = 3'b001;\n  localparam FUNCT3_SW            = 3'b010;\n  // localparam FUNCT3_LB            = 3'b000;\n  // localparam FUNCT3_LH            = 3'b001;\n  // localparam FUNCT3_LW            = 3'b010;\n  // localparam FUNCT3_LBU           = 3'b100;\n  // localparam FUNCT3_LHU           = 3'b101;\n  // localparam FUNCT3_CSRRW         = 3'b001;\n  // localparam FUNCT3_CSRRS         = 3'b010;\n  // localparam FUNCT3_CSRRC         = 3'b011;\n  // localparam FUNCT3_CSRRWI        = 3'b101;\n  // localparam FUNCT3_CSRRSI        = 3'b110;\n  // localparam FUNCT3_CSRRCI        = 3'b111;\n  // localparam FUNCT3_FENCE         = 3'b000;\n  localparam FUNCT3_ECALL         = 3'b000;\n  localparam FUNCT3_EBREAK        = 3'b000;\n  localparam FUNCT3_MRET          = 3'b000;\n\n  // Funct7\n\n  localparam FUNCT7_SUB           = 7'b0100000;\n  localparam FUNCT7_SRA           = 7'b0100000;\n  localparam FUNCT7_ADD           = 7'b0000000;\n  localparam FUNCT7_SLT           = 7'b0000000;\n  localparam FUNCT7_SLTU          = 7'b0000000;\n  localparam FUNCT7_AND           = 7'b0000000;\n  localparam FUNCT7_OR            = 7'b0000000;\n  localparam FUNCT7_XOR           = 7'b0000000;\n  localparam FUNCT7_SLL           = 7'b0000000;\n  localparam FUNCT7_SRL           = 7'b0000000;\n  localparam FUNCT7_SRAI          = 7'b0100000;\n  localparam FUNCT7_SLLI          = 7'b0000000;\n  localparam FUNCT7_SRLI          = 7'b0000000;\n  localparam FUNCT7_ECALL         = 7'b0000000;\n  localparam FUNCT7_EBREAK        = 7'b0000000;\n  localparam FUNCT7_MRET          = 7'b0011000;\n\n  // RS1, RS2 and RD encodings for SYSTEM instructions\n\n  localparam RS1_ECALL            = 5'b00000;\n  localparam RS1_EBREAK           = 5'b00000;\n  localparam RS1_MRET             = 5'b00000;\n  localparam RS2_ECALL            = 5'b00000;\n  localparam RS2_EBREAK           = 5'b00001;\n  localparam RS2_MRET             = 5'b00010;\n  localparam RD_ECALL             = 5'b00000;\n  localparam RD_EBREAK            = 5'b00000;\n  localparam RD_MRET              = 5'b00000;\n\n  //-----------------------------------------------------------------------------------------------//\n  // Wires and regs                                                                                //\n  //-----------------------------------------------------------------------------------------------//\n\n  wire  [31:0]  alu_2nd_operand;\n  wire          alu_2nd_operand_source;\n  wire  [31:0]  alu_adder_2nd_operand_mux;\n  wire  [31:0]  alu_minus_2nd_operand;\n  wire  [3:0 ]  alu_operation_code;\n  reg   [31:0]  alu_output;\n  wire  [31:0]  alu_shift_right_mux;\n  wire          alu_slt_result;\n  wire          alu_sltu_result;\n  wire  [31:0]  alu_sra_result;\n  wire  [31:0]  alu_srl_result;\n  reg           branch_condition_satisfied;\n  wire  [31:0]  branch_target_address;\n  wire          clock_enable;\n  wire  [31:0]  csr_data_mask;\n  reg   [31:0]  csr_data_out;\n  wire          csr_file_write_enable;\n  wire          csr_file_write_request;\n  reg   [31:0]  csr_mcause;\n  reg   [4:0 ]  csr_mcause_code;\n  reg           csr_mcause_interrupt_flag;\n  reg   [63:0]  csr_mcycle;\n  reg   [31:0]  csr_mepc;\n  wire  [31:0]  csr_mie;\n  reg   [15:0]  csr_mie_mfie;\n  reg           csr_mie_meie;\n  reg           csr_mie_msie;\n  reg           csr_mie_mtie;\n  wire  [31:0]  csr_mip;\n  reg   [15:0]  csr_mip_mfip;\n  reg           csr_mip_meip;\n  reg           csr_mip_mtip;\n  reg           csr_mip_msip;\n  reg   [63:0]  csr_minstret;\n  reg   [31:0]  csr_mscratch;\n  wire  [31:0]  csr_mstatus;\n  reg           csr_mstatus_mie;\n  reg           csr_mstatus_mpie;\n  reg   [31:0]  csr_mtvec;\n  reg   [31:0]  csr_mtval;\n  wire  [2:0 ]  csr_operation;\n  reg   [63:0]  csr_utime;\n  reg   [31:0]  csr_write_data;\n  reg   [3:0 ]  current_state;\n  wire          ebreak;\n  wire          ecall;\n  wire          flush;\n  wire          illegal_instruction;\n  reg   [31:0]  immediate;\n  wire  [31:0]  immediate_b_type;\n  wire  [31:0]  immediate_csr_type;\n  wire  [31:0]  immediate_i_type;\n  wire  [31:0]  immediate_j_type;\n  wire  [31:0]  immediate_s_type;\n  wire  [19:0]  immediate_sign_extension;\n  reg   [2:0 ]  immediate_type;\n  wire  [31:0]  immediate_u_type;\n  reg   [31:0]  integer_file [31:1];\n  wire          integer_file_write_enable;\n  wire          integer_file_write_request;\n  wire  [31:0]  instruction;\n  wire  [31:0]  instruction_address;\n  wire  [2:0 ]  instruction_funct3;\n  wire  [6:0 ]  instruction_funct7;\n  wire  [6:0 ]  instruction_opcode;\n  wire  [11:0]  instruction_csr_address;\n  wire  [4:0 ]  instruction_rd_address;\n  wire  [4:0 ]  instruction_rs1_address;\n  wire  [4:0 ]  instruction_rs2_address;\n  wire  [31:0]  interrupt_address_offset;\n  wire          load;\n  reg   [7:0 ]  load_byte_data;\n  wire  [23:0]  load_byte_upper_bits;\n  wire          load_commit_cycle;\n  reg   [31:0]  load_data;\n  reg   [15:0]  load_half_data;\n  wire  [15:0]  load_half_upper_bits;\n  wire          load_pending;\n  wire          load_request;\n  wire  [1:0 ]  load_size;\n  wire          load_unsigned;\n  wire          misaligned_address_exception;\n  wire          misaligned_instruction_address;\n  wire          misaligned_load;\n  wire          misaligned_store;\n  wire          mret;\n  wire  [31:0]  next_address;\n  reg   [31:0]  next_program_counter;\n  reg   [3:0 ]  next_state;\n  reg   [31:0]  prev_instruction;\n  reg   [31:0]  prev_instruction_address;\n  reg           prev_load_request;\n  reg           prev_read_request;\n  reg   [31:0]  prev_rw_address;\n  reg   [31:0]  prev_write_data;\n  reg           prev_write_request;\n  reg   [3:0 ]  prev_write_strobe;\n  reg   [31:0]  program_counter;\n  wire  [31:0]  program_counter_plus_4;\n  reg   [1:0 ]  program_counter_source;\n  // wire  [4:0 ]  rd_addr;\n  // wire  [31:0]  rd_data;\n  wire          reset_internal;\n  reg           reset_reg;\n  // wire  [4:0 ]  rs1_addr;\n  wire  [31:0]  rs1_data;\n  // wire  [31:0]  rs1_mux;\n  // wire  [4:0 ]  rs2_addr;\n  // wire  [31:0]  rs2_mux;\n  wire  [31:0]  rs2_data;\n  wire  [31:0]  rw_address_internal;\n  wire          store;\n  reg   [31:0]  store_byte_data;\n  wire          store_commit_cycle;\n  reg   [31:0]  store_half_data;\n  wire          store_pending;\n  wire          store_request;\n  wire          take_branch;\n  wire          take_trap;\n  wire  [31:0]  target_address_adder;\n  wire          target_address_source;\n  wire  [31:0]  trap_address;\n  reg   [31:0]  write_data_internal;\n  reg   [3:0 ]  write_strobe_for_byte;\n  reg   [3:0 ]  write_strobe_for_half;\n  reg   [3:0 ]  write_strobe_internal;\n  reg   [2:0 ]  writeback_mux_selector;\n  reg   [31:0]  writeback_multiplexer_output;\n  wire          branch_type;\n  wire          jal_type;\n  wire          jalr_type;\n  wire          auipc_type;\n  wire          lui_type;\n  wire          load_type;\n  wire          store_type;\n  wire          system_type;\n  wire          op_type;\n  wire          op_imm_type;\n  wire          misc_mem_type;\n  wire          addi;\n  wire          slti;\n  wire          sltiu;\n  wire          andi;\n  wire          ori;\n  wire          xori;\n  wire          slli;\n  wire          srli;\n  wire          srai;\n  wire          add;\n  wire          sub;\n  wire          slt;\n  wire          sltu;\n  wire          is_and;\n  wire          is_or;\n  wire          is_xor;\n  wire          sll;\n  wire          srl;\n  wire          sra;\n  wire          csrxxx;\n  wire          illegal_store;\n  wire          illegal_load;\n  wire          illegal_jalr;\n  wire          illegal_branch;\n  wire          illegal_op;\n  wire          illegal_op_imm;\n  wire          illegal_system;\n  wire          unknown_type;\n  wire          misaligned_word;\n  wire          misaligned_half;\n  wire          misaligned;\n  wire          is_branch;\n  wire          is_jump;\n  wire          is_equal;\n  wire          is_not_equal;\n  wire          is_less_than_unsigned;\n  wire          is_less_than;\n  wire          is_greater_or_equal_than;\n  wire          is_greater_or_equal_than_unsigned;\n  wire          interrupt_pending;\n  wire          exception_pending;\n\n  //-----------------------------------------------------------------------------------------------//\n  // Global signals                                                                                //\n  //-----------------------------------------------------------------------------------------------//\n\n  always @(posedge clock)\n    reset_reg <= reset;\n\n  assign reset_internal = reset | reset_reg;\n\n  assign clock_enable = !( halt                |\n    (prev_read_request   & !read_response    ) |\n    (prev_write_request  & !write_response   ) );\n\n  always @(posedge clock) begin\n    if (reset_internal) begin\n      prev_instruction_address  <= BOOT_ADDRESS;\n      prev_load_request         <= 1'b0;\n      prev_rw_address           <= 32'h00000000;\n      prev_read_request         <= 1'b0;\n      prev_write_data           <= 32'h00000000;\n      prev_write_request        <= 1'b0;\n      prev_write_strobe         <= 4'b0000;\n    end\n    else if(clock_enable) begin\n      prev_instruction_address  <= instruction_address;\n      prev_load_request         <= load_request;\n      prev_rw_address           <= rw_address;\n      prev_read_request         <= read_request;\n      prev_write_data           <= write_data;\n      prev_write_request        <= write_request;\n      prev_write_strobe         <= write_strobe;\n    end\n  end\n\n  //-----------------------------------------------------------------------------------------------//\n  // Instruction fetch and instruction address logic                                               //\n  //-----------------------------------------------------------------------------------------------//\n\n  assign instruction_address =\n    reset ?\n    BOOT_ADDRESS :\n    (clock_enable ?\n      next_program_counter :\n      prev_instruction_address);\n\n    always @(posedge clock)\n    if (reset_internal)\n      prev_instruction <= NOP_INSTRUCTION;\n    else\n      prev_instruction <= instruction;\n\n  always @* begin : next_program_counter_mux\n    case (program_counter_source)\n      PC_BOOT: next_program_counter = BOOT_ADDRESS;\n      PC_EPC:  next_program_counter = csr_mepc;\n      PC_TRAP: next_program_counter = trap_address;\n      PC_NEXT: next_program_counter = next_address;\n    endcase\n  end\n\n  assign program_counter_plus_4 =\n    program_counter + 32'h00000004;\n\n  assign target_address_adder =\n    target_address_source == 1'b1 ?\n    rs1_data + immediate :\n    program_counter + immediate;\n\n  assign branch_target_address =\n    {target_address_adder[31:1], 1'b0};\n\n  assign next_address =\n   take_branch ?\n   branch_target_address :\n   program_counter_plus_4;\n\n  always @(posedge clock) begin : program_counter_reg_implementation\n    if (reset_internal)\n      program_counter <= BOOT_ADDRESS;\n    else if (clock_enable & !load_pending & !store_pending)\n      program_counter <= next_program_counter;\n  end\n\n  assign instruction =\n    flush ?\n    NOP_INSTRUCTION :\n    (!clock_enable | load_commit_cycle | store_commit_cycle) ?\n      prev_instruction :\n      read_data;\n\n  assign instruction_opcode =\n    instruction[6:0];\n\n  assign instruction_funct3 =\n    instruction[14:12];\n\n  assign instruction_funct7 =\n    instruction[31:25];\n\n  assign instruction_rs1_address =\n    instruction[19:15];\n\n  assign instruction_rs2_address =\n    instruction[24:20];\n\n  assign instruction_rd_address =\n    instruction[11:7];\n\n  assign instruction_csr_address =\n    instruction[31:20];\n\n  //-----------------------------------------------------------------------------------------------//\n  // IO read / write                                                                               //\n  //-----------------------------------------------------------------------------------------------//\n\n  assign read_request =\n    reset_internal ?\n    1'b0 :\n    (clock_enable ?\n      ~store_request :\n      prev_read_request);\n\n  assign rw_address =\n    reset_internal ?\n    32'h00000000 :\n    (clock_enable ?\n      rw_address_internal :\n      prev_rw_address);\n\n  assign write_request =\n    reset_internal ?\n    1'b0 :\n    (clock_enable ?\n      store_request :\n      prev_write_request);\n\n  assign write_data =\n    reset_internal ?\n    32'h00000000 :\n    (clock_enable ?\n      write_data_internal :\n      prev_write_data);\n\n  assign write_strobe =\n    reset_internal ?\n    4'b0 :\n    (clock_enable ?\n      write_strobe_internal :\n      prev_write_strobe);\n\n  assign load_commit_cycle =\n    prev_load_request & read_response;\n\n  assign store_commit_cycle =\n    prev_write_request & write_response;\n\n  assign load_pending =\n    load  & !load_commit_cycle;\n\n  assign store_pending =\n    store & !store_commit_cycle;\n\n  assign load_request =\n    load  & ~misaligned_load  & ~take_trap & ~load_commit_cycle;\n\n  assign store_request =\n    store & ~misaligned_store & ~take_trap & ~store_commit_cycle;\n\n  assign rw_address_internal =\n    load_request | store_request ?\n    {target_address_adder[31:2], 2'b00} :\n    instruction_address;\n\n  always @* begin\n    case(instruction_funct3)\n      FUNCT3_SB: begin\n        write_strobe_internal = write_strobe_for_byte;\n        write_data_internal   = store_byte_data;\n      end\n      FUNCT3_SH: begin\n        write_strobe_internal = write_strobe_for_half;\n        write_data_internal   = store_half_data;\n      end\n      FUNCT3_SW: begin\n        write_strobe_internal = {4{write_request}};\n        write_data_internal   = rs2_data;\n      end\n      default: begin\n        write_strobe_internal = {4{write_request}};\n        write_data_internal   = rs2_data;\n      end\n    endcase\n  end\n\n  always @* begin\n    case(target_address_adder[1:0])\n      2'b00: begin\n        store_byte_data       = {24'b0, rs2_data[7:0]};\n        write_strobe_for_byte = {3'b0, write_request};\n      end\n      2'b01: begin\n        store_byte_data       = {16'b0, rs2_data[7:0], 8'b0};\n        write_strobe_for_byte = {2'b0, write_request, 1'b0};\n      end\n      2'b10: begin\n        store_byte_data       = {8'b0, rs2_data[7:0], 16'b0};\n       "}
{"text": " write_strobe_for_byte = {1'b0, write_request, 2'b0};\n      end\n      2'b11: begin\n        store_byte_data       = {rs2_data[7:0], 24'b0};\n        write_strobe_for_byte = {write_request, 3'b0};\n      end\n    endcase\n  end\n\n  always @* begin\n    case(target_address_adder[1])\n      1'b0: begin\n        store_half_data       = {16'b0, rs2_data[15:0]};\n        write_strobe_for_half = {2'b0, {2{write_request}}};\n      end\n      1'b1: begin\n        store_half_data       = {rs2_data[15:0], 16'b0};\n        write_strobe_for_half = {{2{write_request}}, 2'b0};\n      end\n    endcase\n  end\n\n  //-----------------------------------------------------------------------------------------------//\n  // Instruction decoding                                                                          //\n  //-----------------------------------------------------------------------------------------------//\n\n  // Instruction type detection\n\n  assign branch_type =\n    instruction_opcode == OPCODE_BRANCH;\n\n  assign jal_type =\n    instruction_opcode == OPCODE_JAL;\n\n  assign jalr_type =\n    instruction_opcode == OPCODE_JALR;\n\n  assign auipc_type =\n    instruction_opcode == OPCODE_AUIPC;\n\n  assign lui_type =\n    instruction_opcode == OPCODE_LUI;\n\n  assign load_type =\n    instruction_opcode == OPCODE_LOAD;\n\n  assign store_type =\n    instruction_opcode == OPCODE_STORE;\n\n  assign system_type =\n    instruction_opcode == OPCODE_SYSTEM;\n\n  assign op_type =\n    instruction_opcode == OPCODE_OP;\n\n  assign op_imm_type =\n    instruction_opcode == OPCODE_OP_IMM;\n\n  assign misc_mem_type =\n    instruction_opcode == OPCODE_MISC_MEM;\n\n  // Instruction detection\n\n  assign addi =\n    op_imm_type &\n    instruction_funct3 == FUNCT3_ADDI;\n\n  assign slti =\n    op_imm_type &\n    instruction_funct3 == FUNCT3_SLTI;\n\n  assign sltiu =\n    op_imm_type &\n    instruction_funct3 == FUNCT3_SLTIU;\n\n  assign andi =\n    op_imm_type &\n    instruction_funct3 == FUNCT3_ANDI;\n\n  assign ori =\n    op_imm_type &\n    instruction_funct3 == FUNCT3_ORI;\n\n  assign xori =\n    op_imm_type &\n    instruction_funct3 == FUNCT3_XORI;\n\n  assign slli =\n    op_imm_type &\n    instruction_funct3 == FUNCT3_SLLI &\n    instruction_funct7 == FUNCT7_SLLI;\n\n  assign srli =\n    op_imm_type &\n    instruction_funct3 == FUNCT3_SRLI &\n    instruction_funct7 == FUNCT7_SRLI;\n\n  assign srai =\n    op_imm_type &\n    instruction_funct3 == FUNCT3_SRAI &\n    instruction_funct7 == FUNCT7_SRAI;\n\n  assign add =\n    op_type &\n    instruction_funct3 == FUNCT3_ADD &\n    instruction_funct7 == FUNCT7_ADD;\n\n  assign sub =\n    op_type &\n    instruction_funct3 == FUNCT3_SUB &\n    instruction_funct7 == FUNCT7_SUB;\n\n  assign slt =\n    op_type &\n    instruction_funct3 == FUNCT3_SLT &\n    instruction_funct7 == FUNCT7_SLT;\n\n  assign sltu =\n    op_type &\n    instruction_funct3 == FUNCT3_SLTU &\n    instruction_funct7 == FUNCT7_SLTU;\n\n  assign is_and =\n    op_type &\n    instruction_funct3 == FUNCT3_AND &\n    instruction_funct7 == FUNCT7_AND;\n\n  assign is_or =\n    op_type &\n    instruction_funct3 == FUNCT3_OR &\n    instruction_funct7 == FUNCT7_OR;\n\n  assign is_xor =\n    op_type &\n    instruction_funct3 == FUNCT3_XOR &\n    instruction_funct7 == FUNCT7_XOR;\n\n  assign sll =\n    op_type &\n    instruction_funct3 == FUNCT3_SLL &\n    instruction_funct7 == FUNCT7_SLL;\n\n  assign srl =\n    op_type &\n    instruction_funct3 == FUNCT3_SRL &\n    instruction_funct7 == FUNCT7_SRL;\n\n  assign sra =\n    op_type &\n    instruction_funct3 == FUNCT3_SRA &\n    instruction_funct7 == FUNCT7_SRA;\n\n  assign csrxxx =\n    system_type &\n    instruction_funct3 != 3'b000 &\n    instruction_funct3 != 3'b100;\n\n  assign ecall =\n    system_type &\n    instruction_funct3 == FUNCT3_ECALL &\n    instruction_funct7 == FUNCT7_ECALL &\n    instruction_rs1_address == RS1_ECALL &\n    instruction_rs2_address == RS2_ECALL &\n    instruction_rd_address  == RD_ECALL;\n\n  assign ebreak =\n    system_type &\n    instruction_funct3 == FUNCT3_EBREAK &\n    instruction_funct7 == FUNCT7_EBREAK &\n    instruction_rs1_address == RS1_EBREAK &\n    instruction_rs2_address == RS2_EBREAK &\n    instruction_rd_address  == RD_EBREAK;\n\n  assign mret =\n    system_type &\n    instruction_funct3 == FUNCT3_MRET &\n    instruction_funct7 == FUNCT7_MRET &\n    instruction_rs1_address == RS1_MRET &\n    instruction_rs2_address == RS2_MRET &\n    instruction_rd_address  == RD_MRET;\n\n  // Illegal instruction detection\n\n  assign illegal_store =\n    store_type &\n    (instruction_funct3[2] == 1'b1 ||\n    instruction_funct3[1:0] == 2'b11);\n\n  assign illegal_load =\n    load_type &\n    (instruction_funct3 == 3'b011 ||\n     instruction_funct3 == 3'b110 ||\n     instruction_funct3 == 3'b111);\n\n  assign illegal_jalr =\n    jalr_type &\n    instruction_funct3 != 3'b000;\n\n  assign illegal_branch =\n    branch_type &\n    (instruction_funct3 == 3'b010 ||\n    instruction_funct3 == 3'b011);\n\n  assign illegal_op =\n    op_type &\n    ~(add | sub | slt | sltu | is_and | is_or | is_xor | sll | srl | sra);\n\n  assign illegal_op_imm =\n    op_imm_type &\n    ~(addi | slti | sltiu | andi | ori | xori | slli | srli | srai);\n\n  assign illegal_system =\n    system_type &\n    ~(csrxxx | ecall | ebreak | mret);\n\n  assign unknown_type =\n    ~(branch_type | jal_type | jalr_type | auipc_type | lui_type | load_type | store_type\n    | system_type | op_type | op_imm_type | misc_mem_type);\n\n  assign illegal_instruction =\n    unknown_type | illegal_store | illegal_load | illegal_jalr | illegal_branch | illegal_op\n    | illegal_op_imm | illegal_system;\n\n  // Misaligned address detection\n\n  assign misaligned_word =\n    instruction_funct3[1:0] == 2'b10 &\n    (target_address_adder[1] | target_address_adder[0]);\n\n  assign misaligned_half =\n    instruction_funct3[1:0] == 2'b01 &\n    target_address_adder[0];\n\n  assign misaligned =\n    misaligned_word | misaligned_half;\n\n  assign misaligned_store =\n    store & misaligned;\n\n  assign misaligned_load =\n    load & misaligned;\n\n  // Control signals generation\n\n  assign alu_operation_code[2:0] =\n    instruction_funct3;\n\n  assign alu_operation_code[3] =\n    instruction_funct7[5] &\n    ~(addi | slti | sltiu | andi | ori | xori);\n\n  assign load =\n    load_type &\n    ~illegal_load;\n\n  assign store =\n    store_type &\n    ~illegal_store;\n\n  assign load_size =\n    instruction_funct3[1:0];\n\n  assign load_unsigned =\n    instruction_funct3[2];\n\n  assign alu_2nd_operand_source =\n    instruction_opcode[5];\n\n  assign target_address_source =\n    load_type | store_type | jalr_type;\n\n  assign integer_file_write_request =\n    lui_type | auipc_type | jalr_type | jal_type | op_type | op_imm_type | load_type | csrxxx;\n\n  assign csr_file_write_request =\n    csrxxx;\n\n  assign csr_operation = instruction_funct3;\n\n  always @* begin : writeback_selector_decoding\n    if (op_type == 1'b1 || op_imm_type == 1'b1)\n      writeback_mux_selector = WB_ALU;\n    else if (load_type == 1'b1)\n      writeback_mux_selector = WB_LOAD_UNIT;\n    else if (jal_type == 1'b1 || jalr_type == 1'b1)\n      writeback_mux_selector = WB_PC_PLUS_4;\n    else if (lui_type == 1'b1)\n      writeback_mux_selector = WB_UPPER_IMM;\n    else if (auipc_type == 1'b1)\n      writeback_mux_selector = WB_TARGET_ADDER;\n    else if (csrxxx == 1'b1)\n      writeback_mux_selector = WB_CSR;\n    else\n      writeback_mux_selector = WB_ALU;\n  end\n\n  always @* begin : immediate_type_decoding\n    if (op_imm_type == 1'b1 || load_type == 1'b1 || jalr_type == 1'b1)\n      immediate_type = I_TYPE_IMMEDIATE;\n    else if (store_type == 1'b1)\n      immediate_type = S_TYPE_IMMEDIATE;\n    else if (branch_type == 1'b1)\n      immediate_type = B_TYPE_IMMEDIATE;\n    else if (jal_type == 1'b1)\n      immediate_type = J_TYPE_IMMEDIATE;\n    else if (lui_type == 1'b1 || auipc_type == 1'b1)\n      immediate_type = U_TYPE_IMMEDIATE;\n    else if (csrxxx == 1'b1)\n      immediate_type = CSR_TYPE_IMMEDIATE;\n    else\n      immediate_type = I_TYPE_IMMEDIATE;\n  end\n\n  //-----------------------------------------------------------------------------------------------//\n  // Immediate generation                                                                          //\n  //-----------------------------------------------------------------------------------------------//\n\n  assign immediate_sign_extension = {\n    20 {instruction[31]}\n  };\n\n  assign immediate_i_type = {\n    immediate_sign_extension,\n    instruction[31:20]\n  };\n\n  assign immediate_s_type = {\n    immediate_sign_extension,\n    instruction[31:25],\n    instruction[11:7 ]\n  };\n\n  assign immediate_b_type = {\n    immediate_sign_extension,\n    instruction[7],\n    instruction[30:25],\n    instruction[11:8],\n    1'b0\n  };\n\n  assign immediate_u_type = {\n    instruction[31:12],\n    12'h000\n  };\n\n  assign immediate_j_type = {\n    immediate_sign_extension[11:0],\n    instruction[19:12],\n    instruction[20],\n    instruction[30:21],\n    1'b0\n  };\n\n  assign immediate_csr_type = {\n    27'b0,\n    instruction[19:15]\n  };\n\n  always @(*) begin : immediate_mux\n    case (immediate_type)\n      I_TYPE_IMMEDIATE:\n        immediate = immediate_i_type;\n      S_TYPE_IMMEDIATE:\n        immediate = immediate_s_type;\n      B_TYPE_IMMEDIATE:\n        immediate = immediate_b_type;\n      U_TYPE_IMMEDIATE:\n        immediate = immediate_u_type;\n      J_TYPE_IMMEDIATE:\n        immediate = immediate_j_type;\n      CSR_TYPE_IMMEDIATE:\n        immediate = immediate_csr_type;\n      default:\n        immediate = immediate_i_type;\n    endcase\n  end\n\n  //-----------------------------------------------------------------------------------------------//\n  // Take branch decision                                                                          //\n  //-----------------------------------------------------------------------------------------------//\n\n  assign is_branch =\n    branch_type & !illegal_branch;\n\n  assign is_jump =\n    jal_type | (jalr_type & !illegal_jalr);\n\n  assign is_equal =\n    rs1_data == rs2_data;\n\n  assign is_not_equal =\n    !is_equal;\n\n  assign is_less_than_unsigned =\n    rs1_data < rs2_data;\n\n  assign is_less_than =\n    rs1_data[31] ^ rs2_data[31] ?\n    rs1_data[31] :\n    is_less_than_unsigned;\n\n  assign is_greater_or_equal_than =\n    !is_less_than;\n\n  assign is_greater_or_equal_than_unsigned =\n    !is_less_than_unsigned;\n\n  always @* begin : branch_condition_satisfied_mux\n    case (instruction_funct3)\n      FUNCT3_BEQ:\n        branch_condition_satisfied =\n          is_equal;\n      FUNCT3_BNE:\n        branch_condition_satisfied =\n          is_not_equal;\n      FUNCT3_BLT:\n        branch_condition_satisfied =\n          is_less_than;\n      FUNCT3_BGE:\n        branch_condition_satisfied =\n          is_greater_or_equal_than;\n      FUNCT3_BLTU:\n        branch_condition_satisfied =\n          is_less_than_unsigned;\n      FUNCT3_BGEU:\n        branch_condition_satisfied =\n          is_greater_or_equal_than_unsigned;\n      default:\n        branch_condition_satisfied =\n          1'b0;\n      endcase\n  end\n\n  assign take_branch =\n    (is_jump == 1'b1) ?\n    1'b1 :\n      (is_branch == 1'b1) ?\n      branch_condition_satisfied :\n      1'b0;\n\n  //-----------------------------------------------------------------------------------------------//\n  // Integer File implementation                                                                   //\n  //-----------------------------------------------------------------------------------------------//\n\n  assign integer_file_write_enable =\n    integer_file_write_request & !flush & !load_pending;\n\n  integer i;\n  always @(posedge clock) begin\n    if (reset_internal)\n      for (i = 1; i < 32; i = i + 1) integer_file[i] <= 32'h00000000;\n    else if (clock_enable & integer_file_write_enable)\n      integer_file[instruction_rd_address] <= writeback_multiplexer_output;\n  end\n\n  assign rs1_data =\n    instruction_rs1_address == 5'b00000 ?\n    32'h00000000 :\n    integer_file[instruction_rs1_address];\n\n  assign rs2_data =\n    instruction_rs2_address == 5'b00000 ?\n    32'h00000000 :\n    integer_file[instruction_rs2_address];\n\n  //---------------------------------------------------------------------------------------------//\n  // M-mode logic and hart control                                                               //\n  //---------------------------------------------------------------------------------------------//\n\n  assign flush =\n    current_state != STATE_OPERATING;\n\n  assign interrupt_pending =\n    (csr_mie_meie & csr_mip_meip) |\n    (csr_mie_mtie & csr_mip_mtip) |\n    (csr_mie_msie & csr_mip_msip) |\n    (|(csr_mie_mfie & csr_mip_mfip));\n\n  assign exception_pending =\n    illegal_instruction |\n    misaligned_load |\n    misaligned_store |\n    misaligned_instruction_address;\n\n  assign take_trap =\n    (csr_mstatus_mie & interrupt_pending) |\n    exception_pending |\n    ecall |\n    ebreak;\n\n  always @* begin : m_mode_fsm_next_state_logic\n    case (current_state)\n      STATE_RESET:\n        next_state = STATE_OPERATING;\n      STATE_OPERATING:\n        if(take_trap)\n          next_state = STATE_TRAP_TAKEN;\n        else if(mret)\n          next_state = STATE_TRAP_RETURN;\n        else\n          next_state = STATE_OPERATING;\n      STATE_TRAP_TAKEN:\n        next_state = STATE_OPERATING;\n      STATE_TRAP_RETURN:\n        next_state = STATE_OPERATING;\n      default:\n        next_state = STATE_OPERATING;\n    endcase\n  end\n\n  always @(posedge clock) begin : m_mode_fsm_current_state_register\n    if(reset_internal)\n      current_state <= STATE_RESET;\n    else if (clock_enable | interrupt_pending)\n      current_state <= next_state;\n  end\n\n  always @* begin : program_counter_source_mux\n    case (current_state)\n      STATE_RESET:\n        program_counter_source = PC_BOOT;\n      STATE_OPERATING:\n        program_counter_source = PC_NEXT;\n      STATE_TRAP_TAKEN:\n        program_counter_source = PC_TRAP;\n      STATE_TRAP_RETURN:\n        program_counter_source = PC_EPC;\n      default:\n        program_counter_source = PC_NEXT;\n    endcase\n  end\n\n  assign irq_external_response =\n    (current_state    == STATE_TRAP_TAKEN) &&\n    (csr_mcause_code  == 5'b1011);\n\n  assign irq_timer_response =\n    (current_state    == STATE_TRAP_TAKEN) &&\n    (csr_mcause_code  == 5'b0111);\n\n  assign irq_software_response =\n    (current_state    == STATE_TRAP_TAKEN) &&\n    (csr_mcause_code  == 5'b0011);\n\n  generate\n    genvar ifast;\n    for (ifast = 0; ifast < 16; ifast = ifast + 1) begin\n        assign irq_fast_response[ifast] =\n        (current_state    == STATE_TRAP_TAKEN) &&\n        (csr_mcause_code  == ifast+16);\n    end\n  endgenerate\n\n  //---------------------------------------------------------------------------------------------//\n  // Control and Status Registers implementation                                                 //\n  //---------------------------------------------------------------------------------------------//\n\n  assign csr_data_mask =\n    csr_operation[2] == 1'b1 ?\n    {27'b0, immediate[4:0]} :\n    rs1_data;\n\n  always @* begin : csr_write_data_mux\n    case (csr_operation[1:0])\n      CSR_RWX:\n        csr_write_data = csr_data_mask;\n      CSR_RSX:\n        csr_write_data = csr_data_out |  csr_data_mask;\n      CSR_RCX:\n        csr_write_data = csr_data_out & ~csr_data_mask;\n      default:\n        csr_write_data = csr_data_out;\n    endcase\n  end\n\n  always @* begin : csr_data_out_mux\n    case (instruction_csr_address)\n      MARCHID:       csr_data_out = 32'h00000018; // RISC-V Steel microarchitecture ID\n      MIMPID:        csr_data_out = 32'h00000006; // Version 6\n      CYCLE:         csr_data_out = csr_mcycle    [31:0 ];\n      CYCLEH:        csr_data_out = csr_mcycle    [63:32];\n      TIME:          csr_data_out = csr_utime     [31:0 ];\n      TIMEH:         csr_data_out = csr_utime     [63:32];\n      INSTRET:       csr_data_out = csr_minstret  [31:0 ];\n      INSTRETH:      csr_data_out = csr_minstret  [63:32];\n      MSTATUS:       csr_data_out = csr_mstatus;\n      MSTATUSH:      csr_data_out = 32'h00000000;\n      MISA:          csr_data_out = 32'h40000100; // RV32I base ISA only\n      MIE:           csr_data_out = csr_mie;\n      MTVEC:         csr_data_out = csr_mtvec;\n      MSCRATCH:      csr_data_out = csr_mscratch;\n      MEPC:          csr_data_out = csr_mepc;\n      MCAUSE:        csr_data_out = csr_mcause;\n      MTVAL:         csr_data_out = csr_mtval;\n      MIP:           csr_data_out = csr_mip;\n      MCYCLE:        csr_data_out = csr_mcycle    [31:0 ];\n      MCYCLEH:       csr_data_out = csr_mcycle    [63:32];\n      MINSTRET:      csr_data_out = csr_minstret  [31:0 ];\n      MINSTRETH:     csr_data_out = csr_minstret  [63:32];\n      default:       csr_data_out = 32'h00000000;\n    endcase\n  end\n\n  assign csr_file_write_enable =\n    csr_file_write_request & !flush;\n\n  assign misaligned_instruction_address =\n    take_branch & next_address[1];\n\n  //---------------------------------------------------------------------------------------------//\n  // mstatus : M-mode Status register                                                            //\n  //---------------------------------------------------------------------------------------------//\n\n  assign csr_mstatus = {\n    19'b0000000000000000000,\n    2'b11,              // M-mode Prior Privilege (always M-mode)\n    3'b000,\n    csr_mstatus_mpie,   // M-mode Prior Global Interrupt Enable\n    3'b000,\n    csr_mstatus_mie,    // M-mode Global Interrupt Enable\n    3'b000\n  };\n\n  always @(posedge clock) begin : mstatus_csr_fields_update\n    if(reset_internal) begin\n      csr_mstatus_mie   <= 1'b0;\n      csr_mstatus_mpie  <= 1'b1;\n    end\n    else if (clock_enable) begin\n      if(current_state == STATE_TRAP_RETURN) begin\n        csr_mstatus_mie   <= csr_mstatus_mpie;\n        csr_mstatus_mpie  <= 1'b1;\n      end\n      else if(current_state == STATE_TRAP_TAKEN) begin\n        csr_mstatus_mpie  <= csr_mstatus_mie;\n        csr_mstatus_mie   <= 1'b0;\n      end\n      else if(current_state == STATE_OPERATING && instruction_csr_address == MSTATUS && csr_file_write_enable) begin\n        csr_mstatus_mie   <= csr_write_data[3];\n        csr_mstatus_mpie  <= csr_write_data[7];\n      end\n    end\n  end\n\n  //---------------------------------------------------------------------------------------------//\n  // mie : M-mode Interrupt Enable register                                                      //\n  //---------------------------------------------------------------------------------------------//\n\n  assign csr_mie = {\n    csr_mie_mfie,   // M-mode Designated for platform use (irq fast)\n    4'b0,\n    csr_mie_meie,   // M-mode External Interrupt Enable\n    3'b0,\n    csr_mie_mtie,   // M-mode Timer Interrupt Enable\n    3'b0,\n    csr_mie_msie,   // M-mode Software Interrupt Enable\n    3'b0\n  };\n\n  always @(posedge clock) begin : mie_csr_fields_implementation\n    if(reset_internal) begin\n      csr_mie_mfie <= 16'b0;\n      csr_mie_meie <= 1'b0;\n      csr_mie_mtie <= 1'b0;\n      csr_mie_msie <= 1'b0;\n    end\n    else if(clock_enable & instruction_csr_address == MIE && csr_file_write_enable) begin\n      csr_mie_mfie <= csr_write_data[31:16];\n      csr_mie_meie <= csr_write_data[11];\n      csr_mie_mtie <= csr_write_data[7];\n      csr_mie_msie <= csr_write_data[3];\n    end\n  end\n\n  //---------------------------------------------------------------------------------------------//\n  // mip : M-mode Interrupt Pending                                                              //\n  //---------------------------------------------------------------------------------------------//\n\n  assign csr_mip = {\n    csr_mip_mfip,\n    4'b0,\n    csr_mip_meip,\n    3'b0,\n    csr_mip_mtip,\n    3'b0,\n    csr_mip_msip,\n    3'b0\n  };\n\n  always @(posedge clock) begin : mip_csr_fields_implementation\n    if(reset_internal) begin\n      csr_mip_mfip <= 16'b0;\n      csr_mip_meip <= 1'b0;\n      csr_mip_mtip <= 1'b0;\n      csr_mip_msip <= 1'b0;\n    end\n    else begin\n      csr_mip_mfip <= irq_fast;\n      csr_mip_meip <= irq_external;\n      csr_mip_mtip <= irq_timer;\n      csr_mip_msip <= irq_software;\n    end\n  end\n\n  //------------------------------"}
{"text": "---------------------------------------------------------------//\n  // mepc : M-mode Exception Program Counter register                                            //\n  //---------------------------------------------------------------------------------------------//\n\n  always @(posedge clock) begin : mepc_implementation\n    if(reset_internal)\n      csr_mepc <= 32'h00000000;\n    else if (clock_enable) begin\n      if(take_trap)\n        csr_mepc <= program_counter;\n      else if(current_state == STATE_OPERATING && instruction_csr_address == MEPC && csr_file_write_enable)\n        csr_mepc <= {csr_write_data[31:2], 2'b00};\n    end\n  end\n\n  //---------------------------------------------------------------------------------------------//\n  // mscratch : M-mode Scratch register                                                          //\n  //---------------------------------------------------------------------------------------------//\n\n  always @(posedge clock) begin\n    if(reset_internal)\n      csr_mscratch <= 32'h00000000;\n    else if(clock_enable & instruction_csr_address == MSCRATCH && csr_file_write_enable)\n      csr_mscratch <= csr_write_data;\n  end\n\n  //---------------------------------------------------------------------------------------------//\n  // mcycle : M-mode Cycle Counter register                                                      //\n  //---------------------------------------------------------------------------------------------//\n\n  always @(posedge clock) begin : mcycle_implementation\n    if (reset_internal)\n      csr_mcycle <= 64'b0;\n    else begin\n      if (clock_enable & instruction_csr_address == MCYCLE && csr_file_write_enable)\n        csr_mcycle <= {csr_mcycle[63:32], csr_write_data} + 1;\n      else if (clock_enable & instruction_csr_address == MCYCLEH && csr_file_write_enable)\n        csr_mcycle <= {csr_write_data, csr_mcycle[31:0]} + 1;\n      else\n        csr_mcycle <= csr_mcycle + 1;\n    end\n  end\n\n  //---------------------------------------------------------------------------------------------//\n  // minstret : M-mode Instruction Retired Counter register                                      //\n  //---------------------------------------------------------------------------------------------//\n\n  always @(posedge clock) begin : minstret_implementation\n    if (reset_internal)\n      csr_minstret  <= 64'b0;\n    else if (clock_enable) begin\n      if (instruction_csr_address == MINSTRET && csr_file_write_enable) begin\n        if (current_state == STATE_OPERATING)\n          csr_minstret <= {csr_minstret[63:32], csr_write_data} + 1;\n        else\n          csr_minstret <= {csr_minstret[63:32], csr_write_data};\n      end\n      else if (instruction_csr_address == MINSTRETH && csr_file_write_enable) begin\n        if (current_state == STATE_OPERATING)\n          csr_minstret <= {csr_write_data, csr_minstret[31:0]} + 1;\n        else\n          csr_minstret <= {csr_write_data, csr_minstret[31:0]};\n      end\n      else begin\n        if (current_state == STATE_OPERATING)\n          csr_minstret <= csr_minstret + 1;\n        else\n          csr_minstret <= csr_minstret;\n      end\n    end\n  end\n\n  //---------------------------------------------------------------------------------------------//\n  // utime : Time register (Read-only shadow of mtime)                                           //\n  //---------------------------------------------------------------------------------------------//\n\n  always @(posedge clock) begin : utime_csr_implementation\n    csr_utime <= real_time_clock;\n  end\n\n  //---------------------------------------------------------------------------------------------//\n  // mcause : M-mode Trap Cause register                                                         //\n  //---------------------------------------------------------------------------------------------//\n\n  always @(posedge clock) begin : mcause_implementation\n    if(reset_internal)\n      csr_mcause <= 32'h00000000;\n    else if (clock_enable) begin\n      if(current_state == STATE_TRAP_TAKEN)\n        csr_mcause <= {csr_mcause_interrupt_flag, 26'b0, csr_mcause_code};\n      else if(current_state == STATE_OPERATING && instruction_csr_address == MCAUSE && csr_file_write_enable)\n        csr_mcause <= csr_write_data;\n    end\n  end\n\n  always @(posedge clock) begin : trap_cause_implementation\n    if(reset_internal) begin\n      csr_mcause_code           <= 5'b0;\n      csr_mcause_interrupt_flag <= 1'b0;\n    end\n    if(clock_enable & current_state == STATE_OPERATING) begin\n      if(illegal_instruction) begin\n        csr_mcause_code           <= 5'b0010;\n        csr_mcause_interrupt_flag <= 1'b0;\n      end\n      else if(misaligned_instruction_address) begin\n        csr_mcause_code           <= 5'b0000;\n        csr_mcause_interrupt_flag <= 1'b0;\n      end\n      else if(ecall) begin\n        csr_mcause_code           <= 5'b1011;\n        csr_mcause_interrupt_flag <= 1'b0;\n      end\n      else if(ebreak) begin\n        csr_mcause_code           <= 5'b0011;\n        csr_mcause_interrupt_flag <= 1'b0;\n      end\n      else if(misaligned_store) begin\n        csr_mcause_code           <= 5'b0110;\n        csr_mcause_interrupt_flag <= 1'b0;\n      end\n      else if(misaligned_load) begin\n        csr_mcause_code           <= 5'b0100;\n        csr_mcause_interrupt_flag <= 1'b0;\n      end\n      else if(csr_mstatus_mie & csr_mie_mfie[0] & csr_mip_mfip[0]) begin\n        csr_mcause_code           <= 5'd16;\n        csr_mcause_interrupt_flag <= 1'b1;\n      end\n      else if(csr_mstatus_mie & csr_mie_mfie[1] & csr_mip_mfip[1]) begin\n        csr_mcause_code           <= 5'd17;\n        csr_mcause_interrupt_flag <= 1'b1;\n      end\n      else if(csr_mstatus_mie & csr_mie_mfie[2] & csr_mip_mfip[2]) begin\n        csr_mcause_code           <= 5'd18;\n        csr_mcause_interrupt_flag <= 1'b1;\n      end\n      else if(csr_mstatus_mie & csr_mie_mfie[3] & csr_mip_mfip[3]) begin\n        csr_mcause_code           <= 5'd19;\n        csr_mcause_interrupt_flag <= 1'b1;\n      end\n      else if(csr_mstatus_mie & csr_mie_mfie[4] & csr_mip_mfip[4]) begin\n        csr_mcause_code           <= 5'd20;\n        csr_mcause_interrupt_flag <= 1'b1;\n      end\n      else if(csr_mstatus_mie & csr_mie_mfie[5] & csr_mip_mfip[5]) begin\n        csr_mcause_code           <= 5'd21;\n        csr_mcause_interrupt_flag <= 1'b1;\n      end\n      else if(csr_mstatus_mie & csr_mie_mfie[6] & csr_mip_mfip[6]) begin\n        csr_mcause_code           <= 5'd22;\n        csr_mcause_interrupt_flag <= 1'b1;\n      end\n      else if(csr_mstatus_mie & csr_mie_mfie[7] & csr_mip_mfip[7]) begin\n        csr_mcause_code           <= 5'd23;\n        csr_mcause_interrupt_flag <= 1'b1;\n      end\n      else if(csr_mstatus_mie & csr_mie_mfie[8] & csr_mip_mfip[8]) begin\n        csr_mcause_code           <= 5'd24;\n        csr_mcause_interrupt_flag <= 1'b1;\n      end\n      else if(csr_mstatus_mie & csr_mie_mfie[9] & csr_mip_mfip[9]) begin\n        csr_mcause_code           <= 5'd25;\n        csr_mcause_interrupt_flag <= 1'b1;\n      end\n      else if(csr_mstatus_mie & csr_mie_mfie[10] & csr_mip_mfip[10]) begin\n        csr_mcause_code           <= 5'd26;\n        csr_mcause_interrupt_flag <= 1'b1;\n      end\n      else if(csr_mstatus_mie & csr_mie_mfie[11] & csr_mip_mfip[11]) begin\n        csr_mcause_code           <= 5'd27;\n        csr_mcause_interrupt_flag <= 1'b1;\n      end\n      else if(csr_mstatus_mie & csr_mie_mfie[12] & csr_mip_mfip[12]) begin\n        csr_mcause_code           <= 5'd28;\n        csr_mcause_interrupt_flag <= 1'b1;\n      end\n      else if(csr_mstatus_mie & csr_mie_mfie[13] & csr_mip_mfip[13]) begin\n        csr_mcause_code           <= 5'd29;\n        csr_mcause_interrupt_flag <= 1'b1;\n      end\n      else if(csr_mstatus_mie & csr_mie_mfie[14] & csr_mip_mfip[14]) begin\n        csr_mcause_code           <= 5'd30;\n        csr_mcause_interrupt_flag <= 1'b1;\n      end\n      else if(csr_mstatus_mie & csr_mie_mfie[15] & csr_mip_mfip[15]) begin\n        csr_mcause_code           <= 5'd31;\n        csr_mcause_interrupt_flag <= 1'b1;\n      end\n      else if(csr_mstatus_mie & csr_mie_meie & csr_mip_meip) begin\n        csr_mcause_code           <= 5'b1011;\n        csr_mcause_interrupt_flag <= 1'b1;\n      end\n      else if(csr_mstatus_mie & csr_mie_msie & csr_mip_msip) begin\n        csr_mcause_code           <= 5'b0011;\n        csr_mcause_interrupt_flag <= 1'b1;\n      end\n      else if(csr_mstatus_mie & csr_mie_mtie & csr_mip_mtip) begin\n        csr_mcause_code           <= 5'b0111;\n        csr_mcause_interrupt_flag <= 1'b1;\n      end\n    end\n  end\n\n  //---------------------------------------------------------------------------------------------//\n  // mtval : M-mode Trap Value                                                                   //\n  //---------------------------------------------------------------------------------------------//\n\n  assign misaligned_address_exception =\n    misaligned_load | misaligned_store | misaligned_instruction_address;\n\n  always @(posedge clock) begin : mtval_implementation\n    if(reset_internal)\n      csr_mtval <= 32'h00000000;\n    else if (clock_enable) begin\n      if(take_trap) begin\n        if(misaligned_address_exception)\n          csr_mtval <= target_address_adder;\n        else if (ebreak)\n          csr_mtval <= program_counter;\n        else\n          csr_mtval <= 32'h00000000;\n      end\n      else if(current_state == STATE_OPERATING && instruction_csr_address == MTVAL && csr_file_write_enable)\n        csr_mtval <= csr_write_data;\n    end\n  end\n\n  //---------------------------------------------------------------------------------------------//\n  // mtvec : M-mode Trap Vector Address register                                                 //\n  //---------------------------------------------------------------------------------------------//\n\n  assign interrupt_address_offset =\n    {{25{1'b0}}, csr_mcause_code, 2'b00};\n\n  assign trap_address =\n    csr_mtvec[1:0] == 2'b01 && csr_mcause_interrupt_flag ?\n    {csr_mtvec[31:2], 2'b00} + interrupt_address_offset :\n    {csr_mtvec[31:2], 2'b00};\n\n  always @(posedge clock) begin : mtvec_implementation\n    if(reset_internal)\n      csr_mtvec <= 32'h00000000;\n    else if(clock_enable & instruction_csr_address == MTVEC && csr_file_write_enable)\n      csr_mtvec <= {csr_write_data[31:2], 1'b0, csr_write_data[0]};\n  end\n\n  //---------------------------------------------------------------------------------------------//\n  // Integer register file writeback selection                                                   //\n  //---------------------------------------------------------------------------------------------//\n\n  always @* begin\n    case (writeback_mux_selector)\n      WB_ALU:          writeback_multiplexer_output = alu_output;\n      WB_LOAD_UNIT:    writeback_multiplexer_output = load_data;\n      WB_UPPER_IMM:    writeback_multiplexer_output = immediate;\n      WB_TARGET_ADDER: writeback_multiplexer_output = target_address_adder;\n      WB_CSR:          writeback_multiplexer_output = csr_data_out;\n      WB_PC_PLUS_4:    writeback_multiplexer_output = program_counter_plus_4;\n      default:         writeback_multiplexer_output = alu_output;\n    endcase\n  end\n\n  //-----------------------------------------------------------------------------------------------//\n  // Load data logic                                                                               //\n  //-----------------------------------------------------------------------------------------------//\n\n  always @* begin : load_size_mux\n    case (load_size)\n      LOAD_SIZE_BYTE:\n        load_data = {load_byte_upper_bits, load_byte_data};\n      LOAD_SIZE_HALF:\n        load_data = {load_half_upper_bits, load_half_data};\n      LOAD_SIZE_WORD:\n        load_data = read_data;\n      default:\n        load_data = read_data;\n    endcase\n  end\n\n  always @* begin : load_byte_data_mux\n    case (target_address_adder[1:0])\n      2'b00:\n        load_byte_data = read_data[7:0];\n      2'b01:\n        load_byte_data = read_data[15:8];\n      2'b10:\n        load_byte_data = read_data[23:16];\n      2'b11:\n        load_byte_data = read_data[31:24];\n    endcase\n  end\n\n  always @* begin : load_half_data_mux\n    case (target_address_adder[1])\n      1'b0:\n        load_half_data = read_data[15:0];\n      1'b1:\n        load_half_data = read_data[31:16];\n    endcase\n  end\n\n  assign load_byte_upper_bits =\n    load_unsigned == 1'b1 ?\n    24'b0 :\n    {24{load_byte_data[7]}};\n\n  assign load_half_upper_bits =\n    load_unsigned == 1'b1 ?\n    16'b0 :\n    {16{load_half_data[15]}};\n\n  //-----------------------------------------------------------------------------------------------//\n  // Arithmetic and Logic Unit                                                                     //\n  //-----------------------------------------------------------------------------------------------//\n\n  assign alu_2nd_operand =\n    alu_2nd_operand_source ?\n    rs2_data :\n    immediate;\n\n  assign alu_minus_2nd_operand =\n    - alu_2nd_operand;\n\n  assign alu_adder_2nd_operand_mux =\n    alu_operation_code[3] == 1'b1 ?\n    alu_minus_2nd_operand :\n    alu_2nd_operand;\n\n  assign alu_sra_result =\n    $signed(rs1_data) >>> alu_2nd_operand[4:0];\n\n  assign alu_srl_result =\n    rs1_data >> alu_2nd_operand[4:0];\n\n  assign alu_shift_right_mux =\n    alu_operation_code[3] == 1'b1 ?\n    alu_sra_result :\n    alu_srl_result;\n\n  assign alu_sltu_result =\n    rs1_data < alu_2nd_operand;\n\n  assign alu_slt_result =\n    rs1_data[31] ^ alu_2nd_operand[31] ?\n    rs1_data[31] :\n    alu_sltu_result;\n\n  always @* begin : operation_result_mux\n    case (alu_operation_code[2:0])\n      FUNCT3_ADD:\n        alu_output =\n          rs1_data + alu_adder_2nd_operand_mux;\n      FUNCT3_SRL:\n        alu_output =\n          alu_shift_right_mux;\n      FUNCT3_OR:\n        alu_output =\n          rs1_data | alu_2nd_operand;\n      FUNCT3_AND:\n        alu_output =\n          rs1_data & alu_2nd_operand;\n      FUNCT3_XOR:\n        alu_output =\n          rs1_data ^ alu_2nd_operand;\n      FUNCT3_SLT:\n        alu_output =\n          {31'b0, alu_slt_result};\n      FUNCT3_SLTU:\n        alu_output =\n          {31'b0, alu_sltu_result};\n      FUNCT3_SLL:\n        alu_output =\n          rs1_data << alu_2nd_operand[4:0];\n    endcase\n  end\n\nendmodule\n"}
{"text": "// ----------------------------------------------------------------------------\n// Copyright (c) 2020-2024 RISC-V Steel contributors\n//\n// This work is licensed under the MIT License, see LICENSE file for details.\n// SPDX-License-Identifier: MIT\n// ----------------------------------------------------------------------------\n\nmodule rvsteel_gpio #(\n\n  parameter GPIO_WIDTH = 2\n\n) (\n\n  // Global signals\n\n  input   wire                    clock         ,\n  input   wire                    reset         ,\n\n  // IO interface\n\n  input   wire  [4:0 ]            rw_address    ,\n  output  reg   [31:0]            read_data     ,\n  input   wire                    read_request  ,\n  output  reg                     read_response ,\n  input   wire  [1:0 ]            write_data    ,\n  input   wire  [3:0 ]            write_strobe  ,\n  input   wire                    write_request ,\n  output  reg                     write_response,\n\n  // I/O signals\n\n  input   wire  [GPIO_WIDTH-1:0]  gpio_input    ,\n  output  wire  [GPIO_WIDTH-1:0]  gpio_oe       ,\n  output  wire  [GPIO_WIDTH-1:0]  gpio_output\n\n);\n\n  // Map registers\n  localparam REG_ADDR_WIDTH   = 2'd3;\n\n  localparam REG_IN           = 3'd0;\n  localparam REG_OE           = 3'd1;\n  localparam REG_OUT          = 3'd2;\n  localparam REG_CLR          = 3'd3;\n  localparam REG_SET          = 3'd4;\n\n\n  // Output Enable\n  reg oe_update;\n  reg [GPIO_WIDTH-1:0] oe;\n\n  // Output data\n  reg out_update;\n  reg [GPIO_WIDTH-1:0] out;\n\n  // Clear mask\n  reg clr_update;\n\n  // Set mask\n  reg set_update;\n\n\n  assign gpio_oe = oe;\n  assign gpio_output = out;\n\n\n  // Bus\n  wire address_aligned;\n  assign address_aligned = (~|rw_address[1:0]);\n\n  wire write_word;\n  assign write_word = (&write_strobe);\n\n  wire [REG_ADDR_WIDTH-1:0] address;\n  assign address = rw_address[2 +:REG_ADDR_WIDTH];\n\n\n  always @(posedge clock) begin\n    if (reset) begin\n      oe <= {GPIO_WIDTH{1'b0}};\n      out <= {GPIO_WIDTH{1'b0}};\n    end else begin\n      if (oe_update) begin\n        oe <= write_data[0 +: GPIO_WIDTH];\n      end\n\n      if (out_update) begin\n        out <= write_data[0 +: GPIO_WIDTH];\n      end\n\n      if (clr_update) begin\n        out <= out & ~write_data[0 +: GPIO_WIDTH];\n      end\n\n      if (set_update) begin\n        out <= out | write_data[0 +: GPIO_WIDTH];\n      end\n    end\n  end\n\n\n  // Bus: Response to request\n  always @(posedge clock) begin\n    if (reset) begin\n      read_response <= 1'b0;\n      write_response <= 1'b0;\n    end else begin\n      read_response <= read_request;\n      write_response <= write_request;\n    end\n  end\n\n\n  // Bus: Read registers\n  always @(posedge clock) begin\n    if (reset) begin\n      read_data <= 32'd0;\n    end else begin\n      if (read_request && address_aligned) begin\n        case (address)\n          REG_IN    : read_data <= {{32-GPIO_WIDTH{1'b0}}, gpio_input};\n          REG_OE    : read_data <= {{32-GPIO_WIDTH{1'b0}}, oe};\n          REG_OUT   : read_data <= {{32-GPIO_WIDTH{1'b0}}, out};\n          REG_CLR   : read_data <= 32'd0;\n          REG_SET   : read_data <= 32'd0;\n          default: begin end\n        endcase\n      end\n    end\n  end\n\n\n  // Bus: Update registers\n  always @(*) begin\n    oe_update   = 1'b0;\n    out_update  = 1'b0;\n    clr_update  = 1'b0;\n    set_update  = 1'b0;\n\n    if (write_request && address_aligned && write_word) begin\n        case (address)\n            REG_OE    : oe_update   = 1'b1;\n            REG_OUT   : out_update  = 1'b1;\n            REG_CLR   : clr_update  = 1'b1;\n            REG_SET   : set_update  = 1'b1;\n            default: begin end\n        endcase\n    end\n  end\n\nendmodule\n"}
{"text": "// ----------------------------------------------------------------------------\n// Copyright (c) 2020-2024 RISC-V Steel contributors\n//\n// This work is licensed under the MIT License, see LICENSE file for details.\n// SPDX-License-Identifier: MIT\n// ----------------------------------------------------------------------------\n\nmodule rvsteel_mtimer (\n\n  // Global signals\n\n  input   wire          clock         ,\n  input   wire          reset         ,\n\n  // IO interface\n\n  input   wire  [4:0 ]  rw_address    ,\n  output  reg   [31:0]  read_data     ,\n  input   wire          read_request  ,\n  output  reg           read_response ,\n  input   wire  [31:0]  write_data    ,\n  input   wire  [3:0 ]  write_strobe  ,\n  input   wire          write_request ,\n  output  reg           write_response,\n\n  // TODO: use it later\n  // output  reg        access_fault  ,\n\n  // Side timer irq\n  // Interrupt signaling\n\n  output  reg           irq\n\n);\n\n  localparam REG_ADDR_WIDTH   = 2'd3;\n\n  // Map registers\n  localparam REG_CR           = 3'd0;\n  localparam REG_MTIMEL       = 3'd1;\n  localparam REG_MTIMEH       = 3'd2;\n  localparam REG_MTIMECMPL    = 3'd3;\n  localparam REG_MTIMECMPH    = 3'd4;\n\n  // Map bits\n  // CR\n  localparam BIT_CR_EN        = 5'd0;\n  localparam BIT_CR_WIDTH     = 5'd1;\n  localparam CR_PADDING       = {6'd32-BIT_CR_WIDTH{1'd0}};\n\n  // Control register\n  reg cr_update;\n  reg cr_en;\n\n  // mtime\n  reg mtime_l_update;\n  reg mtime_h_update;\n  reg [63:0] mtime;\n\n  // mtimecmp\n  reg mtimecmp_l_update;\n  reg mtimecmp_h_update;\n  reg [63:0] mtimecmp;\n\n\n  // Bus\n  wire address_aligned;\n  assign address_aligned = (~|rw_address[1:0]);\n\n  wire write_word;\n  assign write_word = (&write_strobe);\n\n  wire [REG_ADDR_WIDTH-1:0] address;\n  assign address = rw_address[2 +:REG_ADDR_WIDTH];\n\n  // Control register\n  always @(posedge clock) begin\n    if (reset) begin\n      cr_en <= 1'b0;\n    end else begin\n      if (cr_update) begin\n        cr_en <= write_data[BIT_CR_EN];\n      end\n    end\n  end\n\n\n  // mtime\n  always @(posedge clock) begin\n    if (reset) begin\n      mtime <= {64{1'b0}};\n    end else begin\n      if (cr_en) begin\n        mtime <= mtime + 1'd1;\n      end\n\n      if (mtime_l_update) begin\n        mtime[31:0] <= write_data;\n      end\n\n      if (mtime_h_update) begin\n        mtime[63:32] <= write_data;\n      end\n    end\n  end\n\n\n  // mtimecmp\n  always @(posedge clock) begin\n    if (reset) begin\n      mtimecmp <= 64'hffff_ffff_ffff_ffff; // Initially, mtimecmp holds the biggest value so mtime is sure to be smaller than mtimecmp\n    end else begin\n      if (mtimecmp_l_update) begin\n        mtimecmp[31:0] <= write_data;\n      end\n\n      if (mtimecmp_h_update) begin\n        mtimecmp[63:32] <= write_data;\n      end\n    end\n  end\n\n\n  // IRQ\n  always @(posedge clock) begin\n    if (reset) begin\n      irq <= 1'b0;\n    end else begin\n      // Don't update while there is an update\n      if (~(mtime_l_update | mtime_h_update | mtimecmp_l_update | mtimecmp_h_update)) begin\n        // A machine timer interrupt becomes pending whenever mtime contains a\n        // value greater than or equal to mtimecmp\n        irq <= (mtime >= mtimecmp);\n      end\n    end\n  end\n\n\n  // Bus: Response to request\n  always @(posedge clock) begin\n    if (reset) begin\n      read_response <= 1'b0;\n      write_response <= 1'b0;\n      // access_fault <= 1'b0;\n    end else begin\n      read_response <= read_request;\n      write_response <= write_request;\n      // access_fault <= (read_request & !address_aligned) |\n      //                 (write_request & !address_aligned) |\n      //                 (write_request & !write_word);\n    end\n  end\n\n\n  // Bus: Read registers\n  always @(posedge clock) begin\n    if (reset) begin\n      read_data <= 32'd0;\n    end else begin\n      if (read_request && address_aligned) begin\n        case (address)\n          REG_CR        : read_data <= {CR_PADDING, cr_en};\n          REG_MTIMEL    : read_data <= mtime[31:0];\n          REG_MTIMEH    : read_data <= mtime[63:32];\n          REG_MTIMECMPL : read_data <= mtimecmp[31:0];\n          REG_MTIMECMPH : read_data <= mtimecmp[63:32];\n          default: begin end\n        endcase\n      end\n    end\n  end\n\n\n  // Bus: Update registers\n  always @(*) begin\n    cr_update         = 1'b0;\n    mtime_l_update    = 1'b0;\n    mtime_h_update    = 1'b0;\n    mtimecmp_l_update = 1'b0;\n    mtimecmp_h_update = 1'b0;\n\n    if (write_request && address_aligned && write_word) begin\n        case (address)\n            REG_CR        : cr_update         = 1'b1;\n            REG_MTIMEL    : mtime_l_update    = 1'b1;\n            REG_MTIMEH    : mtime_h_update    = 1'b1;\n            REG_MTIMECMPL : mtimecmp_l_update = 1'b1;\n            REG_MTIMECMPH : mtimecmp_h_update = 1'b1;\n            default: begin end\n        endcase\n    end\n  end\n\nendmodule\n"}
{"text": "// ----------------------------------------------------------------------------\n// Copyright (c) 2020-2024 RISC-V Steel contributors\n//\n// This work is licensed under the MIT License, see LICENSE file for details.\n// SPDX-License-Identifier: MIT\n// ----------------------------------------------------------------------------\n\nmodule rvsteel_ram #(\n\n  // Memory size in bytes\n  parameter MEMORY_SIZE      = 8192,\n\n  // File with program and data\n  parameter MEMORY_INIT_FILE = \"\"\n\n  ) (\n\n  // Global signals\n\n  input   wire          clock,\n  input   wire          reset,\n\n  // IO interface\n\n  input  wire   [31:0]  rw_address,\n  output reg    [31:0]  read_data,\n  input  wire           read_request,\n  output reg            read_response,\n  input  wire   [31:0]  write_data,\n  input  wire   [3:0 ]  write_strobe,\n  input  wire           write_request,\n  output reg            write_response\n\n  );\n\n  wire                        reset_internal;\n  wire [31:0]                 effective_address;\n  wire                        invalid_address;\n\n  reg                         reset_reg;\n  reg [31:0]                  ram [0:(MEMORY_SIZE/4)-1];\n\n  always @(posedge clock)\n    reset_reg <= reset;\n\n  assign reset_internal = reset | reset_reg;\n  assign invalid_address = $unsigned(rw_address) >= $unsigned(MEMORY_SIZE);\n\n  integer i;\n  initial begin\n    for (i = 0; i < MEMORY_SIZE/4; i = i + 1) ram[i] = 32'h00000000;\n    if (MEMORY_INIT_FILE != \"\")\n      $readmemh(MEMORY_INIT_FILE,ram);\n  end\n\n  assign effective_address =\n    $unsigned(rw_address[31:0] >> 2);\n\n  always @(posedge clock) begin\n    if (reset_internal | invalid_address)\n      read_data <= 32'h00000000;\n    else\n      read_data <= ram[effective_address];\n  end\n\n  always @(posedge clock) begin\n    if(write_request) begin\n      if(write_strobe[0])\n        ram[effective_address][7:0  ] <= write_data[7:0  ];\n      if(write_strobe[1])\n        ram[effective_address][15:8 ] <= write_data[15:8 ];\n      if(write_strobe[2])\n        ram[effective_address][23:16] <= write_data[23:16];\n      if(write_strobe[3])\n        ram[effective_address][31:24] <= write_data[31:24];\n    end\n  end\n\n  always @(posedge clock) begin\n    if (reset_internal) begin\n      read_response  <= 1'b0;\n      write_response <= 1'b0;\n    end\n    else begin\n      read_response  <= read_request;\n      write_response <= write_request;\n    end\n  end\n\n  // Avoid warnings about intentionally unused pins/wires\n  wire unused_ok =\n    &{1'b0,\n    effective_address[31:11],\n    1'b0};\n\nendmodule\n"}
{"text": "// ----------------------------------------------------------------------------\n// Copyright (c) 2020-2024 RISC-V Steel contributors\n//\n// This work is licensed under the MIT License, see LICENSE file for details.\n// SPDX-License-Identifier: MIT\n// ----------------------------------------------------------------------------\n\nmodule rvsteel_soc #(\n\n  // Frequency of 'clock' signal\n  parameter CLOCK_FREQUENCY = 50000000  ,\n  // Desired baud rate for UART unit\n  parameter UART_BAUD_RATE = 9600       ,\n  // Memory size in bytes - must be a power of 2\n  parameter MEMORY_SIZE = 8192          ,\n  // Text file with program and data (one hex value per line)\n  parameter MEMORY_INIT_FILE = \"\"       ,\n  // Address of the first instruction to fetch from memory\n  parameter BOOT_ADDRESS = 32'h00000000 ,\n  // Number of available I/O ports\n  parameter GPIO_WIDTH = 2              ,\n  // Number of CS (Chip Select) pins for the SPI controller\n  parameter NUM_CS_LINES = 1\n\n  ) (\n\n  input   wire                      clock       ,\n  input   wire                      reset       ,\n  input   wire                      halt        ,\n  input   wire                      uart_rx     ,\n  output  wire                      uart_tx     ,\n  input   wire  [GPIO_WIDTH-1:0]    gpio_input  ,\n  output  wire  [GPIO_WIDTH-1:0]    gpio_oe     ,\n  output  wire  [GPIO_WIDTH-1:0]    gpio_output ,\n  output  wire                      sclk        ,\n  output  wire                      pico        ,\n  input   wire                      poci        ,\n  output  wire  [NUM_CS_LINES-1:0]  cs\n\n  );\n\n  // System bus configuration\n\n  localparam NUM_DEVICES    = 5;\n  localparam D0_RAM         = 0;\n  localparam D1_UART        = 1;\n  localparam D2_MTIMER      = 2;\n  localparam D3_GPIO        = 3;\n  localparam D4_SPI         = 4;\n\n  wire  [NUM_DEVICES*32-1:0] device_start_address;\n  wire  [NUM_DEVICES*32-1:0] device_region_size;\n\n  assign device_start_address [32*D0_RAM      +: 32]  = 32'h0000_0000;\n  assign device_region_size   [32*D0_RAM      +: 32]  = MEMORY_SIZE;\n\n  assign device_start_address [32*D1_UART     +: 32]  = 32'h8000_0000;\n  assign device_region_size   [32*D1_UART     +: 32]  = 8;\n\n  assign device_start_address [32*D2_MTIMER   +: 32]  = 32'h8001_0000;\n  assign device_region_size   [32*D2_MTIMER   +: 32]  = 32;\n\n  assign device_start_address [32*D3_GPIO     +: 32]  = 32'h8002_0000;\n  assign device_region_size   [32*D3_GPIO     +: 32]  = 32;\n\n  assign device_start_address [32*D4_SPI      +: 32]  = 32'h8003_0000;\n  assign device_region_size   [32*D4_SPI      +: 32]  = 32;\n\n  // RISC-V Steel 32-bit Processor (Manager Device) <=> System Bus\n\n  wire  [31:0]                manager_rw_address      ;\n  wire  [31:0]                manager_read_data       ;\n  wire                        manager_read_request    ;\n  wire                        manager_read_response   ;\n  wire  [31:0]                manager_write_data      ;\n  wire  [3:0 ]                manager_write_strobe    ;\n  wire                        manager_write_request   ;\n  wire                        manager_write_response  ;\n\n  // System Bus <=> Managed Devices\n\n  wire  [31:0]                device_rw_address       ;\n  wire  [NUM_DEVICES*32-1:0]  device_read_data        ;\n  wire  [NUM_DEVICES-1:0]     device_read_request     ;\n  wire  [NUM_DEVICES-1:0]     device_read_response    ;\n  wire  [31:0]                device_write_data       ;\n  wire  [3:0]                 device_write_strobe     ;\n  wire  [NUM_DEVICES-1:0]     device_write_request    ;\n  wire  [NUM_DEVICES-1:0]     device_write_response   ;\n\n  // Real-time clock (unused)\n\n  wire  [63:0] real_time_clock;\n\n  assign real_time_clock = 64'b0;\n\n  // Interrupt signals\n\n  wire  [15:0] irq_fast;\n  wire         irq_external;\n  wire         irq_timer;\n  wire         irq_software;\n\n  wire  [15:0] irq_fast_response;\n  wire         irq_external_response;\n  wire         irq_timer_response;\n  wire         irq_software_response;\n\n  wire         irq_uart;\n  wire         irq_uart_response;\n\n  // Interrupt signals map\n\n  assign irq_fast               = {15'b0, irq_uart}; // Give UART interrupts the highest priority\n  assign irq_uart_response      = irq_fast_response[0];\n\n  assign irq_external           = 1'b0; // unused\n  assign irq_software           = 1'b0; // unused\n\n\n  rvsteel_core #(\n\n    .BOOT_ADDRESS                   (BOOT_ADDRESS                       )\n\n  ) rvsteel_core_instance (\n\n    // Global signals\n\n    .clock                          (clock                              ),\n    .reset                          (reset                              ),\n    .halt                           (halt                               ),\n\n    // IO interface\n\n    .rw_address                     (manager_rw_address                 ),\n    .read_data                      (manager_read_data                  ),\n    .read_request                   (manager_read_request               ),\n    .read_response                  (manager_read_response              ),\n    .write_data                     (manager_write_data                 ),\n    .write_strobe                   (manager_write_strobe               ),\n    .write_request                  (manager_write_request              ),\n    .write_response                 (manager_write_response             ),\n\n    // Interrupt request signals\n\n    .irq_fast                       (irq_fast                           ),\n    .irq_external                   (irq_external                       ),\n    .irq_timer                      (irq_timer                          ),\n    .irq_software                   (irq_software                       ),\n\n    // Interrupt response signals\n\n    .irq_fast_response              (irq_fast_response                  ),\n    .irq_external_response          (irq_external_response              ),\n    .irq_timer_response             (irq_timer_response                 ),\n    .irq_software_response          (irq_software_response              ),\n\n    // Real Time Clock\n\n    .real_time_clock                (real_time_clock                    )\n\n  );\n\n  rvsteel_bus #(\n\n    .NUM_DEVICES(NUM_DEVICES)\n\n  ) rvsteel_bus_instance (\n\n    // Global signals\n\n    .clock                          (clock                              ),\n    .reset                          (reset                              ),\n\n    // Interface with the manager device (Processor Core IP)\n\n    .manager_rw_address             (manager_rw_address                 ),\n    .manager_read_data              (manager_read_data                  ),\n    .manager_read_request           (manager_read_request               ),\n    .manager_read_response          (manager_read_response              ),\n    .manager_write_data             (manager_write_data                 ),\n    .manager_write_strobe           (manager_write_strobe               ),\n    .manager_write_request          (manager_write_request              ),\n    .manager_write_response         (manager_write_response             ),\n\n    // Interface with the managed devices\n\n    .device_rw_address              (device_rw_address                  ),\n    .device_read_data               (device_read_data                   ),\n    .device_read_request            (device_read_request                ),\n    .device_read_response           (device_read_response               ),\n    .device_write_data              (device_write_data                  ),\n    .device_write_strobe            (device_write_strobe                ),\n    .device_write_request           (device_write_request               ),\n    .device_write_response          (device_write_response              ),\n\n    // Base addresses and masks of the managed devices\n\n    .device_start_address          (device_start_address                ),\n    .device_region_size            (device_region_size                  )\n\n  );\n\n  rvsteel_ram #(\n\n    .MEMORY_SIZE                    (MEMORY_SIZE                        ),\n    .MEMORY_INIT_FILE               (MEMORY_INIT_FILE                   )\n\n  ) rvsteel_ram_instance (\n\n    // Global signals\n\n    .clock                          (clock                              ),\n    .reset                          (reset                              ),\n\n    // IO interface\n\n    .rw_address                     (device_rw_address                  ),\n    .read_data                      (device_read_data[32*D0_RAM +: 32]  ),\n    .read_request                   (device_read_request[D0_RAM]        ),\n    .read_response                  (device_read_response[D0_RAM]       ),\n    .write_data                     (device_write_data                  ),\n    .write_strobe                   (device_write_strobe                ),\n    .write_request                  (device_write_request[D0_RAM]       ),\n    .write_response                 (device_write_response[D0_RAM]      )\n\n  );\n\n  rvsteel_uart #(\n\n    .CLOCK_FREQUENCY                (CLOCK_FREQUENCY                    ),\n    .UART_BAUD_RATE                 (UART_BAUD_RATE                     )\n\n  ) rvsteel_uart_instance (\n\n    // Global signals\n\n    .clock                          (clock                              ),\n    .reset                          (reset                              ),\n\n    // IO interface\n\n    .rw_address                     (device_rw_address[4:0]             ),\n    .read_data                      (device_read_data[32*D1_UART +: 32] ),\n    .read_request                   (device_read_request[D1_UART]       ),\n    .read_response                  (device_read_response[D1_UART]      ),\n    .write_data                     (device_write_data[7:0]             ),\n    .write_request                  (device_write_request[D1_UART]      ),\n    .write_response                 (device_write_response[D1_UART]     ),\n\n    // RX/TX signals\n\n    .uart_tx                        (uart_tx                            ),\n    .uart_rx                        (uart_rx                            ),\n\n    // Interrupt signaling\n\n    .uart_irq                       (irq_uart                           ),\n    .uart_irq_response              (irq_uart_response                  )\n\n  );\n\n  rvsteel_mtimer\n  rvsteel_mtimer_instance (\n\n    // Global signals\n\n    .clock                          (clock                                  ),\n    .reset                          (reset                                  ),\n\n    // IO interface\n\n    .rw_address                     (device_rw_address[4:0]                 ),\n    .read_data                      (device_read_data[32*D2_MTIMER +: 32]   ),\n    .read_request                   (device_read_request[D2_MTIMER]         ),\n    .read_response                  (device_read_response[D2_MTIMER]        ),\n    .write_data                     (device_write_data                      ),\n    .write_strobe                   (device_write_strobe                    ),\n    .write_request                  (device_write_request[D2_MTIMER]        ),\n    .write_response                 (device_write_response[D2_MTIMER]       ),\n\n    // Interrupt signaling\n\n    .irq                            (irq_timer                              )\n\n  );\n\n  rvsteel_gpio #(\n\n    .GPIO_WIDTH                     (GPIO_WIDTH                             )\n\n  ) rvsteel_gpio_instance (\n\n    // Global signals\n\n    .clock                          (clock                                  ),\n    .reset                          (reset                                  ),\n\n    // IO interface\n\n    .rw_address                     (device_rw_address[4:0]                 ),\n    .read_data                      (device_read_data[32*D3_GPIO +: 32]     ),\n    .read_request                   (device_read_request[D3_GPIO]           ),\n    .read_response                  (device_read_response[D3_GPIO]          ),\n    .write_data                     (device_write_data[1:0]                 ),\n    .write_strobe                   (device_write_strobe                    ),\n    .write_request                  (device_write_request[D3_GPIO]          ),\n    .write_response                 (device_write_response[D3_GPIO]         ),\n\n    // I/O signals\n\n    .gpio_input                     (gpio_input                             ),\n    .gpio_oe                        (gpio_oe                                ),\n    .gpio_output                    (gpio_output                            )\n\n  );\n\n  rvsteel_spi #(\n\n    .NUM_CS_LINES                   (NUM_CS_LINES                       )\n\n  ) rvsteel_spi_instance (\n\n    // Global signals\n\n    .clock                          (clock                              ),\n    .reset                          (reset                              ),\n\n    // IO interface\n\n    .rw_address                     (device_rw_address[4:0]             ),\n    .read_data                      (device_read_data[32*D4_SPI +: 32]  ),\n    .read_request                   (device_read_request[D4_SPI]        ),\n    .read_response                  (device_read_response[D4_SPI]       ),\n    .write_data                     (device_write_data[7:0]             ),\n    .write_strobe                   (device_write_strobe                ),\n    .write_request                  (device_write_request[D4_SPI]       ),\n    .write_response                 (device_write_response[D4_SPI]      ),\n\n    // SPI signals\n\n    .sclk                           (sclk                               ),\n    .pico                           (pico                               ),\n    .poci                           (poci                               ),\n    .cs                             (cs                                 )\n\n  );\n\n  // Avoid warnings about intentionally unused pins/wires\n  wire unused_ok =\n    &{1'b0,\n    irq_external,\n    irq_software,\n    irq_external_response,\n    irq_software_response,\n    irq_timer_response,\n    irq_fast_response[15:1],\n    1'b0};\n\nendmodule\n"}
{"text": "// ----------------------------------------------------------------------------\n// Copyright (c) 2020-2024 RISC-V Steel contributors\n//\n// This work is licensed under the MIT License, see LICENSE file for details.\n// SPDX-License-Identifier: MIT\n// ----------------------------------------------------------------------------\n\nmodule rvsteel_spi #(\n\n  parameter NUM_CS_LINES = 1\n\n  )(\n\n  // Global signals\n\n  input   wire                      clock           ,\n  input   wire                      reset           ,\n\n  // IO interface\n\n  input  wire   [4:0 ]              rw_address      ,\n  output reg    [31:0]              read_data       ,\n  input  wire                       read_request    ,\n  output reg                        read_response   ,\n  input  wire   [7:0 ]              write_data      ,\n  input  wire   [3:0 ]              write_strobe    ,\n  input  wire                       write_request   ,\n  output reg                        write_response  ,\n\n  // SPI signals\n\n  output reg                        sclk            ,\n  output reg                        pico            ,\n  input  wire                       poci            ,\n  output reg    [NUM_CS_LINES-1:0]  cs\n\n  );\n\n  reg tx_start;\n  reg cpol;\n  reg cpha;\n  reg clk_edge;\n  reg sclk_internal;\n  reg pico_internal;\n  reg [NUM_CS_LINES-1:0] cs_internal;\n  reg [3:0] curr_state;\n  reg [3:0] next_state;\n  reg [3:0] bit_count;\n  reg [7:0] tx_reg;\n  reg [7:0] rx_reg;\n  reg [7:0] chip_select;\n  reg [7:0] cycle_counter;\n  reg [7:0] clock_div;\n\n  // SPI State Machine\n  localparam SPI_READY        = 4'b0001;\n  localparam SPI_IDLE         = 4'b0010;\n  localparam SPI_CPOL         = 4'b0100;\n  localparam SPI_CPOL_N       = 4'b1000;\n\n  // Register addresses\n  localparam REG_CPOL           = 5'h00;\n  localparam REG_CPHA           = 5'h04;\n  localparam REG_CHIP_SELECT    = 5'h08;\n  localparam REG_CLOCK_DIV      = 5'h0c;\n  localparam REG_WDATA          = 5'h10;\n  localparam REG_RDATA          = 5'h14;\n  localparam REG_STATUS         = 5'h18;\n\n  wire busy_bit = curr_state == SPI_CPOL || curr_state == SPI_CPOL_N;\n  wire valid_write_request = write_request == 1'b1 && &write_strobe == 1'b1;\n\n  integer i;\n\n  always @(posedge clock) begin\n    if (reset) begin\n      read_response <= 1'b0;\n      write_response <= 1'b0;\n    end\n    else begin\n      read_response <= read_request;\n      write_response <= write_request;\n    end\n  end\n\n  always @(posedge clock) begin\n    if (reset)\n      read_data <= 32'hdeadbeef;\n    else if (read_request == 1'b1) begin\n      case (rw_address)\n        REG_CPOL:         read_data <= {31'b0, cpol};\n        REG_CPHA:         read_data <= {31'b0, cpha};\n        REG_CHIP_SELECT:  read_data <= {24'b0, chip_select};\n        REG_CLOCK_DIV:    read_data <= {24'b0, clock_div};\n        REG_RDATA:        read_data <= {24'b0, rx_reg};\n        REG_STATUS:       read_data <= {31'b0, busy_bit};\n        default:          read_data <= 32'hdeadbeef;\n      endcase\n    end\n    else\n      read_data <= 32'hdeadbeef;\n  end\n\n  always @(posedge clock) begin\n    if (reset)\n      cpol <= 1'b0;\n    else if (rw_address == REG_CPOL && valid_write_request == 1'b1)\n      cpol <= write_data[0];\n    else\n      cpol <= cpol;\n  end\n\n  always @(posedge clock) begin\n    if (reset)\n      cpha <= 1'b0;\n    else if (rw_address == REG_CPHA && valid_write_request == 1'b1)\n      cpha <= write_data[0];\n    else\n      cpha <= cpha;\n  end\n\n  always @(posedge clock) begin\n    if (reset)\n      chip_select <= 8'hff;\n    else if (rw_address == REG_CHIP_SELECT && valid_write_request == 1'b1)\n      chip_select <= write_data[7:0];\n    else\n      chip_select <= chip_select;\n  end\n\n  always @(posedge clock) begin\n    if (reset)\n      clock_div <= 8'h00;\n    else if (rw_address == REG_CLOCK_DIV && valid_write_request == 1'b1)\n      clock_div <= write_data[7:0];\n    else\n      clock_div <= clock_div;\n  end\n\n  always @(posedge clock) begin\n    if (reset) begin\n      tx_reg <= 8'h00;\n      tx_start <= 1'b0;\n    end\n    else if (rw_address == REG_WDATA && valid_write_request == 1'b1) begin\n      tx_reg <= (curr_state == SPI_READY || curr_state == SPI_IDLE) ? write_data[7:0] : tx_reg;\n      tx_start <= (curr_state == SPI_READY || curr_state == SPI_IDLE) ? 1'b1 : tx_start;\n    end\n    else begin\n      tx_reg <= tx_reg;\n      tx_start <= (curr_state == SPI_CPOL || curr_state == SPI_CPOL_N) ? 1'b0 : tx_start;\n    end\n  end\n\n  always @(posedge clock) begin\n    if (reset | chip_select == 8'hff)\n      curr_state <= SPI_READY;\n    else\n      curr_state <= next_state;\n  end\n\n  always @(posedge clock) begin\n    if (reset || curr_state == SPI_READY || curr_state == SPI_IDLE)\n      cycle_counter <= 0;\n    else if (curr_state == SPI_CPOL && next_state == SPI_CPOL_N)\n      cycle_counter <= 0;\n    else if (curr_state == SPI_CPOL_N && next_state == SPI_CPOL)\n      cycle_counter <= 0;\n    else\n      cycle_counter <= cycle_counter + 1;\n  end\n\n  always @(posedge clock) begin\n    if (reset || curr_state == SPI_READY || curr_state == SPI_IDLE)\n      bit_count <= 7;\n    else if (cpha == 1'b0 && curr_state == SPI_CPOL_N && next_state == SPI_CPOL)\n      bit_count <= bit_count - 1;\n    else if (cpha == 1'b1 && curr_state == SPI_CPOL && next_state == SPI_CPOL_N)\n      bit_count <= bit_count - 1;\n    else\n      bit_count <= bit_count;\n  end\n\n  always @* begin\n    for (i = 0; i < NUM_CS_LINES; i=i+1) begin\n      cs_internal[i] = ({24'd0, chip_select} == i) ? 1'b0 : 1'b1;\n    end\n    case (curr_state)\n      SPI_READY: begin\n        sclk_internal = cpol;\n        pico_internal = tx_reg[7];\n        next_state = tx_start == 1'b1 ? (cpha == 1'b1 ? SPI_CPOL_N : SPI_CPOL) : curr_state;\n      end\n      SPI_CPOL: begin\n        sclk_internal = cpol;\n        pico_internal = tx_reg[bit_count[2:0]];\n        next_state = cycle_counter < clock_div ? curr_state : (bit_count == 0 && cpha == 1'b1 ? SPI_IDLE : SPI_CPOL_N);\n      end\n      SPI_CPOL_N: begin\n        sclk_internal = !cpol;\n        pico_internal = tx_reg[bit_count[2:0]];\n        next_state = cycle_counter < clock_div ? curr_state : (bit_count == 0 && cpha == 1'b0 ? SPI_IDLE : SPI_CPOL);\n      end\n      SPI_IDLE: begin\n        sclk_internal = cpol;\n        pico_internal = tx_reg[0];\n        next_state = chip_select == 8'hff ? SPI_READY : (tx_start == 1'b1 ? (cpha == 1'b1 ? SPI_CPOL_N : SPI_CPOL) : curr_state);\n      end\n      default: begin\n        sclk_internal = cpol;\n        pico_internal = tx_reg[7];\n        next_state = tx_start == 1'b1 ? SPI_CPOL : curr_state;\n      end\n    endcase\n  end\n\n  always @(posedge clock) begin\n    if (reset) begin\n      sclk <= 1'b0;\n      pico <= 1'b0;\n      cs <= {NUM_CS_LINES{1'b1}};\n    end\n    else begin\n      sclk <= sclk_internal;\n      pico <= pico_internal;\n      cs <= cs_internal;\n    end\n  end\n\n  always @(posedge clock) begin\n    clk_edge <= cpol ^ cpha ? !sclk_internal : sclk_internal;\n  end\n\n  always @(posedge clk_edge) begin\n    rx_reg[7:0] <= {rx_reg[6:0], poci};\n  end\n\nendmodule\n"}
{"text": "// ----------------------------------------------------------------------------\n// Copyright (c) 2020-2024 RISC-V Steel contributors\n//\n// This work is licensed under the MIT License, see LICENSE file for details.\n// SPDX-License-Identifier: MIT\n// ----------------------------------------------------------------------------\n\nmodule rvsteel_uart #(\n\n  parameter CLOCK_FREQUENCY = 50000000,\n  parameter UART_BAUD_RATE  = 9600\n\n  )(\n\n  // Global signals\n\n  input   wire          clock,\n  input   wire          reset,\n\n  // IO interface\n\n  input  wire   [4:0 ]  rw_address,\n  output reg    [31:0]  read_data,\n  input  wire           read_request,\n  output reg            read_response,\n  input  wire   [7:0]   write_data,\n  input  wire           write_request,\n  output reg            write_response,\n\n  // RX/TX signals\n\n  input   wire          uart_rx,\n  output  wire          uart_tx,\n\n  // Interrupt signaling\n\n  output  reg           uart_irq,\n  input   wire          uart_irq_response\n\n  );\n\n  localparam CYCLES_PER_BAUD = CLOCK_FREQUENCY / UART_BAUD_RATE;\n\n  reg [31:0] tx_cycle_counter = 0;\n  reg [31:0] rx_cycle_counter = 0;\n  reg [3:0]  tx_bit_counter;\n  reg [3:0]  rx_bit_counter;\n  reg [9:0]  tx_register;\n  reg [7:0]  rx_register;\n  reg [7:0]  rx_data;\n  reg        rx_active;\n  reg        reset_reg;\n\n  wire       reset_internal;\n\n  always @(posedge clock)\n    reset_reg <= reset;\n\n  assign reset_internal = reset | reset_reg;\n\n  assign uart_tx = tx_register[0];\n\n  always @(posedge clock) begin\n    if (reset_internal) begin\n      tx_cycle_counter <= 0;\n      tx_register <= 10'b1111111111;\n      tx_bit_counter <= 0;\n    end\n    else if (tx_bit_counter == 0 &&\n             rw_address == 5'h00 &&\n             write_request == 1'b1) begin\n      tx_cycle_counter <= 0;\n      tx_register <= {1'b1, write_data[7:0], 1'b0};\n      tx_bit_counter <= 10;\n    end\n    else begin\n      if (tx_cycle_counter < CYCLES_PER_BAUD) begin\n        tx_cycle_counter <= tx_cycle_counter + 1;\n        tx_register <= tx_register;\n        tx_bit_counter <= tx_bit_counter;\n      end\n      else begin\n        tx_cycle_counter <= 0;\n        tx_register <= {1'b1, tx_register[9:1]};\n        tx_bit_counter <= tx_bit_counter > 0 ? tx_bit_counter - 1 : 0;\n      end\n    end\n  end\n\n  always @(posedge clock) begin\n    if (reset_internal) begin\n      rx_cycle_counter <= 0;\n      rx_register <= 8'h00;\n      rx_data <= 8'h00;\n      rx_bit_counter <= 0;\n      uart_irq <= 1'b0;\n      rx_active <= 1'b0;\n    end\n    else if (uart_irq == 1'b1) begin\n      if (uart_irq_response == 1'b1) begin\n        rx_cycle_counter <= 0;\n        rx_register <= 8'h00;\n        rx_data <= rx_data;\n        rx_bit_counter <= 0;\n        uart_irq <= 1'b0;\n        rx_active <= 1'b0;\n      end\n      else begin\n        rx_cycle_counter <= 0;\n        rx_register <= 8'h00;\n        rx_data <= rx_data;\n        rx_bit_counter <= 0;\n        uart_irq <= 1'b1;\n        rx_active <= 1'b0;\n      end\n    end\n    else if (rx_bit_counter == 0 && rx_active == 1'b0) begin\n      if (uart_rx == 1'b1) begin\n        rx_cycle_counter <= 0;\n        rx_register <= 8'h00;\n        rx_data <= rx_data;\n        rx_bit_counter <= 0;\n        uart_irq <= 1'b0;\n        rx_active <= 1'b0;\n      end\n      else if (uart_rx == 1'b0) begin\n        if (rx_cycle_counter < CYCLES_PER_BAUD / 2) begin\n          rx_cycle_counter <= rx_cycle_counter + 1;\n          rx_register <= 8'h00;\n          rx_data <= rx_data;\n          rx_bit_counter <= 0;\n          uart_irq <= 1'b0;\n          rx_active <= 1'b0;\n        end\n        else begin\n          rx_cycle_counter <= 0;\n          rx_register <= 8'h00;\n          rx_data <= rx_data;\n          rx_bit_counter <= 8;\n          uart_irq <= 1'b0;\n          rx_active <= 1'b1;\n        end\n      end\n    end\n    else begin\n      if (rx_cycle_counter < CYCLES_PER_BAUD) begin\n        rx_cycle_counter <= rx_cycle_counter + 1;\n        rx_register <= rx_register;\n        rx_data <= rx_data;\n        rx_bit_counter <= rx_bit_counter;\n        uart_irq <= 1'b0;\n        rx_active <= 1'b1;\n      end\n      else begin\n        rx_cycle_counter <= 0;\n        rx_register <= {uart_rx, rx_register[7:1]};\n        rx_data <= (rx_bit_counter == 0) ? rx_register : rx_data;\n        rx_bit_counter <= rx_bit_counter > 0 ? rx_bit_counter - 1 : 0;\n        uart_irq <= (rx_bit_counter == 0) ? 1'b1 : 1'b0;\n        rx_active <= 1'b1;\n      end\n    end\n  end\n\n  always @(posedge clock) begin\n    if (reset_internal) begin\n      read_response  <= 1'b0;\n      write_response <= 1'b0;\n    end\n    else begin\n      read_response  <= read_request;\n      write_response <= write_request;\n    end\n  end\n\n  always @(posedge clock) begin\n    if (reset_internal)\n      read_data <= 32'h00000000;\n    else if (rw_address == 5'h00 && read_request == 1'b1)\n      read_data <= {31'b0, tx_bit_counter == 0};\n    else if (rw_address == 5'h04 && read_request == 1'b1)\n      read_data <= {24'b0, rx_data};\n    else\n      read_data <= 32'h00000000;\n  end\n\nendmodule\n"}
