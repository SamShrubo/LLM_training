{"text": "/*\n * Copyright (c) 2018, Marcelo Samsoniuk\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice, this\n *   list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n *\n * * Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n`timescale 1ns / 1ps\n`include \"../rtl/config.vh\"\n\nmodule darkcache\n(\n    // TBD\n    \n    output [3:0] DEBUG      // osciloscope\n);\n\n    // darkriscv bus interface\n\n    wire [31:0] IADDR;\n    wire [31:0] DADDR;\n    wire [31:0] IDATA;\n    wire [31:0] DATAO;\n    wire [31:0] DATAI;\n    wire        WR,RD;\n    wire [3:0]  BE;\n\n`ifdef __FLEXBUZZ__\n    wire [31:0] XATAO;\n    wire [31:0] XATAI;\n    wire [ 2:0] DLEN;\n    wire        RW;\n`endif\n\n    wire [31:0] IOMUX [0:4];\n\n    reg  [15:0] GPIOFF = 0;\n    reg  [15:0] LEDFF  = 0;\n\n    wire HLT;\n\n`ifdef __ICACHE__\n\n    // instruction cache\n\n    reg  [55:0] ICACHE [0:63]; // instruction cache\n    reg  [63:0] ITAG = 0;      // instruction cache tag\n\n    wire [5:0]  IPTR    = IADDR[7:2];\n    wire [55:0] ICACHEO = ICACHE[IPTR];\n    wire [31:0] ICACHED = ICACHEO[31: 0]; // data\n    wire [31:8] ICACHEA = ICACHEO[55:32]; // address\n\n    wire IHIT = ITAG[IPTR] && ICACHEA==IADDR[31:8];\n\n    reg  IFFX = 0;\n    reg IFFX2 = 0;\n\n    reg [31:0] ROMFF;\n\n    always@(posedge CLK)\n    begin\n    `ifdef __HARVARD__\n        ROMFF <= ROM[IADDR[`MLEN-1:2]];\n    `else\n        ROMFF <= MEM[IADDR[`MLEN-1:2]];\n    `endif\n        if(IFFX2)\n        begin\n            IFFX2 <= 0;\n            IFFX  <= 0;\n        end\n        else\n        if(!IHIT)\n        begin\n            ICACHE[IPTR] <= { IADDR[31:8], ROMFF };\n            ITAG[IPTR]    <= IFFX; // cached!\n            IFFX          <= 1;\n            IFFX2         <= IFFX;\n        end\n    end\n\n    assign IDATA = ICACHED;\n\n`else\n\n    reg [31:0] ROMFF;\n\n    wire IHIT = 1;\n\n    reg [31:0] ROMFF2 = 0;\n    reg        HLT2   = 0;\n\n    always@(posedge CLK) // stage #0.5\n    begin\n        if(HLT^HLT2)\n        begin\n            ROMFF2 <= ROMFF;\n        end\n\n        HLT2 <= HLT;\n    end\n\n    assign IDATA = HLT2 ? ROMFF2 : ROMFF;\n\n    always@(posedge CLK) // stage #0.5\n    begin\n`ifdef __HARVARD__\n        ROMFF <= ROM[IADDR[`MLEN-1:2]];\n`else\n        ROMFF <= MEM[IADDR[`MLEN-1:2]];\n`endif\n    end\n\n    //assign IDATA = ROM[IADDR[`MLEN-1:2]];\n\n//    always@(posedge CLK)\n//    begin\n//        // weird bug appears to be related to the \"sw ra,12(sp)\" instruction.\n//        if(WR&&DADDR[31]==0&&DADDR[12]==0)\n//        begin\n//            ROMBUG <= IADDR;\n//        end\n//    end\n\n//    assign IDATA = ROMFF;\n\n`endif\n\n`ifdef __DCACHE__\n\n    // data cache\n\n    reg  [55:0] DCACHE [0:63]; // data cache\n    reg  [63:0] DTAG = 0;      // data cache tag\n\n    wire [5:0]  DPTR    = DADDR[7:2];\n    wire [55:0] DCACHEO = DCACHE[DPTR];\n    wire [31:0] DCACHED = DCACHEO[31: 0]; // data\n    wire [31:8] DCACHEA = DCACHEO[55:32]; // address\n\n    wire DHIT = RD&&!DADDR[31]/*&&DADDR[`MLEN-1]*/ ? DTAG[DPTR] && DCACHEA==DADDR[31:8] : 1;\n\n    reg   FFX = 0;\n    reg  FFX2 = 0;\n\n    reg [31:0] RAMFF;\n\n    reg        WTAG    = 0;\n    reg [31:0] WCACHEA = 0;\n\n    wire WHIT = WR&&!DADDR[31]/*&&DADDR[`MLEN-1]*/ ? WTAG&&WCACHEA==DADDR : 1;\n\n    always@(posedge CLK)\n    begin\n    `ifdef __HARVARD__\n        RAMFF <= RAM[DADDR[`MLEN-1:2]];\n    `else\n        RAMFF <= MEM[DADDR[`MLEN-1:2]];\n    `endif\n\n        if(FFX2)\n        begin\n            FFX2 <= 0;\n            FFX  <= 0;\n            WCACHEA <= 0;\n            WTAG <= 0;\n        end\n        else\n        if(!WHIT)\n        begin\n            //individual byte/word/long selection, thanks to HYF!\n        `ifdef __HARVARD__\n            if(BE[0]) RAM[DADDR[`MLEN-1:2]][0 * 8 + 7: 0 * 8] <= DATAO[0 * 8 + 7: 0 * 8];\n            if(BE[1]) RAM[DADDR[`MLEN-1:2]][1 * 8 + 7: 1 * 8] <= DATAO[1 * 8 + 7: 1 * 8];\n            if(BE[2]) RAM[DADDR[`MLEN-1:2]][2 * 8 + 7: 2 * 8] <= DATAO[2 * 8 + 7: 2 * 8];\n            if(BE[3]) RAM[DADDR[`MLEN-1:2]][3 * 8 + 7: 3 * 8] <= DATAO[3 * 8 + 7: 3 * 8];\n        `else\n            if(BE[0]) MEM[DADDR[`MLEN-1:2]][0 * 8 + 7: 0 * 8] <= DATAO[0 * 8 + 7: 0 * 8];\n            if(BE[1]) MEM[DADDR[`MLEN-1:2]][1 * 8 + 7: 1 * 8] <= DATAO[1 * 8 + 7: 1 * 8];\n            if(BE[2]) MEM[DADDR[`MLEN-1:2]][2 * 8 + 7: 2 * 8] <= DATAO[2 * 8 + 7: 2 * 8];\n            if(BE[3]) MEM[DADDR[`MLEN-1:2]][3 * 8 + 7: 3 * 8] <= DATAO[3 * 8 + 7: 3 * 8];\n        `endif\n            DCACHE[DPTR][0 * 8 + 7: 0 * 8] <= BE[0] ? DATAO[0 * 8 + 7: 0 * 8] : RAMFF[0 * 8 + 7: 0 * 8];\n            DCACHE[DPTR][1 * 8 + 7: 1 * 8] <= BE[1] ? DATAO[1 * 8 + 7: 1 * 8] : RAMFF[1 * 8 + 7: 1 * 8];\n            DCACHE[DPTR][2 * 8 + 7: 2 * 8] <= BE[2] ? DATAO[2 * 8 + 7: 2 * 8] : RAMFF[2 * 8 + 7: 2 * 8];\n            DCACHE[DPTR][3 * 8 + 7: 3 * 8] <= BE[3] ? DATAO[3 * 8 + 7: 3 * 8] : RAMFF[3 * 8 + 7: 3 * 8];\n\n            DCACHE[DPTR][55:32] <= DADDR[31:8];\n\n            DTAG[DPTR]   <= FFX; // cached!\n            WTAG         <= FFX;\n\n            WCACHEA      <= DADDR;\n\n            FFX          <= 1;\n            FFX2         <= FFX;\n        end\n        else\n        if(!DHIT)\n        begin\n            DCACHE[DPTR] <= { DADDR[31:8], RAMFF };\n            DTAG[DPTR]   <= FFX; // cached!\n            FFX          <= 1;\n            FFX2         <= FFX;\n        end\n    end\n\n    assign DATAI = DADDR[31] ? IOMUX[DADDR[4:2]==3'b100 ? 3'b100 : DADDR[3:2]] : DCACHED;\n\n`else\n\n    // no cache!\n\n    `ifdef __FLEXBUZZ__\n\n    // must work just exactly as the default interface, since we have no\n    // flexbuzz devices available yet (i.e., all devices are 32-bit now)\n\n    assign XATAI = DLEN[0] ? ( DADDR[1:0]==3 ? DATAI[31:24] :\n                               DADDR[1:0]==2 ? DATAI[23:16] :\n                               DADDR[1:0]==1 ? DATAI[15: 8] :\n                                               DATAI[ 7: 0] ):\n                   DLEN[1] ? ( DADDR[1]==1   ? DATAI[31:16] :\n                                               DATAI[15: 0] ):\n                                               DATAI;\n\n    assign DATAO = DLEN[0] ? ( DADDR[1:0]==3 ? {        XATAO[ 7: 0], 24'hx } :\n                               DADDR[1:0]==2 ? {  8'hx, XATAO[ 7: 0], 16'hx } :\n                               DADDR[1:0]==1 ? { 16'hx, XATAO[ 7: 0],  8'hx } :\n                                               { 24'hx, XATAO[ 7: 0]        } ):\n                   DLEN[1] ? ( DADDR[1]==1   ? { XATAO[15: 0], 16'hx } :\n                                               { 16'hx, XATAO[15: 0] } ):\n                                                 XATAO;\n\n    assign RD = DLEN&&RW==1;\n    assign WR = DLEN&&RW==0;\n\n    assign BE =    DLEN[0] ? ( DADDR[1:0]==3 ? 4'b1000 : // 8-bit\n                               DADDR[1:0]==2 ? 4'b0100 :\n                               DADDR[1:0]==1 ? 4'b0010 :\n                                               4'b0001 ) :\n                   DLEN[1] ? ( DADDR[1]==1   ? 4'b1100 : // 16-bit\n                                               4'b0011 ) :\n                                               4'b1111;  // 32-bit\n\n    `endif\n\n    reg [31:0] RAMFF;\n\n    // for single phase clock: 1 wait state in read op always required!\n\n    reg [1:0] DACK = 0;\n\n    wire WHIT = 1;\n    wire DHIT = !((RD\n            `ifdef __RMW_CYCLE__\n                    ||WR\t\t// worst code ever! but it is 3:12am...\n            `endif\n                    ) && DACK!=1); // the WR operatio does not need ws. in this config.\n\n    always@(posedge CLK) // stage #1.0\n    begin\n        DACK <= RES ? 0 : DACK ? DACK-1 : (RD\n            `ifdef __RMW_CYCLE__\n                    ||WR\t\t// 2nd worst code ever!\n            `endif\n                    ) ? 1 : 0; // wait-states\n    end\n\n    always@(posedge CLK) // stage #1.5\n    begin\n`ifdef __HARVARD__\n        RAMFF <= RAM[DADDR[`MLEN-1:2]];\n`else\n        RAMFF <= MEM[DADDR[`MLEN-1:2]];\n`endif\n    end\n\n    //assign DATAI = DADDR[31] ? IOMUX  : RAM[DADDR[`MLEN-1:2]];\n\n    reg [31:0] IOMUXFF = 0;\n    reg [31:0] XADDR   = 0;\n\n    //individual byte/word/long selection, thanks to HYF!\n\n    always@(posedge CLK)\n    begin\n\n`ifdef __RMW_CYCLE__\n\n        // read-modify-write operation w/ 1 wait-state:\n\n        if(!HLT&&WR&&DADDR[31]==0/*&&DADDR[`MLEN-1]==1*/)\n        begin\n    `ifdef __HARVARD__\n            RAM[DADDR[`MLEN-1:2]] <=\n    `else\n            MEM[DADDR[`MLEN-1:2]] <=\n    `endif\n                                {\n                                    BE[3] ? DATAO[3 * 8 + 7: 3 * 8] : RAMFF[3 * 8 + 7: 3 * 8],\n                                    BE[2] ? DATAO[2 * 8 + 7: 2 * 8] : RAMFF[2 * 8 + 7: 2 * 8],\n                                    BE[1] ? DATAO[1 * 8 + 7: 1 * 8] : RAMFF[1 * 8 + 7: 1 * 8],\n                                    BE[0] ? DATAO[0 * 8 + 7: 0 * 8] : RAMFF[0 * 8 + 7: 0 * 8]\n                                };\n        end\n\n`else\n        // write-only operation w/ 0 wait-states:\n    `ifdef __HARVARD__\n        if(!HLT&&WR&&DADDR[31]==0&&/*DADDR[`MLEN-1]==1&&*/BE[3]) RAM[DADDR[`MLEN-1:2]][3 * 8 + 7: 3 * 8] <= DATAO[3 * 8 + 7: 3 * 8];\n        if(!HLT&&WR&&DADDR[31]==0&&/*DADDR[`MLEN-1]==1&&*/BE[2]) RAM[DADDR[`MLEN-1:2]][2 * 8 + 7: 2 * 8] <= DATAO[2 * 8 + 7: 2 * 8];\n        if(!HLT&&WR&&DADDR[31]==0&&/*DADDR[`MLEN-1]==1&&*/BE[1]) RAM[DADDR[`MLEN-1:2]][1 * 8 + 7: 1 * 8] <= DATAO[1 * 8 + 7: 1 * 8];\n        if(!HLT&&WR&&DADDR[31]==0&&/*DADDR[`MLEN-1]==1&&*/BE[0]) RAM[DADDR[`MLEN-1:2]][0 * 8 + 7: 0 * 8] <= DATAO[0 * 8 + 7: 0 * 8];\n    `else\n        if(!HLT&&WR&&DADDR[31]==0&&/*DADDR[`MLEN-1]==1&&*/BE[3]) MEM[DADDR[`MLEN-1:2]][3 * 8 + 7: 3 * 8] <= DATAO[3 * 8 + 7: 3 * 8];\n        if(!HLT&&WR&&DADDR[31]==0&&/*DADDR[`MLEN-1]==1&&*/BE[2]) MEM[DADDR[`MLEN-1:2]][2 * 8 + 7: 2 * 8] <= DATAO[2 * 8 + 7: 2 * 8];\n        if(!HLT&&WR&&DADDR[31]==0&&/*DADDR[`MLEN-1]==1&&*/BE[1]) MEM[DADDR[`MLEN-1:2]][1 * 8 + 7: 1 * 8] <= DATAO[1 * 8 + 7: 1 * 8];\n        if(!HLT&&WR&&DADDR[31]==0&&/*DADDR[`MLEN-1]==1&&*/BE[0]) MEM[DADDR[`MLEN-1:2]][0 * 8 + 7: 0 * 8] <= DATAO[0 * 8 + 7: 0 * 8];\n    `endif\n`endif\n\n        XADDR <= DADDR; // 1 clock delayed\n        IOMUXFF <= IOMUX[DADDR[4:2]==3'b100 ? 3'b100 : DADDR[3:2]]; // read w/ 2 wait-states\n    end\n\n    //assign DATAI = DADDR[31] ? IOMUX[DADDR[3:2]]  : RAMFF;\n    //assign DATAI = DADDR[31] ? IOMUXFF : RAMFF;\n    assign DATAI = XADDR[31] ? IOMUX[XADDR[4:2]==3'b100 ? 3'b100 : XADDR[3:2]] : RAMFF;\n\n`endif\n\nendmodule\n"}
{"text": "/*\n * Copyright (c) 2018, Marcelo Samsoniuk\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice, this\n *   list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n *\n * * Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n`timescale 1ns / 1ps\n`include \"../rtl/config.vh\"\n\nmodule darkpll\n(\n    input        XCLK,      // external clock\n    input        XRES,      // external reset\n\n    output       CLK,       // internal clock\n    output       RES        // internal reset\n);\n\n    // internal/external reset logic\n\n    reg [7:0] IRES = -1;\n\n`ifdef INVRES\n    always@(posedge XCLK) IRES <= XRES==0 ? -1 : IRES[7] ? IRES-1 : 0; // reset low\n`else\n    always@(posedge XCLK) IRES <= XRES==1 ? -1 : IRES[7] ? IRES-1 : 0; // reset high\n`endif\n\n    wire LOCKED;\n\n    // clock generator logic\n    //`define BOARD_CK (`BOARD_CK_REF * `BOARD_CK_MUL / `BOARD_CK_DIV)\n    // useful script to calculate MUL/DIV values:\n    //\n    // awk 'BEGIN {\n    //   ref=66.6; target=97.4;\n    //   for(m=2;m<=32;m++) for(d=1;d<=32;d++) {\n    //     mul=ref*m; delta=target-(mul/d);\n    //     if(mul>=600&&mul<=1600) print (delta<0?-delta:delta),mul/d,mul,m,d;\n    //   }\n    // }' | sort -nr\n    //\n    // example: reference w/ 66MHz, m=19, d=13 and fx=97.4MHz;\n    // not so useful after I discovered that my evaluation board already has an external clock generator :D\n    //\n    // important remark: the xilinx-7 pll requires a ref*mul bandwidth between 0.6 and 1.6GHz!\n\n`ifdef XILINX7CLK\n\n    wire CLKFB;\n\n    MMCME2_BASE #(\n        .BANDWIDTH(\"OPTIMIZED\"),   // Jitter programming (OPTIMIZED, HIGH, LOW)\n        .CLKFBOUT_MULT_F(`BOARD_CK_MUL),     // Multiply value for all CLKOUT (2.000-64.000).\n        .CLKFBOUT_PHASE(0.0),      // Phase offset in degrees of CLKFB (-360.000-360.000).\n        .CLKIN1_PERIOD((1e9/`BOARD_CK_REF)),       // Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).\n        // CLKOUT0_DIVIDE - CLKOUT6_DIVIDE: Divide amount for each CLKOUT (1-128)\n        .CLKOUT0_DIVIDE_F(`BOARD_CK_DIV),    // Divide amount for CLKOUT0 (1.000-128.000).\n        .CLKOUT1_DIVIDE(`BOARD_CK_DIV),\n        .CLKOUT2_DIVIDE(`BOARD_CK_DIV),\n        .CLKOUT3_DIVIDE(`BOARD_CK_DIV),\n        .CLKOUT4_DIVIDE(`BOARD_CK_DIV),\n        .CLKOUT5_DIVIDE(`BOARD_CK_DIV),\n        .CLKOUT6_DIVIDE(`BOARD_CK_DIV),\n        // CLKOUT0_DUTY_CYCLE - CLKOUT6_DUTY_CYCLE: Duty cycle for each CLKOUT (0.01-0.99).\n        .CLKOUT0_DUTY_CYCLE(0.5),\n        .CLKOUT1_DUTY_CYCLE(0.5),\n        .CLKOUT2_DUTY_CYCLE(0.5),\n        .CLKOUT3_DUTY_CYCLE(0.5),\n        .CLKOUT4_DUTY_CYCLE(0.5),\n        .CLKOUT5_DUTY_CYCLE(0.5),\n        .CLKOUT6_DUTY_CYCLE(0.5),\n        // CLKOUT0_PHASE - CLKOUT6_PHASE: Phase offset for each CLKOUT (-360.000-360.000).\n        .CLKOUT0_PHASE(0.0),\n        .CLKOUT1_PHASE(0.0),\n        .CLKOUT2_PHASE(0.0),\n        .CLKOUT3_PHASE(0.0),\n        .CLKOUT4_PHASE(0.0),\n        .CLKOUT5_PHASE(0.0),\n        .CLKOUT6_PHASE(0.0),\n        .CLKOUT4_CASCADE(\"FALSE\"), // Cascade CLKOUT4 counter with CLKOUT6 (FALSE, TRUE)\n        .DIVCLK_DIVIDE(1),         // Master division value (1-106)\n        .REF_JITTER1(0.0),         // Reference input jitter in UI (0.000-0.999).\n        .STARTUP_WAIT(\"TRUE\")     // Delays DONE until MMCM is locked (FALSE, TRUE)\n    )\n    MMCME2_BASE_inst (\n        // Clock Outputs: 1-bit (each) output: User configurable clock outputs\n        .CLKOUT0(CLK),     // 1-bit output: CLKOUT0\n        //.CLKOUT0B(CLKOUT0B),   // 1-bit output: Inverted CLKOUT0\n        //.CLKOUT1(CLKPWM),     // 1-bit output: CLKOUT1\n        //.CLKOUT1B(CLKOUT1B),   // 1-bit output: Inverted CLKOUT1\n        //.CLKOUT2(CLKOUT2),     // 1-bit output: CLKOUT2\n        //.CLKOUT2B(CLKOUT2B),   // 1-bit output: Inverted CLKOUT2\n        //.CLKOUT3(CLKOUT3),     // 1-bit output: CLKOUT3\n        //.CLKOUT3B(CLKOUT3B),   // 1-bit output: Inverted CLKOUT3\n        //.CLKOUT4(CLKOUT4),     // 1-bit output: CLKOUT4\n        //.CLKOUT5(CLKOUT5),     // 1-bit output: CLKOUT5\n        //.CLKOUT6(CLKOUT6),     // 1-bit output: CLKOUT6\n        // Feedback Clocks: 1-bit (each) output: Clock feedback ports\n        .CLKFBOUT(CLKFB),   // 1-bit output: Feedback clock\n        //.CLKFBOUTB(CLKFBOUTB), // 1-bit output: Inverted CLKFBOUT\n        // Status Ports: 1-bit (each) output: MMCM status ports\n        .LOCKED(LOCKED),       // 1-bit output: LOCK\n        // Clock Inputs: 1-bit (each) input: Clock input\n        .CLKIN1(XCLK),       // 1-bit input: Clock\n        // Control Ports: 1-bit (each) input: MMCM control ports\n        .PWRDWN(1'b0),       // 1-bit input: Power-down\n        .RST(IRES[7]),             // 1-bit input: Reset\n        // Feedback Clocks: 1-bit (each) input: Clock feedback ports\n        .CLKFBIN(CLKFB)      // 1-bit input: Feedback clock\n    );\n\n`elsif XILINX6CLK\n\n    wire CLKFB;\n\n    DCM_SP #(\n        .CLKDV_DIVIDE(2.0),                   // CLKDV divide value\n                                            // (1.5,2,2.5,3,3.5,4,4.5,5,5.5,6,6.5,7,7.5,8,9,10,11,12,13,14,15,16).\n        .CLKFX_DIVIDE(`BOARD_CK_DIV),                     // Divide value on CLKFX outputs - D - (1-32)\n        .CLKFX_MULTIPLY(`BOARD_CK_MUL),                   // Multiply value on CLKFX outputs - M - (2-32)\n        .CLKIN_DIVIDE_BY_2(\"FALSE\"),          // CLKIN divide by two (TRUE/FALSE)\n        .CLKIN_PERIOD((1e9/`BOARD_CK_REF)),                  // Input clock period specified in nS\n        .CLKOUT_PHASE_SHIFT(\"NONE\"),          // Output phase shift (NONE, FIXED, VARIABLE)\n        .CLK_FEEDBACK(\"1X\"),                  // Feedback source (NONE, 1X, 2X)\n        .DESKEW_ADJUST(\"SYSTEM_SYNCHRONOUS\"), // SYSTEM_SYNCHRNOUS or SOURCE_SYNCHRONOUS\n        .DFS_FREQUENCY_MODE(\"LOW\"),           // Unsupported - Do not change value\n        .DLL_FREQUENCY_MODE(\"LOW\"),           // Unsupported - Do not change value\n        .DSS_MODE(\"NONE\"),                    // Unsupported - Do not change value\n        .DUTY_CYCLE_CORRECTION(\"TRUE\"),       // Unsupported - Do not change value\n        .FACTORY_JF(16'hc080),                // Unsupported - Do not change value\n        .PHASE_SHIFT(0),                      // Amount of fixed phase shift (-255 to 255)\n        .STARTUP_WAIT(\"FALSE\")                // Delay config DONE until DCM_SP LOCKED (TRUE/FALSE)\n    )\n    DCM_SP_inst (\n        //.CLK0(CLK0),         // 1-bit output: 0 degree clock output\n        //.CLK180(CLK180),     // 1-bit output: 180 degree clock output\n        //.CLK270(CLK270),     // 1-bit output: 270 degree clock output\n        //.CLK2X(CLK2X),       // 1-bit output: 2X clock frequency clock output\n        //.CLK2X180(CLK2X180), // 1-bit output: 2X clock frequency, 180 degree clock output\n        //.CLK90(CLK90),       // 1-bit output: 90 degree clock output\n        //.CLKDV(CLKDV),       // 1-bit output: Divided clock output\n        .CLKFX(CLK),       // 1-bit output: Digital Frequency Synthesizer output (DFS)\n        //.CLKFX180(CLKFX180), // 1-bit output: 180 degree CLKFX output\n        .LOCKED(LOCKED),     // 1-bit output: DCM_SP Lock Output\n        //.PSDONE(PSDONE),     // 1-bit output: Phase shift done output\n        //.STATUS(STATUS),     // 8-bit output: DCM_SP status output\n        //.CLKFB(CLKFB),       // 1-bit input: Clock feedback input\n        .CLKIN(XCLK),       // 1-bit input: Clock input\n        //.DSSEN(DSSEN),       // 1-bit input: Unsupported, specify to GND.\n        //.PSCLK(PSCLK),       // 1-bit input: Phase shift clock input\n        .PSEN(1'b0),         // 1-bit input: Phase shift enable\n        //.PSINCDEC(PSINCDEC), // 1-bit input: Phase shift increment/decrement input\n        .RST(IRES[7])            // 1-bit input: Active high reset input\n    );\n\n`elsif LATTICE_ECP5_PLL_REF25MHZ\n\n    pll_ref_25MHz #(\n        .freq(`BOARD_CK/1_000_000)\n    ) ecp5_pll_I (\n        .clki(XCLK),\n        .clko(CLK)\n    );\n    \n    assign LOCKED = 1;\n\n`elsif LATTICE_ICE40_BREAKOUT_HX8K\n\n    pll pll_i // 12MHz in, 50 MHz out\n    (\n        .clock_in  (XCLK),\n        .clock_out (CLK),\n        .locked    (LOCKED)\n    );\n\n`else\n\n    // when there is no need for a clock generator:\n    \n   assign CLK = XCLK;\n   assign LOCKED = !IRES[7];\n\n`endif\n\n    // here I use the CLK and LOCKED to drive RES\n\n    reg [7:0] DRES = -1;\n\n    always@(posedge CLK)\n    begin\n        DRES <= LOCKED==0 ? -1 : DRES ? DRES-1 : 0;\n    end\n\n    assign RES = DRES[7];\n\nendmodule\n"}
{"text": "/*\n * Copyright (c) 2018, Marcelo Samsoniuk\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice, this\n *   list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n *\n * * Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n`timescale 1ns / 1ps\n\n// implemented opcodes:\n\n`define LUI     7'b01101_11      // lui   rd,imm[31:12]\n`define AUIPC   7'b00101_11      // auipc rd,imm[31:12]\n`define JAL     7'b11011_11      // jal   rd,imm[xxxxx]\n`define JALR    7'b11001_11      // jalr  rd,rs1,imm[11:0]\n`define BCC     7'b11000_11      // bcc   rs1,rs2,imm[12:1]\n`define LCC     7'b00000_11      // lxx   rd,rs1,imm[11:0]\n`define SCC     7'b01000_11      // sxx   rs1,rs2,imm[11:0]\n`define MCC     7'b00100_11      // xxxi  rd,rs1,imm[11:0]\n`define RCC     7'b01100_11      // xxx   rd,rs1,rs2\n`define CCC     7'b11100_11      // exx, csrxx, mret\n\n// proprietary extension (custom-0)\n`define CUS     7'b00010_11      // cus   rd,rs1,rs2,fc3,fct5\n\n// not implemented opcodes:\n//`define FCC     7'b00011_11      // fencex\n\n\n// configuration file\n\n`include \"../rtl/config.vh\"\n\nmodule darkriscv\n//#(\n//    parameter [31:0] RESET_PC = 0,\n//    parameter [31:0] RESET_SP = 4096\n//)\n(\n    input             CLK,   // clock\n    input             RES,   // reset\n    input             HLT,   // halt\n\n`ifdef __THREADS__\n    output [`__THREADS__-1:0] TPTR,  // thread pointer\n`endif\n\n`ifdef __INTERRUPT__\n    input             INT,   // interrupt request\n`endif\n\n    input      [31:0] IDATA, // instruction data bus\n    output     [31:0] IADDR, // instruction addr bus\n\n    input      [31:0] DATAI, // data bus (input)\n    output     [31:0] DATAO, // data bus (output)\n    output     [31:0] DADDR, // addr bus\n\n`ifdef __FLEXBUZZ__\n    output     [ 2:0] DLEN, // data length\n    output            RW,   // data read/write\n`else\n    output     [ 3:0] BE,   // byte enable\n    output            WR,    // write enable\n    output            RD,    // read enable\n`endif\n\n    output            IDLE,   // idle output\n\n    output [3:0]  DEBUG       // old-school osciloscope based debug! :)\n);\n\n    // dummy 32-bit words w/ all-0s and all-1s:\n\n    wire [31:0] ALL0  = 0;\n    wire [31:0] ALL1  = -1;\n\n    reg XRES = 1;\n\n`ifdef __THREADS__\n    reg [`__THREADS__-1:0] XMODE = 0;     // thread ptr\n\n    assign TPTR = XMODE;\n`endif\n\n    // decode: IDATA is break apart as described in the RV32I specification\n\n`ifdef __3STAGE__\n\n    reg [31:0] XIDATA;\n\n    reg XLUI, XAUIPC, XJAL, XJALR, XBCC, XLCC, XSCC, XMCC, XRCC, XCUS, XCCC; //, XFCC, XCCC;\n\n    reg [31:0] XSIMM;\n    reg [31:0] XUIMM;\n\n    always@(posedge CLK)\n    begin\n        XIDATA <= XRES ? 0 : HLT ? XIDATA : IDATA;\n\n        XLUI   <= XRES ? 0 : HLT ? XLUI   : IDATA[6:0]==`LUI;\n        XAUIPC <= XRES ? 0 : HLT ? XAUIPC : IDATA[6:0]==`AUIPC;\n        XJAL   <= XRES ? 0 : HLT ? XJAL   : IDATA[6:0]==`JAL;\n        XJALR  <= XRES ? 0 : HLT ? XJALR  : IDATA[6:0]==`JALR;\n\n        XBCC   <= XRES ? 0 : HLT ? XBCC   : IDATA[6:0]==`BCC;\n        XLCC   <= XRES ? 0 : HLT ? XLCC   : IDATA[6:0]==`LCC;\n        XSCC   <= XRES ? 0 : HLT ? XSCC   : IDATA[6:0]==`SCC;\n        XMCC   <= XRES ? 0 : HLT ? XMCC   : IDATA[6:0]==`MCC;\n\n        XRCC   <= XRES ? 0 : HLT ? XRCC   : IDATA[6:0]==`RCC;\n        XCUS   <= XRES ? 0 : HLT ? XRCC   : IDATA[6:0]==`CUS;\n        //XFCC   <= XRES ? 0 : HLT ? XFCC   : IDATA[6:0]==`FCC;\n        XCCC   <= XRES ? 0 : HLT ? XCCC   : IDATA[6:0]==`CCC;\n\n        // signal extended immediate, according to the instruction type:\n\n        XSIMM  <= XRES ? 0 : HLT ? XSIMM :\n                 IDATA[6:0]==`SCC ? { IDATA[31] ? ALL1[31:12]:ALL0[31:12], IDATA[31:25],IDATA[11:7] } : // s-type\n                 IDATA[6:0]==`BCC ? { IDATA[31] ? ALL1[31:13]:ALL0[31:13], IDATA[31],IDATA[7],IDATA[30:25],IDATA[11:8],ALL0[0] } : // b-type\n                 IDATA[6:0]==`JAL ? { IDATA[31] ? ALL1[31:21]:ALL0[31:21], IDATA[31], IDATA[19:12], IDATA[20], IDATA[30:21], ALL0[0] } : // j-type\n                 IDATA[6:0]==`LUI||\n                 IDATA[6:0]==`AUIPC ? { IDATA[31:12], ALL0[11:0] } : // u-type\n                                      { IDATA[31] ? ALL1[31:12]:ALL0[31:12], IDATA[31:20] }; // i-type\n        // non-signal extended immediate, according to the instruction type:\n\n        XUIMM  <= XRES ? 0: HLT ? XUIMM :\n                 IDATA[6:0]==`SCC ? { ALL0[31:12], IDATA[31:25],IDATA[11:7] } : // s-type\n                 IDATA[6:0]==`BCC ? { ALL0[31:13], IDATA[31],IDATA[7],IDATA[30:25],IDATA[11:8],ALL0[0] } : // b-type\n                 IDATA[6:0]==`JAL ? { ALL0[31:21], IDATA[31], IDATA[19:12], IDATA[20], IDATA[30:21], ALL0[0] } : // j-type\n                 IDATA[6:0]==`LUI||\n                 IDATA[6:0]==`AUIPC ? { IDATA[31:12], ALL0[11:0] } : // u-type\n                                      { ALL0[31:12], IDATA[31:20] }; // i-type\n    end\n\n    reg [1:0] FLUSH = -1;  // flush instruction pipeline\n\n`else\n\n    wire [31:0] XIDATA;\n\n    wire XLUI, XAUIPC, XJAL, XJALR, XBCC, XLCC, XSCC, XMCC, XRCC, XCUS, XCCC; //, XFCC, XCCC;\n\n    wire [31:0] XSIMM;\n    wire [31:0] XUIMM;\n\n    assign XIDATA = XRES ? 0 : IDATA;\n\n    assign XLUI   = XRES ? 0 : IDATA[6:0]==`LUI;\n    assign XAUIPC = XRES ? 0 : IDATA[6:0]==`AUIPC;\n    assign XJAL   = XRES ? 0 : IDATA[6:0]==`JAL;\n    assign XJALR  = XRES ? 0 : IDATA[6:0]==`JALR;\n\n    assign XBCC   = XRES ? 0 : IDATA[6:0]==`BCC;\n    assign XLCC   = XRES ? 0 : IDATA[6:0]==`LCC;\n    assign XSCC   = XRES ? 0 : IDATA[6:0]==`SCC;\n    assign XMCC   = XRES ? 0 : IDATA[6:0]==`MCC;\n\n    assign XRCC   = XRES ? 0 : IDATA[6:0]==`RCC;\n    assign XCUS   = XRES ? 0 : IDATA[6:0]==`CUS;\n    //assign XFCC   <= XRES ? 0 : IDATA[6:0]==`FCC;\n    assign XCCC   = XRES ? 0 : IDATA[6:0]==`CCC;\n\n    // signal extended immediate, according to the instruction type:\n\n    assign XSIMM  = XRES ? 0 : \n                     IDATA[6:0]==`SCC ? { IDATA[31] ? ALL1[31:12]:ALL0[31:12], IDATA[31:25],IDATA[11:7] } : // s-type\n                     IDATA[6:0]==`BCC ? { IDATA[31] ? ALL1[31:13]:ALL0[31:13], IDATA[31],IDATA[7],IDATA[30:25],IDATA[11:8],ALL0[0] } : // b-type\n                     IDATA[6:0]==`JAL ? { IDATA[31] ? ALL1[31:21]:ALL0[31:21], IDATA[31], IDATA[19:12], IDATA[20], IDATA[30:21], ALL0[0] } : // j-type\n                     IDATA[6:0]==`LUI||\n                     IDATA[6:0]==`AUIPC ? { IDATA[31:12], ALL0[11:0] } : // u-type\n                                          { IDATA[31] ? ALL1[31:12]:ALL0[31:12], IDATA[31:20] }; // i-type\n        // non-signal extended immediate, according to the instruction type:\n\n    assign XUIMM  = XRES ? 0: \n                     IDATA[6:0]==`SCC ? { ALL0[31:12], IDATA[31:25],IDATA[11:7] } : // s-type\n                     IDATA[6:0]==`BCC ? { ALL0[31:13], IDATA[31],IDATA[7],IDATA[30:25],IDATA[11:8],ALL0[0] } : // b-type\n                     IDATA[6:0]==`JAL ? { ALL0[31:21], IDATA[31], IDATA[19:12], IDATA[20], IDATA[30:21], ALL0[0] } : // j-type\n                     IDATA[6:0]==`LUI||\n                     IDATA[6:0]==`AUIPC ? { IDATA[31:12], ALL0[11:0] } : // u-type\n                                          { ALL0[31:12], IDATA[31:20] }; // i-type\n\n    reg FLUSH = -1;  // flush instruction pipeline\n\n`endif\n\n`ifdef __THREADS__\n    `ifdef __RV32E__\n\n        reg [`__THREADS__-1:0] RESMODE = -1;\n\n        wire [`__THREADS__+3:0] DPTR   = XRES ? { RESMODE, 4'd0 } : { XMODE, XIDATA[10: 7] }; // set SP_RESET when RES==1\n        wire [`__THREADS__+3:0] S1PTR  = { XMODE, XIDATA[18:15] };\n        wire [`__THREADS__+3:0] S2PTR  = { XMODE, XIDATA[23:20] };\n    `else\n        reg [`__THREADS__-1:0] RESMODE = -1;\n\n        wire [`__THREADS__+4:0] DPTR   = XRES ? { RESMODE, 5'd0 } : { XMODE, XIDATA[11: 7] }; // set SP_RESET when RES==1\n        wire [`__THREADS__+4:0] S1PTR  = { XMODE, XIDATA[19:15] };\n        wire [`__THREADS__+4:0] S2PTR  = { XMODE, XIDATA[24:20] };\n    `endif\n`else\n    `ifdef __RV32E__\n        wire [3:0] DPTR   = XRES ? 0 : XIDATA[10: 7]; // set SP_RESET when RES==1\n        wire [3:0] S1PTR  = XIDATA[18:15];\n        wire [3:0] S2PTR  = XIDATA[23:20];\n    `else\n        wire [4:0] DPTR   = XRES ? 0 : XIDATA[11: 7]; // set SP_RESET when RES==1\n        wire [4:0] S1PTR  = XIDATA[19:15];\n        wire [4:0] S2PTR  = XIDATA[24:20];\n    `endif\n`endif\n\n    wire [6:0] OPCODE = FLUSH ? 0 : XIDATA[6:0];\n    wire [2:0] FCT3   = XIDATA[14:12];\n    wire [6:0] FCT7   = XIDATA[31:25];\n\n    wire [31:0] SIMM  = XSIMM;\n    wire [31:0] UIMM  = XUIMM;\n\n    // main opcode decoder:\n\n    wire    LUI = FLUSH ? 0 : XLUI;   // OPCODE==7'b0110111;\n    wire  AUIPC = FLUSH ? 0 : XAUIPC; // OPCODE==7'b0010111;\n    wire    JAL = FLUSH ? 0 : XJAL;   // OPCODE==7'b1101111;\n    wire   JALR = FLUSH ? 0 : XJALR;  // OPCODE==7'b1100111;\n\n    wire    BCC = FLUSH ? 0 : XBCC; // OPCODE==7'b1100011; //FCT3\n    wire    LCC = FLUSH ? 0 : XLCC; // OPCODE==7'b0000011; //FCT3\n    wire    SCC = FLUSH ? 0 : XSCC; // OPCODE==7'b0100011; //FCT3\n    wire    MCC = FLUSH ? 0 : XMCC; // OPCODE==7'b0010011; //FCT3\n\n    wire    RCC = FLUSH ? 0 : XRCC; // OPCODE==7'b0110011; //FCT3\n    wire    CUS = FLUSH ? 0 : XCUS; // OPCODE==7'b0110011; //FCT3\n    //wire    FCC = FLUSH ? 0 : XFCC; // OPCODE==7'b0001111; //FCT3\n    wire    CCC = FLUSH ? 0 : XCCC; // OPCODE==7'b1110011; //FCT3\n\n`ifdef __THREADS__\n    `ifdef __3STAGE__\n        reg [31:0] NXPC2 [0:(2**`__THREADS__)-1];       // 32-bit program counter t+2\n    `endif\n\n    `ifdef __RV32E__\n        reg [31:0] REGS [0:16*(2**`__THREADS__)-1];\t// general-purpose 16x32-bit registers (s1)\n    `else\n        reg [31:0] REGS [0:32*(2**`__THREADS__)-1];\t// general-purpose 32x32-bit registers (s1)\n    `endif\n`else\n    `ifdef __3STAGE__\n        reg [31:0] NXPC2;       // 32-bit program counter t+2\n    `endif\n\n    `ifdef __RV32E__\n        reg [31:0] REGS [0:15];\t// general-purpose 16x32-bit registers (s1)\n    `else\n        reg [31:0] REGS [0:31];\t// general-purpose 32x32-bit registers (s1)\n    `endif\n`endif\n\n    reg [31:0] NXPC;        // 32-bit program counter t+1\n    reg [31:0] PC;\t\t    // 32-bit program counter t+0\n\n`ifdef SIMULATION\n    integer i;\n    \n    initial for(i=0;i!=16;i=i+1) REGS[i] = 0;\n`endif\n\n    // source-1 and source-1 register selection\n\n    wire          [31:0] U1REG = REGS[S1PTR];\n    wire          [31:0] U2REG = REGS[S2PTR];\n\n    wire signed   [31:0] S1REG = U1REG;\n    wire signed   [31:0] S2REG = U2REG;\n\n\n    // L-group of instructions (OPCODE==7'b0000011)\n\n`ifdef __FLEXBUZZ__\n\n    wire [31:0] LDATA = FCT3[1:0]==0 ? { FCT3[2]==0&&DATAI[ 7] ? ALL1[31: 8]:ALL0[31: 8] , DATAI[ 7: 0] } :\n                        FCT3[1:0]==1 ? { FCT3[2]==0&&DATAI[15] ? ALL1[31:16]:ALL0[31:16] , DATAI[15: 0] } :\n                                        DATAI;\n`else\n    wire [31:0] LDATA = FCT3==0||FCT3==4 ? ( DADDR[1:0]==3 ? { FCT3==0&&DATAI[31] ? ALL1[31: 8]:ALL0[31: 8] , DATAI[31:24] } :\n                                             DADDR[1:0]==2 ? { FCT3==0&&DATAI[23] ? ALL1[31: 8]:ALL0[31: 8] , DATAI[23:16] } :\n                                             DADDR[1:0]==1 ? { FCT3==0&&DATAI[15] ? ALL1[31: 8]:ALL0[31: 8] , DATAI[15: 8] } :\n                                                             { FCT3==0&&DATAI[ 7] ? ALL1[31: 8]:ALL0[31: 8] , DATAI[ 7: 0] } ):\n                        FCT3==1||FCT3==5 ? ( DADDR[1]==1   ? { FCT3==1&&DATAI[31] ? ALL1[31:16]:ALL0[31:16] , DATAI[31:16] } :\n                                                             { FCT3==1&&DATAI[15] ? ALL1[31:16]:ALL0[31:16] , DATAI[15: 0] } ) :\n                                             DATAI;\n`endif\n\n    // S-group of instructions (OPCODE==7'b0100011)\n\n`ifdef __FLEXBUZZ__\n\n    wire [31:0] SDATA = U2REG; /* FCT3==0 ? { ALL0 [31: 8], U2REG[ 7:0] } :\n                        FCT3==1 ? { ALL0 [31:16], U2REG[15:0] } :\n                                    U2REG;*/\n`else\n    wire [31:0] SDATA = FCT3==0 ? ( DADDR[1:0]==3 ? { U2REG[ 7: 0], ALL0 [23:0] } :\n                                    DADDR[1:0]==2 ? { ALL0 [31:24], U2REG[ 7:0], ALL0[15:0] } :\n                                    DADDR[1:0]==1 ? { ALL0 [31:16], U2REG[ 7:0], ALL0[7:0] } :\n                                                    { ALL0 [31: 8], U2REG[ 7:0] } ) :\n                        FCT3==1 ? ( DADDR[1]==1   ? { U2REG[15: 0], ALL0 [15:0] } :\n                                                    { ALL0 [31:16], U2REG[15:0] } ) :\n                                    U2REG;\n`endif\n\n    // C-group: CSRRW\n\n`ifdef __INTERRUPT__\n\n    reg [31:0] MEPC  = 0;\n    reg [31:0] MTVEC = 0;\n    reg        MIE   = 0;\n    reg        MIP   = 0;\n\n    wire [31:0] CDATA = XIDATA[31:20]==12'h344 ? MIP  : // machine interrupt pending\n                        XIDATA[31:20]==12'h304 ? MIE   : // machine interrupt enable\n                        XIDATA[31:20]==12'h341 ? MEPC  : // machine exception PC\n                        XIDATA[31:20]==12'h305 ? MTVEC : // machine vector table\n                                                 0;\t // unknown\n\n    wire MRET = CCC && FCT3==0 && S2PTR==2;\n    wire CSRW = CCC && FCT3==1;\n    wire CSRR = CCC && FCT3==2;\n`endif\n    wire EBRK = CCC && FCT3==0 && S2PTR==1;\n\n    // RM-group of instructions (OPCODEs==7'b0010011/7'b0110011), merged! src=immediate(M)/register(R)\n\n    wire signed [31:0] S2REGX = XMCC ? SIMM : S2REG;\n    wire        [31:0] U2REGX = XMCC ? UIMM : U2REG;\n\n    wire [31:0] RMDATA = FCT3==7 ? U1REG&S2REGX :\n                         FCT3==6 ? U1REG|S2REGX :\n                         FCT3==4 ? U1REG^S2REGX :\n                         FCT3==3 ? U1REG<U2REGX : // unsigned\n                         FCT3==2 ? S1REG<S2REGX : // signed\n                         FCT3==0 ? (XRCC&&FCT7[5] ? U1REG-S2REGX : U1REG+S2REGX) :\n                         FCT3==1 ? S1REG<<U2REGX[4:0] :\n                         //FCT3==5 ?\n                         !FCT7[5] ? S1REG>>U2REGX[4:0] :\n`ifdef MODEL_TECH\n                                   -((-S1REG)>>U2REGX[4:0]); // workaround for modelsim\n`else\n                                   $signed(S1REG)>>>U2REGX[4:0];  // (FCT7[5] ? U1REG>>>U2REG[4:0] :\n`endif\n\n`ifdef __MAC16X16__\n\n    // MAC instruction rd += s1*s2 (OPCODE==7'b1111111)\n    //\n    // 0000000 01100 01011 100 01100 0110011 xor a2,a1,a2\n    // 0000000 01010 01100 000 01010 0110011 add a0,a2,a0\n    // 0000000 01100 01011 000 01010 0001011 mac a0,a1,a2\n    //\n    // 0000 0000 1100 0101 1000 0101 0000 1011 = 00c5850b\n\n    wire MAC = CUS && FCT3==0;\n\n    wire signed [15:0] K1TMP = S1REG[15:0];\n    wire signed [15:0] K2TMP = S2REG[15:0];\n    wire signed [31:0] KDATA = K1TMP*K2TMP;\n\n`endif\n\n    // J/B-group of instructions (OPCODE==7'b1100011)\n\n    wire BMUX       = FCT3==7 && U1REG>=U2REG  || // bgeu\n                      FCT3==6 && U1REG< U2REGX || // bltu\n                      FCT3==5 && S1REG>=S2REG  || // bge\n                      FCT3==4 && S1REG< S2REGX || // blt\n                      FCT3==1 && U1REG!=U2REGX || // bne\n                      FCT3==0 && U1REG==U2REGX; // beq\n\n    wire [31:0] PCSIMM = PC+SIMM;\n    wire        JREQ = JAL||JALR||(BCC && BMUX);\n    wire [31:0] JVAL = JALR ? DADDR : PCSIMM; // SIMM + (JALR ? U1REG : PC);\n\n    always@(posedge CLK)\n    begin\n`ifdef __THREADS__\n        RESMODE <= RES ? -1 : RESMODE ? RESMODE-1 : 0;\n        XRES <= |RESMODE;\n`else\n        XRES <= RES;\n`endif\n\n`ifdef __3STAGE__\n\t    FLUSH <= XRES ? 2 : HLT ? FLUSH :        // reset and halt\n\t                       FLUSH ? FLUSH-1 :\n    `ifdef __INTERRUPT__\n                            MRET ? 2 :\n    `endif\n\t                       JREQ ? 2 : 0;  // flush the pipeline!\n`else\n        FLUSH <= XRES ? 1 : HLT ? FLUSH :        // reset and halt\n                       JREQ;  // flush the pipeline!\n`endif\n`ifdef __INTERRUPT__\n        if(XRES)\n        begin\n            MTVEC <= 0;\n            MEPC  <= 0;\n            MIP   <= 0;\n            MIE   <= 0;\n        end\n        else\n        if(MIP&&MIE&&JREQ)\n        begin\n            MEPC <= JVAL;\n            MIP  <= 1;\n            MIE  <= 0;\n        end\n        else\n        if(CSRW)\n        begin\n            case(XIDATA[31:20])\n                12'h305: MTVEC <= U1REG;\n                12'h341: MEPC  <= U1REG;\n                12'h304: MIE   <= U1REG;\n            endcase\n        end\n        else\n        if(MRET)\n        begin\n            MIP <= 0;\n            MIE <= 1;\n        end\n        else\n        if(INT==1&&MIE==1)\n        begin\n            MIP <= 1;\n        end\n`endif\n`ifdef __RV32E__\n        REGS[DPTR] <=   XRES||DPTR[3:0]==0 ? 0  :        // reset sp\n`else\n        REGS[DPTR] <=   XRES||DPTR[4:0]==0 ? 0  :        // reset sp\n`endif\n                       HLT ? REGS[DPTR] :        // halt\n                       LCC ? LDATA :\n                     AUIPC ? PCSIMM :\n                      JAL||\n                      JALR ? NXPC :\n                       LUI ? SIMM :\n                  MCC||RCC ? RMDATA:\n\n`ifdef __MAC16X16__\n                       MAC ? REGS[DPTR]+KDATA :\n`endif\n`ifdef __INTERRUPT__\n                       CSRR ? CDATA :\n`endif\n                             REGS[DPTR];\n\n`ifdef __3STAGE__\n\n    `ifdef __THREADS__\n\n        NXPC <= /*XRES ? `__RESETPC__ :*/ HLT ? NXPC : NXPC2[XMODE];\n\n        NXPC2[XRES ? RESMODE : XMODE] <=  XRES ? `__RESETPC__ : HLT ? NXPC2[XMODE] :   // reset and halt\n                                      JREQ ? JVAL :                            // jmp/bra\n\t                                         NXPC2[XMODE]+4;                   // normal flow\n\n        XMODE <= XRES ? 0 : HLT ? XMODE :        // reset and halt\n                            /*JAL*/ JREQ ? XMODE+1 : XMODE;\n\t             //XMODE==0/*&& IREQ*/&&JREQ ? 1 :         // wait pipeflush to switch to irq\n                 //XMODE==1/*&&!IREQ*/&&JREQ ? 0 : XMODE;  // wait pipeflush to return from irq\n\n    `else\n        NXPC <= /*XRES ? `__RESETPC__ :*/ HLT ? NXPC : NXPC2;\n\n\t    NXPC2 <=  XRES ? `__RESETPC__ : HLT ? NXPC2 :   // reset and halt\n        `ifdef __INTERRUPT__\n                     MRET ? MEPC :\n                    MIE&&MIP&&JREQ ? MTVEC : // pending interrupt + pipeline flush\n        `endif\n\t                 JREQ ? JVAL :                    // jmp/bra\n\t                        NXPC2+4;                   // normal flow\n\n    `endif\n\n`else\n        NXPC <= XRES ? `__RESETPC__ : HLT ? NXPC :   // reset and halt\n        `ifdef __INTERRUPT__\n                     MRET ? MEPC :\n                    MIE&&MIP&&JREQ ? MTVEC : // pending interrupt + pipeline flush\n        `endif\n              JREQ ? JVAL :                   // jmp/bra\n                     NXPC+4;                   // normal flow\n`endif\n        PC   <= /*XRES ? `__RESETPC__ :*/ HLT ? PC : NXPC; // current program counter\n\n`ifndef __YOSYS__\n\n        if(EBRK)\n        begin\n            $display(\"breakpoint at %x\",PC);\n            $stop();\n"}
{"text": "        end\n        \n        if(!FLUSH && IDATA===32'dx)\n        begin\n            $display(\"invalid IDATA at %x\",PC);\n            $stop();  \n        end\n        \n        if(LCC && !HLT && DATAI===32'dx)\n        begin\n            $display(\"invalid DATAI@%x at %x\",DADDR,PC);\n            $stop();\n        end\n`endif\n\n    end\n\n    // IO and memory interface\n\n    assign DATAO = SDATA; // SCC ? SDATA : 0;\n    assign DADDR = U1REG + SIMM; // (SCC||LCC) ? U1REG + SIMM : 0;\n\n    // based in the Scc and Lcc\n\n`ifdef __FLEXBUZZ__\n    assign RW      = !SCC;\n    assign DLEN[0] = (SCC||LCC)&&FCT3[1:0]==0;\n    assign DLEN[1] = (SCC||LCC)&&FCT3[1:0]==1;\n    assign DLEN[2] = (SCC||LCC)&&FCT3[1:0]==2;\n`else\n    assign RD = LCC;\n    assign WR = SCC;\n    assign BE = FCT3==0||FCT3==4 ? ( DADDR[1:0]==3 ? 4'b1000 : // sb/lb\n                                     DADDR[1:0]==2 ? 4'b0100 :\n                                     DADDR[1:0]==1 ? 4'b0010 :\n                                                     4'b0001 ) :\n                FCT3==1||FCT3==5 ? ( DADDR[1]==1   ? 4'b1100 : // sh/lh\n                                                     4'b0011 ) :\n                                                     4'b1111; // sw/lw\n`endif\n\n`ifdef __3STAGE__\n    `ifdef __THREADS__\n        assign IADDR = NXPC2[XMODE];\n    `else\n        assign IADDR = NXPC2;\n    `endif\n`else\n    assign IADDR = NXPC;\n`endif\n\n    assign IDLE = |FLUSH;\n`ifdef __INTERRUPT__\n    assign DEBUG = { INT, MIP, MIE, MRET };\n`else\n    assign DEBUG = { XRES, IDLE, SCC, LCC };\n`endif\n\nendmodule\n"}
{"text": "/*\n * Copyright (c) 2018, Marcelo Samsoniuk\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice, this\n *   list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n *\n * * Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n`timescale 1ns / 1ps\n`include \"../rtl/config.vh\"\n\nmodule darksocv\n(\n    input        XCLK,      // external clock\n    input        XRES,      // external reset\n\n    input        UART_RXD,  // UART receive line\n    output       UART_TXD,  // UART transmit line\n\n    output [3:0] LED,       // on-board leds\n    output [3:0] DEBUG      // osciloscope\n);\n\n    wire CLK,RES;\n    \n    darkpll darkpll0(.XCLK(XCLK),.XRES(XRES),.CLK(CLK),.RES(RES));\n\n    // ro/rw memories\n\n`ifdef __HARVARD__\n\n    reg [31:0] ROM [0:2**`MLEN/4-1]; // ro memory\n    reg [31:0] RAM [0:2**`MLEN/4-1]; // rw memory\n\n    // memory initialization\n\n    integer i;\n    initial\n    begin\n        for(i=0;i!=2**`MLEN/4;i=i+1)\n        begin\n            ROM[i] = 32'd0;\n            RAM[i] = 32'd0;\n        end\n\n        // workaround for vivado: no path in simulation and .mem extension\n\n    `ifdef XILINX_SIMULATOR\n        $readmemh(\"darksocv.rom.mem\",ROM);\n        $readmemh(\"darksocv.ram.mem\",RAM);\n    `else\n        $readmemh(\"../src/darksocv.rom.mem\",ROM);\n        $readmemh(\"../src/darksocv.ram.mem\",RAM);\n    `endif\n    end\n\n`else\n\n\n    reg [31:0] MEM [0:2**`MLEN/4-1]; // ro memory\n\n    // memory initialization\n\n    integer i;\n    initial\n    begin\n`ifdef SIMULATION\n\n        for(i=0;i!=2**`MLEN/4;i=i+1)\n        begin\n            MEM[i] = 32'd0;\n        end\n`endif\n\n        // workaround for vivado: no path in simulation and .mem extension\n\n    `ifdef XILINX_SIMULATOR\n        $readmemh(\"darksocv.mem\",MEM);\n\t `elsif MODEL_TECH\n\t\t  $readmemh(\"../../../../src/darksocv.mem\",MEM);\n    `else\n        $readmemh(\"../src/darksocv.mem\",MEM,0);\n    `endif\n    end\n\n`endif\n\n    // darkriscv bus interface\n\n    wire [31:0] IADDR;\n    wire [31:0] DADDR;\n    wire [31:0] IDATA;\n    wire [31:0] DATAO;\n    wire [31:0] DATAI;\n    wire        WR,RD;\n    wire [3:0]  BE;\n\n`ifdef __FLEXBUZZ__\n    wire [31:0] XATAO;\n    wire [31:0] XATAI;\n    wire [ 2:0] DLEN;\n    wire        RW;\n`endif\n\n    wire [31:0] IOMUX [0:4];\n\n    reg  [15:0] GPIOFF = 0;\n    reg  [15:0] LEDFF  = 0;\n\n    wire HLT;\n\n    // instruction bus\n\n    reg [31:0] ROMFF;\n\n    wire IHIT = 1;\n\n    reg [31:0] ROMFF2 = 0;\n    reg        HLT2   = 0;\n\n    always@(posedge CLK) // stage #0.5\n    begin\n        if(HLT^HLT2)\n        begin\n            ROMFF2 <= ROMFF;\n        end\n\n        HLT2 <= HLT;\n    end\n\n    assign IDATA = HLT2 ? ROMFF2 : ROMFF;\n\n    always@(posedge CLK) // stage #0.5\n    begin\n`ifdef __HARVARD__\n        ROMFF <= ROM[IADDR[`MLEN-1:2]];\n`else\n        ROMFF <= MEM[IADDR[`MLEN-1:2]];\n`endif\n    end\n\n    // data bus\n\n`ifdef __FLEXBUZZ__\n\n    // must work just exactly as the default interface, since we have no\n    // flexbuzz devices available yet (i.e., all devices are 32-bit now)\n\n    assign XATAI = DLEN[0] ? ( DADDR[1:0]==3 ? DATAI[31:24] :\n                               DADDR[1:0]==2 ? DATAI[23:16] :\n                               DADDR[1:0]==1 ? DATAI[15: 8] :\n                                               DATAI[ 7: 0] ):\n                   DLEN[1] ? ( DADDR[1]==1   ? DATAI[31:16] :\n                                               DATAI[15: 0] ):\n                                               DATAI;\n\n    assign DATAO = DLEN[0] ? ( DADDR[1:0]==3 ? {        XATAO[ 7: 0], 24'hx } :\n                               DADDR[1:0]==2 ? {  8'hx, XATAO[ 7: 0], 16'hx } :\n                               DADDR[1:0]==1 ? { 16'hx, XATAO[ 7: 0],  8'hx } :\n                                               { 24'hx, XATAO[ 7: 0]        } ):\n                   DLEN[1] ? ( DADDR[1]==1   ? { XATAO[15: 0], 16'hx } :\n                                               { 16'hx, XATAO[15: 0] } ):\n                                                 XATAO;\n\n    assign RD = DLEN&&RW==1;\n    assign WR = DLEN&&RW==0;\n\n    assign BE =    DLEN[0] ? ( DADDR[1:0]==3 ? 4'b1000 : // 8-bit\n                               DADDR[1:0]==2 ? 4'b0100 :\n                               DADDR[1:0]==1 ? 4'b0010 :\n                                               4'b0001 ) :\n                   DLEN[1] ? ( DADDR[1]==1   ? 4'b1100 : // 16-bit\n                                               4'b0011 ) :\n                                               4'b1111;  // 32-bit\n\n`endif\n\n    reg [31:0] RAMFF;\n\n    // for single phase clock: 1 wait state in read op always required!\n\n    reg [1:0] DACK = 0;\n\n    wire WHIT = 1;\n    wire DHIT = !((RD\n            `ifdef __RMW_CYCLE__\n                    ||WR\t\t// worst code ever! but it is 3:12am...\n            `endif\n                    ) && DACK!=1); // the WR operatio does not need ws. in this config.\n\n    always@(posedge CLK) // stage #1.0\n    begin\n        DACK <= RES ? 0 : DACK ? DACK-1 : (RD\n            `ifdef __RMW_CYCLE__\n                    ||WR\t\t// 2nd worst code ever!\n            `endif\n                    ) ? 1 : 0; // wait-states\n    end\n\n    always@(posedge CLK) // stage #1.5\n    begin\n`ifdef __HARVARD__\n        RAMFF <= RAM[DADDR[`MLEN-1:2]];\n`else\n        RAMFF <= MEM[DADDR[`MLEN-1:2]];\n`endif\n    end\n\n    //assign DATAI = DADDR[31] ? IOMUX  : RAM[DADDR[`MLEN-1:2]];\n\n    reg [31:0] IOMUXFF = 0;\n    reg [31:0] XADDR   = 0;\n\n    //individual byte/word/long selection, thanks to HYF!\n\n    always@(posedge CLK)\n    begin\n\n`ifdef __RMW_CYCLE__\n\n        // read-modify-write operation w/ 1 wait-state:\n\n        if(!HLT&&WR&&DADDR[31]==0/*&&DADDR[`MLEN-1]==1*/)\n        begin\n    `ifdef __HARVARD__\n            RAM[DADDR[`MLEN-1:2]] <=\n    `else\n            MEM[DADDR[`MLEN-1:2]] <=\n    `endif\n                                {\n                                    BE[3] ? DATAO[3 * 8 + 7: 3 * 8] : RAMFF[3 * 8 + 7: 3 * 8],\n                                    BE[2] ? DATAO[2 * 8 + 7: 2 * 8] : RAMFF[2 * 8 + 7: 2 * 8],\n                                    BE[1] ? DATAO[1 * 8 + 7: 1 * 8] : RAMFF[1 * 8 + 7: 1 * 8],\n                                    BE[0] ? DATAO[0 * 8 + 7: 0 * 8] : RAMFF[0 * 8 + 7: 0 * 8]\n                                };\n        end\n\n`else\n        // write-only operation w/ 0 wait-states:\n    `ifdef __HARVARD__\n        if(!HLT&&WR&&DADDR[31]==0&&/*DADDR[`MLEN-1]==1&&*/BE[3]) RAM[DADDR[`MLEN-1:2]][3 * 8 + 7: 3 * 8] <= DATAO[3 * 8 + 7: 3 * 8];\n        if(!HLT&&WR&&DADDR[31]==0&&/*DADDR[`MLEN-1]==1&&*/BE[2]) RAM[DADDR[`MLEN-1:2]][2 * 8 + 7: 2 * 8] <= DATAO[2 * 8 + 7: 2 * 8];\n        if(!HLT&&WR&&DADDR[31]==0&&/*DADDR[`MLEN-1]==1&&*/BE[1]) RAM[DADDR[`MLEN-1:2]][1 * 8 + 7: 1 * 8] <= DATAO[1 * 8 + 7: 1 * 8];\n        if(!HLT&&WR&&DADDR[31]==0&&/*DADDR[`MLEN-1]==1&&*/BE[0]) RAM[DADDR[`MLEN-1:2]][0 * 8 + 7: 0 * 8] <= DATAO[0 * 8 + 7: 0 * 8];\n    `else\n        if(!HLT&&WR&&DADDR[31]==0&&/*DADDR[`MLEN-1]==1&&*/BE[3]) MEM[DADDR[`MLEN-1:2]][3 * 8 + 7: 3 * 8] <= DATAO[3 * 8 + 7: 3 * 8];\n        if(!HLT&&WR&&DADDR[31]==0&&/*DADDR[`MLEN-1]==1&&*/BE[2]) MEM[DADDR[`MLEN-1:2]][2 * 8 + 7: 2 * 8] <= DATAO[2 * 8 + 7: 2 * 8];\n        if(!HLT&&WR&&DADDR[31]==0&&/*DADDR[`MLEN-1]==1&&*/BE[1]) MEM[DADDR[`MLEN-1:2]][1 * 8 + 7: 1 * 8] <= DATAO[1 * 8 + 7: 1 * 8];\n        if(!HLT&&WR&&DADDR[31]==0&&/*DADDR[`MLEN-1]==1&&*/BE[0]) MEM[DADDR[`MLEN-1:2]][0 * 8 + 7: 0 * 8] <= DATAO[0 * 8 + 7: 0 * 8];\n    `endif\n`endif\n\n        XADDR <= DADDR; // 1 clock delayed\n        IOMUXFF <= IOMUX[DADDR[4:2]==3'b100 ? 3'b100 : DADDR[3:2]]; // read w/ 2 wait-states\n    end\n\n    //assign DATAI = DADDR[31] ? IOMUX[DADDR[3:2]]  : RAMFF;\n    //assign DATAI = DADDR[31] ? IOMUXFF : RAMFF;\n    assign DATAI = XADDR[31] ? IOMUX[XADDR[4:2]==3'b100 ? 3'b100 : XADDR[3:2]] : RAMFF;\n\n    // io for debug\n\n    reg [7:0] IREQ = 0;\n    reg [7:0] IACK = 0;\n\n    reg [31:0] TIMERFF = 0;\n    reg [31:0] TIMEUS = 0;\n\n    wire [7:0] BOARD_IRQ;\n\n    wire   [7:0] BOARD_ID = `BOARD_ID;              // board id\n    wire   [7:0] BOARD_CM = (`BOARD_CK/2000000);    // board clock (MHz)\n\n`ifdef __THREADS__\n    wire [`__THREADS__-1:0] TPTR;\n    wire   [7:0] CORE_ID = TPTR;                    // core id\n`else\n    wire   [7:0] CORE_ID = 0;                       // core id\n`endif\n\n    assign IOMUX[0] = { BOARD_IRQ, CORE_ID, BOARD_CM, BOARD_ID };\n    //assign IOMUX[1] = from UART!\n    assign IOMUX[2] = { GPIOFF, LEDFF };\n    assign IOMUX[3] = TIMERFF;\n    assign IOMUX[4] = TIMEUS;\n\n    reg [31:0] TIMER = 0;\n\n    reg XTIMER = 0;\n\n    always@(posedge CLK)\n    begin\n        if(WR&&DADDR[31]&&DADDR[3:0]==4'b1000)\n        begin\n            LEDFF <= DATAO[15:0];\n        end\n\n        if(WR&&DADDR[31]&&DADDR[3:0]==4'b1010)\n        begin\n            GPIOFF <= DATAO[31:16];\n        end\n\n        if(RES)\n            TIMERFF <= (`BOARD_CK/1000000)-1; // timer set to 1MHz by default\n        else\n        if(WR&&DADDR[31]&&DADDR[3:0]==4'b1100)\n        begin\n            TIMERFF <= DATAO[31:0];\n        end\n\n        if(RES)\n            IACK <= 0;\n        else\n        if(WR&&DADDR[31]&&DADDR[3:0]==4'b0011)\n        begin\n            //$display(\"clear io.irq = %x (ireq=%x, iack=%x)\",DATAO[32:24],IREQ,IACK);\n\n            IACK[7] <= DATAO[7+24] ? IREQ[7] : IACK[7];\n            IACK[6] <= DATAO[6+24] ? IREQ[6] : IACK[6];\n            IACK[5] <= DATAO[5+24] ? IREQ[5] : IACK[5];\n            IACK[4] <= DATAO[4+24] ? IREQ[4] : IACK[4];\n            IACK[3] <= DATAO[3+24] ? IREQ[3] : IACK[3];\n            IACK[2] <= DATAO[2+24] ? IREQ[2] : IACK[2];\n            IACK[1] <= DATAO[1+24] ? IREQ[1] : IACK[1];\n            IACK[0] <= DATAO[0+24] ? IREQ[0] : IACK[0];\n        end\n\n        if(RES)\n            IREQ <= 0;\n        else\n        if(TIMERFF)\n        begin\n            TIMER <= TIMER ? TIMER-1 : TIMERFF;\n\n            if(TIMER==0 && IREQ==IACK)\n            begin\n                IREQ[7] <= !IACK[7];\n\n                //$display(\"timr0 set\");\n            end\n\n            XTIMER  <= XTIMER+(TIMER==0);\n            TIMEUS <= (TIMER == TIMERFF) ? TIMEUS + 1'b1 : TIMEUS;\n        end\n    end\n\n    assign BOARD_IRQ = IREQ^IACK;\n\n    assign HLT = !IHIT||!DHIT||!WHIT;\n\n    // darkuart\n\n    wire [3:0] UDEBUG;\n\n    wire FINISH_REQ;\n\n    darkuart\n//    #(\n//      .BAUD((`BOARD_CK/115200))\n//    )\n    uart0\n    (\n      .CLK(CLK),\n      .RES(RES),\n      .RD(!HLT&&RD&&DADDR[31]&&DADDR[3:2]==1),\n      .WR(!HLT&&WR&&DADDR[31]&&DADDR[3:2]==1),\n      .BE(BE),\n      .DATAI(DATAO),\n      .DATAO(IOMUX[1]),\n      //.IRQ(UART_IRQ),\n\n`ifndef TESTMODE\n      .RXD(UART_RXD),\n      .TXD(UART_TXD),\n`endif\t\t\n\t\t`ifdef SIMULATION\n      .FINISH_REQ(FINISH_REQ),\n`endif\n      .DEBUG(UDEBUG)\n    );\n\n    // darkriscv\n\n    wire [3:0] KDEBUG;\n\n    wire IDLE;\n\n    darkriscv\n//    #(\n//        .RESET_PC(32'h00000000),\n//        .RESET_SP(32'h00002000)\n//    )\n    core0\n    (\n        .CLK(CLK),\n        .RES(RES),\n        .HLT(HLT),\n`ifdef __THREADS__\n        .TPTR(TPTR),\n`endif\n`ifdef __INTERRUPT__\n        .INT(|BOARD_IRQ),\n`endif\n        .IDATA(IDATA),\n        .IADDR(IADDR),\n        .DADDR(DADDR),\n\n`ifdef __FLEXBUZZ__\n        .DATAI(XATAI),\n        .DATAO(XATAO),\n        .DLEN(DLEN),\n        .RW(RW),\n`else\n        .DATAI(DATAI),\n        .DATAO(DATAO),\n        .BE(BE),\n        .WR(WR),\n        .RD(RD),\n`endif\n\n        .IDLE(IDLE),\n\n        .DEBUG(KDEBUG)\n    );\n\n`ifdef TESTMODE\n\t \n    // tips to port darkriscv for a new target:\n\t // \n\t // - 1st of all, test the blink code to confirms the reset\n\t //   polarity, i.e. the LEDs must blink at startup when\n\t //   the reset button *is not pressed*\n\t // - 2nd check the blink rate: the 31-bit counter that starts\n\t //   with BOARD_CK value and counts to zero, blinking w/\n\t //   50% of this period\n\n\t reg [31:0] BLINK = 0;\n\t \n\t always@(posedge CLK)\n\t begin\n        BLINK <= RES ? 0 : BLINK ? BLINK-1 : `BOARD_CK;\n\t end\n\t \n\t assign LED = (BLINK < (`BOARD_CK/2)) ? -1 : 0;\n\t assign UART_TXD = UART_RXD;\n`else\n    assign LED   = LEDFF[3:0];\n`endif\n\t \n    assign DEBUG = { XTIMER, KDEBUG[2:0] }; // UDEBUG;\n\n`ifdef SIMULATION\n\n    `ifdef __PERFMETER__\n\n        integer clocks=0, running=0, load=0, store=0, flush=0, halt=0;\n\n    `ifdef __THREADS__\n        integer thread[0:(2**`__THREADS__)-1],curtptr=0,cnttptr=0;\n        integer j;\n\n        initial for(j=0;j!=(2**`__THREADS__);j=j+1) thread[j] = 0;\n    `endif\n\n        always@(posedge CLK)\n        begin\n            if(!RES)\n            begin\n                clocks = clocks+1;\n\n                if(HLT)\n                begin\n                         if(WR)\tstore = store+1;\n                    else if(RD)\tload  = load +1;\n                    else \t\thalt  = halt +1;\n                end\n                else\n                if(IDLE)\n                begin\n                    flush=flush+1;\n                end\n                else\n                begin\n\n        `ifdef __THREADS__\n                    for(j=0;j!=(2**`__THREADS__);j=j+1)\n                            thread[j] = thread[j]+(j==TPTR?1:0);\n\n                    if(TPTR!=curtptr)\n                    begin\n                        curtptr = TPTR;\n                        cnttptr = cnttptr+1;\n                    end\n        `endif\n                    running = running +1;\n                end\n\n                if(FINISH_REQ)\n                begin\n                    $display(\"****************************************************************************\");\n                    $display(\"DarkRISCV Pipeline Report (%0d clocks):\",clocks);\n\n                    $display(\"core0: %0d%% run, %0d%% wait (%0d%% i-bus, %0d%% d-bus/rd, %0d%% d-bus/wr), %0d%% idle\",\n                        100.0*running/clocks,\n                        100.0*(load+store+halt)/clocks,\n                        100.0*halt/clocks,\n                        100.0*load/clocks,\n                        100.0*store/clocks,\n                        100.0*flush/clocks);\n\n         `ifdef __THREADS__\n                    for(j=0;j!=(2**`__THREADS__);j=j+1) $display(\"  thread%0d: %0d%% running\",j,100.0*thread[j]/clocks);\n\n                    $display(\"%0d thread switches, %0d clocks/threads\",cnttptr,clocks/cnttptr);\n         `endif\n                    $display(\"****************************************************************************\");\n                    $finish();\n                end\n            end\n        end\n    `else\n        always@(posedge CLK) if(FINISH_REQ) $finish();\n    `endif\n\n`endif\n\nendmodule\n"}
{"text": "/*\n * Copyright (c) 2018, Marcelo Samsoniuk\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * \n * * Redistributions of source code must retain the above copyright notice, this\n *   list of conditions and the following disclaimer.\n * \n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n * \n * * Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. \n */\n\n`timescale 1ns / 1ps\n`include \"../rtl/config.vh\"\n\n// the following defines are automatically defined:\n/*\n`ifdef __ICARUS__\n    `define SIMULATION 1\n`endif\n\n`ifdef XILINX_ISIM\n    `define SIMULATION 2\n`endif\n\n`ifdef MODEL_TECH\n    `define SIMULATION 3\n`endif\n\n`ifdef XILINX_SIMULATOR\n    `define SIMULATION 4\n`endif\n*/\n// uart states\n\n`define UART_STATE_IDLE  6\n`define UART_STATE_START 7\n`define UART_STATE_DATA0 8\n`define UART_STATE_DATA1 9\n`define UART_STATE_DATA2 10\n`define UART_STATE_DATA3 11\n`define UART_STATE_DATA4 12\n`define UART_STATE_DATA5 13\n`define UART_STATE_DATA6 14\n`define UART_STATE_DATA7 15\n`define UART_STATE_STOP  0\n`define UART_STATE_ACK   1\n\n// UART registers\n// \n// 0: status register ro, 1 = xmit busy, 2 = recv bfusy\n// 1: buffer register rw, w = xmit fifo, r = recv fifo\n// 2: baud rate msb   rw (not used)\n// 3: baud rate lsb   rw (not used)\n\nmodule darkuart\n//#(\n// parameter [15:0] BAUD = 0\n//) \n(\n    input           CLK,            // clock\n    input           RES,            // reset\n        \n    input           RD,             // bus read\n    input           WR,             // bus write\n    input  [ 3:0]   BE,             // byte enable\n    input  [31:0]   DATAI,          // data input\n    output [31:0]   DATAO,          // data output\n    output          IRQ,            // interrupt req\n\n    input           RXD,            // UART recv line\n    output          TXD,            // UART xmit line\n\n`ifdef SIMULATION\n    output reg\t    FINISH_REQ = 0,\n`endif\n    \n    output [3:0]    DEBUG           // osc debug\n);\n\n    reg [15:0]  UART_TIMER = `__BAUD__;  // baud rate from config.vh\n    reg         UART_IREQ  = 0;     // UART interrupt req\n    reg         UART_IACK  = 0;     // UART interrupt ack\n\n`ifdef __UARTQUEUE__\n    reg [ 7:0]  UART_XFIFO [0:255]; // UART TX FIFO\n    wire [7:0]  UART_XTMP;          // UART TX FIFO\n    reg [ 8:0]  UART_XREQ  = 0;     // xmit request (core side)\n    reg [ 8:0]  UART_XACK  = 0;     // xmit ack (uart side)\n`else\n    reg [ 7:0]  UART_XFIFO = 0;     // UART TX FIFO\n    reg         UART_XREQ  = 0;     // xmit request (core side)\n    reg         UART_XACK  = 0;     // xmit ack (uart side)\n`endif\n    reg [15:0]  UART_XBAUD = 0;     // baud rate counter\n    reg [ 3:0]  UART_XSTATE= 0;     // idle state\n\n`ifdef __UARTQUEUE__\n    reg [ 7:0]  UART_RFIFO [0:255]; // UART RX FIFO\n    reg [ 7:0]  UART_RTMP  = 0;     // UART RX FIFO\n    reg [ 8:0]  UART_RREQ  = 0;     // request (uart side)\n    reg [ 8:0]  UART_RACK  = 0;     // ack (core side)\n`else\n    reg [ 7:0]  UART_RFIFO = 0;     // UART RX FIFO\n    reg         UART_RREQ  = 0;     // request (uart side)\n    reg         UART_RACK  = 0;     // ack (core side)\n`endif\n    reg [15:0]  UART_RBAUD = 0;     // baud rate counter\n    reg [ 3:0]  UART_RSTATE= 0;     // idle state\n\n    reg [2:0]   UART_RXDFF = -1;\n\n`ifdef __UARTQUEUE__\n    wire [7:0]  UART_STATE = { 6'd0, UART_RREQ!=UART_RACK, UART_XREQ==(UART_XACK^9'h100) };\n\n    integer i;\n    \n    initial\n    for(i=0;i!=256;i=i+1)\n    begin\n        UART_RFIFO[i] = 0;\n        UART_XFIFO[i] = 0;\n    end\n`else\n    wire [7:0]  UART_STATE = { 6'd0, UART_RREQ!=UART_RACK, UART_XREQ!=UART_XACK };    \n`endif\n    reg [7:0]   UART_STATEFF = 0;\n\n    // bus interface\n\n    reg [31:0] DATAOFF = 0;\n\n    reg [1:0] IOREQ = 0;\n    reg [1:0] IOACK = 0;\n\n    always@(posedge CLK)\n    begin\n        if(WR)\n        begin\n            if(BE[1])\n            begin\n\n`ifdef SIMULATION\n                // print the UART output to console! :)\n                if(DATAI[15:8]!=13) // remove the '\\r'\n                begin\n                    UART_XFIFO <= DATAI[15:8];\n                    $write(\"%c\",DATAI[15:8]);\n                    $fflush();\n                    \n                    if(IOREQ==1&&DATAI[15:8]==\" \")\n                    begin\n                        $fflush(32'h8000_0001);\n                        IOREQ <= 2;\n                    end\n                    else\n                        IOREQ <= 0;\n                end\n                \n                //if(DATAI[15:8]==\"#\") // break point\n                //begin\n                //    $display(\"[checkpoint #]\");\n                //    $stop();\n                //end\n                \n                if(DATAI[15:8]==\">\") // prompt '>'\n                begin\n                \n    `ifndef __INTERACTIVE__\n                    $display(\" the __INTERACTIVE__ option is disabled, ending simulation...\");\n                    FINISH_REQ <= 1;\n    `endif                    \n                    if(IOACK==0) IOREQ <= 1;\n                end\n`else\n    `ifdef __UARTQUEUE__\n                if(UART_XREQ!=(UART_XACK^9'h100))\n                begin\n                    UART_XFIFO[UART_XREQ[7:0]] <= DATAI[15:8];\n                    UART_XREQ <= UART_XREQ+1;\n                end\n    `else            \n                UART_XFIFO <= DATAI[15:8];\n                UART_XREQ <= !UART_XACK;    // activate UART!\n    `endif\n`endif\n            end\n            //if(BE[2]) UART_TIMER[ 7:0] <= DATAI[23:16];\n            //if(BE[3]) UART_TIMER[15:8] <= DATAI[31:24];           \n        end\n    \n        if(RES)\n        begin\n            UART_RACK <= UART_RREQ;\n            UART_STATEFF <= UART_STATE;\n        end\n        else\n        if(RD)\n        begin\n`ifdef __UARTQUEUE__\n            if(BE[1]) UART_RACK     <= UART_RACK!=UART_RREQ?UART_RACK+1:UART_RACK; // fifo ready\n`else\n            if(BE[1]) UART_RACK     <= UART_RREQ; // fifo ready\n`endif\n            if(BE[0]) UART_STATEFF <= UART_STATE; // state update, clear irq\n        end\n    end\n    \n    assign IRQ   = |(UART_STATE^UART_STATEFF);\n`ifdef __UARTQUEUE__\n    assign DATAO = { UART_TIMER, UART_RFIFO[UART_RACK[7:0]], UART_STATE };\n`else\n    assign DATAO = { UART_TIMER, UART_RFIFO, UART_STATE };\n`endif\n\n    // xmit path: 6(IDLE), 7(START), 8, 9, 10, 11, 12, 13, 14, 15, 0(STOP), 1(ACK)\n    \n    always@(posedge CLK)\n    begin    \n        UART_XBAUD <= UART_XSTATE==`UART_STATE_IDLE ? UART_TIMER :      // xbaud=timer\n                      UART_XBAUD ? UART_XBAUD-1 : UART_TIMER;           // while() { while(xbaud--); xbaud=timer }\n\n        UART_XSTATE <= RES||UART_XSTATE==`UART_STATE_ACK  ? `UART_STATE_IDLE :\n                            UART_XSTATE==`UART_STATE_IDLE ? UART_XSTATE+(UART_XREQ!=UART_XACK) :\n                                                            UART_XSTATE+(UART_XBAUD==0);\n`ifdef __UARTQUEUE__\n        UART_XACK   <= RES ? UART_XREQ : UART_XSTATE==`UART_STATE_ACK && UART_XACK!=UART_XREQ  ? UART_XACK+1 : UART_XACK;\n`else                                                           \n        UART_XACK   <= RES||UART_XSTATE==`UART_STATE_ACK  ? UART_XREQ : UART_XACK;\n`endif        \n    end\n\n`ifdef __UARTQUEUE__\n    assign UART_XTMP = UART_XFIFO[UART_XACK[7:0]];\n    \n    assign TXD = UART_XSTATE[3] ? UART_XTMP[UART_XSTATE[2:0]] : UART_XSTATE==`UART_STATE_START ? 0 : 1;\n`else\n    assign TXD = UART_XSTATE[3] ? UART_XFIFO[UART_XSTATE[2:0]] : UART_XSTATE==`UART_STATE_START ? 0 : 1;\n`endif\n\n    // recv path: 6(IDLE), 7(START), 8, 9, 10, 11, 12, 13, 14, 15, 0(STOP), 1(ACK)\n\n    always@(posedge CLK)\n    begin\n        UART_RXDFF <= (UART_RXDFF<<1)|RXD;\n\n        UART_RBAUD <= UART_RSTATE==`UART_STATE_IDLE ? { 1'b0, UART_TIMER[15:1] } :    // rbaud=timer/2\n                      UART_RBAUD ? UART_RBAUD-1 : UART_TIMER;               // while() { while(rbaud--); rbaud=timer }\n\n        UART_RSTATE <= RES||UART_RSTATE==`UART_STATE_ACK  ? `UART_STATE_IDLE :\n                            UART_RSTATE==`UART_STATE_IDLE ? UART_RSTATE+(UART_RXDFF[2:1]==2'b10) : // start bit detection\n                                                            UART_RSTATE+(UART_RBAUD==0);\n                                                            \n`ifdef __UARTQUEUE__\n        if(UART_RSTATE==`UART_STATE_ACK&&(UART_RREQ!=(UART_RACK^9'h100)))\n        begin\n            UART_RREQ <= UART_RREQ+1;\n            UART_RFIFO[UART_RREQ[7:0]] <= UART_RTMP;\n        end\n`else\n        UART_RREQ <= (IOACK==2 || UART_RSTATE==`UART_STATE_ACK) ? !UART_RACK : UART_RREQ;\n`endif\n        if(UART_RSTATE[3]) \n        begin\n`ifdef __UARTQUEUE__  \n            UART_RTMP[UART_RSTATE[2:0]] <= UART_RXDFF[2];\n`else\n            UART_RFIFO[UART_RSTATE[2:0]] <= UART_RXDFF[2];\n`endif\n        end\n`ifdef SIMULATION\n        else\n        if(IOACK==1)\n        begin\n            UART_RFIFO <= $fgetc(32'h8000_0000);\n            IOACK <= 2;\n        end\n        else\n        if(IOACK==2)\n        begin\n            IOACK <= UART_RREQ^UART_RACK ? 3 : 2;\n        end\n        else\n        if(IOACK==3)\n        begin\n            IOACK <= UART_RREQ^UART_RACK ? 3 : (UART_RFIFO==\"\\n\" ? 0 : 1);\n        end\n        else\n        if(IOREQ==2)\n        begin\n            IOACK <= 1;\n        end\n`endif        \n    end\n\n    //debug\n    \n    assign DEBUG = { RXD, TXD, UART_XSTATE!=`UART_STATE_IDLE, UART_RSTATE!=`UART_STATE_IDLE };\n    \nendmodule\n"}
