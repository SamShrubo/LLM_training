{"text": "['`timescale 1ns / 1ps\\n', 'module ADC_interface_AXI (CLK,RST,AWVALID,WVALID,BREADY,AWADDR,WDATA,WSTRB,AWREADY,WREADY,BVALID,DATA,ARADDR,ARVALID,RREADY,ARREADY,RVALID,RDATA,BUSY);\\n', '\\n', '//----general--input----\\n', '\\tinput CLK,RST;\\n', '//----write--input----\\n', '\\tinput AWVALID,WVALID, BREADY;\\n', '\\tinput [31:0] AWADDR,WDATA;\\n', '\\tinput [3:0] WSTRB;\\n', '//----write--output----\\n', '\\toutput reg AWREADY, WREADY, BVALID;\\t\\n', '//----write--signals----\\t\\t\\n', '\\treg [2:0] state_write;\\n', '//----read--input----\\n', '\\tinput [31:0] ARADDR;\\n', '\\tinput ARVALID,RREADY,BUSY;\\n', '\\tinput [9:0] DATA;\\n', '//----read--output----\\n', '\\toutput reg ARREADY, RVALID;\\n', '\\toutput wire [31:0] RDATA;\\n', '//----read--signals----\\n', '\\treg [2:0] state_read;\\n', '\\treg [9:0] latch_DATA;\\n', '\\treg ena_rdata;\\n', '\\n', '//----FSM--WRITE----\\n', '\\n', \"\\tparameter START_W = 3'b000, WAIT_BREADY = 3'b001, START_R = 3'b010, PROCESS = 3'b011;\\t\\t\\n\", '\\n', '//----RESET--PARAMETERS----\\n', '\\n', '\\talways @( posedge CLK or negedge RST)\\n', '\\tbegin\\t\\t\\n', \"\\tif (RST == 1'b0) begin\\n\", '\\t\\tstate_write = START_W;\\n', '\\tend\\n', '//----LOGIC----\\n', '\\telse\\n', '\\t\\tbegin\\n', '\\t\\t\\tcase (state_write)\\n', \"\\t\\t\\tSTART_W :if (AWVALID == 1'b1) \\n\", '\\t\\t\\t\\tbegin\\n', '\\t\\t\\t\\t\\tstate_write = WAIT_BREADY;\\n', '\\t\\t\\t\\tend\\n', '\\t\\t\\telse\\n', '\\t\\t\\t\\tbegin\\n', '\\t\\t\\t\\t\\tstate_write = START_W;\\n', '\\t\\t\\t\\tend\\n', \"\\t\\t\\tWAIT_BREADY : if (BREADY == 1'b1)\\n\", '\\t\\t\\t\\tbegin \\n', '\\t\\t\\t\\t\\tstate_write = START_W;\\n', '\\t\\t\\t\\tend\\n', '\\t\\t\\telse\\n', '\\t\\t\\t\\tbegin\\n', '\\t\\t\\t\\t\\tstate_write = WAIT_BREADY;\\n', '\\t\\t\\t\\tend\\n', '\\t\\t\\tdefault : state_write = START_W;\\n', '\\t\\t\\tendcase\\n', '\\t\\tend\\n', '\\tend\\n', '//----OUTPUTS--FSM--WRITE----\\n', '\\talways @(posedge CLK or negedge RST)\\n', '\\tbegin\\t\\t\\n', \"\\t\\tif (RST == 1'b0)\\n\", '\\t\\tbegin\\n', '\\t\\t\\t\\tAWREADY <= 0;\\n', '\\t\\t\\t\\tWREADY <= 0;\\n', '\\t\\t\\t\\tBVALID <= 0;\\n', '\\t\\tend\\n', '\\t//----LOGIC----\\n', '\\t\\telse\\n', '\\t\\tbegin\\t\\n', '\\t\\t\\tcase (state_write)\\n', '\\t\\t\\t\\tSTART_W :begin //----0\\n', '\\t\\t\\t\\t\\tAWREADY <= 1;\\n', '\\t\\t\\t\\t\\tWREADY <= 0;\\n', '\\t\\t\\t\\t\\tBVALID <= 0;\\n', '\\t\\t\\t\\t\\tend\\n', '\\t\\t\\t\\tWAIT_BREADY  :begin //----1\\n', '\\t\\t\\t\\t\\tAWREADY <= 1;\\n', '\\t\\t\\t\\t\\tWREADY <= 1;\\n', '\\t\\t\\t\\t\\tBVALID <= 1;\\n', '\\t\\t\\t\\t\\tend\\t\\t\\t\\t\\n', '\\t\\t\\tendcase\\n', '\\t\\tend\\n', '\\tend\\n', '\\n', '//----FSM--READ----\\n', '\\n', '\\n', '//----RESET--PARAMETERS----\\n', '\\talways @( posedge CLK or negedge RST)\\n', '\\tbegin\\t\\t\\n', '\\tif (~RST) begin\\n', '\\t\\tstate_read = START_R;\\n', '\\tend\\n', '//----LOGIC----\\n', '\\telse\\n', '\\t\\tbegin\\n', '\\t\\t\\tcase (state_read)\\n', \"\\t\\t\\tSTART_R :if (ARVALID == 1'b1) \\n\", '\\t\\t\\t\\tbegin\\n', '\\t\\t\\t\\t\\tstate_read = PROCESS;\\n', '\\t\\t\\t\\tend\\n', '\\t\\t\\telse\\n', '\\t\\t\\t\\tbegin\\n', '\\t\\t\\t\\t\\tstate_read = START_R;\\n', '\\t\\t\\t\\tend\\n', '\\t\\t\\t\\n', \"\\t\\t\\tPROCESS : if (RREADY == 1'b1)\\n\", '\\t\\t\\t\\tbegin \\n', '\\t\\t\\t\\t\\tstate_read = START_R;\\n', '\\t\\t\\t\\tend\\n', '\\t\\t\\telse\\n', '\\t\\t\\t\\tbegin\\n', '\\t\\t\\t\\t\\tstate_read = PROCESS;\\n', '\\t\\t\\t\\tend\\n', '\\t\\t\\t\\n', '\\t\\t\\tdefault : state_read = START_R;\\n', '\\t\\t\\tendcase\\n', '\\t\\tend\\n', '\\tend\\n', '//----OUTPUTS--FSM--READ----\\n', '\\talways @(posedge CLK)\\n', '\\tbegin\\t\\t\\n', \"\\t\\tif (RST == 1'b0)\\n\", '\\t\\tbegin\\n', '\\t\\t\\tARREADY <= 0;\\n', '\\t\\t\\tRVALID <= 0;\\n', '\\t\\tend\\n', '\\n', '//----LOGIC----\\n', '\\t\\telse\\n', '\\t\\tbegin\\t\\n', '\\t\\t\\t\\tcase (state_read)\\n', '\\t\\t\\t\\tSTART_R :begin\\n', '\\t\\t\\t\\t\\tARREADY <= 0;\\n', '\\t\\t\\t\\t\\tRVALID <= 0;\\n', '\\t\\t\\t\\t\\tena_rdata <= 0;\\n', '\\t\\t\\t\\t\\tend\\n', '\\t\\t\\t\\tPROCESS :begin\\n', '\\t\\t\\t\\t\\tARREADY <= 1;\\n', '\\t\\t\\t\\t\\tRVALID <= 1;\\n', '\\t\\t\\t\\t\\tena_rdata <= 1;\\n', '\\t\\t\\t\\t\\tend\\n', '\\t\\t\\t\\tdefault : begin\\n', '\\t\\t\\t\\t\\tARREADY <= 0;\\n', '\\t\\t\\t\\t\\tRVALID <= 0;\\n', '\\t\\t\\t\\t\\tena_rdata <= 0;\\t\\t\\t\\n', '\\t\\t\\t\\t\\tend\\n', '\\t\\t\\t\\tendcase\\n', '\\t\\tend\\n', '\\tend\\n', '\\n', '//----FLIP--FLOPS--WRITE----\\n', '\\talways @( posedge CLK )\\n', '\\tbegin\\n', '\\t\\tif (~RST) begin\\n', \"\\t\\t\\tlatch_DATA <= 10'b0;\\n\", '\\t\\tend\\n', '\\t\\telse begin\\n', '\\t\\t\\tif (BUSY)\\t\\t\\t\\n', '\\t\\t\\tbegin\\n', '\\t\\t\\tlatch_DATA <= DATA;\\n', '\\t\\t\\tend\\n', '\\t\\t\\telse begin\\n', '\\t\\t\\tlatch_DATA <= latch_DATA;\\n', '\\t\\t\\tend\\n', '\\t\\tend\\t\\t\\n', '\\tend\\n', '\\n', \"assign RDATA = ena_rdata ? latch_DATA:10'b0;\\n\", '\\n', 'endmodule\\n', '\\n', '\\t\\n']"}
{"text": "['`timescale 1ns / 1ps\\n', '\\n', 'module DAC_interface_tb;\\n', 'parameter CLKPERIOD = 10;\\n', '\\n', 'reg CLK = 0, RST;\\n', 'reg AWVALID, WVALID, BREADY;\\n', 'reg [31:0] AWADDR, WDATA;\\n', 'reg [3:0] WSTRB; \\n', 'reg ARVALID, RREADY, BUSY;\\n', 'reg [9:0] DATA;\\n', '\\n', 'wire AWREADY, WREADY, BVALID;\\n', 'wire ARREADY, RVALID;\\n', 'wire [31:0] RDATA; \\n', '\\n', 'ADC_interface_AXI ADC_interface_AXI_inst(\\n', '.RST(RST),\\n', '.CLK(CLK),\\n', '.AWVALID(AWVALID),\\n', '.WVALID(WVALID),\\n', '.BREADY(BREADY),\\n', '.AWADDR(AWADDR), \\n', '.WDATA(WDATA),\\n', '.WSTRB(WSTRB),\\n', '.AWREADY(AWREADY),\\n', '.WREADY(WREADY),\\n', '.BVALID(BVALID),\\n', '.ARVALID(ARVALID), \\n', '.RREADY(RREADY),\\n', '.BUSY(BUSY), \\n', '.DATA(DATA), \\n', '.ARREADY(ARREADY),\\n', '.RVALID(RVALID), \\n', '.RDATA(RDATA));\\n', '\\n', 'always \\n', '\\tbegin\\n', '\\t\\t#(CLKPERIOD/2) CLK = ~CLK;\\n', '\\tend\\n', '\\n', 'initial begin\\n', '\\n', \"RST <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*100);//-------------------------START_R--AND--START_W\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'b0; \\n\", \"WDATA <= 32'b0;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", 'DATA <= \\n', 'BUSY <= \\n', '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'hfffffff1; \\n\", \"WDATA <= 32'h12345678;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bx;\\n\", \"AWVALID <= 1'bx;\\n\", \"WVALID <= 1'bx;\\n\", \"BREADY <= 1'bx;\\n\", \"AWADDR <= 32'bx; \\n\", \"WDATA <= 32'hx;\\n\", \"ARVALID <= 1'bX;\\n\", \"RREADY <= 1'bX;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bz;\\n\", \"AWVALID <= 1'bz;\\n\", \"WVALID <= 1'bz;\\n\", \"BREADY <= 1'bz;\\n\", \"AWADDR <= 32'bz; \\n\", \"WDATA <= 32'hz;\\n\", \"ARVALID <= 1'bZ;\\n\", \"RREADY <= 1'bZ;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b1;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'hfffffff1; \\n\", \"WDATA <= 32'h12345678;\\n\", \"ARVALID <= 1'b1;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*10);//-------------------------WAIT_WVALID--AND--WAIT_RREADY\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'b0; \\n\", \"WDATA <= 32'b0;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'hfffffff1; \\n\", \"WDATA <= 32'h12345678;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bX;\\n\", \"AWVALID <= 1'bX;\\n\", \"WVALID <= 1'bX;\\n\", \"BREADY <= 1'bX;\\n\", \"AWADDR <= 32'bX; \\n\", \"WDATA <= 32'bX;\\n\", \"ARVALID <= 1'bX;\\n\", \"RREADY <= 1'bX;\\n\", '\\n', '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bZ;\\n\", \"AWVALID <= 1'bZ;\\n\", \"WVALID <= 1'bZ;\\n\", \"BREADY <= 1'bZ;\\n\", \"AWADDR <= 32'bZ; \\n\", \"WDATA <= 32'bZ;\\n\", \"ARVALID <= 1'bZ;\\n\", \"RREADY <= 1'bZ;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b1;\\n\", \"BREADY <= 1'b1;\\n\", \"AWADDR <= 32'hfffffff1; \\n\", \"WDATA <= 32'h12345678;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b1;\\n\", '\\n', '#(CLKPERIOD*10);//-------------------------WORKING--AND--START_R\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'b0; \\n\", \"WDATA <= 32'b0;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'hfffffff1; \\n\", \"WDATA <= 32'h12345678;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bX;\\n\", \"AWVALID <= 1'bX;\\n\", \"WVALID <= 1'bX;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'bX; \\n\", \"WDATA <= 32'bX;\\n\", \"ARVALID <= 1'bX;\\n\", \"RREADY <= 1'bX;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bZ;\\n\", \"AWVALID <= 1'bZ;\\n\", \"WVALID <= 1'bZ;\\n\", \"BREADY <= 1'bZ;\\n\", \"AWADDR <= 32'bZ; \\n\", \"WDATA <= 32'bZ;\\n\", \"ARVALID <= 1'bZ;\\n\", \"RREADY <= 1'bZ;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'b0; \\n\", \"WDATA <= 32'b0;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*10);\\n', '\\n', '//----------------------------------reset------------------------\\n', '\\n', \"RST <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*100);//-------------------------START_R--AND--START_W\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'b0; \\n\", \"WDATA <= 32'b0;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'hfffffff2; \\n\", \"WDATA <= 32'h87654321;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bx;\\n\", \"AWVALID <= 1'bx;\\n\", \"WVALID <= 1'bx;\\n\", \"BREADY <= 1'bx;\\n\", \"AWADDR <= 32'bx; \\n\", \"WDATA <= 32'hx;\\n\", \"ARVALID <= 1'bX;\\n\", \"RREADY <= 1'bX;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bz;\\n\", \"AWVALID <= 1'bz;\\n\", \"WVALID <= 1'bz;\\n\", \"BREADY <= 1'bz;\\n\", \"AWADDR <= 32'bz; \\n\", \"WDATA <= 32'hz;\\n\", \"ARVALID <= 1'bZ;\\n\", \"RREADY <= 1'bZ;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b1;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'hfffffff2; \\n\", \"WDATA <= 32'h87654321;\\n\", \"ARVALID <= 1'b1;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*10);//-------------------------WAIT_WVALID--AND--WAIT_RREADY\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'b0; \\n\", \"WDATA <= 32'b0;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'hfffffff2; \\n\", \"WDATA <= 32'h87654321;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bX;\\n\", \"AWVALID <= 1'bX;\\n\", \"WVALID <= 1'bX;\\n\", \"BREADY <= 1'bX;\\n\", \"AWADDR <= 32'bX; \\n\", \"WDATA <= 32'bX;\\n\", \"ARVALID <= 1'bX;\\n\", \"RREADY <= 1'bX;\\n\", '\\n', '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bZ;\\n\", \"AWVALID <= 1'bZ;\\n\", \"WVALID <= 1'bZ;\\n\", \"BREADY <= 1'bZ;\\n\", \"AWADDR <= 32'bZ; \\n\", \"WDATA <= 32'bZ;\\n\", \"ARVALID <= 1'bZ;\\n\", \"RREADY <= 1'bZ;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b1;\\n\", \"BREADY <= 1'b1;\\n\", \"AWADDR <= 32'hfffffff2; \\n\", \"WDATA <= 32'h87654321;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b1;\\n\", '\\n', '#(CLKPERIOD*10);//-------------------------WORKING--AND--START_R\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'b0; \\n\", \"WDATA <= 32'b0;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'hfffffff2; \\n\", \"WDATA <= 32'h87654321;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bX;\\n\", \"AWVALID <= 1'bX;\\n\", \"WVALID <= 1'bX;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'bX; \\n\", \"WDATA <= 32'bX;\\n\", \"ARVALID <= 1'bX;\\n\", \"RREADY <= 1'bX;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bZ;\\n\", \"AWVALID <= 1'bZ;\\n\", \"WVALID <= 1'bZ;\\n\", \"BREADY <= 1'bZ;\\n\", \"AWADDR <= 32'bZ; \\n\", \"WDATA <= 32'bZ;\\n\", \"ARVALID <= 1'bZ;\\n\", \"RREADY <= 1'bZ;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'b0; \\n\", \"WDATA <= 32'b0;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b1;\\n\", '\\n', '#(CLKPERIOD*10)\\n', '\\n', '//-------------------------START_R--AND--START_W\\n', '\\n', '//----------------------------------NO--reset------------------------\\n', '\\n', \"//RST <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*100);//-------------------------START_R--AND--START_W\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'b0; \\n\", \"WDATA <= 32'b0;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'hfffffff3; \\n\", \"WDATA <= 32'h55555555;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bx;\\n\", \"AWVALID <= 1'bx;\\n\", \"WVALID <= 1'bx;\\n\", \"BREADY <= 1'bx;\\n\", \"AWADDR <= 32'bx; \\n\", \"WDATA <= 32'hx;\\n\", \"ARVALID <= 1'bX;\\n\", \"RREADY <= 1'bX;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bz;\\n\", \"AWVALID <= 1'bz;\\n\", \"WVALID <= 1'bz;\\n\", \"BREADY <= 1'bz;\\n\", \"AWADDR <= 32'bz; \\n\", \"WDATA <= 32'hz;\\n\", \"ARVALID <= 1'bZ;\\n\", \"RREADY <= 1'bZ;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b1;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'hfffffff3; \\n\", \"WDATA <= 32'h55555555;\\n\", \"ARVALID <= 1'b1;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*10);//-------------------------WAIT_WVALID--AND--WAIT_RREADY\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'b0; \\n\", \"WDATA <= 32'b0;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'hfffffff3; \\n\", \"WDATA <= 32'h55555555;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bX;\\n\", \"AWVALID <= 1'bX;\\n\", \"WVALID <= 1'bX;\\n\", \"BREADY <= 1'bX;\\n\", \"AWADDR <= 32'bX; \\n\", \"WDATA <= 32'bX;\\n\", \"ARVALID <= 1'bX;\\n\", \"RREADY <= 1'bX;\\n\", '\\n', '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bZ;\\n\", \"AWVALID <= 1'bZ;\\n\", \"WVALID <= 1'bZ;\\n\", \"BREADY <= 1'bZ;\\n\", \"AWADDR <= 32'bZ; \\n\", \"WDATA <= 32'bZ;\\n\", \"ARVALID <= 1'bZ;\\n\", \"RREADY <= 1'bZ;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b1;\\n\", \"BREADY <= 1'b1;\\n\", \"AWADDR <= 32'hfffffff3; \\n\", \"WDATA <= 32'h55555555;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b1;\\n\", '\\n', '#(CLKPERIOD*10);//-------------------------WORKING--AND--START_R\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'b0; \\n\", \"WDATA <= 32'b0;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'hfffffff3; \\n\", \"WDATA <= 32'h55555555;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bX;\\n\", \"AWVALID <= 1'bX;\\n\", \"WVALID <= 1'bX;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'bX; \\n\", \"WDATA <= 32'bX;\\n\", \"ARVALID <= 1'bX;\\n\", \"RREADY <= 1'bX;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bZ;\\n\", \"AWVALID <= 1'bZ;\\n\", \"WVALID <= 1'bZ;\\n\", \"BREADY <= 1'bZ;\\n\", \"AWADDR <= 32'bZ; \\n\", \"WDATA <= 32'bZ;\\n\", \"ARVALID <= 1'bZ;\\n\", \"RREADY <= 1'bZ;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'b0; \\n\", \"WDATA <= 32'b0;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*10)\\n', '\\n', '//-------------------------START--AND--WAIT_RREADY\\n', '\\n', '$finish;\\n', '\\n', 'end\\n', 'endmodule\\n']"}
{"text": "['// Created by: CKDUR\\n', '`timescale 1ns/1ns\\n', '\\n', 'module axi4_interconnect #\\n', '\\t(\\n', '\\tparameter  \\t\\t\\tmasters = 2,\\n', '\\tparameter  \\t\\t\\tslaves = 5,\\n', '\\tparameter  \\t\\t\\tsword = 32,\\n', '\\n', '\\t/*\\n', '\\tIMPLEMENTATION SETTINGS\\n', '\\timpl: 0,Classic  1,Simulation\\n', '\\taddressing: 0,ByTristate  1,ByAGiantMux\\n', '\\t*/\\n', '\\tparameter\\t\\t\\timpl = 0,\\n', '\\tparameter\\t\\t\\taddressing = 0,\\n', '\\t\\n', '\\t/*\\n', '\\tADDRESS MASKING SETTINGS\\n', '\\tYou put here the adress mask for each slave\\n', '\\tPLEASE dont letme on zeros or i wont work.\\n', '\\n', '\\tFor each address mask you need to do the address use\\n', '\\t0x00FF <-- This is an address mask\\n', '\\t0x0100 <-- This is an address use\\n', '\\tIf the master access the address 0x01XX, refer to this\\n', \"\\tslave, otherwise won't be like this\\n\", '\\tWARNING Please ensure that all mask-use pairs for all\\n', '\\tslaves are excluyent, because if you use tri-state \\n', '\\taddressing, there will have problems.\\n', '\\t*/\\n', \"\\tparameter [slaves*sword-1:0] addr_mask = {32'h00000000,32'h0000000F,32'h00000001,32'h00000001,32'h000003FF},\\n\", \"\\tparameter [slaves*sword-1:0] addr_use  = {32'h04000000,32'h00000410,32'h00000408,32'h00000400,32'h00000000}\\n\", '\\t)\\n', '\\n', '\\t(\\n', '\\tinput\\t\\t\\t\\t\\t\\t\\tCLK,\\n', '\\tinput\\t\\t\\t\\t\\t\\t\\tRST,\\n', '\\t\\n', '\\t// AXI4-lite master memory interfaces\\n', '\\n', '\\tinput  [masters-1:0]       m_axi_awvalid,\\n', '\\toutput [masters-1:0]       m_axi_awready,\\n', '\\tinput  [masters*sword-1:0] m_axi_awaddr,\\n', '\\tinput  [masters*3-1:0]     m_axi_awprot,\\n', '\\n', '\\tinput  [masters-1:0]       m_axi_wvalid,\\n', '\\toutput [masters-1:0]       m_axi_wready,\\n', '\\tinput  [masters*sword-1:0] m_axi_wdata,\\n', '\\tinput  [masters*4-1:0]     m_axi_wstrb,\\n', '\\n', '\\toutput [masters-1:0]       m_axi_bvalid,\\n', '\\tinput  [masters-1:0]       m_axi_bready,\\n', '\\n', '\\tinput  [masters-1:0]       m_axi_arvalid,\\n', '\\toutput [masters-1:0]       m_axi_arready,\\n', '\\tinput  [masters*sword-1:0] m_axi_araddr,\\n', '\\tinput  [masters*3-1:0]     m_axi_arprot,\\n', '\\n', '\\toutput [masters-1:0]       m_axi_rvalid,\\n', '\\tinput  [masters-1:0]       m_axi_rready,\\n', '\\toutput [masters*sword-1:0] m_axi_rdata,\\n', '\\t\\n', '\\t// AXI4-lite slave memory interfaces\\n', '\\n', '\\toutput [slaves-1:0]       s_axi_awvalid,\\n', '\\tinput  [slaves-1:0]       s_axi_awready,\\n', '\\toutput [slaves*sword-1:0] s_axi_awaddr,\\n', '\\toutput [slaves*3-1:0]     s_axi_awprot,\\n', '\\n', '\\toutput [slaves-1:0]       s_axi_wvalid,\\n', '\\tinput  [slaves-1:0]       s_axi_wready,\\n', '\\toutput [slaves*sword-1:0] s_axi_wdata,\\n', '\\toutput [slaves*4-1:0]     s_axi_wstrb,\\n', '\\n', '\\tinput  [slaves-1:0]       s_axi_bvalid,\\n', '\\toutput [slaves-1:0]       s_axi_bready,\\n', '\\n', '\\toutput [slaves-1:0]       s_axi_arvalid,\\n', '\\tinput  [slaves-1:0]       s_axi_arready,\\n', '\\toutput [slaves*sword-1:0] s_axi_araddr,\\n', '\\toutput [slaves*3-1:0]     s_axi_arprot,\\n', '\\n', '\\tinput  [slaves-1:0]       s_axi_rvalid,\\n', '\\toutput [slaves-1:0]       s_axi_rready,\\n', '\\tinput  [slaves*sword-1:0] s_axi_rdata\\n', '    );\\n', '\\t\\n', '\\t// HELPERS ***********************************************\\n', '\\tfunction integer clogb2;\\n', '\\t\\tinput integer value;\\n', '\\t\\tinteger \\ti;\\n', '\\t\\tbegin\\n', '\\t\\t\\tclogb2 = 0;\\n', '\\t\\t\\tfor(i = 0; 2**i < value; i = i + 1)\\n', '\\t\\t\\tclogb2 = i + 1;\\n', '\\t\\tend\\n', '\\tendfunction\\n', '\\t\\n', '\\tgenvar i;\\n', '\\tgenvar unpk_idx; \\n', '\\t// ********************************************************\\n', '\\tlocalparam numbit_masters = clogb2(masters);\\n', '\\tlocalparam numbit_slaves = clogb2(slaves);\\n', '\\t\\n', '\\t// Masters read requests\\n', '\\twire [masters-1:0]\\t\\trrequests;\\n', '\\tassign rrequests = m_axi_arvalid;\\t// In readings, is the address valid\\n', '\\twire [masters-1:0]\\t\\twrequests;\\n', '\\tassign wrequests = m_axi_awvalid|m_axi_wvalid;\\t// In writtings, is the address valid or the write valid (AXI4-spec)\\n', '\\t\\n', '\\t// The master director. This chooses who is going to do the request\\n', '\\treg [numbit_masters-1:0] counter_rrequests;\\n', '\\treg [numbit_masters-1:0] counter_wrequests;\\n', '\\t// This comes from fsms for stopping the counters if there is a pendant request\\n', '\\twire en_rrequests;\\t// TODO: NOT ASSIGNED ALREADY\\n', '\\twire en_wrequests;\\t// TODO: NOT ASSIGNED ALREADY\\n', '\\talways @ (posedge CLK)\\n', '\\tbegin\\n', \"\\t\\tif (RST == 1'b0)\\n\", '\\t\\tbegin\\n', \"\\t\\t\\tcounter_rrequests <= {numbit_masters{1'b0}};\\t\\t// RESET \\n\", '\\t\\tend else \\n', '\\t\\tbegin\\n', \"\\t\\t\\tif (en_rrequests == 1'b0)\\n\", '\\t\\t\\tbegin\\n', '\\t\\t\\t\\tcounter_rrequests <= counter_rrequests;\\t// NOTHING \\n', '\\t\\t\\tend else\\n', '\\t\\t\\tbegin\\n', '\\t\\t\\t\\tif(counter_rrequests < masters)\\n', '\\t\\t\\t\\t\\tcounter_rrequests <= counter_rrequests+1;\\t\\t\\t\\t\\t\\t// SHIFTING\\n', '\\t\\t\\t\\telse\\n', '\\t\\t\\t\\t\\tcounter_rrequests <= 0;\\n', '\\t\\t\\tend\\n', '\\t\\tend\\n', '\\tend\\n', '\\t\\n', '\\talways @ (posedge CLK)\\n', '\\tbegin\\n', \"\\t\\tif (RST == 1'b0)\\n\", '\\t\\tbegin\\n', \"\\t\\t\\tcounter_wrequests <= {numbit_masters{1'b0}};\\t\\t// RESET \\n\", '\\t\\tend else \\n', '\\t\\tbegin\\n', \"\\t\\t\\tif (en_wrequests == 1'b0)\\n\", '\\t\\t\\tbegin\\n', '\\t\\t\\t\\tcounter_wrequests <= counter_wrequests;\\t// NOTHING \\n', '\\t\\t\\tend else\\n', '\\t\\t\\tbegin\\n', '\\t\\t\\t\\tif(counter_wrequests < masters)\\n', '\\t\\t\\t\\t\\tcounter_wrequests <= counter_wrequests+1;\\t\\t\\t\\t\\t\\t// SHIFTING\\n', '\\t\\t\\t\\telse\\n', '\\t\\t\\t\\t\\tcounter_wrequests <= 0;\\t\\t\\t\\t\\t// SHIFTING\\n', '\\t\\t\\tend\\n', '\\t\\tend\\n', '\\tend\\n', '\\t\\n', '\\twire [masters-1:0] dec_wrequests;\\n', '\\tassign dec_wrequests = 1 << counter_wrequests;\\n', '\\twire [masters-1:0] dec_rrequests;\\n', '\\tassign dec_rrequests = 1 << counter_rrequests;\\n', '\\t\\n', '\\t// INTENTION: Send to fsms that there is a request\\n', '\\twire is_rrequests;\\t// TODO: NOT USED ALREADY\\n', '\\tassign is_rrequests = |(dec_rrequests&rrequests);\\n', '\\twire is_wrequests;\\t// TODO: NOT USED ALREADY\\n', '\\tassign is_wrequests = |(dec_wrequests&wrequests);\\n', '\\t\\n', '\\t// INTENTION: Recv from fsms that the request is complete\\n', '\\t/*wire erase_cur_rrequest;\\t// TODO: NOT ASSIGNED ALREADY\\n', '\\twire erase_cur_wrequest;\\t// TODO: NOT ASSIGNED ALREADY\\n', '\\twire [masters-1] erase_rrequest;\\n', '\\tassign erase_rrequest = counter_rrequests & {masters{erase_cur_rrequest}};\\n', '\\twire [masters-1] erase_wrequest;\\n', '\\tassign erase_rrequest = counter_rrequests & {masters{erase_cur_rrequest}};*/\\n', '\\t\\n', '\\t\\n', '\\t// The global addr\\n', '\\twire [sword-1:0] awaddr;\\n', '\\twire [sword-1:0] araddr;\\n', '\\treg [sword-1:0] m_axi_awaddr_g [0:masters-1];\\n', '\\treg [sword-1:0] m_axi_araddr_g [0:masters-1];\\n', '\\t// Phase 1 - Convert to latched array\\n', '\\tgenerate \\n', '\\t\\tfor (unpk_idx=0; unpk_idx<(masters); unpk_idx=unpk_idx+1) begin \\n', '\\t\\t\\talways @(m_axi_awvalid[unpk_idx] or RST or m_axi_awaddr[((sword)*unpk_idx+(sword-1)):((sword)*unpk_idx)]) begin\\n', \"\\t\\t\\t\\tif(RST == 1'b0) begin\\n\", \"\\t\\t\\t\\t\\tm_axi_awaddr_g[unpk_idx] = {sword{1'b0}};\\n\", \"\\t\\t\\t\\tend else if (m_axi_awvalid[unpk_idx] == 1'b1) begin\\n\", '\\t\\t\\t\\t\\tm_axi_awaddr_g[unpk_idx] = m_axi_awaddr[((sword)*unpk_idx+(sword-1)):((sword)*unpk_idx)];\\n', '\\t\\t\\t\\tend\\n', '\\t\\t\\tend\\n', '\\t\\t\\talways @(m_axi_arvalid[unpk_idx] or RST or m_axi_araddr[((sword)*unpk_idx+(sword-1)):((sword)*unpk_idx)]) begin\\n', \"\\t\\t\\t\\tif(RST == 1'b0) begin\\n\", \"\\t\\t\\t\\t\\tm_axi_araddr_g[unpk_idx] = {sword{1'b0}};\\n\", \"\\t\\t\\t\\tend else if (m_axi_arvalid[unpk_idx] == 1'b1) begin\\n\", '\\t\\t\\t\\t\\tm_axi_araddr_g[unpk_idx] = m_axi_araddr[((sword)*unpk_idx+(sword-1)):((sword)*unpk_idx)];\\n', '\\t\\t\\t\\tend\\n', '\\t\\t\\tend\\n', '\\t\\tend \\n', '\\tendgenerate\\n', '\\t// Phase 2 - Do the addressing\\n', '\\tgenerate\\n', '\\t\\tif(addressing) begin\\n', '\\t\\t\\t// Giant MUX\\n', '\\t\\t\\tassign awaddr = m_axi_awaddr_g[counter_rrequests];\\n', '\\t\\t\\tassign araddr = m_axi_araddr_g[counter_rrequests];\\n', '\\t\\tend else begin\\n', '\\t\\t\\t// tri-state buff bus\\n', '\\t\\t\\twire [masters*sword-1:0] trib_wd;\\n', '\\t\\t\\twire [masters*sword-1:0] trib_rd;\\n', '\\t\\t\\tfor (i = 0; i < masters; i = i + 1) begin \\n', \"\\t\\t\\t\\tassign trib_wd[(i+1)*sword - 1:i*sword] = dec_wrequests[i]?m_axi_awaddr_g[i]:{sword{1'bz}};\\n\", '\\t\\t\\t\\tassign awaddr = trib_wd[(i+1)*sword - 1:i*sword];\\n', \"\\t\\t\\t\\tassign trib_rd[(i+1)*sword - 1:i*sword] = dec_rrequests[i]?m_axi_araddr_g[i]:{sword{1'bz}};\\n\", '\\t\\t\\t\\tassign araddr = trib_rd[(i+1)*sword - 1:i*sword];\\n', '\\t\\t\\tend\\n', '\\t\\tend\\n', '\\tendgenerate\\n', '\\t\\n', '\\t// Addr mask-use packing (Easier for us, no repercution into gates)\\n', '\\twire [sword-1:0] addr_mask_o [0:slaves-1];\\n', '\\twire [sword-1:0] addr_ruse_o [0:slaves-1];\\n', '\\twire [sword-1:0] addr_wuse_o [0:slaves-1];\\n', '\\tgenerate \\n', '\\t\\tfor (unpk_idx=0; unpk_idx<(slaves); unpk_idx=unpk_idx+1) begin \\n', '\\t\\t\\tassign addr_mask_o[unpk_idx][((sword)-1):0] = addr_mask[((sword)*unpk_idx+(sword-1)):((sword)*unpk_idx)]; \\n', '\\t\\t\\tassign addr_ruse_o[unpk_idx][((sword)-1):0] = addr_use[((sword)*unpk_idx+(sword-1)):((sword)*unpk_idx)] ^\\n', '\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  (araddr & ~addr_mask_o[unpk_idx]);  \\n', '\\t\\t\\tassign addr_wuse_o[unpk_idx][((sword)-1):0] = addr_use[((sword)*unpk_idx+(sword-1)):((sword)*unpk_idx)] ^\\n', '\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  (awaddr & ~addr_mask_o[unpk_idx]); \\n', '\\t\\tend \\n', '\\tendgenerate\\n', '\\t\\n', '\\t// Addr decoder (yeah... this is the longest gate-path \\n', '\\t// because there is a and logic, an encoder an a decoder, f*ck me)\\n', '\\twire slave_rvalid, slave_wvalid;\\n', '\\twire [slaves-1:0] slave_rdec1, slave_wdec1;\\n', '\\t// First-generate decoder via addr_mask-use rainbow\\n', '\\tgenerate \\n', '\\t\\tfor (i=0; i<(slaves); i=i+1) begin \\n', '\\t\\t\\tassign slave_rdec1[i] = ~(|(addr_ruse_o[i])); \\n', '\\t\\t\\tassign slave_wdec1[i] = ~(|(addr_wuse_o[i]));\\n', '\\t\\tend \\n', '\\tendgenerate\\n', '\\twire [numbit_slaves-1:0] slave_raddr, slave_waddr;\\n', '\\t// Pri-encoder for address\\n', '\\tgenerate\\n', '\\t\\tif(addressing) begin\\n', '\\t\\t\\t// Giant Encoder\\n', '\\t\\t\\tpriencr #(.width(slaves)) priencr_raddrencr(.decode(slave_rdec1),.encode(slave_raddr),.valid(slave_rvalid));\\n', '\\t\\t\\tpriencr #(.width(slaves)) priencr_waddrencr(.decode(slave_wdec1),.encode(slave_waddr),.valid(slave_wvalid));\\n', '\\t\\tend else begin\\t// TODO: This maybe is not necesary\\n', \"\\t\\t\\tassign slave_raddr = {numbit_slaves{1'b0}};\\n\", \"\\t\\t\\tassign slave_waddr = {numbit_slaves{1'b0}};\\n\", '\\t\\tend\\n', '\\tendgenerate\\n', '\\t\\n', '\\t// Master-slave end requests\\n', '\\t// The condition for reading is that slave tiggers arvalid and master triggers arready\\n', '\\t// The condition for writting is that slave tiggers bvalid and master triggers bready\\n', '\\twire slave_arvalid, slave_bvalid;\\n', '\\tgenerate\\n', '\\t\\tif(addressing) begin\\n', '\\t\\t\\t// Giant MUX \\n', '\\t\\t\\tassign slave_rvalid = s_axi_rvalid[slave_raddr];\\n', '\\t\\t\\tassign slave_bvalid = s_axi_bvalid[slave_waddr];\\n', '\\t\\tend else begin\\n', '\\t\\t\\t// tri-state buff bus\\n', '\\t\\t\\twire [slaves-1:0] trib_rvalid;\\n', '\\t\\t\\twire [slaves-1:0] trib_bvalid;\\n', '\\t\\t\\tfor (i = 0; i < slaves; i = i + 1) begin \\n', \"\\t\\t\\t\\tassign trib_rvalid[i] = slave_rdec1[i]?s_axi_rvalid[i]:1'bz;\\n\", '\\t\\t\\t\\tassign slave_rvalid = trib_rvalid[i];\\n', \"\\t\\t\\t\\tassign trib_bvalid[i] = slave_wdec1[i]?s_axi_bvalid[i]:1'bz;\\n\", '\\t\\t\\t\\tassign slave_bvalid = trib_bvalid[i];\\n', '\\t\\t\\tend\\n', '\\t\\tend\\n', '\\tendgenerate\\n', '\\twire master_rready, master_bready;\\n', '\\tgenerate\\n', '\\t\\tif(addressing) begin\\n', '\\t\\t\\t// Giant MUX\\n', '\\t\\t\\tassign master_rready = m_axi_rready[counter_rrequests];\\n', '\\t\\t\\tassign master_bready = m_axi_bready[counter_wrequests];\\n', '\\t\\tend else begin\\n', '\\t\\t\\t// tri-state buff bus\\n', '\\t\\t\\twire [masters-1:0] trib_rready;\\n', '\\t\\t\\twire [masters-1:0] trib_bready;\\n', '\\t\\t\\tfor (i = 0; i < masters; i = i + 1) begin \\n', \"\\t\\t\\t\\tassign trib_rready[i] = dec_rrequests[i]?m_axi_rready[i]:1'bz;\\n\", '\\t\\t\\t\\tassign master_rready = trib_rready[i];\\n', \"\\t\\t\\t\\tassign trib_bready[i] = dec_wrequests[i]?m_axi_bready[i]:1'bz;\\n\", '\\t\\t\\t\\tassign master_bready = trib_bready[i];\\n', '\\t\\t\\tend\\n', '\\t\\tend\\n', '\\tendgenerate\\n', '\\twire fi_rrequests, fi_wrequests;\\n', '\\tassign fi_rrequests = master_rready & slave_rvalid;\\n', '\\tassign fi_wrequests = master_bready & slave_bvalid;\\n', '\\t\\n', '\\t// Little state machine\\n', '\\treg rtrans, wtrans;\\n', '\\talways @ (posedge CLK)\\n', '\\tbegin\\n', \"\\t\\tif (RST == 1'b0)\\n\", '\\t\\tbegin\\n', \"\\t\\t\\trtrans <= 1'b0;\\t\\t// RESET \\n\", '\\t\\tend else \\n', '\\t\\tbegin\\n', \"\\t\\t\\tif (rtrans == 1'b0) begin\\n\", \"\\t\\t\\t\\tif(is_rrequests == 1'b1)\\n\", '\\t\\t\\t\\tbegin\\n', \"\\t\\t\\t\\t\\trtrans <= 1'b1;\\t// BEGIN TRANSMISSION, GOTO TRANSMITTING\\n\", '\\t\\t\\t\\tend \\n', '\\t\\t\\tend else begin\\n', \"\\t\\t\\t\\tif(fi_rrequests == 1'b1)\\n\", '\\t\\t\\t\\tbegin\\n', \"\\t\\t\\t\\t\\trtrans <= 1'b0;\\t// FINISHED TRANSMITTING, GOTO INIT\\n\", '\\t\\t\\t\\tend \\n', '\\t\\t\\tend\\n', '\\t\\tend\\n', '\\tend\\n', '\\talways @ (posedge CLK)\\n', '\\tbegin\\n', \"\\t\\tif (RST == 1'b0)\\n\", '\\t\\tbegin\\n', \"\\t\\t\\twtrans <= 1'b0;\\t\\t// RESET \\n\", '\\t\\tend else \\n', '\\t\\tbegin\\n', \"\\t\\t\\tif (wtrans == 1'b0) begin\\n\", \"\\t\\t\\t\\tif(is_wrequests == 1'b1)\\n\", '\\t\\t\\t\\tbegin\\n', \"\\t\\t\\t\\t\\twtrans <= 1'b1;\\t// BEGIN TRANSMISSION, GOTO TRANSMITTING\\n\", '\\t\\t\\t\\tend \\n', '\\t\\t\\tend else begin\\n', \"\\t\\t\\t\\tif(fi_wrequests == 1'b1)\\n\", '\\t\\t\\t\\tbegin\\n', \"\\t\\t\\t\\t\\twtrans <= 1'b0;\\t// FINISHED TRANSMITTING, GOTO INIT\\n\", '\\t\\t\\t\\tend \\n', '\\t\\t\\tend\\n', '\\t\\tend\\n', '\\tend\\n', '\\tassign en_rrequests = ~rtrans & ~is_rrequests;\\n', '\\tassign en_wrequests = ~wtrans & ~is_wrequests;\\n', '\\n', '\\t// Send the channel \\n', '\\t// For writting\\n', '\\t// Master-slave dir\\n', '\\tlocalparam numbit_bus_wms = 1+sword+3+1+sword+4+1;\\n', '\\twire [numbit_bus_wms-1:0] axi_wms;\\n', '\\twire [numbit_bus_wms-1:0] axi_wms_o [0:masters-1];\\n', '\\tgenerate // PACK FIRST\\n', '\\t\\tfor (unpk_idx=0; unpk_idx<(masters); unpk_idx=unpk_idx+1) begin \\n', '\\t\\t\\tassign axi_wms_o[unpk_idx] = {m_axi_awvalid[unpk_idx], \\n', '\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  m_axi_awaddr[(unpk_idx+1)*sword-1:unpk_idx*sword], \\n', '\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  m_axi_awprot[(unpk_idx+1)*3-1:unpk_idx*3], \\n', '\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  m_axi_wvalid[unpk_idx], \\n', '\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  m_axi_wdata[(unpk_idx+1)*sword-1:unpk_idx*sword], \\n', '\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  m_axi_wstrb[(unpk_idx+1)*4-1:unpk_idx*4], \\n', '\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  m_axi_bready[unpk_idx]};\\n', '\\t\\tend \\n', '\\tendgenerate\\n', '\\tgenerate // DO ADDRESSING\\n', '\\t\\tif(addressing) begin\\n', '\\t\\t\\t// Giant MUX\\n', '\\t\\t\\tassign axi_wms = axi_wms_o[counter_wrequests];\\n', '\\t\\tend else begin\\n', '\\t\\t\\t// tri-state buff bus\\n', '\\t\\t\\twire [numbit_bus_wms-1:0] trib_axi_wms [0:masters-1];\\n', '\\t\\t\\tfor (i = 0; i < masters; i = i + 1) begin \\n', \"\\t\\t\\t\\tassign trib_axi_wms[i] = dec_wrequests[i]?axi_wms_o[i]:{numbit_bus_wms{1'bz}};\\n\", '\\t\\t\\t\\tassign axi_wms = trib_axi_wms[i];\\n', '\\t\\t\\tend\\n', '\\t\\tend\\n', '\\tendgenerate\\n', '\\tgenerate // UNPACK AND SEND TO SLAVES\\n', '\\t\\tfor (unpk_idx=0; unpk_idx<(slaves); unpk_idx=unpk_idx+1) begin \\n', '\\t\\t\\tassign {s_axi_awvalid[unpk_idx], \\n', '\\t\\t\\t\\t    s_axi_awaddr[(unpk_idx+1)*sword-1:unpk_idx*sword], \\n', '\\t\\t\\t\\t    s_axi_awprot[(unpk_idx+1)*3-1:unpk_idx*3], \\n', '\\t\\t\\t\\t    s_axi_wvalid[unpk_idx], \\n', '\\t\\t\\t\\t    s_axi_wdata[(unpk_idx+1)*sword-1:unpk_idx*sword], \\n', '\\t\\t\\t\\t    s_axi_wstrb[(unpk_idx+1)*4-1:unpk_idx*4], \\n', '\\t\\t\\t\\t    s_axi_bready[unpk_idx]} = axi_wms & {numbit_bus_wms{slave_wdec1[unpk_idx] & wtrans}};\\n', '\\t\\t\\t\\t    // TODO: This assignment is LAZY. This will waste ANDs\\n', '\\t\\t\\t\\t    // but, as for we need this urgent... well.. this\\n', '\\t\\t\\t\\t    // We only need \"and\" the control messages\\n', '\\t\\tend \\n', '\\tendgenerate\\n', '\\t// Slave-master dir\\n', '\\tlocalparam numbit_bus_wsm = 1+1+1;\\n', '\\twire [numbit_bus_wsm-1:0] axi_wsm;\\n', '\\twire [numbit_bus_wsm-1:0] axi_wsm_o [0:slaves-1];\\n', '\\tgenerate // PACK FIRST\\n', '\\t\\tfor (unpk_idx=0; unpk_idx<(slaves); unpk_idx=unpk_idx+1) begin \\n', '\\t\\t\\tassign axi_wsm_o[unpk_idx] = {s_axi_awready[unpk_idx], \\n', '\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  s_axi_wready[unpk_idx], \\n', '\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  s_axi_bvalid[unpk_idx]};\\n', '\\t\\tend \\n', '\\tendgenerate\\n', '\\tgenerate // DO ADDRESSING\\n', '\\t\\tif(addressing) begin\\n', '\\t\\t\\t// Giant MUX\\n', '\\t\\t\\tassign axi_wsm = axi_wsm_o[slave_waddr];\\n', '\\t\\tend else begin\\n', '\\t\\t\\t// tri-state buff bus\\n', '\\t\\t\\twire [numbit_bus_wsm-1:0] trib_axi_wsm [0:slaves-1];\\n', '\\t\\t\\tfor (i = 0; i < slaves; i = i + 1) begin \\n', \"\\t\\t\\t\\tassign trib_axi_wsm[i] = slave_wdec1[i]?axi_wsm_o[i]:{numbit_bus_wsm{1'bz}};\\n\", '\\t\\t\\t\\tassign axi_wsm = trib_axi_wsm[i];\\n', '\\t\\t\\tend\\n', '\\t\\tend\\n', '\\tendgenerate\\n', '\\tgenerate // UNPACK AND SEND TO MASTERS\\n', '\\t\\tfor (unpk_idx=0; unpk_idx<(masters); unpk_idx=unpk_idx+1) begin \\n', '\\t\\t\\tassign {m_axi_awready[unpk_idx],  \\n', '\\t\\t\\t\\t    m_axi_wready[unpk_idx], \\n', '\\t\\t\\t\\t    m_axi_bvalid[unpk_idx]} = axi_wsm & {numbit_bus_wsm{dec_wrequests[unpk_idx] & wtrans}};\\n', '\\t\\t\\t\\t    // TODO: This assignment is LAZY. This will waste ANDs\\n', '\\t\\t\\t\\t    // but, as for we need this urgent... well.. this\\n', '\\t\\t\\t\\t    // We only need \"and\" the control messages\\n', '\\t\\tend \\n', '\\tendgenerate\\n', '\\t// For reading\\n', '\\t// Master-Slave dir\\n', '\\tlocalparam numbit_bus_rms = 1+sword+3+1;\\n', '\\twire [numbit_bus_rms-1:0] axi_rms;\\n', '\\twire [numbit_bus_rms-1:0] axi_rms_o [0:masters-1];\\n', '\\tgenerate // PACK FIRST\\n', '\\t\\tfor (unpk_idx=0; unpk_idx<(masters); unpk_idx=unpk_idx+1) begin \\n', '\\t\\t\\tassign axi_rms_o[unpk_idx] = {m_axi_arvalid[unpk_idx], \\n', '\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  m_axi_araddr[(unpk_idx+1)*sword-1:unpk_idx*sword], \\n', '\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  m_axi_arprot[(unpk_idx+1)*3-1:unpk_idx*3], \\n', '\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  m_axi_rready[unpk_idx]};\\n', '\\t\\tend \\n', '\\tendgenerate\\n', '\\tgenerate // DO ADDRESSING\\n', '\\t\\tif(addressing) begin\\n', '\\t\\t\\t// Giant MUX\\n', '\\t\\t\\tassign axi_rms = axi_rms_o[counter_rrequests];\\n', '\\t\\tend else begin\\n', '\\t\\t\\t// tri-state buff bus\\n', '\\t\\t\\twire [numbit_bus_rms-1:0] trib_axi_rms [0:masters-1];\\n', '\\t\\t\\tfor (i = 0; i < masters; i = i + 1) begin \\n', \"\\t\\t\\t\\tassign trib_axi_rms[i] = dec_rrequests[i]?axi_rms_o[i]:{numbit_bus_rms{1'bz}};\\n\", '\\t\\t\\t\\tassign axi_rms = trib_axi_rms[i];\\n', '\\t\\t\\tend\\n', '\\t\\tend\\n', '\\tendgenerate\\n', '\\tgenerate // UNPACK AND SEND TO SLAVES\\n', '\\t\\tfor (unpk_idx=0; unpk_idx<(slaves); unpk_idx=unpk_idx+1) begin \\n', '\\t\\t\\tassign {s_axi_arvalid[unpk_idx], \\n', '\\t\\t\\t\\t    s_axi_araddr[(unpk_idx+1)*sword-1:unpk_idx*sword], \\n', '\\t\\t\\t\\t    s_axi_arprot[(unpk_idx+1)*3-1:unpk_idx*3], \\n', '\\t\\t\\t\\t    s_axi_rready[unpk_idx]} = axi_rms & {numbit_bus_rms{slave_rdec1[unpk_idx] & rtrans}};\\n', '\\t\\t\\t\\t    // TODO: This assignment is LAZY. This will waste ANDs\\n', '\\t\\t\\t\\t    // but, as for we need this urgent... well.. this\\n', '\\t\\t\\t\\t    // We only need \"and\" the control messages\\n', '\\t\\tend \\n', '\\tendgenerate\\n', '\\t// Slave-master dir\\n', '\\tlocalparam numbit_bus_rsm = 1+sword+1;\\n', '\\twire [numbit_bus_rsm-1:0] axi_rsm;\\n', '\\twire [numbit_bus_rsm-1:0] axi_rsm_o [0:slaves-1];\\n', '\\tgenerate // PACK FIRST\\n', '\\t\\tfor (unpk_idx=0; unpk_idx<(slaves); unpk_idx=unpk_idx+1) begin \\n', '\\n', '\\t\\t\\tassign axi_rsm_o[unpk_idx] = {s_axi_arready[unpk_idx], \\n', '\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  s_axi_rdata[(unpk_idx+1)*sword-1:unpk_idx*sword], \\n', '\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  s_axi_rvalid[unpk_idx]};\\n', '\\t\\tend \\n', '\\tendgenerate\\n', '\\tgenerate // DO ADDRESSING\\n', '\\t\\tif(addressing) begin\\n', '\\t\\t\\t// Giant MUX\\n', '\\t\\t\\tassign axi_rsm = axi_rsm_o[slave_raddr];\\n', '\\t\\tend else begin\\n', '\\t\\t\\t// tri-state buff bus\\n', '\\t\\t\\twire [numbit_bus_rsm-1:0] trib_axi_rsm [0:slaves-1];\\n', '\\t\\t\\tfor (i = 0; i < slaves; i = i + 1) begin \\n', \"\\t\\t\\t\\tassign trib_axi_rsm[i] = slave_rdec1[i]?axi_rsm_o[i]:{numbit_bus_rsm{1'bz}};\\n\", '\\t\\t\\t\\tassign axi_rsm = trib_axi_rsm[i];\\n', '\\t\\t\\tend\\n', '\\t\\tend\\n', '\\tendgenerate\\n', '\\tgenerate // UNPACK AND SEND TO MASTERS\\n', '\\t\\tfor (unpk_idx=0; unpk_idx<(masters); unpk_idx=unpk_idx+1) begin \\n', '\\t\\t\\tassign {m_axi_arready[unpk_idx],  \\n', '\\t\\t\\t\\t    m_axi_rdata[(unpk_idx+1)*sword-1:unpk_idx*sword], \\n', '\\t\\t\\t\\t    m_axi_rvalid[unpk_idx]} = axi_rsm & {numbit_bus_rsm{dec_rrequests[unpk_idx] & rtrans}};\\n', '\\t\\t\\t\\t    // TODO: This assignment is LAZY. This will waste ANDs\\n', '\\t\\t\\t\\t    // but, as for we need this urgent... well.. this\\n', '\\t\\t\\t\\t    // We only need \"and\" the control messages\\n', '\\t\\tend \\n', '\\tendgenerate\\n', '\\n', 'endmodule\\n']"}
{"text": "['`timescale 1ns/1ns\\n', '\\n', 'module axi4_interconnect_tb();\\n', '\\n', '// HELPER\\n', '\\tfunction integer clogb2;\\n', '\\t\\tinput integer value;\\n', '\\t\\tinteger \\ti;\\n', '\\t\\tbegin\\n', '\\t\\t\\tclogb2 = 0;\\n', '\\t\\t\\tfor(i = 0; 2**i < value; i = i + 1)\\n', '\\t\\t\\tclogb2 = i + 1;\\n', '\\t\\tend\\n', '\\tendfunction\\n', '\\t\\n', 'localparam  \\t\\t\\tmasters = 2;\\n', 'localparam  \\t\\t\\tslaves = 5;\\n', 'localparam  \\t\\t\\tsword = 32;\\n', '\\n', 'localparam\\t\\t\\timpl = 0;\\n', 'localparam\\t\\t\\taddressing = 0;\\n', '\\n', '// MEMORY MAP SPEC\\n', \"localparam [slaves*sword-1:0] addr_mask = {32'h00000000,32'h0000000F,32'h00000001,32'h00000001,32'h000003FF};\\n\", \"localparam [slaves*sword-1:0] addr_use  = {32'h04000000,32'h00000410,32'h00000408,32'h00000400,32'h00000000};\\n\", '\\n', '// Autogen localparams\\n', '\\n', \"reg \\tCLK = 1'b0;\\n\", 'reg\\t \\tRST;\\n', '\\n', '// AXI4-lite master memory interfaces\\n', '\\n', 'reg  [masters-1:0]       m_axi_awvalid;\\n', 'wire [masters-1:0]       m_axi_awready;\\n', 'wire [masters*sword-1:0] m_axi_awaddr;\\n', 'wire [masters*3-1:0]     m_axi_awprot;\\n', '\\n', 'reg  [masters-1:0]       m_axi_wvalid;\\n', 'wire [masters-1:0]       m_axi_wready;\\n', 'wire [masters*sword-1:0] m_axi_wdata;\\n', 'wire [masters*4-1:0]     m_axi_wstrb;\\n', '\\n', 'wire [masters-1:0]       m_axi_bvalid;\\n', 'reg  [masters-1:0]       m_axi_bready;\\n', '\\n', 'reg  [masters-1:0]       m_axi_arvalid;\\n', 'wire [masters-1:0]       m_axi_arready;\\n', 'wire [masters*sword-1:0] m_axi_araddr;\\n', 'wire [masters*3-1:0]     m_axi_arprot;\\n', '\\n', 'wire [masters-1:0]       m_axi_rvalid;\\n', 'reg  [masters-1:0]       m_axi_rready;\\n', 'wire [masters*sword-1:0] m_axi_rdata;\\n', '\\n', '// AXI4-lite slave memory interfaces\\n', '\\n', 'wire [slaves-1:0]       s_axi_awvalid;\\n', 'reg  [slaves-1:0]       s_axi_awready;\\n', 'wire [slaves*sword-1:0] s_axi_awaddr;\\n', 'wire [slaves*3-1:0]     s_axi_awprot;\\n', '\\n', 'wire [slaves-1:0]       s_axi_wvalid;\\n', 'reg  [slaves-1:0]       s_axi_wready;\\n', 'wire [slaves*sword-1:0] s_axi_wdata;\\n', 'wire [slaves*4-1:0]     s_axi_wstrb;\\n', '\\n', 'reg  [slaves-1:0]       s_axi_bvalid;\\n', 'wire [slaves-1:0]       s_axi_bready;\\n', '\\n', 'wire [slaves-1:0]       s_axi_arvalid;\\n', 'reg  [slaves-1:0]       s_axi_arready;\\n', 'wire [slaves*sword-1:0] s_axi_araddr;\\n', 'wire [slaves*3-1:0]     s_axi_arprot;\\n', '\\n', 'reg  [slaves-1:0]       s_axi_rvalid;\\n', 'wire [slaves-1:0]       s_axi_rready;\\n', 'wire [slaves*sword-1:0] s_axi_rdata;\\n', '\\n', '// THE CONCENTRATION\\n', '\\n', 'reg  [sword-1:0] m_axi_awaddr_o [0:masters-1];\\n', 'reg  [3-1:0]     m_axi_awprot_o [0:masters-1];\\n', 'reg  [sword-1:0] m_axi_wdata_o [0:masters-1];\\n', 'reg  [4-1:0]     m_axi_wstrb_o [0:masters-1];\\n', 'reg  [sword-1:0] m_axi_araddr_o [0:masters-1];\\n', 'reg  [3-1:0]     m_axi_arprot_o [0:masters-1];\\n', 'wire [sword-1:0] m_axi_rdata_o [0:masters-1];\\n', 'wire [sword-1:0] s_axi_awaddr_o [0:slaves-1];\\n', 'wire [3-1:0]     s_axi_awprot_o [0:slaves-1];\\n', 'wire [sword-1:0] s_axi_wdata_o [0:slaves-1];\\n', 'wire [4-1:0]     s_axi_wstrb_o [0:slaves-1];\\n', 'wire [sword-1:0] s_axi_araddr_o [0:slaves-1];\\n', 'wire [3-1:0]     s_axi_arprot_o [0:slaves-1];\\n', 'reg  [sword-1:0] s_axi_rdata_o [0:slaves-1];\\n', '\\n', 'wire  [sword-1:0] addr_mask_o [0:slaves-1];\\n', 'wire  [sword-1:0] addr_use_o [0:slaves-1];\\n', 'genvar k;\\n', 'generate\\n', '\\tfor(k = 0; k < masters; k=k+1) begin\\n', '\\t\\tassign m_axi_awaddr[(k+1)*sword-1:k*sword] = m_axi_awaddr_o[k];\\n', '\\t\\tassign m_axi_awprot[(k+1)*3-1:k*3] = m_axi_awprot_o[k];\\n', '\\t\\tassign m_axi_wdata[(k+1)*sword-1:k*sword] = m_axi_wdata_o[k];\\n', '\\t\\tassign m_axi_wstrb[(k+1)*4-1:k*4] = m_axi_wstrb_o[k];\\n', '\\t\\tassign m_axi_araddr[(k+1)*sword-1:k*sword] = m_axi_araddr_o[k];\\n', '\\t\\tassign m_axi_arprot[(k+1)*3-1:k*3] = m_axi_arprot_o[k];\\n', '\\t\\tassign m_axi_rdata_o[k] = m_axi_rdata[(k+1)*sword-1:k*sword];\\n', '\\tend\\n', '\\tfor(k = 0; k < slaves; k=k+1) begin\\n', '\\t\\tassign s_axi_awaddr_o[k] = s_axi_awaddr[(k+1)*sword-1:k*sword];\\n', '\\t\\tassign s_axi_awprot_o[k] = s_axi_awprot[(k+1)*3-1:k*3];\\n', '\\t\\tassign s_axi_wdata_o[k] = s_axi_wdata[(k+1)*sword-1:k*sword];\\n', '\\t\\tassign s_axi_wstrb_o[k] = s_axi_wstrb[(k+1)*4-1:k*4];\\n', '\\t\\tassign s_axi_araddr_o[k] = s_axi_araddr[(k+1)*sword-1:k*sword];\\n', '\\t\\tassign s_axi_arprot_o[k] = s_axi_arprot[(k+1)*3-1:k*3];\\n', '\\t\\tassign addr_mask_o[k] = addr_mask[(k+1)*sword-1:k*sword];\\n', '\\t\\tassign addr_use_o[k] = addr_use[(k+1)*sword-1:k*sword];\\n', '\\t\\tassign s_axi_rdata[(k+1)*sword-1:k*sword] = s_axi_rdata_o[k];\\n', '\\tend\\n', 'endgenerate\\n', '\\t\\n', '\\tinteger \\tfd1, tmp1, ifstop;\\n', '\\tinteger PERIOD = 20 ;\\n', '\\tinteger i, j, error, l;\\n', '\\t\\n', '\\t\\n', '\\taxi4_interconnect/* #\\n', '\\t(\\n', '\\t.masters(masters),\\n', '\\t.slaves(slaves),\\n', '\\t.sword(sword),\\n', '\\t.impl(impl),\\n', '\\t.addressing(addressing),\\n', '\\t.addr_mask(addr_mask),\\n', '\\t.addr_use(addr_use)\\n', '\\t) */\\n', '\\tinst_axi4_interconnect\\n', '\\t(\\n', '\\t.CLK\\t\\t(CLK),\\n', '\\t.RST\\t(RST),\\n', '\\t.m_axi_awvalid(m_axi_awvalid),\\n', '\\t.m_axi_awready(m_axi_awready),\\n', '\\t.m_axi_awaddr(m_axi_awaddr),\\n', '\\t.m_axi_awprot(m_axi_awprot),\\n', '\\t.m_axi_wvalid(m_axi_wvalid),\\n', '\\t.m_axi_wready(m_axi_wready),\\n', '\\t.m_axi_wdata(m_axi_wdata),\\n', '\\t.m_axi_wstrb(m_axi_wstrb),\\n', '\\t.m_axi_bvalid(m_axi_bvalid),\\n', '\\t.m_axi_bready(m_axi_bready),\\n', '\\t.m_axi_arvalid(m_axi_arvalid),\\n', '\\t.m_axi_arready(m_axi_arready),\\n', '\\t.m_axi_araddr(m_axi_araddr),\\n', '\\t.m_axi_arprot(m_axi_arprot),\\n', '\\t.m_axi_rvalid(m_axi_rvalid),\\n', '\\t.m_axi_rready(m_axi_rready),\\n', '\\t.m_axi_rdata(m_axi_rdata),\\n', '\\t.s_axi_awvalid(s_axi_awvalid),\\n', '\\t.s_axi_awready(s_axi_awready),\\n', '\\t.s_axi_awaddr(s_axi_awaddr),\\n', '\\t.s_axi_awprot(s_axi_awprot),\\n', '\\t.s_axi_wvalid(s_axi_wvalid),\\n', '\\t.s_axi_wready(s_axi_wready),\\n', '\\t.s_axi_wdata(s_axi_wdata),\\n', '\\t.s_axi_wstrb(s_axi_wstrb),\\n', '\\t.s_axi_bvalid(s_axi_bvalid),\\n', '\\t.s_axi_bready(s_axi_bready),\\n', '\\t.s_axi_arvalid(s_axi_arvalid),\\n', '\\t.s_axi_arready(s_axi_arready),\\n', '\\t.s_axi_araddr(s_axi_araddr),\\n', '\\t.s_axi_arprot(s_axi_arprot),\\n', '\\t.s_axi_rvalid(s_axi_rvalid),\\n', '\\t.s_axi_rready(s_axi_rready),\\n', '\\t.s_axi_rdata(s_axi_rdata)\\n', '\\t); \\n', '\\t\\n', '\\talways\\n', '\\tbegin #(PERIOD/2) CLK = ~CLK; end \\n', '\\n', '\\ttask aexpect;\\n', '\\t\\tinput [sword-1:0] av, e;\\n', '\\t\\tbegin\\n', '\\t\\t if (av == e)\\n', '\\t\\t\\t$display (\"TIME=%t.\" , $time, \" Actual value of trans=%b, expected is %b. MATCH!\", av, e);\\n', '\\t\\t else\\n', '\\t\\t  begin\\n', '\\t\\t\\t$display (\"TIME=%t.\" , $time, \" Actual value of trans=%b, expected is %b. ERROR!\", av, e);\\n', '\\t\\t\\terror = error + 1;\\n', '\\t\\t  end\\n', '\\t\\tend\\n', '\\tendtask\\n', '\\t\\n', \"\\treg [63:0] xorshift64_state = 64'd88172645463325252;\\n\", '\\n', '\\ttask xorshift64_next;\\n', '\\t\\tbegin\\n', '\\t\\t\\t// see page 4 of Marsaglia, George (July 2003). \"Xorshift RNGs\". Journal of Statistical Software 8 (14).\\n', '\\t\\t\\txorshift64_state = xorshift64_state ^ (xorshift64_state << 13);\\n', '\\t\\t\\txorshift64_state = xorshift64_state ^ (xorshift64_state >>  7);\\n', '\\t\\t\\txorshift64_state = xorshift64_state ^ (xorshift64_state << 17);\\n', '\\t\\tend\\n', '\\tendtask\\n', '\\n', '\\n', '\\tinitial begin\\n', '\\t\\t$sdf_annotate(\"axi4_interconnect.sdf\",inst_axi4_interconnect);\\n', '\\t\\tfd1 = $fopen (\"data.txt\",\"r\");\\n', \"\\t\\tCLK \\t= 1'b1;\\n\", \"\\t\\tRST \\t= 1'b0;\\n\", '\\t\\terror = 0;\\n', \"\\t\\tm_axi_awvalid = {(masters){1'b0}};\\n\", \"\\t\\tm_axi_wvalid = {(masters){1'b0}};\\n\", \"\\t\\tm_axi_bready = {(masters){1'b0}};\\n\", \"\\t\\tm_axi_arvalid = {(masters){1'b0}};\\n\", \"\\t\\tm_axi_rready = {(masters){1'b0}};\\n\", \"\\t\\ts_axi_awready = {(slaves){1'b0}};\\n\", \"\\t\\ts_axi_wready = {(slaves){1'b0}};\\n\", \"\\t\\ts_axi_bvalid = {(slaves){1'b0}};\\n\", \"\\t\\ts_axi_arready = {(slaves){1'b0}};\\n\", \"\\t\\ts_axi_rvalid = {(slaves){1'b0}};\\n\", '\\t\\tfor(i = 0; i < masters; i=i+1) begin\\n', \"\\t\\t\\tm_axi_awaddr_o[i] = {sword{1'b0}};\\n\", \"\\t\\t\\tm_axi_awprot_o[i] = {3{1'b0}};\\n\", \"\\t\\t\\tm_axi_wdata_o[i] = {sword{1'b0}};\\n\", \"\\t\\t\\tm_axi_wstrb_o[i] = {4{1'b0}};\\n\", \"\\t\\t\\tm_axi_araddr_o[i] = {sword{1'b0}};\\n\", \"\\t\\t\\tm_axi_arprot_o[i] = {3{1'b0}};\\n\", '\\t\\tend\\n', '\\t\\tfor(i = 0; i < slaves; i=i+1) begin\\n', \"\\t\\t\\ts_axi_rdata_o[i] = {sword{1'b0}};\\n\", '\\t\\tend\\n', '\\t\\t#20\\t;\\n', \"\\t\\tRST \\t= 1'b1;\\n\", '\\t\\t// READING TEST\\n', '\\t\\tfor(i = 0; i < masters; i = i+1) begin\\n', '\\t\\t\\tfor(j = 0; j < slaves; j = j+1) begin\\n', '\\t\\t\\t\\t#(PERIOD*8);\\n', \"\\t\\t\\t\\tm_axi_arvalid[i] = 1'b1;\\n\", '\\t\\t\\t\\tm_axi_araddr_o[i] = addr_use_o[j] | (xorshift64_state[31:0] & addr_mask_o[j]);\\n', '\\t\\t\\t\\t#PERIOD;\\n', '\\t\\t\\t\\twhile(!m_axi_arready[i]) begin\\n', '\\t\\t\\t\\t\\t#PERIOD; \\n', '\\t\\t\\t\\tend\\n', '\\t\\t\\t\\twhile(!m_axi_rvalid[i]) begin\\n', '\\t\\t\\t\\t\\t#PERIOD; \\n', '\\t\\t\\t\\tend\\n', \"\\t\\t\\t\\tm_axi_rready[i] = 1'b1;\\n\", '\\t\\t\\t\\t$display (\"Master: %d, Task: RData\", i);\\n', '\\t\\t\\t\\taexpect(m_axi_rdata_o[i], xorshift64_state[63:32]);\\n', '\\t\\t\\t\\t#PERIOD; \\n', \"\\t\\t\\t\\tm_axi_arvalid[i] = 1'b0;\\n\", \"\\t\\t\\t\\tm_axi_rready[i] = 1'b0;\\n\", '\\t\\t\\t\\txorshift64_next;\\n', '\\t\\t\\t\\tif(j == 2) begin\\n', '\\t\\t\\t\\t\\t#(PERIOD*6);\\n', \"\\t\\t\\t\\t\\tRST = 1'b0;\\n\", '\\t\\t\\t\\t\\t#(PERIOD*6);\\n', \"\\t\\t\\t\\t\\tRST = 1'b1;\\n\", '\\t\\t\\t\\t\\t#(PERIOD*6);\\n', '\\t\\t\\t\\tend\\n', '\\t\\t\\tend\\n', '\\t\\tend\\n', '\\t\\t\\n', '\\t\\t// WRITTING TEST\\n', '\\t\\tfor(i = 0; i < masters; i = i+1) begin\\n', '\\t\\t\\tfor(j = 0; j < slaves; j = j+1) begin\\n', '\\t\\t\\t\\t#(PERIOD*8);\\n', \"\\t\\t\\t\\tm_axi_awvalid[i] = 1'b1;\\n\", '\\t\\t\\t\\tm_axi_awaddr_o[i] = addr_use_o[j] | (xorshift64_state[31:0] & addr_mask_o[j]);\\n', '\\t\\t\\t\\t#PERIOD;\\n', '\\t\\t\\t\\twhile(!m_axi_awready[i]) begin\\n', '\\t\\t\\t\\t\\t#PERIOD; \\n', '\\t\\t\\t\\tend\\n', \"\\t\\t\\t\\tm_axi_wvalid[i] = 1'b1;\\n\", '\\t\\t\\t\\tm_axi_wdata_o[i] = xorshift64_state[63:32];\\n', '\\t\\t\\t\\twhile(!m_axi_wready[i]) begin\\n', '\\t\\t\\t\\t\\t#PERIOD; \\n', '\\t\\t\\t\\tend\\n', '\\t\\t\\t\\twhile(!m_axi_bvalid[i]) begin\\n', '\\t\\t\\t\\t\\t#PERIOD; \\n', '\\t\\t\\t\\tend\\n', \"\\t\\t\\t\\tm_axi_bready[i] = 1'b1;\\n\", '\\t\\t\\t\\t#PERIOD; \\n', \"\\t\\t\\t\\tm_axi_awvalid[i] = 1'b0;\\n\", \"\\t\\t\\t\\tm_axi_wvalid[i] = 1'b0;\\n\", \"\\t\\t\\t\\tm_axi_bready[i] = 1'b0;\\n\", '\\t\\t\\t\\txorshift64_next;\\n', '\\t\\t\\t\\tif(j == 2) begin\\n', '\\t\\t\\t\\t\\t#(PERIOD*6);\\n', \"\\t\\t\\t\\t\\tRST = 1'b0;\\n\", '\\t\\t\\t\\t\\t#(PERIOD*6);\\n', \"\\t\\t\\t\\t\\tRST = 1'b1;\\n\", '\\t\\t\\t\\t\\t#(PERIOD*6);\\n', '\\t\\t\\t\\tend\\n', '\\t\\t\\tend\\n', '\\t\\tend\\n', '\\t\\t$timeformat(-9,0,\"ns\",7);\\n', '\\t\\t#(PERIOD*8) if (error == 0)\\n', '\\t\\t\\t\\t\\t$display(\"All match\");\\n', '\\t\\t\\t\\telse\\n', '\\t\\t\\t\\t\\t$display(\"Mismatches = %d\", error);\\n', '\\t\\t$finish;\\n', '\\tend\\n', '\\t\\n', '\\talways @(posedge CLK) begin\\n', '\\t\\tfor(l = 0; l < slaves; l = l+1) begin\\n', '\\t\\t\\tif(s_axi_arvalid[l] && !s_axi_arready[i] && !s_axi_rready[l]) begin\\n', \"\\t\\t\\t\\ts_axi_arready[l] = 1'b1;\\n\", \"\\t\\t\\t\\ts_axi_rvalid[l] = 1'b1;\\n\", '\\t\\t\\t\\ts_axi_rdata_o[l] = xorshift64_state[63:32];\\n', '\\t\\t\\t\\t$display (\"Slave: %d, Task: RAddr\", l);\\n', '\\t\\t\\t\\taexpect(s_axi_araddr_o[l], addr_use_o[l] | (xorshift64_state[31:0] & addr_mask_o[l]));\\n', '\\t\\t\\tend else if(s_axi_rready[l]) begin\\n', \"\\t\\t\\t\\ts_axi_arready[l] = 1'b0;\\n\", \"\\t\\t\\t\\ts_axi_rvalid[l] = 1'b0;\\n\", '\\t\\t\\tend\\n', '\\t\\t\\t\\n', '\\t\\t\\t\\n', '\\t\\t\\tif(s_axi_awvalid[l] && !s_axi_awready[i] && !s_axi_bready[l]) begin\\n', \"\\t\\t\\t\\ts_axi_awready[l] = 1'b1;\\n\", '\\t\\t\\t\\t$display (\"Slave: %d, Task: WAddr\", l);\\n', '\\t\\t\\t\\taexpect(s_axi_awaddr_o[l], addr_use_o[l] | (xorshift64_state[31:0] & addr_mask_o[l]));\\n', '\\t\\t\\tend if(s_axi_wvalid[l] && !s_axi_wready[i] && !s_axi_bready[l]) begin\\n', \"\\t\\t\\t\\ts_axi_wready[l] = 1'b1;\\n\", \"\\t\\t\\t\\ts_axi_bvalid[l] = 1'b1;\\n\", '\\t\\t\\t\\t$display (\"Slave: %d, Task: WData\", l);\\n', '\\t\\t\\t\\taexpect(s_axi_wdata_o[l], xorshift64_state[63:32]);\\n', '\\t\\t\\tend else if(s_axi_bready[l]) begin\\n', \"\\t\\t\\t\\ts_axi_awready[l] = 1'b0;\\n\", \"\\t\\t\\t\\ts_axi_wready[l] = 1'b0;\\n\", \"\\t\\t\\t\\ts_axi_bvalid[l] = 1'b0;\\n\", '\\t\\t\\tend\\n', '\\t\\tend\\n', '\\tend\\n', '\\n', 'endmodule\\n']"}
{"text": "['// CLOCK DOMAIN SYNC BY CKDUR\\n', '`timescale 1ns/1ns\\n', '\\n', 'module bus_sync_sf #\\n', '(\\n', '\\t// 0 F1 > F2, 1 F1 < F2\\n', '\\tparameter impl = 0,\\n', '\\t// Numbits\\n', '\\tparameter sword = 32\\n', ')\\n', '(\\n', '\\tinput CLK1,\\n', '\\tinput CLK2,\\n', '\\tinput RST,\\n', '\\tinput [sword-1:0] data_in,\\n', '\\toutput [sword-1:0] data_out\\n', ');\\n', '\\n', 'generate\\n', '\\tif (impl) begin\\n', '\\t\\twire NCLK2;\\n', '\\t\\tassign NCLK2 = ~CLK2;\\n', '\\t\\treg ECLK1, EECLK1;\\n', '\\t\\talways @(posedge NCLK2) begin\\n', \"\\t\\t\\tif(RST == 1'b0) begin\\n\", \"\\t\\t\\t\\tECLK1 <= 1'b0;\\n\", \"\\t\\t\\t\\tEECLK1 <= 1'b0;\\n\", '\\t\\t\\tend else begin\\n', '\\t\\t\\t\\tECLK1 <= CLK1;\\n', '\\t\\t\\t\\tEECLK1 <= ECLK1;\\n', '\\t\\t\\tend\\n', '\\t\\tend\\n', '\\t\\treg [sword-1:0] reg_data1;\\n', '\\t\\treg [sword-1:0] reg_data2;\\n', '\\t\\treg [sword-1:0] reg_data3;\\n', '\\t\\talways @(posedge CLK1) begin\\n', \"\\t\\t\\tif(RST == 1'b0) begin\\n\", \"\\t\\t\\t\\treg_data1 <= {sword{1'b0}};\\n\", '\\t\\t\\tend else begin\\n', '\\t\\t\\t\\treg_data1 <= data_in;\\n', '\\t\\t\\tend\\n', '\\t\\tend\\n', '\\t\\talways @(posedge CLK2) begin\\n', \"\\t\\t\\tif(RST == 1'b0) begin\\n\", \"\\t\\t\\t\\treg_data2 <= {sword{1'b0}};\\n\", \"\\t\\t\\t\\treg_data3 <= {sword{1'b0}};\\n\", '\\t\\t\\tend else begin\\n', '\\t\\t\\t\\tif(EECLK1) begin\\n', '\\t\\t\\t\\t\\treg_data2 <= reg_data1;\\n', '\\t\\t\\t\\tend\\n', '\\t\\t\\t\\treg_data3 <= reg_data2;\\n', '\\t\\t\\tend\\n', '\\t\\tend\\n', '\\t\\tassign data_out = reg_data3;\\n', '\\tend else begin\\n', '\\t\\twire NCLK1;\\n', '\\t\\tassign NCLK1 = ~CLK1;\\n', '\\t\\treg ECLK2, EECLK2;\\n', '\\t\\talways @(posedge NCLK1) begin\\n', \"\\t\\t\\tif(RST == 1'b0) begin\\n\", \"\\t\\t\\t\\tECLK2 <= 1'b0;\\n\", \"\\t\\t\\t\\tEECLK2 <= 1'b0;\\n\", '\\t\\t\\tend else begin\\n', '\\t\\t\\t\\tECLK2 <= CLK2;\\n', '\\t\\t\\t\\tEECLK2 <= ECLK2;\\n', '\\t\\t\\tend\\n', '\\t\\tend\\n', '\\t\\treg [sword-1:0] reg_data1;\\n', '\\t\\treg [sword-1:0] reg_data2;\\n', '\\t\\treg [sword-1:0] reg_data3;\\n', '\\t\\talways @(posedge CLK1) begin\\n', \"\\t\\t\\tif(RST == 1'b0) begin\\n\", \"\\t\\t\\t\\treg_data1 <= {sword{1'b0}};\\n\", \"\\t\\t\\t\\treg_data2 <= {sword{1'b0}};\\n\", '\\t\\t\\tend else begin\\n', '\\t\\t\\t\\treg_data1 <= data_in;\\n', '\\t\\t\\t\\tif(EECLK2) begin\\n', '\\t\\t\\t\\t\\treg_data2 <= reg_data1;\\n', '\\t\\t\\t\\tend\\n', '\\t\\t\\tend\\n', '\\t\\tend\\n', '\\t\\talways @(posedge CLK2) begin\\n', \"\\t\\t\\tif(RST == 1'b0) begin\\n\", \"\\t\\t\\t\\treg_data3 <= {sword{1'b0}};\\n\", '\\t\\t\\tend else begin\\n', '\\t\\t\\t\\treg_data3 <= reg_data2;\\n', '\\t\\t\\tend\\n', '\\t\\tend\\n', '\\t\\tassign data_out = reg_data3;\\n', '\\tend\\n', 'endgenerate\\n', '\\n', 'endmodule']"}
{"text": "['`timescale 1ns / 1ps\\n', '\\n', 'module completogpio(\\n', '    input [31:0] WAddress,Wdata,\\n', '    input AWvalid,\\n', '\\t input [7:0] pindata,\\n', '    input [31:0] RAddress,\\n', '    input Wvalid,\\n', '\\t input clock,\\n', '\\t input ARvalid,\\n', '\\t input reset,\\n', '    input Rready,\\n', '    input Bready,\\n', '\\t output reg ARready,Rvalid,AWready,Wready,Bvalid,\\n', '    output reg[7:0] Rx,datanw,\\n', '    output reg [7:0] Tx,DSE,\\n', '\\t output reg [31:0] Rdata\\n', '    );\\n', '\\t\\t\\n', '\\t\\twire [2:0] LWAddress,LRAddress;\\n', '\\t\\twire [7:0] W,R,Tm,Rm;\\n', '\\t\\twire [4:0] salm;\\n', '\\t\\twire [7:0] outdataw,DS;\\n', '\\t\\treg Rdata1,vel;\\n', '\\t\\t\\n', '\\n', '\\t\\t\\n', '\\n', '//decodificador para Wend\\t\\t\\n', '\\n', ' \\n', '\\n', '\\t \\n', '\\t// maquina\\n', '\\tmacstate2 maquina (\\n', '\\t\\t.clock(clock),\\n', '\\t\\t.vel(vel), \\n', '\\t\\t.reset(reset), \\n', '\\t\\t.salida(salm), \\n', '\\t\\t.AWvalid(AWvalid), \\n', '\\t\\t.Wvalid(Wvalid), \\n', '\\t\\t.Bready(Bready), \\n', '\\t\\t.ARvalid(ARvalid), \\n', '\\t\\t.Rready(Rready)\\n', '\\t\\t);\\n', '\\n', '\\n', '\\t////////////////////////////////////////////////////////////////////////\\n', '\\n', '\\t always @ (posedge clock) begin\\n', '\\t\\t\\n', '\\t\\tif (!reset) begin\\n', '\\t\\t\\tvel<=1;\\n', '\\n', '\\t\\tend\\n', '\\t\\t\\n', '\\t\\telse if (Wvalid) begin\\n', '\\t\\t\\tvel<=Wdata[2];\\n', '\\t\\tend\\n', '\\t\\t\\n', '\\t\\telse begin\\n', '\\t\\t\\tvel<=vel;\\n', '\\t\\tend\\n', '\\tend\\n', '\\n', '/////////////////////////////////////\\n', '\\n', '\\t\\n', '\\t// latch escritura\\n', '\\tlatchW latchW (\\n', '\\t\\t.clock(clock),\\n', '\\t\\t.reset(reset),\\n', '\\t\\t.AWvalid(AWvalid), \\n', '\\t\\t.WAddres(WAddress), \\n', '\\t\\t.LWAddres(LWAddress)\\n', '\\t\\t);\\n', '\\t \\n', '\\t // latch lectura\\n', '\\tlatchW latchR (\\n', '\\t\\t.clock(clock),\\n', '\\t\\t.reset(reset),\\n', '\\t\\t.AWvalid(ARvalid), \\n', '\\t\\t.WAddres(RAddress), \\n', '\\t\\t.LWAddres(LRAddress)\\n', '\\t\\t);\\n', '\\t\\t\\n', '\\t\\t// decodificador escritura\\n', '\\tdecodificador decow (\\n', '\\t\\t.AWready(salm[2]), \\n', '\\t\\t.clock(clock), \\n', '\\t\\t.LWAddress(LWAddress), \\n', '\\t\\t.W(W)\\n', '\\t\\t);\\n', '\\t\\n', '\\t\\n', '\\t/////////////////////////////////////\\n', '\\t// Instantiate the module\\n', '\\tflipsdataw flipw1(\\n', '\\t\\t.reset(reset),\\n', '\\t\\t.en(W[0]), \\n', '\\t\\t.clock(clock), \\n', '\\t\\t.datain(Wdata[1:0]), \\n', '\\t\\t.outdata(outdataw[0]),\\n', '\\t\\t.DS(DS[0])\\n', '\\t\\t);\\n', '\\tflipsdataw flipw2 (\\n', '\\t\\t.reset(reset),\\t\\t\\n', '\\t\\t.en(W[1]), \\n', '\\t\\t.clock(clock), \\n', '\\t\\t.datain(Wdata[1:0]), \\n', '\\t\\t.outdata(outdataw[1]),\\n', '\\t\\t.DS(DS[1])\\n', '\\t\\t);\\n', '\\tflipsdataw flipw3 (\\n', '\\t\\t.reset(reset),\\n', '\\t\\t.en(W[2]), \\n', '\\t\\t.clock(clock), \\n', '\\t\\t.datain(Wdata[1:0]), \\n', '\\t\\t.outdata(outdataw[2]),\\n', '\\t\\t.DS(DS[2])\\n', '\\t\\t);\\n', '\\tflipsdataw flipw4 (\\n', '\\t\\t.reset(reset),\\n', '\\t\\t.en(W[3]), \\n', '\\t\\t.clock(clock), \\n', '\\t\\t.datain(Wdata[1:0]), \\n', '\\t\\t.outdata(outdataw[3]),\\n', '\\t\\t.DS(DS[3])\\n', '\\t\\t);\\n', '\\tflipsdataw flipw5 (\\n', '\\t\\t.reset(reset),\\n', '\\t\\t.en(W[4]), \\n', '\\t\\t.clock(clock), \\n', '\\t\\t.datain(Wdata[1:0]), \\n', '\\t\\t.outdata(outdataw[4]),\\n', '\\t\\t.DS(DS[4])\\n', '\\t\\t);\\n', '\\t\\n', '\\tflipsdataw flipw6 (\\n', '\\t\\t.reset(reset),\\n', '\\t\\t.en(W[5]), \\n', '\\t\\t.clock(clock), \\n', '\\t\\t.datain(Wdata[1:0]), \\n', '\\t\\t.outdata(outdataw[5]),\\n', '\\t\\t.DS(DS[5])\\n', '\\t\\t);\\n', '\\tflipsdataw flipw7 (\\n', '\\t\\t.reset(reset),\\n', '\\t\\t.en(W[6]), \\n', '\\t\\t.clock(clock), \\n', '\\t\\t.datain(Wdata[1:0]), \\n', '\\t\\t.outdata(outdataw[6]),\\n', '\\t\\t.DS(DS[6])\\n', '\\t\\t);\\n', '\\tflipsdataw flipw8 (\\n', '\\t\\t.reset(reset),\\n', '\\t\\t.en(W[7]), \\n', '\\t\\t.clock(clock), \\n', '\\t\\t.datain(Wdata[1:0]), \\n', '\\t\\t.outdata(outdataw[7]),\\n', '\\t\\t.DS(DS[7])\\n', '\\t\\t);\\t\\t\\n', '\\t\\n', '\\t \\n', '\\t\\n', '\\t\\n', '\\t/////////////////////////////////////\\n', '\\t\\n', '\\t// decodificador lectura\\n', '\\tdecodificador decor (\\n', '\\t\\t.AWready(salm[4]), \\n', '\\t\\t.clock(clock), \\n', '\\t\\t.LWAddress(LRAddress), \\n', '\\t\\t.W(R)\\n', '\\t\\t);\\n', '\\t\\n', '\\t/////////////////////////////////////////////////////////////////\\n', '\\t\\t///////////FLIP FLOPS//////////////////////////////////\\n', '\\t\\t\\n', '\\t\\t// flip1\\n', '\\tflipflopRS flip1 (\\n', '\\t\\t.reset(reset),\\n', '\\t\\t.Tx(Tm[0]),\\n', '\\t\\t.Rx(Rm[0]),\\n', '\\t\\t.W1(W[0]), \\n', '\\t\\t.R1(R[0]), \\n', '\\t\\t.clock(clock)\\n', '\\t\\t);\\n', '\\n', '\\t\\t// flip2\\n', '\\tflipflopRS flip2 (\\n', '\\t\\t.reset(reset),\\n', '\\t\\t.Tx(Tm[1]),\\n', '\\t\\t.Rx(Rm[1]),\\n', '\\t\\t.W1(W[1]), \\n', '\\t\\t.R1(R[1]), \\n', '\\t\\t.clock(clock)\\n', '\\t\\t);\\n', '\\n', '\\t\\t// flip3\\n', '\\tflipflopRS flip3 (\\n', '\\t\\t.reset(reset),\\n', '\\t\\t.Tx(Tm[2]),\\n', '\\t\\t.Rx(Rm[2]),\\n', '\\t\\t.W1(W[2]), \\n', '\\t\\t.R1(R[2]), \\n', '\\t\\t.clock(clock)\\n', '\\t\\t);\\n', '\\n', '\\t\\t// flip4\\n', '\\tflipflopRS flip4 (\\n', '\\t\\t.reset(reset),\\n', '\\t\\t.Tx(Tm[3]),\\n', '\\t\\t.Rx(Rm[3]), \\n', '\\t\\t.W1(W[3]), \\n', '\\t\\t.R1(R[3]), \\n', '\\t\\t.clock(clock)\\n', '\\t\\t);\\n', '\\t\\t\\n', '\\t\\t// flip5\\n', '\\tflipflopRS flip5 (\\n', '\\t\\t.reset(reset),\\n', '\\t\\t.Tx(Tm[4]),\\n', '\\t\\t.Rx(Rm[4]),\\n', '\\t\\t.W1(W[4]), \\n', '\\t\\t.R1(R[4]), \\n', '\\t\\t.clock(clock)\\n', '\\t\\t);\\n', '\\t\\t\\n', '\\t\\t// flip6\\n', '\\tflipflopRS flip6 (\\n', '\\t\\t.reset(reset),\\n', '\\t\\t.Tx(Tm[5]),\\n', '\\t\\t.Rx(Rm[5]),\\n', '\\t\\t.W1(W[5]), \\n', '\\t\\t.R1(R[5]), \\n', '\\t\\t.clock(clock)\\n', '\\t\\t);\\n', '\\t\\t\\n', '\\t\\t// flip7\\n', '\\tflipflopRS flip7 (\\n', '\\t\\t.reset(reset),\\n', '\\t\\t.Tx(Tm[6]),\\n', '\\t\\t.Rx(Rm[6]),\\n', '\\t\\t.W1(W[6]), \\n', '\\t\\t.R1(R[6]), \\n', '\\t\\t.clock(clock)\\n', '\\t\\t);\\n', '\\n', '\\t\\t// flip8\\n', '\\tflipflopRS flip8 (\\n', '\\t\\t.reset(reset),\\n', '\\t\\t.Tx(Tm[7]),\\n', '\\t\\t.Rx(Rm[7]),\\n', '\\t\\t.W1(W[7]), \\n', '\\t\\t.R1(R[7]), \\n', '\\t\\t.clock(clock)\\n', '\\t\\t);\\n', '\\t \\n', '/*\\t always @(P , reset) begin\\n', '\\t\\tif (!reset) begin\\n', '\\t\\t\\tRx=0;\\n', '\\t\\t\\tTx=0;\\n', '\\t\\tend\\n', '\\t\\telse begin\\n', '\\t\\t\\tRx=~P;\\n', '\\t\\t\\tTx=P;\\n', '\\t\\tend\\n', '\\tend\\n', '*/\\n', '\\n', '   always @(LRAddress or pindata) begin\\n', '      case (LRAddress)\\n', \"         3'b000: Rdata1 =pindata[0];\\n\", \"         3'b001: Rdata1 =pindata[1];\\n\", \"         3'b010: Rdata1 =pindata[2];\\n\", \"         3'b011: Rdata1 =pindata[3];\\n\", \"         3'b100: Rdata1 =pindata[4];\\n\", \"         3'b101: Rdata1 =pindata[5];\\n\", \"         3'b110: Rdata1 =pindata[6];\\n\", \"         3'b111: Rdata1 =pindata[7];\\n\", '      endcase\\n', '\\tend\\n', '\\n', '\\n', '\\n', '\\t\\n', '   always @(posedge clock)\\n', '      if (!reset) begin\\n', \"         Rdata[0] <= 1'b0;\\n\", '      end else begin\\n', '         Rdata[0] <= Rdata1;\\n', '      end\\n', '\\t\\t\\t\\t\\t\\t\\n', '\\n', '\\n', '\\talways@* begin\\n', '\\t\\tDSE=DS;\\n', '\\t\\tRdata[31:1]=0;\\n', '\\t\\tTx=Tm;\\n', '\\t\\tRx=Rm;\\n', '\\t\\tBvalid=salm[0];\\n', '\\t\\tWready=salm[1];\\n', '\\t\\tAWready=salm[2];\\n', '\\t\\tRvalid=salm[3];\\n', '\\t\\tARready=salm[4];\\n', '\\t\\tdatanw=outdataw;\\n', \"\\t\\t//Rend=1'b1;\\n\", \"\\t\\t//Wend=1'b1;\\n\", '\\t\\tend\\n', 'endmodule\\n', '\\n']"}
{"text": "['`timescale 1ns / 1ps\\n', '\\n', '\\n', '\\n', 'module completogpio_tb;\\n', '\\n', '\\t// Inputs\\n', '\\treg [31:0] WAddress;\\n', '\\treg [31:0] Wdata;\\n', '\\treg AWvalid;\\n', '\\treg [7:0] pindata;\\n', '\\treg [31:0] RAddress;\\n', '\\treg Wvalid;\\n', '\\treg clock;\\n', '\\treg ARvalid;\\n', '\\treg reset;\\n', '\\treg Rready;\\n', '\\treg Bready;\\n', '\\treg [3:0 ]strobe;\\n', '\\n', '\\t// Outputs\\n', '\\twire [7:0] DSE;\\n', '\\twire ARready;\\n', '\\twire Rvalid;\\n', '\\twire AWready;\\n', '\\twire Wready;\\n', '\\twire Bvalid;\\n', '\\twire [7:0] Rx;\\n', '\\twire [7:0] datanw;\\n', '\\twire [7:0] Tx;\\n', '\\twire [31:0] Rdata;\\n', '\\n', '\\t// Instantiate the Unit Under Test (UUT)\\n', '\\tcompletogpio uut (\\n', '\\t\\t.WAddress(WAddress), \\n', '\\t\\t.Wdata(Wdata), \\n', '\\t\\t.AWvalid(AWvalid), \\n', '\\t\\t.pindata(pindata), \\n', '\\t\\t.RAddress(RAddress), \\n', '\\t\\t.Wvalid(Wvalid), \\n', '\\t\\t.clock(clock), \\n', '\\t\\t.ARvalid(ARvalid), \\n', '\\t\\t.reset(reset), \\n', '\\t\\t.Rready(Rready), \\n', '\\t\\t.Bready(Bready), \\n', '\\t\\t.DSE(DSE), \\n', '\\t\\t.ARready(ARready), \\n', '\\t\\t.Rvalid(Rvalid), \\n', '\\t\\t.AWready(AWready), \\n', '\\t\\t.Wready(Wready), \\n', '\\t\\t.Bvalid(Bvalid), \\n', '\\t\\t.Rx(Rx), \\n', '\\t\\t.datanw(datanw), \\n', '\\t\\t.Tx(Tx), \\n', '\\t\\t.Rdata(Rdata)\\n', '\\t);\\n', '\\n', '\\talways #1 clock=~clock;\\n', '\\tinitial begin\\n', '\\t\\t// Initialize Inputs\\n', '\\t\\tWAddress = 0;\\n', '\\t\\tWdata = 0;\\n', '\\t\\tAWvalid = 0;\\n', \"\\t\\tpindata = 8'd0;\\n\", '\\t\\tRAddress = 0;\\n', '\\t\\tWvalid = 0;\\n', '\\t\\tclock = 0;\\n', '\\t\\tARvalid = 0;\\n', '\\t\\treset = 0;\\n', '\\t\\tRready = 0;\\n', '\\t\\tBready = 0;\\n', '\\t\\t\\n', '\\n', '\\t\\t// escritura\\n', '\\t\\t#2;\\n', '\\t\\treset=1;\\n', '\\t\\tRready=0;\\n', \"\\t\\tWAddress=32'hEFA;\\n\", \"\\t\\tWdata=32'hABCDEFFF;\\n\", \"\\t\\tpindata = 8'b10101010;\\n\", \"\\t\\tRAddress=32'd88393348;\\n\", '\\t\\tAWvalid=1;\\n', '\\t\\t#1;\\n', '\\t\\tWvalid=1;\\n', '\\t\\t#2.5;\\n', '\\t\\tWvalid=0;\\t\\t\\n', '\\t\\t#2.5;\\n', '\\t\\tAWvalid=0;\\n', '\\t\\tBready=1;\\n', '\\t\\t\\n', '\\t\\t#2.5;\\n', '\\t\\treset=0;\\n', '\\t\\tBready=0;\\t\\t\\n', '\\t\\t// lectura\\n', '\\t\\t\\n', '\\t\\t#10;\\n', '\\t\\treset=1;\\n', '\\t\\t\\n', '\\t\\tARvalid=1;\\n', '\\t\\t#2.5;\\n', '\\t\\tRready=1;\\n', '\\t\\tARvalid=0;\\n', '\\t\\t#2.0;\\n', '\\t\\tRready=0;\\n', '\\t\\t\\n', '\\t\\t\\n', '\\t\\t\\n', '\\t\\t#4;\\n', '\\t\\treset=0;\\n', '\\t\\t// escritura\\n', '\\t\\t#10;\\n', '\\t\\treset=1;\\n', '\\t\\tRready=0;\\n', \"\\t\\tWAddress=32'hEFA6;\\n\", \"\\t\\tWdata=32'hABCDEFF1;\\n\", \"\\t\\tpindata = 8'b10101010;\\n\", \"\\t\\tRAddress=32'd88393348;\\n\", '\\t\\tAWvalid=1;\\n', '\\t\\t#1;\\n', '\\t\\tWvalid=1;\\n', '\\t\\t#8;\\n', '\\t\\tWvalid=0;\\t\\t\\n', '\\t\\t#9;\\n', '\\t\\tAWvalid=0;\\n', '\\t\\tBready=1;\\n', '\\t\\t\\n', '\\t\\t#9;\\n', '\\t\\treset=0;\\t\\n', '\\t\\tBready=0;\\n', '\\t\\t\\n', '\\t\\t// lectura\\n', '\\t\\t\\n', '\\t\\t#10;\\n', '\\t\\treset=1;\\n', '\\t\\tARvalid=1;\\n', '\\t\\t#6;\\n', '\\t\\tRready=1;\\n', '\\t\\tARvalid=0;\\n', '\\t\\t\\n', '\\t\\t#4;\\n', '\\t\\treset=0;\\n', '\\t\\tRready=0;\\n', '\\t\\t#2;\\n', '\\t\\treset=1;\\n', '\\t\\t$finish;\\n', '/*\\t\\t\\t\\t// escritura\\n', '\\t\\t#100;\\n', '\\t\\treset=1;\\n', '\\t\\tRready=0;\\n', \"\\t\\tWAddress=32'hEFA;\\n\", \"\\t\\tWdata=32'hABCDEFFF;\\n\", \"\\t\\tpindata = 8'b10101010;\\n\", \"\\t\\tRAddress=32'd88393348;\\n\", '\\t\\tAWvalid=1;\\n', '\\t\\t#10;\\n', '\\t\\tWvalid=1;\\n', '\\t\\t#25;\\n', '\\t\\tWvalid=0;\\t\\t\\n', '\\t\\t#25;\\n', '\\t\\tAWvalid=0;\\n', '\\t\\tBready=1;\\n', '\\t\\t\\n', '\\t\\t#25;\\n', '\\t\\treset=0;\\t\\t\\n', '\\t\\t// lectura\\n', '\\t\\t\\n', '\\t\\t#100;\\n', '\\t\\treset=1;\\n', '\\t\\tBready=0;\\n', '\\t\\tARvalid=1;\\n', '\\t\\t#25;\\n', '\\t\\tRready=1;\\n', '\\t\\tARvalid=0;\\n', '\\t\\t\\n', '\\t\\t\\n', '\\t\\t\\n', '\\t\\t\\n', '\\t\\t#20;\\n', '\\t\\treset=0;\\n', '\\t\\tRready=0;*/\\n', '\\t\\t/*// escritura\\n', '\\t\\t#100;\\n', '\\t\\treset=1;\\n', '\\t\\tRready=0;\\n', \"\\t\\tWAddress=32'hEFA6;\\n\", \"\\t\\tWdata=32'hABCDEFF1;\\n\", \"\\t\\tpindata = 8'b10101010;\\n\", \"\\t\\tRAddress=32'd88393348;\\n\", '\\t\\tAWvalid=1;\\n', '\\t\\t#10;\\n', '\\t\\tWvalid=1;\\n', '\\t\\t#80;\\n', '\\t\\tWvalid=0;\\t\\t\\n', '\\t\\t#90;\\n', '\\t\\tAWvalid=0;\\n', '\\t\\tBready=1;\\n', '\\t\\t\\n', '\\t\\t#90;\\n', '\\t\\treset=0;\\t\\n', '\\t\\t\\n', '\\t\\t// lectura\\n', '\\t\\t\\n', '\\t\\t#100;\\n', '\\t\\treset=1;\\n', '\\t\\tBready=0;\\n', '\\t\\tARvalid=1;\\n', '\\t\\t#60;\\n', '\\t\\tRready=1;\\n', '\\t\\tARvalid=0;\\n', '\\t\\t\\n', '\\t\\t#60;\\n', '\\t\\treset=0;\\n', '\\t\\tRready=0;*/\\n', '\\t\\t\\n', '\\t\\t// Add stimulus here\\n', '\\n', '\\tend\\n', '      \\n', 'endmodule\\n', '\\n']"}
{"text": "['`timescale 1ns / 1ps\\n', 'module DAC_interface_AXI(CLK,RST,AWVALID,WVALID,BREADY,AWADDR,WDATA,WSTRB,AWREADY,WREADY,BVALID,DATA,ARVALID,RREADY,ARREADY,RVALID,RDATA);\\n', '\\n', '//----general--input----\\n', '\\tinput CLK,RST;\\n', '//----write--input----\\n', '\\tinput AWVALID,WVALID, BREADY;\\n', '\\tinput [31:0] AWADDR,WDATA;\\n', '\\tinput [3:0] WSTRB;\\n', '//----write--output----\\n', '\\toutput reg AWREADY, WREADY, BVALID;\\t\\n', '\\toutput wire [11:0] DATA;\\n', '//----write--signals----\\n', '\\treg [4:0] delay;\\n', '\\treg [2:0] state_write;\\n', '\\treg [11:0] latch_WDATA;\\n', '\\treg latch_reset, Q_WVALID, ena_DATA;\\n', '\\twire latch_WVALID;\\n', '//----read--input----\\n', '\\tinput ARVALID,RREADY;\\n', '//----read--output----\\n', '\\toutput reg ARREADY, RVALID;\\n', '\\toutput reg [31:0] RDATA;\\n', '//----read--signals----\\n', '\\treg state_read;\\n', '\\n', '//----FSM--WRITE----\\n', '\\n', \"\\tparameter START_W = 3'b000, WAIT_WVALID = 3'b001, SAVE_WDATA = 3'b010, WORKING = 3'b011, RESET = 3'b100, START_R = 1'b0, WAIT_RREADY = 1'b1;\\t\\t\\n\", '\\n', '//----RESET--PARAMETERS----\\n', '\\n', '\\talways @( posedge CLK or negedge RST)\\n', '\\tbegin\\t\\t\\n', \"\\tif (RST == 1'b0) begin\\n\", '\\t\\tstate_write = START_W;\\n', \"\\t\\tdelay = 5'b00000;\\n\", '\\tend\\n', '//----LOGIC----\\n', '\\telse\\n', '\\t\\tbegin\\n', '\\t\\t\\tcase (state_write)\\n', '\\n', \"\\t\\t\\tSTART_W :if (AWVALID == 1'b1) \\n\", '\\t\\t\\t\\tbegin\\n', '\\t\\t\\t\\t\\tstate_write = WAIT_WVALID;\\n', \"\\t\\t\\t\\t\\tdelay = 5'b00000;\\n\", '\\t\\t\\t\\tend\\n', '\\t\\t\\telse\\n', '\\t\\t\\t\\tbegin\\n', '\\t\\t\\t\\t\\tstate_write = START_W;\\n', '\\t\\t\\t\\tend\\n', '\\n', \"\\t\\t\\tWAIT_WVALID : if (WVALID == 1'b1)\\n\", '\\t\\t\\t\\tbegin \\n', '\\t\\t\\t\\t\\tstate_write = SAVE_WDATA;\\n', '\\t\\t\\t\\tend\\n', '\\t\\t\\telse\\n', '\\t\\t\\t\\tbegin\\n', '\\t\\t\\t\\t\\tstate_write = WAIT_WVALID;\\n', '\\t\\t\\t\\tend\\n', '\\n', '\\n', '\\t\\t\\tSAVE_WDATA :\\n', '\\t\\t\\t\\tbegin \\n', '\\t\\t\\t\\t\\tstate_write = WORKING;\\n', '\\t\\t\\t\\tend\\n', '\\n', '\\n', \"\\t\\t\\tWORKING : if (delay == 5'b01010) \\n\", '\\t\\t\\t\\tbegin\\n', '\\t\\t\\t\\t\\tstate_write = RESET;\\n', '\\t\\t\\t\\tend\\n', '\\t\\t\\telse\\n', '\\t\\t\\t\\tbegin\\n', '\\t\\t\\t\\t\\tstate_write = WORKING;\\n', \"\\t\\t\\t\\t\\tdelay = delay + 5'b00001;\\n\", '\\t\\t\\t\\tend\\n', '\\n', '\\n', \"\\t\\t\\tRESET : if (BREADY == 1'b1) \\n\", '\\t\\t\\t\\tbegin\\n', '\\t\\t\\t\\t\\tstate_write = START_W;\\n', '\\t\\t\\t\\tend\\n', '\\t\\t\\telse\\n', '\\t\\t\\t\\tbegin\\n', '\\t\\t\\t\\t\\tstate_write = RESET;\\n', '\\t\\t\\t\\tend\\n', '\\n', '\\t\\t\\tdefault :\\n', '\\t\\t\\t\\tbegin\\n', '\\t\\t\\t\\t\\tstate_write = START_W;\\n', '\\t\\t\\t\\tend\\n', '\\n', '\\t\\t\\tendcase\\n', '\\t\\tend\\n', '\\tend\\n', '//----OUTPUTS--FSM--WRITE----\\n', '\\talways @(state_write or RST)\\n', '\\tbegin\\t\\t\\n', \"\\t\\tif (RST == 1'b0)\\n\", '\\t\\tbegin\\n', '\\t\\t\\t\\tAWREADY = 0;\\n', '\\t\\t\\t\\tWREADY = 0;\\n', '\\t\\t\\t\\tBVALID = 0;\\n', '\\t\\t\\t\\tena_DATA = 0;\\n', '\\t\\t\\t\\tlatch_reset = 0;\\n', '\\t\\tend\\n', '\\t//----LOGIC----\\n', '\\t\\telse\\n', '\\t\\tbegin\\t\\n', '\\t\\t\\tcase (state_write)\\n', '\\t\\t\\t\\tSTART_W :begin //----0\\n', '\\t\\t\\t\\t\\tAWREADY = 0;\\n', '\\t\\t\\t\\t\\tWREADY = 0;\\n', '\\t\\t\\t\\t\\tBVALID = 0;\\n', '\\t\\t\\t\\t\\tena_DATA = 1;\\n', '\\t\\t\\t\\t\\tlatch_reset = 0;\\n', '\\t\\t\\t\\t\\tend\\n', '\\t\\t\\t\\tWAIT_WVALID :begin //----1\\n', '\\t\\t\\t\\t\\tAWREADY = 1;\\n', '\\t\\t\\t\\t\\tWREADY = 0;\\n', '\\t\\t\\t\\t\\tBVALID = 0;\\n', '\\t\\t\\t\\t\\tena_DATA = 1;\\n', '\\t\\t\\t\\t\\tlatch_reset = 0;\\n', '\\t\\t\\t\\t\\tend\\n', '\\t\\t\\t\\tSAVE_WDATA :begin //----2\\n', '\\t\\t\\t\\t\\tAWREADY = 1;\\n', '\\t\\t\\t\\t\\tWREADY = 1;\\n', '\\t\\t\\t\\t\\tBVALID = 0;\\n', '\\t\\t\\t\\t\\tena_DATA = 1;\\n', '\\t\\t\\t\\t\\tlatch_reset = 0;\\n', '\\t\\t\\t\\t\\tend\\n', '\\t\\t\\t\\tWORKING :begin //----3\\n', '\\t\\t\\t\\t\\tAWREADY = 1;\\n', '\\t\\t\\t\\t\\tWREADY = 1;\\n', '\\t\\t\\t\\t\\tBVALID = 0;\\n', '\\t\\t\\t\\t\\tena_DATA = 1;\\n', '\\t\\t\\t\\t\\tlatch_reset = 0;\\n', '\\t\\t\\t\\t\\tend\\n', '\\t\\t\\t\\tRESET :begin //----4\\n', '\\t\\t\\t\\t\\tAWREADY = 1;\\n', '\\t\\t\\t\\t\\tWREADY = 1;\\n', '\\t\\t\\t\\t\\tBVALID = 1;\\n', '\\t\\t\\t\\t\\tena_DATA = 1;\\n', '\\t\\t\\t\\t\\tlatch_reset = 1;\\n', '\\t\\t\\t\\t\\tend\\n', '\\t\\t\\t\\t\\t\\n', '\\t\\t\\t\\tdefault :begin\\n', '\\t\\t\\t\\t\\tAWREADY = 0;\\n', '\\t\\t\\t\\t\\tWREADY = 0;\\n', '\\t\\t\\t\\t\\tBVALID = 0;\\n', '\\t\\t\\t\\t\\tena_DATA = 1;\\n', '\\t\\t\\t\\t\\tlatch_reset = 0;\\n', '\\t\\t\\t\\t\\tend\\t\\t\\n', '\\t\\t\\t\\t\\t\\t\\n', '\\t\\t\\t\\t\\n', '\\n', '\\t\\t\\t\\tendcase\\n', '\\t\\t\\tend\\n', '\\t\\tend\\n', '//----LATCH_WVALID----\\n', '\\n', 'assign latch_WVALID = WVALID & ~Q_WVALID;\\n', '\\n', '\\talways @( posedge CLK )\\n', '\\tbegin\\n', \"\\t\\tif (RST == 1'b0 || latch_reset )\\n\", '\\t\\t\\tbegin\\n', \"\\t\\t\\t\\tQ_WVALID <= 1'b0;\\n\", '\\t\\t\\tend\\n', '\\t\\telse\\n', '\\t\\t\\tbegin\\n', '\\t\\t\\t\\tQ_WVALID <= WVALID;\\n', '\\t\\t\\tend\\n', '\\tend\\n', '\\n', '\\n', '//----FLIP--FLOPS--WRITE----\\n', '\\n', '\\talways @( posedge CLK )\\n', '\\tbegin\\n', \"\\t\\tif (RST == 1'b0)\\n\", '\\t\\t\\tbegin\\n', \"\\t\\t\\t\\tlatch_WDATA <= 32'b0;\\n\", '\\t\\t\\tend\\n', '\\t\\telse if (latch_WVALID) \\n', '\\t\\t\\tbegin\\n', '\\t\\t\\t\\tlatch_WDATA <= WDATA;\\n', '\\t\\t\\tend\\n', '\\t\\telse \\n', '\\t\\t\\tbegin\\n', '\\t\\t\\t\\tlatch_WDATA <= latch_WDATA;\\n', '\\t\\t\\tend\\t\\n', '\\tend\\n', '\\n', '//----OUTPUT--DATA----\\n', '\\n', \"assign DATA = ena_DATA ? latch_WDATA : 12'b0;\\n\", ' \\n', '//----FSM--READ----\\n', '\\n', '\\n', '//----RESET--PARAMETERS----\\n', '\\talways @( posedge CLK or negedge RST)\\n', '\\tbegin\\t\\t\\n', \"\\tif (RST == 1'b0) begin\\n\", '\\t\\tstate_read = START_R;\\n', '\\tend\\n', '//----LOGIC----\\n', '\\telse\\n', '\\t\\tbegin\\n', '\\t\\t\\tcase (state_read)\\n', \"\\t\\t\\tSTART_R :if (ARVALID == 1'b1) \\n\", '\\t\\t\\t\\tbegin\\n', '\\t\\t\\t\\t\\tstate_read = WAIT_RREADY;\\n', '\\t\\t\\t\\tend\\n', '\\t\\t\\telse\\n', '\\t\\t\\t\\tbegin\\n', '\\t\\t\\t\\t\\tstate_read = START_R;\\n', '\\t\\t\\t\\tend\\n', '\\t\\t\\t\\n', \"\\t\\t\\tWAIT_RREADY : if (RREADY == 1'b1)\\n\", '\\t\\t\\t\\tbegin \\n', '\\t\\t\\t\\t\\tstate_read = START_R;\\n', '\\t\\t\\t\\tend\\n', '\\t\\t\\telse\\n', '\\t\\t\\t\\tbegin\\n', '\\t\\t\\t\\t\\tstate_read = WAIT_RREADY;\\n', '\\t\\t\\t\\tend\\n', '\\t\\t\\t\\n', '\\t\\t\\tendcase\\n', '\\t\\tend\\n', '\\tend\\n', '//----OUTPUTS--FSM--READ----\\n', '\\talways @(state_read or RST)\\n', '\\tbegin\\t\\t\\n', \"\\t\\tif (RST == 1'b0)\\n\", '\\t\\tbegin\\n', '\\t\\t\\tARREADY = 0;\\n', '\\t\\t\\tRVALID = 0;\\n', \"\\t\\t\\tRDATA = 32'b0;\\n\", '\\t\\tend\\n', '//----LOGIC----\\n', '\\t\\telse\\n', '\\t\\tbegin\\t\\n', '\\t\\t\\t\\tcase (state_read)\\n', '\\t\\t\\t\\tSTART_R :begin\\n', '\\t\\t\\t\\t\\tARREADY = 1;\\n', '\\t\\t\\t\\t\\tRVALID = 0;\\n', \"\\t\\t\\t\\t\\tRDATA = 32'b0;\\n\", '\\t\\t\\t\\t\\tend\\n', '\\t\\t\\t\\tWAIT_RREADY  :begin\\n', '\\t\\t\\t\\t\\tARREADY = 1;\\n', '\\t\\t\\t\\t\\tRVALID = 1;\\n', \"\\t\\t\\t\\t\\tRDATA = 32'h55555555;\\n\", '\\t\\t\\t\\t\\tend\\n', '\\t\\n', '\\t\\t\\t\\tendcase\\n', '\\t\\tend\\n', '\\tend\\n', 'endmodule\\n', '\\n', '\\t\\n']"}
{"text": "['`timescale 1ns / 1ps\\n', '\\n', 'module DAC_interface_AXI_tb;\\n', 'parameter CLKPERIOD = 10;\\n', '\\n', 'reg CLK = 0, RST;\\n', 'reg AWVALID, WVALID, BREADY;\\n', 'reg [31:0] AWADDR, WDATA;\\n', 'reg [3:0] WSTRB; \\n', 'reg ARVALID, RREADY;\\n', '\\n', 'wire AWREADY, WREADY, BVALID;\\n', 'wire [11:0] DATA;\\n', 'wire ARREADY, RVALID;\\n', 'wire [31:0] RDATA; \\n', '\\n', 'DAC_interface_AXI DAC_interface_AXI_inst(\\n', '\\t\\t.RST(RST),\\n', '\\t\\t.CLK(CLK),\\n', '\\t\\t.AWVALID(AWVALID),\\n', '\\t\\t.WVALID(WVALID),\\n', '\\t\\t.BREADY(BREADY),\\n', '\\t\\t.AWADDR(AWADDR),\\n', '\\t\\t.WDATA(WDATA),\\n', '\\t\\t.WSTRB(WSTRB),\\n', '\\t\\t.AWREADY(AWREADY),\\n', '\\t\\t.WREADY(WREADY),\\n', '\\t\\t.BVALID(BVALID), \\n', '\\t\\t.DATA(DATA), \\n', '\\t\\t.ARVALID(ARVALID),\\n', '\\t\\t.RREADY(RREADY),\\n', '\\t\\t.ARREADY(ARREADY),\\n', '\\t\\t.RVALID(RVALID),\\n', '\\t\\t.RDATA(RDATA));\\n', '\\n', 'always \\n', '\\tbegin\\n', '\\t\\t#(CLKPERIOD/2) CLK = ~CLK;\\n', '\\tend\\n', '\\n', 'initial begin\\n', '\\n', \"RST <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*100);//-------------------------START_W--AND--START_R\\n', '\\n', '/*\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'b0; \\n\", \"WDATA <= 32'b0;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'hfffffff1; \\n\", \"WDATA <= 32'h12345678;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bx;\\n\", \"AWVALID <= 1'bx;\\n\", \"WVALID <= 1'bx;\\n\", \"BREADY <= 1'bx;\\n\", \"AWADDR <= 32'bx; \\n\", \"WDATA <= 32'hx;\\n\", \"ARVALID <= 1'bX;\\n\", \"RREADY <= 1'bX;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bz;\\n\", \"AWVALID <= 1'bz;\\n\", \"WVALID <= 1'bz;\\n\", \"BREADY <= 1'bz;\\n\", \"AWADDR <= 32'bz; \\n\", \"WDATA <= 32'hz;\\n\", \"ARVALID <= 1'bZ;\\n\", \"RREADY <= 1'bZ;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '*/\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b1;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'hfffffff1; \\n\", \"WDATA <= 32'h12345678;\\n\", \"ARVALID <= 1'b1;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*20);//-------------------------WAIT_WVALID--AND--WAIT_RREADY\\n', '/*\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'b0; \\n\", \"WDATA <= 32'b0;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'hfffffff1; \\n\", \"WDATA <= 32'h12345678;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bX;\\n\", \"AWVALID <= 1'bX;\\n\", \"WVALID <= 1'bX;\\n\", \"BREADY <= 1'bX;\\n\", \"AWADDR <= 32'bX; \\n\", \"WDATA <= 32'bX;\\n\", \"ARVALID <= 1'bX;\\n\", \"RREADY <= 1'bX;\\n\", '\\n', '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bZ;\\n\", \"AWVALID <= 1'bZ;\\n\", \"WVALID <= 1'bZ;\\n\", \"BREADY <= 1'bZ;\\n\", \"AWADDR <= 32'bZ; \\n\", \"WDATA <= 32'bZ;\\n\", \"ARVALID <= 1'bZ;\\n\", \"RREADY <= 1'bZ;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '*/\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b1;\\n\", \"BREADY <= 1'b1;\\n\", \"AWADDR <= 32'hfffffff1; \\n\", \"WDATA <= 32'h55555555;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b1;\\n\", '\\n', '#(CLKPERIOD*20);//-------------------------WORKING--AND--START_R\\n', '/*\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'b0; \\n\", \"WDATA <= 32'b0;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'hfffffff1; \\n\", \"WDATA <= 32'h12345678;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bX;\\n\", \"AWVALID <= 1'bX;\\n\", \"WVALID <= 1'bX;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'bX; \\n\", \"WDATA <= 32'bX;\\n\", \"ARVALID <= 1'bX;\\n\", \"RREADY <= 1'bX;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bZ;\\n\", \"AWVALID <= 1'bZ;\\n\", \"WVALID <= 1'bZ;\\n\", \"BREADY <= 1'bZ;\\n\", \"AWADDR <= 32'bZ; \\n\", \"WDATA <= 32'bZ;\\n\", \"ARVALID <= 1'bZ;\\n\", \"RREADY <= 1'bZ;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'b0; \\n\", \"WDATA <= 32'b0;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*10);\\n', '*/\\n', '//----------------------------------reset------------------------\\n', '\\n', \"RST <= 1'b0;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'h0; \\n\", \"WDATA <= 32'h0;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*100);//-------------------------START_R--AND--START_W\\n', '/*\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'b0; \\n\", \"WDATA <= 32'b0;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'hfffffff2; \\n\", \"WDATA <= 32'h87654321;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bx;\\n\", \"AWVALID <= 1'bx;\\n\", \"WVALID <= 1'bx;\\n\", \"BREADY <= 1'bx;\\n\", \"AWADDR <= 32'bx; \\n\", \"WDATA <= 32'hx;\\n\", \"ARVALID <= 1'bX;\\n\", \"RREADY <= 1'bX;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bz;\\n\", \"AWVALID <= 1'bz;\\n\", \"WVALID <= 1'bz;\\n\", \"BREADY <= 1'bz;\\n\", \"AWADDR <= 32'bz; \\n\", \"WDATA <= 32'hz;\\n\", \"ARVALID <= 1'bZ;\\n\", \"RREADY <= 1'bZ;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b1;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'hfffffff2; \\n\", \"WDATA <= 32'h87654321;\\n\", \"ARVALID <= 1'b1;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '*/\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b1;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'hfffffff1; \\n\", \"WDATA <= 32'h44444444;\\n\", \"ARVALID <= 1'b1;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '\\n', '#(CLKPERIOD*20);//-------------------------WAIT_WVALID--AND--WAIT_RREADY\\n', '/*\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'b0; \\n\", \"WDATA <= 32'b0;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'hfffffff2; \\n\", \"WDATA <= 32'h87654321;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bX;\\n\", \"AWVALID <= 1'bX;\\n\", \"WVALID <= 1'bX;\\n\", \"BREADY <= 1'bX;\\n\", \"AWADDR <= 32'bX; \\n\", \"WDATA <= 32'bX;\\n\", \"ARVALID <= 1'bX;\\n\", \"RREADY <= 1'bX;\\n\", '\\n', '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bZ;\\n\", \"AWVALID <= 1'bZ;\\n\", \"WVALID <= 1'bZ;\\n\", \"BREADY <= 1'bZ;\\n\", \"AWADDR <= 32'bZ; \\n\", \"WDATA <= 32'bZ;\\n\", \"ARVALID <= 1'bZ;\\n\", \"RREADY <= 1'bZ;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b1;\\n\", \"BREADY <= 1'b1;\\n\", \"AWADDR <= 32'hfffffff2; \\n\", \"WDATA <= 32'h87654321;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b1;\\n\", '*/\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b1;\\n\", \"BREADY <= 1'b1;\\n\", \"AWADDR <= 32'hfffffff1; \\n\", \"WDATA <= 32'h44444444;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b1;\\n\", '\\n', '#(CLKPERIOD*20);//-------------------------WORKING--AND--START_R\\n', '/*\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'b0; \\n\", \"WDATA <= 32'b0;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'hfffffff2; \\n\", \"WDATA <= 32'h87654321;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bX;\\n\", \"AWVALID <= 1'bX;\\n\", \"WVALID <= 1'bX;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'bX; \\n\", \"WDATA <= 32'bX;\\n\", \"ARVALID <= 1'bX;\\n\", \"RREADY <= 1'bX;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bZ;\\n\", \"AWVALID <= 1'bZ;\\n\", \"WVALID <= 1'bZ;\\n\", \"BREADY <= 1'bZ;\\n\", \"AWADDR <= 32'bZ; \\n\", \"WDATA <= 32'bZ;\\n\", \"ARVALID <= 1'bZ;\\n\", \"RREADY <= 1'bZ;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'b0; \\n\", \"WDATA <= 32'b0;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b1;\\n\", '\\n', '#(CLKPERIOD*10)\\n', '*/\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'h0; \\n\", \"WDATA <= 32'h0;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b1;\\n\", '\\n', '\\n', '//-------------------------START_R--AND--START_W\\n', '\\n', '//----------------------------------NO--reset------------------------\\n', '\\n', \"//RST <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*100);//-------------------------START_R--AND--START_W\\n', '/*\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'b0; \\n\", \"WDATA <= 32'b0;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'hfffffff3; \\n\", \"WDATA <= 32'h55555555;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bx;\\n\", \"AWVALID <= 1'bx;\\n\", \"WVALID <= 1'bx;\\n\", \"BREADY <= 1'bx;\\n\", \"AWADDR <= 32'bx; \\n\", \"WDATA <= 32'hx;\\n\", \"ARVALID <= 1'bX;\\n\", \"RREADY <= 1'bX;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bz;\\n\", \"AWVALID <= 1'bz;\\n\", \"WVALID <= 1'bz;\\n\", \"BREADY <= 1'bz;\\n\", \"AWADDR <= 32'bz; \\n\", \"WDATA <= 32'hz;\\n\", \"ARVALID <= 1'bZ;\\n\", \"RREADY <= 1'bZ;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b1;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'hfffffff3; \\n\", \"WDATA <= 32'h55555555;\\n\", \"ARVALID <= 1'b1;\\n\", \"RREADY <= 1'b0;\\n\", '*/\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b1;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'hfffffff1; \\n\", \"WDATA <= 32'h66666666;\\n\", \"ARVALID <= 1'b1;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*20);//-------------------------WAIT_WVALID--AND--WAIT_RREADY\\n', '/*\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'b0; \\n\", \"WDATA <= 32'b0;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'hfffffff3; \\n\", \"WDATA <= 32'h55555555;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bX;\\n\", \"AWVALID <= 1'bX;\\n\", \"WVALID <= 1'bX;\\n\", \"BREADY <= 1'bX;\\n\", \"AWADDR <= 32'bX; \\n\", \"WDATA <= 32'bX;\\n\", \"ARVALID <= 1'bX;\\n\", \"RREADY <= 1'bX;\\n\", '\\n', '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bZ;\\n\", \"AWVALID <= 1'bZ;\\n\", \"WVALID <= 1'bZ;\\n\", \"BREADY <= 1'bZ;\\n\", \"AWADDR <= 32'bZ; \\n\", \"WDATA <= 32'bZ;\\n\", \"ARVALID <= 1'bZ;\\n\", \"RREADY <= 1'bZ;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b1;\\n\", \"BREADY <= 1'b1;\\n\", \"AWADDR <= 32'hfffffff3; \\n\", \"WDATA <= 32'h55555555;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b1;\\n\", '\\n', '*/\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b1;\\n\", \"BREADY <= 1'b1;\\n\", \"AWADDR <= 32'hfffffff1; \\n\", \"WDATA <= 32'h66666666;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b1;\\n\", '\\n', '#(CLKPERIOD*100);//-------------------------WORKING--AND--START_R\\n', '/*\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'b0; \\n\", \"WDATA <= 32'b0;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'hfffffff3; \\n\", \"WDATA <= 32'h55555555;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bX;\\n\", \"AWVALID <= 1'bX;\\n\", \"WVALID <= 1'bX;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'bX; \\n\", \"WDATA <= 32'bX;\\n\", \"ARVALID <= 1'bX;\\n\", \"RREADY <= 1'bX;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'bZ;\\n\", \"AWVALID <= 1'bZ;\\n\", \"WVALID <= 1'bZ;\\n\", \"BREADY <= 1'bZ;\\n\", \"AWADDR <= 32'bZ; \\n\", \"WDATA <= 32'bZ;\\n\", \"ARVALID <= 1'bZ;\\n\", \"RREADY <= 1'bZ;\\n\", '\\n', '#(CLKPERIOD*5);//-------------------------\\n', '\\n', \"RST <= 1'b1;\\n\", \"AWVALID <= 1'b0;\\n\", \"WVALID <= 1'b0;\\n\", \"BREADY <= 1'b0;\\n\", \"AWADDR <= 32'b0; \\n\", \"WDATA <= 32'b0;\\n\", \"ARVALID <= 1'b0;\\n\", \"RREADY <= 1'b0;\\n\", '\\n', '#(CLKPERIOD*10)\\n', '\\n', '//-------------------------START--AND--WAIT_RREADY\\n', '*/\\n', '$finish;\\n', '\\n', 'end\\n', 'endmodule\\n']"}
{"text": "['`timescale 1ns / 1ps\\n', '\\n', 'module decodificador(\\n', '    input AWready,\\n', '\\t input clock,\\n', '    input [2:0] LWAddress,\\n', '    output [7:0] W\\n', '    );\\n', '\\t \\n', '\\t      \\n', '   assign W = AWready? (1 << LWAddress) : 0;\\n', '   /*always @(posedge clock)\\n', '      if (!AWready)\\n', \"         W <= 8'h00;\\n\", '      else\\n', '         case (LWAddress)\\n', \"            3'b000  : W <= 8'b00000001;\\n\", \"            3'b001  : W <= 8'b00000010;\\n\", \"            3'b010  : W <= 8'b00000100;\\n\", \"            3'b011  : W <= 8'b00001000;\\n\", \"            3'b100  : W <= 8'b00010000;\\n\", \"            3'b101  : W <= 8'b00100000;\\n\", \"            3'b110  : W <= 8'b01000000;\\n\", \"            default  : W <= 8'b10000000;\\n\", '            \\n', '         endcase*/\\n', '\\t\\t\\t\\t\\n', '\\n', '\\n', 'endmodule\\n']"}
{"text": "['`timescale 1ns / 1ps\\n', '\\n', 'module flipflopRS(\\n', '    \\n', '    output reg Rx,Tx,\\n', '    input W1,reset,\\n', '    input R1,\\n', '    input clock\\n', '    );\\n', '\\n', '\\treg D;\\n', '   always @(posedge clock)\\n', '\\t\\tif (!reset) begin\\n', \"\\t\\t\\tRx<=1'b0;\\n\", \"\\t\\t\\tTx<=1'b1;\\n\", '\\t\\t\\t\\n', '\\t\\tend\\n', '      else if (R1 && !W1) begin\\n', \"         Tx <= 1'b1;\\n\", \"\\t\\t\\tRx<=1'b1;\\n\", '\\t\\t\\t\\n', '      end else if (W1 && !R1) begin\\n', \"         Tx<= 1'b0;\\n\", \"\\t\\t\\tRx<=1'b0;\\n\", '\\t\\t\\t \\n', '\\t\\t\\n', '\\t\\tend\\n', '\\t\\telse begin\\n', '\\t\\t\\tTx<=Tx;\\n', '\\t\\t\\tRx<=Rx;\\n', '\\t\\t\\t\\n', '      end\\n', '\\t\\t\\t\\t\\t\\t\\n', '\\n', 'endmodule\\n']"}
{"text": "['`timescale 1ns / 1ps\\n', '\\n', 'module flipsdataw(\\n', '    input en,clock,reset,\\n', '    input [1:0] datain,\\n', '    output reg  outdata,\\n', '\\t output reg DS\\n', '    );\\n', '\\t \\n', '\\t //reg es1,es2;\\n', '\\t always @ (posedge clock) begin\\n', '\\t\\t\\n', '\\t\\tif (!reset) begin\\n', '\\t\\t\\tDS<=0;\\n', '\\t\\t\\toutdata<=0;\\n', '\\t\\t\\t//es1<=0;\\n', '\\t\\t\\t//es2<=0;\\n', '\\t\\tend\\n', '\\t\\t\\n', '\\n', '\\t\\telse if (en) begin\\n', '\\t\\t\\toutdata<=datain[0];\\n', '\\t\\t\\tDS<=datain[1];\\n', '\\t\\t\\t//es1<=datain[0];\\n', '\\t\\t\\t//es2<=datain[1];\\n', '\\t\\t\\t\\n', '\\t\\tend\\n', '\\tend\\n', '\\n', 'endmodule\\n']"}
{"text": "['`timescale 1ns/1ns\\n', '\\n', 'module impl_axi(\\n', '    // General\\n', '    input             CLK,\\n', '    input             RST,\\n', '    // Master 1 (picorv32_axi), trap\\n', '    output            trap,\\n', '    // Master 2 (spi_axi_master), SPI Slave Interface\\n', '    input             spi_axi_master_CEB, \\n', '    input             spi_axi_master_SCLK, \\n', '    input             spi_axi_master_DATA, \\n', '    output             spi_axi_master_DOUT,\\n', '    // Slave 1 (AXI_SP32B1024), NOTHING\\n', '    // Slave 2 (DAC_interface_AXI), DAC Interface\\n', '    output [11:0]     DAC_interface_AXI_DATA,\\n', '    // Slave 3 (ADC_interface_AXI), ADC Interface\\n', '    input             ADC_interface_AXI_BUSY,\\n', '    input  [9:0]     ADC_interface_AXI_DATA,\\n', '    // Slave 4 (completogpio), GPIO Control Pins\\n', '    input  [7:0]     completogpio_pindata,\\n', '    output [7:0]     completogpio_Rx,\\n', '    output [7:0]     completogpio_Tx,\\n', '    output [7:0]     completogpio_datanw,\\n', '    output [7:0]     completogpio_DSE,\\n', '    // Slave 5 (spi_axi_slave), SPI Master Interface\\n', '    output             spi_axi_slave_CEB, \\n', '    output             spi_axi_slave_SCLK, \\n', '    output             spi_axi_slave_DATA\\n', '    );\\n', '    \\n', '    // Internals\\n', '    // Picorv RST\\n', '    wire PICORV_RST;\\n', '    \\n', '    // ALL-AXI and its distribution\\n', '    // MEMORY MAP SPEC\\n', '    localparam                sword = 32;\\n', '    localparam              masters = 2;\\n', '    localparam              slaves = 5;\\n', \"    localparam [slaves*sword-1:0] addr_mask = {32'h00000000,32'h0000000F,32'h00000001,32'h00000001,32'h000003FF};\\n\", \"    localparam [slaves*sword-1:0] addr_use  = {32'h04000000,32'h00000410,32'h00000408,32'h00000400,32'h00000000};\\n\", '    \\n', '    // AXI4-lite master memory interfaces\\n', '\\n', '    wire [masters-1:0]       m_axi_awvalid;\\n', '    wire [masters-1:0]       m_axi_awready;\\n', '    wire [masters*sword-1:0] m_axi_awaddr;\\n', '    wire [masters*3-1:0]     m_axi_awprot;\\n', '\\n', '    wire [masters-1:0]       m_axi_wvalid;\\n', '    wire [masters-1:0]       m_axi_wready;\\n', '    wire [masters*sword-1:0] m_axi_wdata;\\n', '    wire [masters*4-1:0]     m_axi_wstrb;\\n', '\\n', '    wire [masters-1:0]       m_axi_bvalid;\\n', '    wire [masters-1:0]       m_axi_bready;\\n', '\\n', '    wire [masters-1:0]       m_axi_arvalid;\\n', '    wire [masters-1:0]       m_axi_arready;\\n', '    wire [masters*sword-1:0] m_axi_araddr;\\n', '    wire [masters*3-1:0]     m_axi_arprot;\\n', '\\n', '    wire [masters-1:0]       m_axi_rvalid;\\n', '    wire [masters-1:0]       m_axi_rready;\\n', '    wire [masters*sword-1:0] m_axi_rdata;\\n', '\\n', '    // AXI4-lite slave memory interfaces\\n', '\\n', '    wire [slaves-1:0]       s_axi_awvalid;\\n', '    wire [slaves-1:0]       s_axi_awready;\\n', '    wire [slaves*sword-1:0] s_axi_awaddr;\\n', '    wire [slaves*3-1:0]     s_axi_awprot;\\n', '\\n', '    wire [slaves-1:0]       s_axi_wvalid;\\n', '    wire [slaves-1:0]       s_axi_wready;\\n', '    wire [slaves*sword-1:0] s_axi_wdata;\\n', '    wire [slaves*4-1:0]     s_axi_wstrb;\\n', '\\n', '    wire [slaves-1:0]       s_axi_bvalid;\\n', '    wire [slaves-1:0]       s_axi_bready;\\n', '\\n', '    wire [slaves-1:0]       s_axi_arvalid;\\n', '    wire [slaves-1:0]       s_axi_arready;\\n', '    wire [slaves*sword-1:0] s_axi_araddr;\\n', '    wire [slaves*3-1:0]     s_axi_arprot;\\n', '\\n', '    wire [slaves-1:0]       s_axi_rvalid;\\n', '    wire [slaves-1:0]       s_axi_rready;\\n', '    wire [slaves*sword-1:0] s_axi_rdata;\\n', '\\n', '    // THE CONCENTRATION\\n', '\\n', '    wire [sword-1:0] m_axi_awaddr_o [0:masters-1];\\n', '    wire [3-1:0]     m_axi_awprot_o [0:masters-1];\\n', '    wire [sword-1:0] m_axi_wdata_o [0:masters-1];\\n', '    wire [4-1:0]     m_axi_wstrb_o [0:masters-1];\\n', '    wire [sword-1:0] m_axi_araddr_o [0:masters-1];\\n', '    wire [3-1:0]     m_axi_arprot_o [0:masters-1];\\n', '    wire [sword-1:0] m_axi_rdata_o [0:masters-1];\\n', '    wire [sword-1:0] s_axi_awaddr_o [0:slaves-1];\\n', '    wire [3-1:0]     s_axi_awprot_o [0:slaves-1];\\n', '    wire [sword-1:0] s_axi_wdata_o [0:slaves-1];\\n', '    wire [4-1:0]     s_axi_wstrb_o [0:slaves-1];\\n', '    wire [sword-1:0] s_axi_araddr_o [0:slaves-1];\\n', '    wire [3-1:0]     s_axi_arprot_o [0:slaves-1];\\n', '    wire [sword-1:0] s_axi_rdata_o [0:slaves-1];\\n', '\\n', '    wire  [sword-1:0] addr_mask_o [0:slaves-1];\\n', '    wire  [sword-1:0] addr_use_o [0:slaves-1];\\n', '    genvar k;\\n', '    generate\\n', '        for(k = 0; k < masters; k=k+1) begin\\n', '            assign m_axi_awaddr[(k+1)*sword-1:k*sword] = m_axi_awaddr_o[k];\\n', '            assign m_axi_awprot[(k+1)*3-1:k*3] = m_axi_awprot_o[k];\\n', '            assign m_axi_wdata[(k+1)*sword-1:k*sword] = m_axi_wdata_o[k];\\n', '            assign m_axi_wstrb[(k+1)*4-1:k*4] = m_axi_wstrb_o[k];\\n', '            assign m_axi_araddr[(k+1)*sword-1:k*sword] = m_axi_araddr_o[k];\\n', '            assign m_axi_arprot[(k+1)*3-1:k*3] = m_axi_arprot_o[k];\\n', '            assign m_axi_rdata_o[k] = m_axi_rdata[(k+1)*sword-1:k*sword];\\n', '        end\\n', '        for(k = 0; k < slaves; k=k+1) begin\\n', '            assign s_axi_awaddr_o[k] = s_axi_awaddr[(k+1)*sword-1:k*sword];\\n', '            assign s_axi_awprot_o[k] = s_axi_awprot[(k+1)*3-1:k*3];\\n', '            assign s_axi_wdata_o[k] = s_axi_wdata[(k+1)*sword-1:k*sword];\\n', '            assign s_axi_wstrb_o[k] = s_axi_wstrb[(k+1)*4-1:k*4];\\n', '            assign s_axi_araddr_o[k] = s_axi_araddr[(k+1)*sword-1:k*sword];\\n', '            assign s_axi_arprot_o[k] = s_axi_arprot[(k+1)*3-1:k*3];\\n', '            assign addr_mask_o[k] = addr_mask[(k+1)*sword-1:k*sword];\\n', '            assign addr_use_o[k] = addr_use[(k+1)*sword-1:k*sword];\\n', '            assign s_axi_rdata[(k+1)*sword-1:k*sword] = s_axi_rdata_o[k];\\n', '        end\\n', '    endgenerate\\n', '    \\n', '    // Slave 1 (AXI_SP32B1024), Memory Interface\\n', '    wire  [31:0]     AXI_SP32B1024_D;\\n', '    wire  [31:0]     AXI_SP32B1024_Q;\\n', '    wire  [9:0]      AXI_SP32B1024_A;\\n', '    wire             AXI_SP32B1024_CEN;\\n', '    wire             AXI_SP32B1024_WEN;\\n', '    \\n', '    // Instances\\n', '    \\n', '    // AXI INTERCONNECT, axi4_interconnect\\n', '    axi4_interconnect inst_axi4_interconnect\\n', '    (\\n', '        .CLK        (CLK),\\n', '        .RST    (RST),\\n', '        .m_axi_awvalid(m_axi_awvalid),\\n', '        .m_axi_awready(m_axi_awready),\\n', '        .m_axi_awaddr(m_axi_awaddr),\\n', '        .m_axi_awprot(m_axi_awprot),\\n', '        .m_axi_wvalid(m_axi_wvalid),\\n', '        .m_axi_wready(m_axi_wready),\\n', '        .m_axi_wdata(m_axi_wdata),\\n', '        .m_axi_wstrb(m_axi_wstrb),\\n', '        .m_axi_bvalid(m_axi_bvalid),\\n', '        .m_axi_bready(m_axi_bready),\\n', '        .m_axi_arvalid(m_axi_arvalid),\\n', '        .m_axi_arready(m_axi_arready),\\n', '        .m_axi_araddr(m_axi_araddr),\\n', '        .m_axi_arprot(m_axi_arprot),\\n', '        .m_axi_rvalid(m_axi_rvalid),\\n', '        .m_axi_rready(m_axi_rready),\\n', '        .m_axi_rdata(m_axi_rdata),\\n', '        .s_axi_awvalid(s_axi_awvalid),\\n', '        .s_axi_awready(s_axi_awready),\\n', '        .s_axi_awaddr(s_axi_awaddr),\\n', '        .s_axi_awprot(s_axi_awprot),\\n', '        .s_axi_wvalid(s_axi_wvalid),\\n', '        .s_axi_wready(s_axi_wready),\\n', '        .s_axi_wdata(s_axi_wdata),\\n', '        .s_axi_wstrb(s_axi_wstrb),\\n', '        .s_axi_bvalid(s_axi_bvalid),\\n', '        .s_axi_bready(s_axi_bready),\\n', '        .s_axi_arvalid(s_axi_arvalid),\\n', '        .s_axi_arready(s_axi_arready),\\n', '        .s_axi_araddr(s_axi_araddr),\\n', '        .s_axi_arprot(s_axi_arprot),\\n', '        .s_axi_rvalid(s_axi_rvalid),\\n', '        .s_axi_rready(s_axi_rready),\\n', '        .s_axi_rdata(s_axi_rdata)\\n', '    ); \\n', '    \\n', '    // Master 1, processor\\n', '    // For everyone in this vast processor world, address increments in 4-terms\\n', '    // For us, only increment one\\n', '    // This is a fix for this issue (as expresed on the testbench)\\n', '    // This is a little workaround for the RAM\\n', \"    wire [31:0] mriscvcore_awaddr; assign m_axi_awaddr_o[0] = {2'b00, mriscvcore_awaddr[31:2]};\\n\", \"    wire [31:0] mriscvcore_araddr; assign m_axi_araddr_o[0] = {2'b00, mriscvcore_araddr[31:2]};\\n\", '    mriscvcore mriscvcore_inst (\\n', '        .clk    (CLK            ),\\n', '        .rstn   (PICORV_RST         ),\\n', '        .trap   (trap           ),\\n', '        .AWvalid(m_axi_awvalid[0]),\\n', '        .AWready(m_axi_awready[0]),\\n', '        .AWdata (mriscvcore_awaddr),\\n', '        .AWprot (m_axi_awprot_o[0]),\\n', '        .Wvalid (m_axi_wvalid[0]),\\n', '        .Wready (m_axi_wready[0]),\\n', '        .Wdata  (m_axi_wdata_o[0]),\\n', '        .Wstrb  (m_axi_wstrb_o[0]),\\n', '        .Bvalid (m_axi_bvalid[0]),\\n', '        .Bready (m_axi_bready[0]),\\n', '        .ARvalid(m_axi_arvalid[0]),\\n', '        .ARready(m_axi_arready[0]),\\n', '        .ARdata (mriscvcore_araddr),\\n', '        .ARprot (m_axi_arprot_o[0]),\\n', '        .Rvalid (m_axi_rvalid[0]),\\n', '        .RReady (m_axi_rready[0]),\\n', '        .Rdata  (m_axi_rdata_o[0]),\\n', '        //.outirr (irq            ),\\n', \"        .inirr  (32'd0          )\\n\", '    );\\n', '    \\n', '    // Master 2, spi_axi_master\\n', '    spi_axi_master inst_spi_axi_master\\n', '    (\\n', '        .CEB(spi_axi_master_CEB), \\n', '        .SCLK(spi_axi_master_SCLK), \\n', '        .DATA(spi_axi_master_DATA), \\n', '        .DOUT(spi_axi_master_DOUT), \\n', '        .RST(RST), \\n', '        .PICORV_RST(PICORV_RST), \\n', '        .CLK(CLK), \\n', '        .axi_awvalid(m_axi_awvalid[1]), \\n', '        .axi_awready(m_axi_awready[1]), \\n', '        .axi_awaddr(m_axi_awaddr_o[1]), \\n', '        .axi_awprot(m_axi_awprot_o[1]), \\n', '        .axi_wvalid(m_axi_wvalid[1]),\\n', '        .axi_wready(m_axi_wready[1]), \\n', '        .axi_wdata(m_axi_wdata_o[1]), \\n', '        .axi_wstrb(m_axi_wstrb_o[1]), \\n', '        .axi_bvalid(m_axi_bvalid[1]), \\n', '        .axi_bready(m_axi_bready[1]),\\n', '        .axi_arvalid(m_axi_arvalid[1]), \\n', '        .axi_arready(m_axi_arready[1]), \\n', '        .axi_araddr(m_axi_araddr_o[1]), \\n', '        .axi_arprot(m_axi_arprot_o[1]), \\n', '        .axi_rvalid(m_axi_rvalid[1]),\\n', '        .axi_rready(m_axi_rready[1]), \\n', '        .axi_rdata(m_axi_rdata_o[1])\\n', '    );\\n', '    \\n', '    // Slave 1, AXI_SP32B1024\\n', '    AXI_SP32B1024 inst_AXI_SP32B1024(\\n', '        .CLK(CLK),\\n', '        .RST(RST),\\n', '        .axi_awvalid(s_axi_awvalid[0]),\\n', '        .axi_awready(s_axi_awready[0]),\\n', '        .axi_awaddr(s_axi_awaddr_o[0]),\\n', '        .axi_awprot(s_axi_awprot_o[0]),\\n', '        .axi_wvalid(s_axi_wvalid[0]),\\n', '        .axi_wready(s_axi_wready[0]),\\n', '        .axi_wdata(s_axi_wdata_o[0]),\\n', '        .axi_wstrb(s_axi_wstrb_o[0]),\\n', '        .axi_bvalid(s_axi_bvalid[0]),\\n', '        .axi_bready(s_axi_bready[0]),\\n', '        .axi_arvalid(s_axi_arvalid[0]),\\n', '        .axi_arready(s_axi_arready[0]),\\n', '        .axi_araddr(s_axi_araddr_o[0]),\\n', '        .axi_arprot(s_axi_arprot_o[0]),\\n', '        .axi_rvalid(s_axi_rvalid[0]),\\n', '        .axi_rready(s_axi_rready[0]),\\n', '        .axi_rdata(s_axi_rdata_o[0]),\\n', '        .Q(AXI_SP32B1024_Q),\\n', '        .CEN(AXI_SP32B1024_CEN),\\n', '        .WEN(AXI_SP32B1024_WEN),\\n', '        .A(AXI_SP32B1024_A),\\n', '        .D(AXI_SP32B1024_D)\\n', '    );\\n', '    // THIS IS A STANDARD CELL! YOU IDIOT!\\n', '    SP32B1024 SP32B1024_INT(\\n', '    .Q        (AXI_SP32B1024_Q),\\n', '    .CLK      (CLK),\\n', '    .CEN      (AXI_SP32B1024_CEN),\\n', '    .WEN      (AXI_SP32B1024_WEN),\\n', '    .A        (AXI_SP32B1024_A),\\n', '    .D        (AXI_SP32B1024_D)\\n', '    );\\n', '    \\n', '    // Slave 2, DAC_interface_AXI\\n', '    DAC_interface_AXI inst_DAC_interface_AXI(\\n', '        .CLK(CLK),\\n', '        .RST(RST),\\n', '        .AWVALID(s_axi_awvalid[1]),\\n', '        .WVALID(s_axi_wvalid[1]),\\n', '        .BREADY(s_axi_bready[1]),\\n', '        .AWADDR(s_axi_awaddr_o[1]),\\n', '        .WDATA(s_axi_wdata_o[1]),\\n', '        .WSTRB(s_axi_wstrb_o[1]),\\n', '        .AWREADY(s_axi_awready[1]),\\n', '        .WREADY(s_axi_wready[1]),\\n', '        .BVALID(s_axi_bvalid[1]),\\n', '        .ARVALID(s_axi_arvalid[1]),\\n', '        .RREADY(s_axi_rready[1]),\\n', '        .ARREADY(s_axi_arready[1]),\\n', '        .RVALID(s_axi_rvalid[1]),\\n', '        .RDATA(s_axi_rdata_o[1]),\\n', '        .DATA(DAC_interface_AXI_DATA)\\n', '    );\\n', '    \\n', '    //Slave 3, ADC_interface_AXI\\n', '    ADC_interface_AXI inst_ADC_interface_AXI(\\n', '        .CLK(CLK),\\n', '        .RST(RST),\\n', '        .AWVALID(s_axi_awvalid[2]),\\n', '        .WVALID(s_axi_wvalid[2]),\\n', '        .BREADY(s_axi_bready[2]),\\n', '        .AWADDR(s_axi_awaddr_o[2]),\\n', '        .WDATA(s_axi_wdata_o[2]),\\n', '        .WSTRB(s_axi_wstrb_o[2]),\\n', '        .AWREADY(s_axi_awready[2]),\\n', '        .WREADY(s_axi_wready[2]),\\n', '        .BVALID(s_axi_bvalid[2]),\\n', '        .ARADDR(s_axi_araddr_o[2]),\\n', '        .ARVALID(s_axi_arvalid[2]),\\n', '        .RREADY(s_axi_rready[2]),\\n', '        .ARREADY(s_axi_arready[2]),\\n', '        .RVALID(s_axi_rvalid[2]),\\n', '        .RDATA(s_axi_rdata_o[2]),\\n', '        .DATA(ADC_interface_AXI_DATA),\\n', '        .BUSY(ADC_interface_AXI_BUSY)\\n', '    );\\n', '    \\n', '    //Slave 4, completogpio\\n', '    completogpio inst_completogpio(\\n', '        .clock(CLK),\\n', '        .reset(RST),\\n', '        .WAddress(s_axi_awaddr_o[3]),\\n', '        .Wdata(s_axi_wdata_o[3]),\\n', '        .Rdata(s_axi_rdata_o[3]),\\n', '        .AWvalid(s_axi_awvalid[3]),\\n', '        .RAddress(s_axi_araddr_o[3]),\\n', '        .Wvalid(s_axi_wvalid[3]),\\n', '        .ARvalid(s_axi_arvalid[3]),\\n', '        .Rready(s_axi_rready[3]),\\n', '        .Bready(s_axi_bready[3]),\\n', '        .ARready(s_axi_arready[3]),\\n', '        .Rvalid(s_axi_rvalid[3]),\\n', '        .AWready(s_axi_awready[3]),\\n', '        .Wready(s_axi_wready[3]),\\n', '        .Bvalid(s_axi_bvalid[3]),\\n', '        .pindata(completogpio_pindata),\\n', '        .Rx(completogpio_Rx),\\n', '        .datanw(completogpio_datanw),\\n', '        .Tx(completogpio_Tx),\\n', '        .DSE(completogpio_DSE)\\n', '    );\\n', '    \\n', '    // Slave 5, spi_axi_slave\\n', '    spi_axi_slave inst_spi_axi_slave\\n', '    (\\n', '        .CEB(spi_axi_slave_CEB), \\n', '        .SCLK(spi_axi_slave_SCLK), \\n', '        .DATA(spi_axi_slave_DATA), \\n', '        .RST(RST), \\n', '        .CLK(CLK), \\n', '        .axi_awvalid(s_axi_awvalid[4]), \\n', '        .axi_awready(s_axi_awready[4]), \\n', '        .axi_awaddr(s_axi_awaddr_o[4]), \\n', '        .axi_awprot(s_axi_awprot_o[4]), \\n', '        .axi_wvalid(s_axi_wvalid[4]),\\n', '        .axi_wready(s_axi_wready[4]), \\n', '        .axi_wdata(s_axi_wdata_o[4]), \\n', '        .axi_wstrb(s_axi_wstrb_o[4]), \\n', '        .axi_bvalid(s_axi_bvalid[4]), \\n', '        .axi_bready(s_axi_bready[4]),\\n', '        .axi_arvalid(s_axi_arvalid[4]), \\n', '        .axi_arready(s_axi_arready[4]), \\n', '        .axi_araddr(s_axi_araddr_o[4]), \\n', '        .axi_arprot(s_axi_arprot_o[4]), \\n', '        .axi_rvalid(s_axi_rvalid[4]),\\n', '        .axi_rready(s_axi_rready[4]), \\n', '        .axi_rdata(s_axi_rdata_o[4])\\n', '    );\\n', '    \\n', 'endmodule\\n']"}
{"text": "['`timescale 1ns/1ns\\n', '\\n', 'module impl_axi_tb();\\n', '\\n', '// HELPER\\n', '\\tfunction integer clogb2;\\n', '\\t\\tinput integer value;\\n', '\\t\\tinteger \\ti;\\n', '\\t\\tbegin\\n', '\\t\\t\\tclogb2 = 0;\\n', '\\t\\t\\tfor(i = 0; 2**i < value; i = i + 1)\\n', '\\t\\t\\tclogb2 = i + 1;\\n', '\\t\\tend\\n', '\\tendfunction\\n', '\\t\\n', 'localparam\\ttries = 10;\\n', 'localparam  sword = 32;\\t\\n', 'localparam  \\t\\t\\tmasters = 2;\\n', 'localparam  \\t\\t\\tslaves = 5;\\n', '\\n', 'localparam\\timpl = 0;\\n', 'localparam\\tsyncing = 0;\\n', 'localparam\\tmax_wait = 1000000;\\n', '\\n', '// Autogen localparams\\n', '\\n', \"reg \\tCLK = 1'b0;\\n\", \"reg \\tSCLK = 1'b0;\\n\", \"reg \\tADCCLK = 1'b0;\\n\", 'reg\\t \\tRST;\\n', '\\n', 'reg  DATA;\\n', 'wire DOUT;\\n', 'reg  CEB;\\n', 'wire [11:0] \\tDAC_interface_AXI_DATA;\\n', 'reg \\t\\t\\tADC_interface_AXI_BUSY;\\n', 'reg  [9:0] \\t\\tADC_interface_AXI_DATA;\\n', 'reg  [7:0] \\t\\tcompletogpio_pindata;\\n', 'wire [7:0] \\t\\tcompletogpio_Rx;\\n', 'wire [7:0] \\t\\tcompletogpio_Tx;\\n', 'wire [7:0] \\t\\tcompletogpio_datanw;\\n', 'wire [7:0] \\t\\tcompletogpio_DSE;\\n', 'wire \\t\\t\\tspi_axi_slave_CEB; \\n', 'wire \\t\\t\\tspi_axi_slave_SCLK; \\n', 'wire \\t\\t\\tspi_axi_slave_DATA;\\n', '\\n', 'localparam numbit_instr = 2;\\t\\t\\t// Nop (00), Read(01), Write(10)\\n', 'localparam numbit_address = sword;\\n', 'localparam numbit_handshake = numbit_instr+numbit_address+sword;\\n', '\\n', 'reg [numbit_handshake-1:0] handshake;\\n', 'reg [sword-1:0] result;\\n', '\\n', '// Data per capturing\\n', 'reg [sword-1:0] cap;\\n', '\\n', 'reg stat;\\n', 'reg stats;\\n', 'reg is_o, is_ok;\\n', 'reg waiting_ok;\\n', 'integer waiting;\\n', '\\t\\n', 'integer fd1, tmp1, ifstop;\\n', 'integer PERIOD = 10 ;\\n', 'integer SPERIOD = 20 ;\\n', 'integer ADCPERIOD = 100 ;\\n', 'integer i, j, error, l;\\n', '\\t\\n', '\\t// Device under test\\n', '\\timpl_axi inst_impl_axi(\\n', '\\t\\t// General\\n', '\\t\\t.CLK(CLK),\\n', '\\t\\t.RST(RST),\\n', '\\t\\t.spi_axi_master_CEB(CEB), \\n', '\\t\\t.spi_axi_master_SCLK(SCLK), \\n', '\\t\\t.spi_axi_master_DATA(DATA), \\n', '\\t\\t.spi_axi_master_DOUT(DOUT),\\n', '\\t\\t.DAC_interface_AXI_DATA(DAC_interface_AXI_DATA),\\n', '\\t\\t.ADC_interface_AXI_BUSY(ADC_interface_AXI_BUSY),\\n', '\\t\\t.ADC_interface_AXI_DATA(ADC_interface_AXI_DATA),\\n', '\\t\\t.completogpio_pindata(completogpio_pindata),\\n', '\\t\\t.completogpio_Rx(completogpio_Rx),\\n', '\\t\\t.completogpio_Tx(completogpio_Tx),\\n', '\\t\\t.completogpio_datanw(completogpio_datanw),\\n', '\\t\\t.completogpio_DSE(completogpio_DSE),\\n', '\\t\\t.spi_axi_slave_CEB(spi_axi_slave_CEB), \\n', '\\t\\t.spi_axi_slave_SCLK(spi_axi_slave_SCLK), \\n', '\\t\\t.spi_axi_slave_DATA(spi_axi_slave_DATA)\\n', '\\t);\\n', '\\t\\n', '\\talways\\n', '\\tbegin #(SPERIOD/2) SCLK = ~SCLK; end \\n', '\\talways\\n', '\\tbegin #(PERIOD/2) CLK = ~CLK; end \\n', '\\talways\\n', '\\tbegin #(ADCPERIOD/2) ADCCLK = ~ADCCLK; end \\n', '\\t\\n', '\\t// Task for expect something (helper)\\n', '\\ttask aexpect;\\n', '\\t\\tinput [sword-1:0] av, e;\\n', '\\t\\tbegin\\n', '\\t\\t if (av == e)\\n', '\\t\\t\\t$display (\"TIME=%t.\" , $time, \" Actual value of trans=%b, expected is %b. MATCH!\", av, e);\\n', '\\t\\t else\\n', '\\t\\t  begin\\n', '\\t\\t\\t$display (\"TIME=%t.\" , $time, \" Actual value of trans=%b, expected is %b. ERROR!\", av, e);\\n', '\\t\\t\\terror = error + 1;\\n', '\\t\\t  end\\n', '\\t\\tend\\n', '\\tendtask\\n', '\\t\\n', '\\t// Our pseudo-random generator\\n', \"\\treg [63:0] xorshift64_state = 64'd88172645463325252;\\n\", '\\ttask xorshift64_next;\\n', '\\t\\tbegin\\n', '\\t\\t\\t// see page 4 of Marsaglia, George (July 2003). \"Xorshift RNGs\". Journal of Statistical Software 8 (14).\\n', '\\t\\t\\txorshift64_state = xorshift64_state ^ (xorshift64_state << 13);\\n', '\\t\\t\\txorshift64_state = xorshift64_state ^ (xorshift64_state >>  7);\\n', '\\t\\t\\txorshift64_state = xorshift64_state ^ (xorshift64_state << 17);\\n', '\\t\\tend\\n', '\\tendtask\\n', '\\t\\n', '\\t// Memory to write\\n', '\\treg [31:0] memory [0:1023];\\n', '\\tinitial $readmemh(\"firmware_mini.hex\", memory);\\n', '\\n', '\\tinitial begin\\n', '\\t\\t//$sdf_annotate(\"spi_axi_master.sdf\",inst_spi_axi_master);\\n', '\\t\\twaiting = 0;\\n', \"\\t\\twaiting_ok = 1'b0;\\n\", \"\\t\\tcap = {sword{1'b0}};\\n\", \"\\t\\tADC_interface_AXI_BUSY = 1'b0;\\n\", \"\\t\\tADC_interface_AXI_DATA = {10{1'b0}};\\n\", \"\\t\\tcompletogpio_pindata = {8{1'b0}};\\n\", \"\\t\\tis_o = 1'b0;\\n\", \"\\t\\tis_ok = 1'b0;\\n\", \"\\t\\tCEB\\t\\t= 1'b1;\\n\", \"\\t\\tCLK \\t= 1'b0;\\n\", \"\\t\\tSCLK \\t= 1'b0;\\n\", \"\\t\\tADCCLK \\t= 1'b0;\\n\", \"\\t\\tRST \\t= 1'b0;\\n\", \"\\t\\tDATA \\t= 1'b0;\\n\", \"\\t\\tstat = 1'b0;\\n\", \"\\t\\tstats = 1'b0;\\n\", '\\t\\terror = 0;\\n', \"\\t\\tresult = {sword{1'b0}};\\n\", \"\\t\\thandshake = {numbit_handshake{1'b0}};\\n\", '\\t\\t#(SPERIOD*20);\\n', \"\\t\\tRST \\t= 1'b1;\\n\", '\\t\\t#(SPERIOD*6);\\n', '\\t\\t\\n', '\\t\\t// SENDING PICORV RESET TO ZERO\\n', \"\\t\\tCEB = 1'b0;\\n\", \"\\t\\tDATA = 1'b0;\\n\", '\\t\\t#SPERIOD;\\n', \"\\t\\tDATA = 1'b0;\\n\", '\\t\\t#SPERIOD;\\t\\t// SENT \"SEND STATUS\", but we ignore totally the result\\n', '\\t\\t#(SPERIOD*(2*sword-1));\\n', \"\\t\\tDATA = 1'b0;\\t// Send to the reset\\n\", '\\t\\t#SPERIOD;\\n', \"\\t\\tCEB = 1'b1;\\n\", '\\t\\t#(SPERIOD*4);\\n', '\\t\\t\\n', '\\t\\t// WRITTING PROGRAM\\n', '\\t\\tfor(i = 0; i < 1024; i = i+1) begin\\n', '\\t\\t\\t#(SPERIOD*8);\\n', \"\\t\\t\\tCEB = 1'b0;\\n\", '\\t\\t\\t// Making handshake, writting, ordinal dir, at data program\\n', \"\\t\\t\\thandshake = {2'b10,32'h00000000|i,memory[i]};\\n\", '\\t\\t\\tfor(j = 0; j < numbit_handshake; j = j+1) begin\\n', '\\t\\t\\t\\tDATA = handshake[numbit_handshake-j-1];\\n', '\\t\\t\\t\\t#SPERIOD;\\n', '\\t\\t\\tend\\n', \"\\t\\t\\tCEB = 1'b1;\\n\", '\\t\\t\\t#(SPERIOD*4);\\n', \"\\t\\t\\tstat = 1'b1;\\n\", '\\t\\t\\t// Wait the axi handshake, SPI-POV\\n', '\\t\\t\\twhile(stat) begin\\n', \"\\t\\t\\t\\tCEB = 1'b0;\\n\", \"\\t\\t\\t\\tDATA = 1'b0;\\n\", '\\t\\t\\t\\t#SPERIOD;\\n', \"\\t\\t\\t\\tDATA = 1'b0;\\n\", '\\t\\t\\t\\t#SPERIOD;\\t\\t// SENT \"SEND STATUS\"\\n', '\\t\\t\\t\\tfor(j = 0; j < sword; j = j+1) begin\\n', '\\t\\t\\t\\t\\tresult[sword-j-1] = DOUT;\\n', '\\t\\t\\t\\t\\t#SPERIOD;\\n', '\\t\\t\\t\\tend\\n', \"\\t\\t\\t\\tCEB = 1'b1;\\n\", '\\t\\t\\t\\t#(SPERIOD*2);\\n', \"\\t\\t\\t\\tif(result[1] == 1'b0 && result[0] == 1'b0) begin\\t// CHECKING WBUSY AND BUSY\\n\", \"\\t\\t\\t\\t\\tstat = 1'b0;\\n\", '\\t\\t\\t\\tend\\n', '\\t\\t\\tend\\n', '\\t\\t\\t$display (\"SPI: Written data %x = %x\", i, memory[i]);\\n', '\\t\\t\\t#(SPERIOD*8);\\n', \"            if(memory[i] == 32'd0) i = 1024;   // Workaround\\n\", '\\t\\tend\\n', '\\t\\t\\n', '\\t\\t// SENDING PICORV RESET TO ONE\\n', \"\\t\\tCEB = 1'b0;\\n\", \"\\t\\tDATA = 1'b0;\\n\", '\\t\\t#SPERIOD;\\n', \"\\t\\tDATA = 1'b0;\\n\", '\\t\\t#SPERIOD;\\t\\t// SENT \"SEND STATUS\", but we ignore totally the result\\n', '\\t\\t#(SPERIOD*(2*sword-1));\\n', \"\\t\\tDATA = 1'b1;\\t// Send to the reset\\n\", '\\t\\t#SPERIOD;\\n', \"\\t\\tCEB = 1'b1;\\n\", '\\t\\t#(SPERIOD*4);\\n', '\\t\\t\\n', '\\t\\t$display (\"SPI: Programmed all instructions, picorv32 activated!\");\\n', '\\t\\t$timeformat(-9,0,\"ns\",7);\\n', '\\t\\t\\n', '\\t\\t// Waiting picorv to finish (Remember to put OK)\\n', '\\t\\twhile(~waiting_ok) #SPERIOD;\\n', '\\t\\t\\n', '\\t\\t// DAC_interface_AXI\\n', '\\t\\t$display(\"Doing the DAC_interface_AXI test\");\\n', '\\t\\t//$stop;\\n', '\\t\\tfor(i = 0; i < 8; i = i + 1) begin\\n', '\\t\\t\\txorshift64_next;\\n', '\\t\\t\\t#SPERIOD;\\n', '\\t\\tend\\n', '\\t\\tfor(l = 0; l < tries; l = l + 1) begin\\n', \"\\t\\t\\tCEB = 1'b0;\\n\", '\\t\\t\\t// Making handshake, writting, DAC dir, at random data \\n', \"\\t\\t\\thandshake = {2'b10,32'h00000400,xorshift64_state[31:0]};\\n\", '\\t\\t\\tfor(j = 0; j < numbit_handshake; j = j+1) begin\\n', '\\t\\t\\t\\tDATA = handshake[numbit_handshake-j-1];\\n', '\\t\\t\\t\\t#SPERIOD;\\n', '\\t\\t\\tend\\n', \"\\t\\t\\tCEB = 1'b1;\\n\", '\\t\\t\\t#(SPERIOD*4);\\n', \"\\t\\t\\tstat = 1'b1;\\n\", '\\t\\t\\t// Wait the axi handshake, SPI-POV\\n', '\\t\\t\\twhile(stat) begin\\n', \"\\t\\t\\t\\tCEB = 1'b0;\\n\", \"\\t\\t\\t\\tDATA = 1'b0;\\n\", '\\t\\t\\t\\t#SPERIOD;\\n', \"\\t\\t\\t\\tDATA = 1'b0;\\n\", '\\t\\t\\t\\t#SPERIOD;\\t\\t// SENT \"SEND STATUS\"\\n', '\\t\\t\\t\\tfor(j = 0; j < sword; j = j+1) begin\\n', '\\t\\t\\t\\t\\tresult[sword-j-1] = DOUT;\\n', '\\t\\t\\t\\t\\t#SPERIOD;\\n', '\\t\\t\\t\\tend\\n', \"\\t\\t\\t\\tCEB = 1'b1;\\n\", '\\t\\t\\t\\t#(SPERIOD*2);\\n', \"\\t\\t\\t\\tif(result[1] == 1'b0 && result[0] == 1'b0) begin\\t// CHECKING WBUSY AND BUSY\\n\", \"\\t\\t\\t\\t\\tstat = 1'b0;\\n\", '\\t\\t\\t\\tend else begin\\n', '\\t\\t\\t\\t\\t$display (\"SPI: Waiting writting to be done (%b) %x = %x\", result[2:0], 32\\'h00000400, xorshift64_state[31:0]);\\n', '\\t\\t\\t\\tend\\n', '\\t\\t\\tend\\n', '\\t\\t\\t$display (\"SPI: Written data %x = %x\", 32\\'h00000400, xorshift64_state[31:0]);\\n', '\\t\\t\\taexpect(DAC_interface_AXI_DATA, xorshift64_state[11:0]);\\n', '\\t\\t\\t\\n', '\\t\\t\\t#(SPERIOD*8);\\n', '\\t\\t\\txorshift64_next;\\n', '\\t\\tend\\n', '\\t\\t\\n', '\\t\\t// ADC_interface_AXI\\n', '\\t\\t$display(\"Doing the ADC_interface_AXI test\");\\n', '\\t\\t//$stop;\\n', '\\t\\tfor(i = 0; i < 8; i = i + 1) begin\\n', '\\t\\t\\txorshift64_next;\\n', '\\t\\t\\t#SPERIOD;\\n', '\\t\\tend\\n', '\\t\\t\\n', '\\t\\tfor(l = 0; l < tries; l = l + 1) begin\\n', \"\\t\\t\\tCEB = 1'b0;\\n\", '\\t\\t\\t// Making handshake, reading, at ADC dir, at random data (ignored)\\n', \"\\t\\t\\thandshake = {2'b01,32'h00000408,32'h00000000};\\n\", '\\t\\t\\tfor(j = 0; j < numbit_handshake; j = j+1) begin\\n', '\\t\\t\\t\\tDATA = handshake[numbit_handshake-j-1];\\n', '\\t\\t\\t\\t#SPERIOD;\\n', '\\t\\t\\tend\\n', \"\\t\\t\\tCEB = 1'b1;\\n\", '\\t\\t\\t#(SPERIOD*3);\\n', \"\\t\\t\\tstat = 1'b1;\\n\", '\\t\\t\\t// Wait the axi handshake, SPI-POV\\n', '\\t\\t\\twhile(stat) begin\\n', \"\\t\\t\\t\\tCEB = 1'b0;\\n\", \"\\t\\t\\t\\tDATA = 1'b0;\\n\", '\\t\\t\\t\\t#SPERIOD;\\n', \"\\t\\t\\t\\tDATA = 1'b0;\\n\", '\\t\\t\\t\\t#SPERIOD;\\t\\t// SENT \"SEND STATUS\"\\n', '\\t\\t\\t\\tfor(j = 0; j < sword; j = j+1) begin\\n', '\\t\\t\\t\\t\\tresult[sword-j-1] = DOUT;\\n', '\\t\\t\\t\\t\\t#SPERIOD;\\n', '\\t\\t\\t\\tend\\n', \"\\t\\t\\t\\tCEB = 1'b1;\\n\", '\\t\\t\\t\\t#(SPERIOD*3);\\n', \"\\t\\t\\t\\tif(result[2] == 1'b0 && result[0] == 1'b0) begin\\t// CHECKING RBUSY AND BUSY\\n\", \"\\t\\t\\t\\t\\tstat = 1'b0;\\n\", '\\t\\t\\t\\tend else begin\\n', '\\t\\t\\t\\t\\t$display (\"SPI: Waiting reading to be done (%b) %x\", result[2:0], 32\\'h00000408);\\n', '\\t\\t\\t\\tend\\n', '\\t\\t\\tend\\n', \"\\t\\t\\tCEB = 1'b0;\\n\", \"\\t\\t\\tDATA = 1'b1;\\n\", '\\t\\t\\t#SPERIOD;\\n', \"\\t\\t\\tDATA = 1'b1;\\n\", '\\t\\t\\t#SPERIOD;\\t\\t// SEND \"SEND RDATA\"\\n', '\\t\\t\\tfor(j = 0; j < sword; j = j+1) begin\\n', '\\t\\t\\t\\tresult[sword-j-1] = DOUT;\\n', '\\t\\t\\t\\t#SPERIOD;\\n', '\\t\\t\\tend\\n', \"\\t\\t\\tCEB = 1'b1;\\n\", '\\t\\t\\t$display (\"SPI: Read data %x = %x\", 32\\'h00000408, result);\\n', '\\t\\t\\taexpect(result[9:0], xorshift64_state[9:0]);\\n', '\\t\\t\\t\\n', '\\t\\t\\t#(SPERIOD*8);\\n', '\\t\\t\\txorshift64_next;\\n', '\\t\\tend\\n', '\\t\\t\\n', '\\t\\t\\n', '\\t\\t// completogpio\\n', '\\t\\t$display(\"Doing the completegpio test\");\\n', '\\t\\t//$stop;\\n', '\\t\\tfor(i = 0; i < 8; i = i + 1) begin\\n', '\\t\\t\\txorshift64_next;\\n', '\\t\\t\\t#SPERIOD;\\n', '\\t\\tend\\n', '\\t\\t\\n', '\\t\\tfor(l = 0; l < tries; l = l + 1) begin\\n', '\\t\\t\\t// READING TEST\\n', '\\t\\t\\tfor(i = 0; i < 8; i = i+1) begin\\n', '\\t\\t\\t\\t#(SPERIOD*8);\\n', \"\\t\\t\\t\\tCEB = 1'b0;\\n\", '\\t\\t\\t\\t// Making handshake, reading, at completogpio dir, at random data (ignored)\\n', \"\\t\\t\\t\\thandshake = {2'b01,32'h00000410 | i, 32'h00000000};\\n\", '\\t\\t\\t\\tfor(j = 0; j < numbit_handshake; j = j+1) begin\\n', '\\t\\t\\t\\t\\tDATA = handshake[numbit_handshake-j-1];\\n', '\\t\\t\\t\\t\\t#SPERIOD;\\n', '\\t\\t\\t\\tend\\n', \"\\t\\t\\t\\tCEB = 1'b1;\\n\", '\\t\\t\\t\\t#(SPERIOD*3);\\n', \"\\t\\t\\t\\tstat = 1'b1;\\n\", '\\t\\t\\t\\t// Wait the axi handshake, SPI-POV\\n', '\\t\\t\\t\\twhile(stat) begin\\n', \"\\t\\t\\t\\t\\tCEB = 1'b0;\\n\", \"\\t\\t\\t\\t\\tDATA = 1'b0;\\n\", '\\t\\t\\t\\t\\t#SPERIOD;\\n', \"\\t\\t\\t\\t\\tDATA = 1'b0;\\n\", '\\t\\t\\t\\t\\t#SPERIOD;\\t\\t// SENT \"SEND STATUS\"\\n', '\\t\\t\\t\\t\\tfor(j = 0; j < sword; j = j+1) begin\\n', '\\t\\t\\t\\t\\t\\tresult[sword-j-1] = DOUT;\\n', '\\t\\t\\t\\t\\t\\t#SPERIOD;\\n', '\\t\\t\\t\\t\\tend\\n', \"\\t\\t\\t\\t\\tCEB = 1'b1;\\n\", '\\t\\t\\t\\t\\t#(SPERIOD*3);\\n', \"\\t\\t\\t\\t\\tif(result[2] == 1'b0 && result[0] == 1'b0) begin\\t// CHECKING RBUSY AND BUSY\\n\", \"\\t\\t\\t\\t\\t\\tstat = 1'b0;\\n\", '\\t\\t\\t\\t\\tend\\n', '\\t\\t\\t\\tend\\n', \"\\t\\t\\t\\tCEB = 1'b0;\\n\", \"\\t\\t\\t\\tDATA = 1'b1;\\n\", '\\t\\t\\t\\t#SPERIOD;\\n', \"\\t\\t\\t\\tDATA = 1'b1;\\n\", '\\t\\t\\t\\t#SPERIOD;\\t\\t// SEND \"SEND RDATA\"\\n', '\\t\\t\\t\\tfor(j = 0; j < sword; j = j+1) begin\\n', '\\t\\t\\t\\t\\tresult[sword-j-1] = DOUT;\\n', '\\t\\t\\t\\t\\t#SPERIOD;\\n', '\\t\\t\\t\\tend\\n', \"\\t\\t\\t\\tCEB = 1'b1;\\n\", '\\t\\t\\t\\t$display (\"SPI: Read data %x = %x\", 32\\'h00000410|i, result);\\n', '\\t\\t\\t\\taexpect(result[0], xorshift64_state[i]);\\n', '\\t\\t\\tend\\n', '\\t\\t\\t$display (\"completogpio: Making test of Rx\");\\n', \"\\t\\t\\taexpect(completogpio_Rx, 8'b11111111);\\n\", '\\t\\t\\t// WRITTING TEST\\n', '\\t\\t\\tfor(i = 0; i < 8; i = i+1) begin\\n', '\\t\\t\\t\\t#(SPERIOD*8);\\n', \"\\t\\t\\t\\tCEB = 1'b0;\\n\", '\\t\\t\\t\\t// Making handshake, writting, completogpio dir, at random data \\n', \"\\t\\t\\t\\thandshake = {2'b10, 32'h00000410 | i, 32'h00000004 | xorshift64_state[16+i]};\\n\", '\\t\\t\\t\\tfor(j = 0; j < numbit_handshake; j = j+1) begin\\n', '\\t\\t\\t\\t\\tDATA = handshake[numbit_handshake-j-1];\\n', '\\t\\t\\t\\t\\t#SPERIOD;\\n', '\\t\\t\\t\\tend\\n', \"\\t\\t\\t\\tCEB = 1'b1;\\n\", '\\t\\t\\t\\t#(SPERIOD*4);\\n', \"\\t\\t\\t\\tstat = 1'b1;\\n\", '\\t\\t\\t\\t// Wait the axi handshake, SPI-POV\\n', '\\t\\t\\t\\twhile(stat) begin\\n', \"\\t\\t\\t\\t\\tCEB = 1'b0;\\n\", \"\\t\\t\\t\\t\\tDATA = 1'b0;\\n\", '\\t\\t\\t\\t\\t#SPERIOD;\\n', \"\\t\\t\\t\\t\\tDATA = 1'b0;\\n\", '\\t\\t\\t\\t\\t#SPERIOD;\\t\\t// SENT \"SEND STATUS\"\\n', '\\t\\t\\t\\t\\tfor(j = 0; j < sword; j = j+1) begin\\n', '\\t\\t\\t\\t\\t\\tresult[sword-j-1] = DOUT;\\n', '\\t\\t\\t\\t\\t\\t#SPERIOD;\\n', '\\t\\t\\t\\t\\tend\\n', \"\\t\\t\\t\\t\\tCEB = 1'b1;\\n\", '\\t\\t\\t\\t\\t#(SPERIOD*2);\\n', \"\\t\\t\\t\\t\\tif(result[1] == 1'b0 && result[0] == 1'b0) begin\\t// CHECKING WBUSY AND BUSY\\n\", \"\\t\\t\\t\\t\\t\\tstat = 1'b0;\\n\", '\\t\\t\\t\\t\\tend\\n', '\\t\\t\\t\\tend\\n', '\\t\\t\\t\\t$display (\"SPI: Written data %x = %x\", 32\\'h00000410 | i, 32\\'h00000000 | xorshift64_state[16+i]);\\n', '\\t\\t\\t\\taexpect(completogpio_datanw[i], xorshift64_state[16+i]);\\n', '\\t\\t\\tend\\n', '\\t\\t\\t$display (\"completogpio: Making test of Tx\");\\n', \"\\t\\t\\taexpect(completogpio_Tx, 8'b00000000);\\n\", '\\t\\t\\t\\n', '\\t\\t\\t#(SPERIOD*8);\\n', '\\t\\t\\txorshift64_next;\\n', '\\t\\tend\\n', '\\t\\t\\n', '\\t\\tif (error == 0)\\n', '\\t\\t\\t$display(\"All match\");\\n', '\\t\\telse\\n', '\\t\\t\\t$display(\"Mismatches = %d\", error);\\n', '\\t\\t$finish;\\n', '\\t\\t//$stop;\\n', '\\t\\t\\n', '\\tend\\n', '\\t\\n', '\\t// SPI AXI SLAVE interface simulation\\n', '\\talways @(posedge spi_axi_slave_SCLK) begin\\n', \"\\t\\tif(spi_axi_slave_CEB == 1'b0) begin\\n\", \"\\t\\t\\tstats <= 1'b1;\\n\", '\\t\\t\\tcap <= {cap[sword-2:0], spi_axi_slave_DATA};\\n', \"\\t\\tend else if(stats == 1'b1) begin\\n\", \"\\t\\t\\tstats <= 1'b0;\\n\", \"\\t\\t\\tif(cap == 68 || (cap == 79 && is_o == 1'b1) || (cap == 78 && is_o == 1'b1) || (cap == 69 && is_o == 1'b1))\\n\", \"\\t\\t\\t\\tis_o <= 1'b1;\\n\", '\\t\\t\\telse\\n', \"\\t\\t\\t\\tis_o <= 1'b0;\\n\", \"\\t\\t\\tif(cap == 69 && is_o == 1'b1)\\n\", \"\\t\\t\\t\\tis_ok <= 1'b1;\\n\", '`ifdef VERBOSE\\n', '\\t\\t\\tif (32 <= cap && cap < 128)\\n', '\\t\\t\\t\\t$display(\"OUT: \\'%c\\'\", cap);\\n', '\\t\\t\\telse\\n', '\\t\\t\\t\\t$display(\"OUT: %3d\", cap);\\n', '`else\\n', '\\t\\t\\t$write(\"%c\", cap);\\n', '\\t\\t\\t$fflush();\\n', '`endif\\n', '\\t\\tend\\n', '\\tend\\n', '\\t\\n', '\\t// Waiting to end program\\n', '\\talways @(posedge SCLK) begin\\n', \"\\t\\tif(waiting_ok == 1'b0) begin\\n\", \"\\t\\t\\tif(is_ok == 1'b1) begin\\n\", '\\t\\t\\t\\t\\n', '\\t\\t\\t\\t// SENDING PICORV RESET TO ZERO\\n', \"\\t\\t\\t\\t/*CEB = 1'b0;\\n\", \"\\t\\t\\t\\tDATA = 1'b0;\\n\", '\\t\\t\\t\\t#SPERIOD;\\n', \"\\t\\t\\t\\tDATA = 1'b0;\\n\", '\\t\\t\\t\\t#SPERIOD;\\t\\t// SENT \"SEND STATUS\", but we ignore totally the result\\n', '\\t\\t\\t\\t#(SPERIOD*(2*sword-1));\\n', \"\\t\\t\\t\\tDATA = 1'b0;\\t// Send to the reset\\n\", '\\t\\t\\t\\t#SPERIOD;\\n', \"\\t\\t\\t\\tCEB = 1'b1;\\n\", '\\t\\t\\t\\t#(SPERIOD*4);*/\\n', '\\t\\n', '\\t\\t\\t\\t$display (\"Program Suceed! Reseted the picorv\");\\n', '\\t\\t\\t\\t\\n', \"\\t\\t\\t\\t// screw it! we'll put all this to reset\\n\", \"\\t\\t\\t\\t/*RST = 1'b0;\\n\", '\\t\\t\\t\\t#(SPERIOD*4);\\n', \"\\t\\t\\t\\tRST = 1'b1;*/\\n\", '\\t\\t\\t\\n', \"\\t\\t\\t\\twaiting_ok = 1'b1;\\n\", '\\t\\t\\t\\t#(SPERIOD*4);\\n', '\\t\\t\\t\\n', '\\t\\t\\tend else begin\\n', '\\t\\t\\t\\twaiting = waiting + 1;\\n', '\\t\\t\\t\\tif(waiting >= max_wait) begin\\n', \"\\t\\t\\t\\t\\twaiting_ok = 1'b1;\\n\", '\\t\\t\\t\\t\\t$display(\"TIMEOUT!, PLEASE DO NOT FORGET TO PUT \\'DONE\\' ON THE FIRMWARE\");\\n', '\\t\\t\\t\\t\\t$finish;\\n', '\\t\\t\\t\\tend\\n', '\\t\\t\\t\\txorshift64_next;\\n', '\\t\\t\\tend\\n', '\\t\\tend \\n', '\\tend\\n', '\\t\\n', '\\t// ADC simulation\\n', '\\talways @(posedge ADCCLK) begin\\n', '\\t\\tADC_interface_AXI_BUSY <= ~ADC_interface_AXI_BUSY;\\n', '\\t\\tADC_interface_AXI_DATA <= xorshift64_state[9:0];\\n', '\\tend\\n', '\\t\\n', '\\t// completogpio simulation\\n', '\\talways @* begin\\n', '\\t\\tcompletogpio_pindata = xorshift64_state[7:0];\\n', '\\tend\\n', '\\n', 'endmodule\\n']"}
{"text": "['`timescale 1ns / 1ps\\n', '/////////////////////////////////////////////////////////////////////////////////\\n', 'module latchW(\\n', '    input  clock,\\n', '    input  reset,\\n', '    input  AWvalid,\\n', '    input [31:0] WAddres,\\n', '    output reg [2:0] LWAddres\\n', '    );\\n', '\\t \\n', '\\t always @ ( posedge clock )\\n', '            if (!reset) begin\\n', \"                LWAddres=3'b0;\\n\", '\\t\\t\\tend else if (AWvalid) begin\\n', '\\t\\t\\t\\tLWAddres=WAddres[2:0];\\n', '\\t\\t\\tend\\n', '\\n', 'endmodule\\n']"}
{"text": "['`timescale 1ns / 1ps\\n', '\\n', '//////////////////////////////////////////////////////////////////////////////////\\n', 'module macstate2(\\n', '\\t input clock,\\n', '    input reset,\\n', '    output reg [4:0] salida,\\n', '    input AWvalid,\\n', '    input Wvalid,Bready,\\n', '    input ARvalid,Rready,\\n', '    input vel\\n', '    );\\n', '\\t\\n', '\\treg [3:0] state,nexstate;\\n', \"\\tparameter reposo = 4'd0000;\\n\", \"   parameter lectura = 4'b0001;\\n\", \"   parameter waitR = 4'b0010;\\n\", \"   parameter escritura = 4'b0011;\\n\", \"   parameter waitW = 4'b0100;\\n\", \"   parameter delay1 = 4'b0101;\\n\", \"\\tparameter delay2=4'b0110;\\n\", \"\\tparameter delay3=4'b0111;\\n\", \"\\tparameter delay4=4'b1000;\\n\", \"\\tparameter delay5=4'b1001;\\n\", \"\\tparameter delay6=4'b1010;\\n\", \"\\tparameter delay7=4'b1011;\\n\", '\\t//asignacion estado siguiente\\n', '\\t\\n', '\\talways @(state,ARvalid,AWvalid,Wvalid,Bready,Rready,vel) begin\\n', '\\t\\tcase (state)\\n', '            reposo : begin\\n', '               if (ARvalid) begin\\n', '                  nexstate = lectura;\\n', '\\t\\t\\t\\t\\tend\\n', '               else if (AWvalid) begin\\n', '                  nexstate = waitW;\\n', '\\t\\t\\t\\t\\tend\\n', '               else begin\\n', '                  nexstate = reposo;\\n', '\\t\\t\\t\\t\\tend\\n', '            end\\n', '\\t\\t\\t\\t\\n', '            lectura : begin\\n', '            \\tif(!vel) begin\\n', '                   nexstate = delay4;\\n', '                end\\n', '                else begin\\n', '                \\tnexstate=delay7;\\n', '                end\\n', '                \\n', '            end\\n', '\\t\\t\\t\\t\\n', '            delay4 : begin\\n', '               nexstate=delay5;\\n', '            end\\n', '\\t\\t\\t\\t\\n', '            delay5 : begin\\n', '               nexstate=delay6;\\n', '            end\\n', '\\t\\t\\t\\t\\n', '\\t\\t\\t\\tdelay6: begin\\n', '\\t\\t\\t\\t\\tnexstate=delay7;\\n', '\\t\\t\\t\\tend\\n', '\\t\\t\\t\\t\\n', '\\t\\t\\t\\tdelay7: begin\\n', '\\t\\t\\t\\t\\tif (Rready) begin\\n', '\\t\\t\\t\\t\\t\\tnexstate=reposo;\\n', '\\t\\t\\t\\t\\tend\\n', '\\t\\t\\t\\t\\telse begin\\n', '\\t\\t\\t\\t\\t\\tnexstate=delay7;\\n', '\\t\\t\\t\\t\\tend\\n', '\\t\\t\\t\\tend\\n', '\\t\\t\\t\\t\\n', '\\t\\t\\t\\twaitW : begin\\n', '               if (Wvalid) begin\\n', '                  nexstate = escritura;\\n', '\\t\\t\\t\\t\\tend\\n', '               else begin\\n', '                  nexstate = waitW;\\n', '\\t\\t\\t\\t\\tend\\n', '            end\\n', '\\t\\t\\t\\t\\n', '\\t\\t\\tescritura : begin\\n', '              if (!vel) begin\\n', '              \\tnexstate=delay1;\\n', '              end\\n', '              else begin\\n', '              \\tnexstate=delay3;\\n', '              end\\n', '            end\\n', '\\t\\t\\t\\t\\n', '\\t\\t\\t\\t\\n', '            delay1 : begin\\n', '\\t\\t\\t\\t\\tnexstate=delay2;\\n', '            end\\n', '\\t\\t\\t\\t\\n', '\\t\\t\\t\\tdelay2: begin\\n', '\\t\\t\\t\\t\\tnexstate=delay3;\\n', '\\t\\t\\t\\tend\\n', '\\t\\t\\t\\t\\n', '\\t\\t\\t\\tdelay3: begin\\n', '\\t\\t\\t\\t\\tif (Bready) begin\\n', '\\t\\t\\t\\t\\t\\tnexstate=reposo;\\n', '\\t\\t\\t\\t\\tend\\n', '\\t\\t\\t\\t\\telse begin\\n', '\\t\\t\\t\\t\\t\\tnexstate=delay3;\\n', '\\t\\t\\t\\t\\tend\\n', '\\t\\t\\t\\tend\\n', '\\t\\t\\t\\t\\t\\n', '            default : begin  // Fault Recovery\\n', '               nexstate = reposo;\\n', '            end   \\n', '         endcase\\n', '\\t\\tend\\n', '\\t\\t\\n', '\\t\\t// asignacion sincrona\\n', '\\t\\talways @(posedge clock)\\n', \"\\t\\t\\tif(reset == 0) state <= 3'b0;\\n\", '\\t\\t\\telse state <= nexstate;\\n', '\\t\\t\\n', '\\t\\t// asignacion salidas\\n', '\\t\\t\\n', '\\t\\talways @(state) begin\\n', \"\\t\\t\\tif (state==4'b0)\\n\", \"\\t\\t\\t\\tsalida=5'b00000;\\n\", \"\\t\\t\\telse if(state==4'b1)\\n\", \"\\t\\t\\t\\tsalida=5'b10000;\\n\", \"\\t\\t\\telse if (state==4'b010)\\n\", \"\\t\\t\\t\\tsalida=5'b11000;\\n\", \"\\t\\t\\telse if (state==4'b011)\\n\", \"\\t\\t\\t\\tsalida=5'b00110;\\n\", \"\\t\\t\\telse if (state==4'b100)\\n\", \"\\t\\t\\t\\tsalida=5'b00100;\\n\", \"\\t\\t\\telse if (state==4'b101)\\n\", \"\\t\\t\\t\\tsalida=5'b00110;\\n\", \"\\t\\t\\telse if (state==4'b110)\\n\", \"\\t\\t\\t\\tsalida=5'b00110;\\n\", \"\\t\\t\\telse if (state==4'b111)\\n\", \"\\t\\t\\t\\tsalida=5'b00111;\\n\", \"\\t\\t\\telse if (state==4'b1000)\\n\", \"\\t\\t\\t\\tsalida=5'b10000;\\n\", \"\\t\\t\\telse if (state==4'b1001)\\n\", \"\\t\\t\\t\\tsalida=5'b10000;\\n\", \"\\t\\t\\telse if (state==4'b1010)\\n\", \"\\t\\t\\t\\tsalida=5'b10000;\\n\", \"\\t\\t\\telse if (state==4'b1011)\\n\", \"\\t\\t\\t\\tsalida=5'b11000;\\n\", '\\t\\t\\telse\\n', \"\\t\\t\\t\\tsalida=5'b0;\\n\", '\\t\\t\\t\\n', '\\t\\t\\t\\n', '\\t\\tend\\n', '\\t\\t\\t\\t\\n', '\\t\\t\\t\\t\\n', '\\t\\t\\n', '\\t\\t\\n', '\\n', 'endmodule\\n']"}
{"text": "['module priencr #(parameter width = 64)\\n', '  (\\n', '   input [width-1:0] decode,\\n', '   output [log2(width)-1:0] encode,\\n', '   output valid\\n', '   );\\n', '\\n', '  function [31:0] log2;\\n', '    input reg [31:0] value;\\n', '    begin\\n', '      value = value-1;\\n', '      for (log2=0; value>0; log2=log2+1)\\n', '\\tvalue = value>>1;\\n', '    end\\n', '  endfunction\\n', '\\n', '  generate\\n', '    if (width == 2)\\n', '      begin\\n', '\\tassign valid = |decode;\\n', '\\tassign encode = decode[1];\\n', '      end\\n', '    else if (width & (width-1))\\n', \"      priencr #(1<<log2(width)) priencr ({1<<log2(width) {1'b0}} | decode,\\n\", '                                         encode,valid);\\n', '    else\\n', '      begin\\n', '\\twire [log2(width)-2:0] encode_low;\\n', '\\twire [log2(width)-2:0] encode_high;\\n', '\\twire valid_low, valid_high;\\n', '\\tpriencr #(width>>1) low(decode[(width>>1)-1:0],encode_low,valid_low);\\n', '\\tpriencr #(width>>1) high(decode[width-1:width>>1],encode_high,valid_high);\\n', '\\tassign valid = valid_low | valid_high;\\n', \"\\tassign encode = valid_high ? {1'b1,encode_high} : {1'b0,encode_low};\\n\", '      end\\n', '  endgenerate\\n', 'endmodule']"}
{"text": "['// Created by: CKDUR\\n', '`timescale 1ns/1ns\\n', '\\n', 'module spi_axi_master #\\n', '\\t(\\n', '\\tparameter  \\t\\t\\tsword = 32,\\n', '\\n', '\\t/*\\n', '\\tIMPLEMENTATION SETTINGS\\n', '\\timpl: 0,Classic  1,Simulation\\n', '\\tsyncing: 0,ByCounterAndDecoder  1,ByMirrorShiftRegister\\n', '\\t*/\\n', '\\tparameter\\t\\t\\timpl = 0,\\n', '\\tparameter\\t\\t\\tsyncing = 0\\n', '\\t)\\n', '\\n', '\\t(\\n', '\\t// SPI INTERFACE\\n', '\\tinput\\t\\t\\t\\t\\t\\t\\tCEB,\\n', '\\tinput\\t\\t\\t\\t\\t\\t\\tSCLK,\\n', '\\tinput \\t\\t\\t\\t\\t\\t\\tDATA,\\n', '\\toutput \\t\\t\\t\\t\\t\\t\\tDOUT,\\n', '\\t// MISC\\n', '\\tinput\\t\\t\\t\\t\\t\\t\\tRST,\\n', '\\toutput \\t\\t\\t\\t\\t\\t\\tPICORV_RST,\\n', '\\t// AXI4-lite master memory interface\\n', '\\t\\n', '\\tinput\\t\\t\\t   CLK,\\n', '\\toutput reg         axi_awvalid,\\n', '\\tinput              axi_awready,\\n', '\\toutput [sword-1:0] axi_awaddr,\\n', '\\toutput [3-1:0]     axi_awprot,\\n', '\\n', '\\toutput reg         axi_wvalid,\\n', '\\tinput              axi_wready,\\n', '\\toutput [sword-1:0] axi_wdata,\\n', '\\toutput [4-1:0]     axi_wstrb,\\n', '\\n', '\\tinput              axi_bvalid,\\n', '\\toutput reg         axi_bready,\\n', '\\n', '\\toutput reg         axi_arvalid,\\n', '\\tinput              axi_arready,\\n', '\\toutput [sword-1:0] axi_araddr,\\n', '\\toutput [3-1:0]     axi_arprot,\\n', '\\n', '\\tinput              axi_rvalid,\\n', '\\toutput reg         axi_rready,\\n', '\\tinput  [sword-1:0] axi_rdata\\n', '    );\\n', '\\n', '\\t// HELPER\\n', '\\tfunction integer clogb2;\\n', '\\t\\tinput integer value;\\n', '\\t\\tinteger \\ti;\\n', '\\t\\tbegin\\n', '\\t\\t\\tclogb2 = 0;\\n', '\\t\\t\\tfor(i = 0; 2**i < value; i = i + 1)\\n', '\\t\\t\\tclogb2 = i + 1;\\n', '\\t\\tend\\n', '\\tendfunction\\n', '\\t\\n', '\\tlocalparam numbit_instr = 2;\\t\\t\\t// Nop (00), Read(01), Write(10)\\n', '\\tlocalparam numbit_address = sword;\\n', '\\tlocalparam numbit_handshake = numbit_instr+numbit_address+sword;\\n', '\\tlocalparam numbit_posthandshake = numbit_handshake;\\n', '\\treg\\t[numbit_handshake-1:0]\\tsft_reg;\\t// Because address + word width\\n', '\\treg \\t\\t\\t\\t\\t\\twe;\\t\\t\\t// Instruction Write\\n', '\\treg \\t\\t\\t\\t\\t\\tre;\\t\\t\\t// Instruction Read\\n', '\\tgenvar\\t\\t\\t\\t\\t\\ti;\\n', '\\n', '\\t// Serial to paralell registers\\n', '\\talways @ (posedge SCLK)\\n', '\\tbegin\\n', \"\\t\\tif(RST == 1'b0)\\n\", '\\t\\tbegin\\n', \"\\t\\t\\tsft_reg <= {numbit_handshake{1'b0}};\\t\\t\\t\\t\\t// RESET\\n\", \"\\t\\tend else if(CEB == 1'b0)\\n\", '\\t\\tbegin\\n', '\\t\\t\\tsft_reg <= {sft_reg[numbit_handshake-2:0], DATA};\\t\\t// SHIFT\\n', '\\t\\tend else\\n', '\\t\\tbegin\\n', '\\t\\t\\tsft_reg <= sft_reg;\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// NOTHING\\n', '\\t\\tend\\n', '\\tend\\n', '\\n', '\\t// SPI SYNC\\n', '\\t/*\\n', '\\tsync\\n', '\\t+ + + + + + + + + + + + + + + + + + + + + + + + + + + +\\n', '\\t*/\\n', '\\twire [numbit_posthandshake - 1:0] sync;\\n', '\\tgenerate if(syncing) begin\\n', '\\t\\tlocalparam numbit_counter = clogb2(numbit_posthandshake);\\n', '\\t\\treg [numbit_counter - 1:0] counter;\\n', '\\t\\talways @ (posedge SCLK)\\n', '\\t\\tbegin\\n', \"\\t\\t\\tif(RST == 1'b0)\\n\", '\\t\\t\\tbegin\\n', \"\\t\\t\\t\\tcounter <= {numbit_counter{1'b0}};\\t\\t// RESET \\n\", '\\t\\t\\tend else \\n', '\\t\\t\\tbegin\\n', \"\\t\\t\\t\\tif(CEB == 1'b1)\\n\", '\\t\\t\\t\\tbegin\\n', \"\\t\\t\\t\\t\\tcounter <= {numbit_counter{1'b0}};\\t// RESET\\n\", '\\t\\t\\t\\tend else\\n', '\\t\\t\\t\\tbegin\\n', '\\t\\t\\t\\t\\tcounter <= counter+1;\\t\\t\\t\\t// COUNTING\\n', '\\t\\t\\t\\tend\\n', '\\t\\t\\tend\\n', '\\t\\tend\\n', '\\t\\tassign sync = (1 << counter);\\n', '\\tend else begin\\n', '\\t\\treg [numbit_posthandshake - 1:0] counter;\\n', '\\t\\talways @ (posedge SCLK)\\n', '\\t\\tbegin\\n', \"\\t\\t\\tif (RST == 1'b0)\\n\", '\\t\\t\\tbegin\\n', \"\\t\\t\\t\\tcounter <= {{(numbit_posthandshake-1){1'b0}},1'b1};\\t\\t// RESET \\n\", '\\t\\t\\tend else \\n', '\\t\\t\\tbegin\\n', \"\\t\\t\\t\\tif (CEB == 1'b1)\\n\", '\\t\\t\\t\\tbegin\\n', \"\\t\\t\\t\\t\\tcounter <= {{(numbit_posthandshake-1){1'b0}},1'b1};\\t// RESET \\n\", '\\t\\t\\t\\tend else\\n', '\\t\\t\\t\\tbegin\\n', '\\t\\t\\t\\t\\tcounter <= counter << 1;\\t\\t\\t\\t\\t\\t// SHIFTING\\n', '\\t\\t\\t\\tend\\n', '\\t\\t\\tend\\n', '\\t\\tend\\n', '\\t\\tassign sync = counter;\\n', '\\tend\\n', '\\tendgenerate\\n', '\\n', '\\t// we / re capturing\\n', '\\talways @ (posedge SCLK)\\n', '\\tbegin\\n', \"\\t\\tif(RST == 1'b0)\\n\", '\\t\\tbegin\\n', \"\\t\\t\\twe <= 1'b0;\\t\\t\\t\\t\\t// RESET\\n\", \"\\t\\t\\tre <= 1'b0;\\n\", \"\\t\\tend else if(CEB == 1'b0)\\n\", '\\t\\tbegin\\n', \"\\t\\t\\tif(sync[0] == 1'b1) begin\\t\\n\", '\\t\\t\\t\\twe <= DATA;\\n', '\\t\\t\\tend\\n', \"\\t\\t\\tif(sync[1] == 1'b1) begin\\n\", '\\t\\t\\t\\tre <= DATA;\\n', '\\t\\t\\tend\\n', '\\t\\tend\\n', '\\tend\\n', '\\t\\n', '\\t// A_ADDR and AWDATA capturing\\n', '\\treg [sword-1:0] A_ADDR;\\n', '\\treg [sword-1:0] WDATA;\\n', '\\treg PICORV_RST_SPI;\\n', '\\talways @ (posedge SCLK)\\n', '\\tbegin\\n', \"\\t\\tif(RST == 1'b0)\\n\", '\\t\\tbegin\\n', \"\\t\\t\\tA_ADDR <= {sword{1'b0}};\\n\", \"\\t\\t\\tWDATA <= {sword{1'b0}};\\n\", \"\\t\\t\\tPICORV_RST_SPI <= 1'b0;\\n\", \"\\t\\tend else if(CEB == 1'b0)\\n\", '\\t\\tbegin\\n', \"\\t\\t\\tif(sync[numbit_instr+sword-1] == 1'b1 && (re ^ we)) begin\\t\\n\", '\\t\\t\\t\\tA_ADDR <= {sft_reg[sword-2:0], DATA};\\n', '\\t\\t\\tend\\n', \"\\t\\t\\tif(sync[numbit_instr+sword+sword-1] == 1'b1 && we == 1'b1) begin\\n\", '\\t\\t\\t\\tWDATA <= {sft_reg[sword-2:0], DATA};\\n', '\\t\\t\\tend\\n', \"\\t\\t\\tif(sync[numbit_instr+sword+sword-1] == 1'b1 && we == 1'b0 && re == 1'b0) begin\\n\", '\\t\\t\\t\\tPICORV_RST_SPI <= DATA;\\n', '\\t\\t\\tend\\n', '\\t\\tend\\n', '\\tend\\n', '\\t\\n', '\\t// Logic and stuff\\n', '\\twire ens, encap_status, encap_rdata, enos_status, enos_rdata, en_status, en_rdata, is_hand;\\n', '\\twire encap, enos, rdata_notstatus;\\n', '\\t// Enable shifting\\n', '\\tassign ens = |sync[sword+2-1:2];\\n', '\\t// Enable output shifting for status data\\n', '\\tassign enos_status = ~we & ~re & ens;\\n', '\\t// Enable output shifting for read data\\n', '\\tassign enos_rdata = we & re & ens;\\n', '\\t// Enable capture for status data (Treat DATA as re)\\n', '\\tassign encap_status = ~we & ~DATA & sync[1];\\n', '\\t// Enable capture for read data (Treat DATA as re)\\n', '\\tassign encap_rdata = we & DATA & sync[1];\\n', '\\t// Enable output shifting (General)\\n', '\\tassign enos = enos_status | enos_rdata;\\n', '\\t// Enable capture (General)\\n', '\\tassign encap = encap_status | encap_rdata;\\n', '\\t// Enable status data (Info for FSM)\\n', '\\tassign en_status = enos_status | encap_status;\\n', '\\t// Enable read data (Info for FSM)\\n', '\\tassign en_rdata = enos_rdata | encap_rdata;\\n', '\\t// Is handshake (Info for FSM)\\n', '\\tassign is_hand = en_status | en_rdata;\\n', '\\t// Mux selector about capturing data\\n', '\\tassign rdata_notstatus = encap_rdata;\\n', '\\t\\n', '\\t// The status flags\\n', '\\twire [sword-1:0] status;\\n', '\\treg busy;\\t// TODO: FSM\\n', '\\treg rbusy;\\n', '\\treg wbusy;\\n', '\\twire [2:0] status_sclk;\\n', '\\tbus_sync_sf #(.impl(0), .sword(3)) bus_sync_status(.CLK1(CLK), .CLK2(SCLK), .RST(RST), .data_in({rbusy, wbusy, busy}), .data_out(status_sclk));\\n', \"\\tassign status = {{(sword-3){1'b0}}, status_sclk};\\n\", '\\t\\n', '\\t// The data reading\\n', '\\treg encap_data;\\t// TODO: FSM\\n', '\\treg [sword-1:0] rdata;\\n', '\\talways @ (posedge CLK)\\n', '\\tbegin\\n', \"\\t\\tif(RST == 1'b0)\\n\", '\\t\\tbegin\\n', \"\\t\\t\\trdata <= {sword{1'b0}};\\t\\t// RESET\\n\", \"\\t\\tend else if(encap_data == 1'b1)\\n\", '\\t\\tbegin\\n', '\\t\\t\\trdata <= axi_rdata;\\t\\t\\t\\t// CAPTURE\\n', '\\t\\tend\\n', '\\tend\\n', '\\twire [sword-1:0] rdata_sclk;\\n', '\\tbus_sync_sf #(.impl(0), .sword(sword)) bus_sync_rdata(.CLK1(CLK), .CLK2(SCLK), .RST(RST), .data_in(rdata), .data_out(rdata_sclk));\\n', '\\t\\n', '\\t// Assignment to the value to capture\\n', '\\twire [sword-1:0] bus_rd;\\n', '\\tassign bus_rd = rdata_notstatus?rdata_sclk:status;\\n', '\\n', '\\t// Capturing the value to put to Dout\\n', '\\treg [sword-1:0] bus_cap;\\n', '\\talways @ (posedge SCLK)\\n', '\\tbegin\\n', \"\\t\\tif(RST == 1'b0)\\n\", '\\t\\tbegin\\n', \"\\t\\t\\tbus_cap <= {sword{1'b0}};\\t\\t// RESET\\n\", \"\\t\\tend else if(encap == 1'b1)\\n\", '\\t\\tbegin\\n', '\\t\\t\\tbus_cap <= bus_rd;\\t\\t\\t\\t// CAPTURE\\n', \"\\t\\tend else if(enos == 1'b1)\\n\", '\\t\\tbegin\\n', '\\t\\t\\tbus_cap <= bus_cap << 1;\\t\\t// SHIFT\\n', '\\t\\tend\\n', '\\tend\\n', '\\n', '\\t// with reg for putting the Dout\\n', '\\twire DOUTNOZ;\\n', '\\tassign DOUTNOZ = bus_cap[sword-1];\\n', '\\t\\n', '\\t// tri-state out\\n', '\\twire enoz;\\n', '\\tassign enoz = enos;\\n', \"\\tassign DOUT = enoz&!CEB?DOUTNOZ:1'bz;\\n\", '\\t\\n', '\\t// Axi assignments\\n', '\\twire [sword-1:0] A_ADDR_CLK;\\n', '\\twire [sword-1:0] WDATA_CLK;\\n', '\\tbus_sync_sf #(.impl(1), .sword(sword+sword)) bus_sync_axi_bus(.CLK1(SCLK), .CLK2(CLK), .RST(RST), .data_in({A_ADDR, WDATA}), .data_out({A_ADDR_CLK, WDATA_CLK}));\\n', '\\tassign axi_araddr = A_ADDR_CLK;\\n', '\\tassign axi_awaddr = A_ADDR_CLK;\\n', '\\tassign axi_wdata = WDATA_CLK;\\n', \"\\tassign axi_wstrb = 4'b1111;\\t// Write all, SPI must write all unless inside the handshake is the wstrb\\n\", \"\\tassign axi_awprot = 3'b000; // Unpriviliged access, Secure access, Data access\\n\", \"\\tassign axi_arprot = 3'b000; // Unpriviliged access, Secure access, Data access\\n\", '\\t\\n', '\\t// THE FSM\\n', '\\t// Declare state register\\n', '\\treg\\t\\t[3:0]state;\\n', '\\twire we_clk, re_clk, fini_spi_clk;\\n', '\\t// This is for sync the data with the fini_spi\\n', '\\treg fini_spi;\\n', '\\talways @(posedge SCLK) begin\\n', \"\\t\\tif(RST == 1'b0) begin\\n\", \"\\t\\t\\tfini_spi <= 1'b0;\\n\", '\\t\\tend else begin\\n', '\\t\\t\\tfini_spi <= sync[numbit_instr+sword+sword-1];\\n', '\\t\\tend\\n', '\\tend\\n', '\\tbus_sync_sf #(.impl(1), .sword(4)) bus_sync_state_machine(.CLK1(SCLK), .CLK2(CLK), .RST(RST), .data_in({PICORV_RST_SPI, we, re, fini_spi}), .data_out({PICORV_RST, we_clk, re_clk, fini_spi_clk}));\\n', '\\t\\n', '\\t// Declare states\\n', '\\tparameter st0_nothing = 0, st1_awvalid = 1, st2_wvalid = 2, st3_wwait = 3, st4_bready = 4, st5_arvalid = 5, st6_rwait = 6, st7_rready = 7, st8_wait_spi = 8;\\n', '\\t\\n', '\\t// Output depends only on the state\\n', '\\talways @ (state) begin\\n', '\\t\\tcase (state)\\n', '\\t\\t\\tst0_nothing: begin\\n', \"\\t\\t\\t\\taxi_arvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_awvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_wvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_rready = 1'b0;\\n\", \"\\t\\t\\t\\taxi_bready = 1'b0;\\n\", \"\\t\\t\\t\\tbusy = 1'b0;\\n\", \"\\t\\t\\t\\trbusy = 1'b0;\\n\", \"\\t\\t\\t\\twbusy = 1'b0;\\n\", \"\\t\\t\\t\\tencap_data = 1'b0; end\\n\", '\\t\\t\\tst1_awvalid: begin\\n', \"\\t\\t\\t\\taxi_arvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_awvalid = 1'b1;\\n\", \"\\t\\t\\t\\taxi_wvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_rready = 1'b0;\\n\", \"\\t\\t\\t\\taxi_bready = 1'b0;\\n\", \"\\t\\t\\t\\tbusy = 1'b1;\\n\", \"\\t\\t\\t\\trbusy = 1'b0;\\n\", \"\\t\\t\\t\\twbusy = 1'b1;\\n\", \"\\t\\t\\t\\tencap_data = 1'b0; end\\n\", '\\t\\t\\tst2_wvalid: begin\\n', \"\\t\\t\\t\\taxi_arvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_awvalid = 1'b1;\\n\", \"\\t\\t\\t\\taxi_wvalid = 1'b1;\\n\", \"\\t\\t\\t\\taxi_rready = 1'b0;\\n\", \"\\t\\t\\t\\taxi_bready = 1'b0;\\n\", \"\\t\\t\\t\\tbusy = 1'b1;\\n\", \"\\t\\t\\t\\trbusy = 1'b0;\\n\", \"\\t\\t\\t\\twbusy = 1'b1;\\n\", \"\\t\\t\\t\\tencap_data = 1'b0; end\\n\", '\\t\\t\\tst3_wwait: begin\\n', \"\\t\\t\\t\\taxi_arvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_awvalid = 1'b1;\\n\", \"\\t\\t\\t\\taxi_wvalid = 1'b1;\\n\", \"\\t\\t\\t\\taxi_rready = 1'b0;\\n\", \"\\t\\t\\t\\taxi_bready = 1'b0;\\n\", \"\\t\\t\\t\\tbusy = 1'b1;\\n\", \"\\t\\t\\t\\trbusy = 1'b0;\\n\", \"\\t\\t\\t\\twbusy = 1'b1;\\n\", \"\\t\\t\\t\\tencap_data = 1'b0; end\\n\", '\\t\\t\\tst4_bready: begin\\n', \"\\t\\t\\t\\taxi_arvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_awvalid = 1'b1;\\n\", \"\\t\\t\\t\\taxi_wvalid = 1'b1;\\n\", \"\\t\\t\\t\\taxi_rready = 1'b0;\\n\", \"\\t\\t\\t\\taxi_bready = 1'b1;\\n\", \"\\t\\t\\t\\tbusy = 1'b1;\\n\", \"\\t\\t\\t\\trbusy = 1'b0;\\n\", \"\\t\\t\\t\\twbusy = 1'b1;\\n\", \"\\t\\t\\t\\tencap_data = 1'b0; end\\n\", '\\t\\t\\tst5_arvalid: begin\\n', \"\\t\\t\\t\\taxi_arvalid = 1'b1;\\n\", \"\\t\\t\\t\\taxi_awvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_wvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_rready = 1'b0;\\n\", \"\\t\\t\\t\\taxi_bready = 1'b0;\\n\", \"\\t\\t\\t\\tbusy = 1'b1;\\n\", \"\\t\\t\\t\\trbusy = 1'b1;\\n\", \"\\t\\t\\t\\twbusy = 1'b0;\\n\", \"\\t\\t\\t\\tencap_data = 1'b0; end\\n\", '\\t\\t\\tst6_rwait: begin\\n', \"\\t\\t\\t\\taxi_arvalid = 1'b1;\\n\", \"\\t\\t\\t\\taxi_awvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_wvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_rready = 1'b0;\\n\", \"\\t\\t\\t\\taxi_bready = 1'b0;\\n\", \"\\t\\t\\t\\tbusy = 1'b1;\\n\", \"\\t\\t\\t\\trbusy = 1'b1;\\n\", \"\\t\\t\\t\\twbusy = 1'b0;\\n\", \"\\t\\t\\t\\tencap_data = 1'b0; end\\n\", '\\t\\t\\tst7_rready: begin\\n', \"\\t\\t\\t\\taxi_arvalid = 1'b1;\\n\", \"\\t\\t\\t\\taxi_awvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_wvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_rready = 1'b1;\\n\", \"\\t\\t\\t\\taxi_bready = 1'b0;\\n\", \"\\t\\t\\t\\tbusy = 1'b1;\\n\", \"\\t\\t\\t\\trbusy = 1'b1;\\n\", \"\\t\\t\\t\\twbusy = 1'b0;\\n\", \"\\t\\t\\t\\tencap_data = 1'b1; end\\n\", '\\t\\t\\tst8_wait_spi: begin\\n', \"\\t\\t\\t\\taxi_arvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_awvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_wvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_rready = 1'b0;\\n\", \"\\t\\t\\t\\taxi_bready = 1'b0;\\n\", \"\\t\\t\\t\\tbusy = 1'b1;\\n\", \"\\t\\t\\t\\trbusy = 1'b0;\\n\", \"\\t\\t\\t\\twbusy = 1'b0;\\n\", \"\\t\\t\\t\\tencap_data = 1'b0; end\\n\", '\\t\\t\\tdefault: begin\\n', \"\\t\\t\\t\\taxi_arvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_awvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_wvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_rready = 1'b0;\\n\", \"\\t\\t\\t\\taxi_bready = 1'b0;\\n\", \"\\t\\t\\t\\tbusy = 1'b0;\\n\", \"\\t\\t\\t\\trbusy = 1'b0;\\n\", \"\\t\\t\\t\\twbusy = 1'b0;\\n\", \"\\t\\t\\t\\tencap_data = 1'b0; end\\n\", '\\t\\tendcase\\n', '\\tend\\n', '\\t\\n', '\\t// Determine the next state\\n', '\\talways @ (posedge CLK) begin\\n', \"\\t\\tif (RST == 1'b0)\\n\", '\\t\\t\\tstate <= st0_nothing;\\n', '\\t\\telse\\n', '\\t\\t\\tcase (state)\\n', '\\t\\t\\t\\tst0_nothing:\\n', '\\t\\t\\t\\t\\tif(we_clk & ~re_clk & fini_spi_clk)\\n', '\\t\\t\\t\\t\\t\\tstate <= st1_awvalid;\\n', '\\t\\t\\t\\t\\telse if(re_clk & ~we_clk & fini_spi_clk)\\n', '\\t\\t\\t\\t\\t\\tstate <= st5_arvalid;\\n', '\\t\\t\\t\\t\\telse\\n', '\\t\\t\\t\\t\\t\\tstate <= st0_nothing;\\n', '\\t\\t\\t\\tst1_awvalid:\\n', '\\t\\t\\t\\t\\tif (axi_awready)\\n', '\\t\\t\\t\\t\\t\\tstate <= st2_wvalid;\\n', '\\t\\t\\t\\t\\telse\\n', '\\t\\t\\t\\t\\t\\tstate <= st1_awvalid;\\n', '\\t\\t\\t\\tst2_wvalid:\\n', '\\t\\t\\t\\t\\tif (axi_wready)\\n', '\\t\\t\\t\\t\\t\\tstate <= st3_wwait;\\n', '\\t\\t\\t\\t\\telse\\n', '\\t\\t\\t\\t\\t\\tstate <= st2_wvalid;\\n', '\\t\\t\\t\\tst3_wwait:\\n', '\\t\\t\\t\\t\\tif (axi_bvalid)\\n', '\\t\\t\\t\\t\\t\\tstate <= st4_bready;\\n', '\\t\\t\\t\\t\\telse\\n', '\\t\\t\\t\\t\\t\\tstate <= st3_wwait;\\n', '\\t\\t\\t\\tst4_bready:\\n', '\\t\\t\\t\\t\\tstate <= st8_wait_spi;\\n', '\\t\\t\\t\\tst5_arvalid:\\n', '\\t\\t\\t\\t\\tif (axi_arready)\\n', '\\t\\t\\t\\t\\t\\tstate <= st6_rwait;\\n', '\\t\\t\\t\\t\\telse\\n', '\\t\\t\\t\\t\\t\\tstate <= st5_arvalid;\\n', '\\t\\t\\t\\tst6_rwait:\\n', '\\t\\t\\t\\t\\tif (axi_rvalid)\\n', '\\t\\t\\t\\t\\t\\tstate <= st7_rready;\\n', '\\t\\t\\t\\t\\telse\\n', '\\t\\t\\t\\t\\t\\tstate <= st6_rwait;\\n', '\\t\\t\\t\\tst7_rready:\\n', '\\t\\t\\t\\t\\tstate <= st8_wait_spi;\\n', '\\t\\t\\t\\tst8_wait_spi:\\n', '\\t\\t\\t\\t\\tif(~fini_spi_clk)\\n', '\\t\\t\\t\\t\\t\\tstate <= st0_nothing;\\n', '\\t\\t\\t\\t\\telse\\n', '\\t\\t\\t\\t\\t\\tstate <= st8_wait_spi;\\n', '\\t\\t\\t\\tdefault:\\n', '\\t\\t\\t\\t\\tstate <= st0_nothing;\\n', '\\t\\t\\tendcase\\n', '\\tend\\n', '\\n', 'endmodule\\n']"}
{"text": "['`timescale 1ns/1ns\\n', '\\n', 'module spi_axi_master_tb();\\n', '\\n', '// HELPER\\n', '\\tfunction integer clogb2;\\n', '\\t\\tinput integer value;\\n', '\\t\\tinteger \\ti;\\n', '\\t\\tbegin\\n', '\\t\\t\\tclogb2 = 0;\\n', '\\t\\t\\tfor(i = 0; 2**i < value; i = i + 1)\\n', '\\t\\t\\tclogb2 = i + 1;\\n', '\\t\\tend\\n', '\\tendfunction\\n', '\\t\\n', 'localparam\\ttries = 10;\\n', 'localparam  \\t\\t\\tsword = 32;\\n', '\\n', 'localparam\\t\\t\\timpl = 0;\\n', 'localparam\\t\\t\\tsyncing = 0;\\n', '\\n', '// Autogen localparams\\n', '\\n', \"reg \\tCLK = 1'b0;\\n\", \"reg \\tSCLK = 1'b0;\\n\", 'reg\\t \\tRST;\\n', '\\n', '// AXI4-lite slave memory interfaces\\n', '\\n', 'wire             axi_awvalid;\\n', 'reg              axi_awready;\\n', 'wire [sword-1:0] axi_awaddr;\\n', 'wire [3-1:0]     axi_awprot;\\n', '\\n', 'wire             axi_wvalid;\\n', 'reg              axi_wready;\\n', 'wire [sword-1:0] axi_wdata;\\n', 'wire [4-1:0]     axi_wstrb;\\n', '\\n', 'reg              axi_bvalid;\\n', 'wire             axi_bready;\\n', '\\n', 'wire             axi_arvalid;\\n', 'reg              axi_arready;\\n', 'wire [sword-1:0] axi_araddr;\\n', 'wire [3-1:0]     axi_arprot;\\n', '\\n', 'reg              axi_rvalid;\\n', 'wire             axi_rready;\\n', 'reg  [sword-1:0] axi_rdata;\\n', '\\n', 'reg DATA;\\n', 'wire DOUT;\\n', 'reg CEB;\\n', '\\n', 'wire PICORV_RST;\\n', '\\n', 'localparam numbit_instr = 2;\\t\\t\\t// Nop (00), Read(01), Write(10)\\n', 'localparam numbit_address = sword;\\n', 'localparam numbit_handshake = numbit_instr+numbit_address+sword;\\n', '\\n', 'reg [numbit_handshake-1:0] handshake;\\n', 'reg [sword-1:0] result;\\n', '\\n', 'reg stat;\\n', '\\t\\n', '\\tinteger \\tfd1, tmp1, ifstop;\\n', '\\tinteger PERIOD = 8 ;\\n', '\\tinteger SPERIOD = 20 ;\\n', '\\tinteger i, j, error, l;\\n', '\\t\\n', '\\t\\n', '\\tspi_axi_master /*#\\n', '\\t(\\n', '\\t.sword(sword),\\n', '\\t.impl(impl),\\n', '\\t.syncing(syncing)\\n', '\\t) */\\n', '\\tinst_spi_axi_master\\n', '\\t(\\n', '\\t.SCLK\\t\\t(SCLK),\\n', '\\t.CEB\\t(CEB),\\n', '\\t.DATA\\t(DATA),\\n', '\\t.DOUT\\t(DOUT),\\n', '\\t.RST\\t(RST),\\n', '\\t.CLK\\t\\t(CLK),\\n', '\\t.PICORV_RST(PICORV_RST),\\n', '\\t.axi_awvalid(axi_awvalid),\\n', '\\t.axi_awready(axi_awready),\\n', '\\t.axi_awaddr(axi_awaddr),\\n', '\\t.axi_awprot(axi_awprot),\\n', '\\t.axi_wvalid(axi_wvalid),\\n', '\\t.axi_wready(axi_wready),\\n', '\\t.axi_wdata(axi_wdata),\\n', '\\t.axi_wstrb(axi_wstrb),\\n', '\\t.axi_bvalid(axi_bvalid),\\n', '\\t.axi_bready(axi_bready),\\n', '\\t.axi_arvalid(axi_arvalid),\\n', '\\t.axi_arready(axi_arready),\\n', '\\t.axi_araddr(axi_araddr),\\n', '\\t.axi_arprot(axi_arprot),\\n', '\\t.axi_rvalid(axi_rvalid),\\n', '\\t.axi_rready(axi_rready),\\n', '\\t.axi_rdata(axi_rdata)\\n', '\\t); \\n', '\\t\\n', '\\talways\\n', '\\tbegin #(SPERIOD/2) SCLK = ~SCLK; end \\n', '\\talways\\n', '\\tbegin #(PERIOD/2) CLK = ~CLK; end \\n', '\\n', '\\ttask aexpect;\\n', '\\t\\tinput [sword-1:0] av, e;\\n', '\\t\\tbegin\\n', '\\t\\t if (av == e)\\n', '\\t\\t\\t$display (\"TIME=%t.\" , $time, \" Actual value of trans=%b, expected is %b. MATCH!\", av, e);\\n', '\\t\\t else\\n', '\\t\\t  begin\\n', '\\t\\t\\t$display (\"TIME=%t.\" , $time, \" Actual value of trans=%b, expected is %b. ERROR!\", av, e);\\n', '\\t\\t\\terror = error + 1;\\n', '\\t\\t  end\\n', '\\t\\tend\\n', '\\tendtask\\n', '\\t\\n', \"\\treg [63:0] xorshift64_state = 64'd88172645463325252;\\n\", '\\n', '\\ttask xorshift64_next;\\n', '\\t\\tbegin\\n', '\\t\\t\\t// see page 4 of Marsaglia, George (July 2003). \"Xorshift RNGs\". Journal of Statistical Software 8 (14).\\n', '\\t\\t\\txorshift64_state = xorshift64_state ^ (xorshift64_state << 13);\\n', '\\t\\t\\txorshift64_state = xorshift64_state ^ (xorshift64_state >>  7);\\n', '\\t\\t\\txorshift64_state = xorshift64_state ^ (xorshift64_state << 17);\\n', '\\t\\tend\\n', '\\tendtask\\n', '\\n', '\\n', '\\tinitial begin\\n', '\\t\\t$sdf_annotate(\"spi_axi_master.sdf\",inst_spi_axi_master);\\n', \"\\t\\tCEB\\t\\t= 1'b1;\\n\", \"\\t\\tCLK \\t= 1'b0;\\n\", \"\\t\\tSCLK \\t= 1'b0;\\n\", \"\\t\\tRST \\t= 1'b0;\\n\", \"\\t\\tDATA \\t= 1'b0;\\n\", \"\\t\\tstat = 1'b0;\\n\", '\\t\\terror = 0;\\n', \"\\t\\taxi_awready = 1'b0;\\n\", \"\\t\\taxi_wready = 1'b0;\\n\", \"\\t\\taxi_bvalid = 1'b0;\\n\", \"\\t\\taxi_arready = 1'b0;\\n\", \"\\t\\taxi_rvalid = 1'b0;\\n\", \"\\t\\taxi_rdata = {sword{1'b0}};\\n\", \"\\t\\tresult = {sword{1'b0}};\\n\", \"\\t\\thandshake = {numbit_handshake{1'b0}};\\n\", '\\t\\t#(SPERIOD*20);\\n', \"\\t\\tRST \\t= 1'b1;\\n\", '\\t\\t\\n', '\\t\\t#(SPERIOD*6);\\n', '\\t\\t\\n', '\\t\\t// SENDING PICORV RESET TO ZERO\\n', \"\\t\\tCEB = 1'b0;\\n\", \"\\t\\tDATA = 1'b0;\\n\", '\\t\\t#SPERIOD;\\n', \"\\t\\tDATA = 1'b0;\\n\", '\\t\\t#SPERIOD;\\t\\t// SENT \"SEND STATUS\", but we ignore totally the result\\n', '\\t\\t#(SPERIOD*(2*sword-1));\\n', \"\\t\\tDATA = 1'b0;\\t// Send to the reset\\n\", '\\t\\t#SPERIOD;\\n', \"\\t\\tCEB = 1'b1;\\n\", '\\t\\t#(SPERIOD*4);\\n', '\\t\\t\\n', '\\t\\t$display(\"The PICORV_RST is on ZERO? %b\", PICORV_RST);\\n', '\\t\\t\\n', '\\t\\t// WRITTING TEST\\n', '\\t\\tfor(i = 0; i < tries; i = i+1) begin\\n', '\\t\\t\\t#(SPERIOD*8);\\n', \"\\t\\t\\tCEB = 1'b0;\\n\", '\\t\\t\\t// Making handshake, writting, at random dir, at random data\\n', \"\\t\\t\\thandshake = {2'b10,xorshift64_state};\\n\", '\\t\\t\\tfor(j = 0; j < numbit_handshake; j = j+1) begin\\n', '\\t\\t\\t\\tDATA = handshake[numbit_handshake-j-1];\\n', '\\t\\t\\t\\t#SPERIOD;\\n', '\\t\\t\\tend\\n', \"\\t\\t\\tCEB = 1'b1;\\n\", '\\t\\t\\t#SPERIOD;\\n', \"\\t\\t\\tstat = 1'b1;\\n\", '\\t\\t\\t// Wait the axi handshake, SPI-POV\\n', '\\t\\t\\twhile(stat) begin\\n', \"\\t\\t\\t\\tCEB = 1'b0;\\n\", \"\\t\\t\\t\\tDATA = 1'b0;\\n\", '\\t\\t\\t\\t#SPERIOD;\\n', \"\\t\\t\\t\\tDATA = 1'b0;\\n\", '\\t\\t\\t\\t#SPERIOD;\\t\\t// SENT \"SEND STATUS\"\\n', '\\t\\t\\t\\tfor(j = 0; j < sword; j = j+1) begin\\n', '\\t\\t\\t\\t\\tresult[sword-j-1] = DOUT;\\n', '\\t\\t\\t\\t\\t#SPERIOD;\\n', '\\t\\t\\t\\tend\\n', \"\\t\\t\\t\\tCEB = 1'b1;\\n\", '\\t\\t\\t\\t#(SPERIOD*2);\\n', \"\\t\\t\\t\\tif(result[1] == 1'b0 && result[0] == 1'b0) begin\\t// CHECKING WBUSY AND BUSY\\n\", \"\\t\\t\\t\\t\\tstat = 1'b0;\\n\", '\\t\\t\\t\\tend\\n', '\\t\\t\\tend\\n', '\\t\\t\\t$display (\"SPI: Task: WData\");\\n', '\\t\\t\\txorshift64_next;\\n', '\\t\\t\\t#(SPERIOD*8);\\n', '\\t\\tend\\n', '\\t\\t\\n', '\\t\\t// READING TEST\\n', '\\t\\tfor(i = 0; i < tries; i = i+1) begin\\n', '\\t\\t\\t#(SPERIOD*8);\\n', \"\\t\\t\\tCEB = 1'b0;\\n\", '\\t\\t\\t// Making handshake, reading, at random dir, at random data (ignored)\\n', \"\\t\\t\\thandshake = {2'b01,xorshift64_state};\\n\", '\\t\\t\\tfor(j = 0; j < numbit_handshake; j = j+1) begin\\n', '\\t\\t\\t\\tDATA = handshake[numbit_handshake-j-1];\\n', '\\t\\t\\t\\t#SPERIOD;\\n', '\\t\\t\\tend\\n', \"\\t\\t\\tCEB = 1'b1;\\n\", '\\t\\t\\t#(SPERIOD*3);\\n', \"\\t\\t\\tstat = 1'b1;\\n\", '\\t\\t\\t// Wait the axi handshake, SPI-POV\\n', '\\t\\t\\twhile(stat) begin\\n', \"\\t\\t\\t\\tCEB = 1'b0;\\n\", \"\\t\\t\\t\\tDATA = 1'b0;\\n\", '\\t\\t\\t\\t#SPERIOD;\\n', \"\\t\\t\\t\\tDATA = 1'b0;\\n\", '\\t\\t\\t\\t#SPERIOD;\\t\\t// SENT \"SEND STATUS\"\\n', '\\t\\t\\t\\tfor(j = 0; j < sword; j = j+1) begin\\n', '\\t\\t\\t\\t\\tresult[sword-j-1] = DOUT;\\n', '\\t\\t\\t\\t\\t#SPERIOD;\\n', '\\t\\t\\t\\tend\\n', \"\\t\\t\\t\\tCEB = 1'b1;\\n\", '\\t\\t\\t\\t#(SPERIOD*3);\\n', \"\\t\\t\\t\\tif(result[2] == 1'b0 && result[0] == 1'b0) begin\\t// CHECKING RBUSY AND BUSY\\n\", \"\\t\\t\\t\\t\\tstat = 1'b0;\\n\", '\\t\\t\\t\\tend\\n', '\\t\\t\\tend\\n', '\\t\\t\\t\\n', \"\\t\\t\\tCEB = 1'b0;\\n\", \"\\t\\t\\tDATA = 1'b1;\\n\", '\\t\\t\\t#SPERIOD;\\n', \"\\t\\t\\tDATA = 1'b1;\\n\", '\\t\\t\\t#SPERIOD;\\t\\t// SEND \"SEND RDATA\"\\n', '\\t\\t\\tfor(j = 0; j < sword; j = j+1) begin\\n', '\\t\\t\\t\\tresult[sword-j-1] = DOUT;\\n', '\\t\\t\\t\\t#SPERIOD;\\n', '\\t\\t\\tend\\n', \"\\t\\t\\tCEB = 1'b1;\\n\", '\\t\\t\\t$display (\"SPI: Task: RData\");\\n', '\\t\\t\\taexpect(result, xorshift64_state[31:0]);\\n', '\\t\\t\\txorshift64_next;\\n', '\\t\\t\\t#(SPERIOD*8);\\n', '\\t\\tend\\n', '\\t\\t\\n', '\\t\\t// SENDING PICORV RESET TO ONE\\n', \"\\t\\tCEB = 1'b0;\\n\", \"\\t\\tDATA = 1'b0;\\n\", '\\t\\t#SPERIOD;\\n', \"\\t\\tDATA = 1'b0;\\n\", '\\t\\t#SPERIOD;\\t\\t// SENT \"SEND STATUS\", but we ignore totally the result\\n', '\\t\\t#(SPERIOD*(2*sword-1));\\n', \"\\t\\tDATA = 1'b1;\\t// Send to the reset\\n\", '\\t\\t#SPERIOD;\\n', \"\\t\\tCEB = 1'b1;\\n\", '\\t\\t#(SPERIOD*4);\\n', '\\t\\t$display(\"The PICORV_RST is on ONE? %b\", PICORV_RST);\\n', '\\t\\t\\n', '\\t\\t$timeformat(-9,0,\"ns\",7);\\n', '\\t\\t#(SPERIOD*8) if (error == 0)\\n', '\\t\\t\\t\\t\\t$display(\"All match\");\\n', '\\t\\t\\t\\telse\\n', '\\t\\t\\t\\t\\t$display(\"Mismatches = %d\", error);\\n', '\\t\\t$finish;\\n', '\\tend\\n', '\\t\\n', '\\talways @(posedge CLK) begin\\n', '\\t\\tif(axi_arvalid && !axi_arready && !axi_rready) begin\\n', \"\\t\\t\\taxi_arready = 1'b1;\\n\", \"\\t\\t\\taxi_rvalid = 1'b1;\\n\", '\\t\\t\\taxi_rdata = xorshift64_state[31:0];\\n', '\\t\\t\\t$display (\"AXI: Task: RAddr\");\\n', '\\t\\t\\taexpect(axi_araddr, xorshift64_state[63:32]);\\n', '\\t\\tend else if(axi_rready) begin\\n', \"\\t\\t\\taxi_arready = 1'b0;\\n\", \"\\t\\t\\taxi_rvalid = 1'b0;\\n\", '\\t\\tend\\n', '\\t\\t\\n', '\\t\\t\\n', '\\t\\tif(axi_awvalid && !axi_awready && !axi_bready) begin\\n', \"\\t\\t\\taxi_awready = 1'b1;\\n\", '\\t\\t\\t$display (\"AXI: Task: WAddr\");\\n', '\\t\\t\\taexpect(axi_awaddr, xorshift64_state[63:32]);\\n', '\\t\\tend else if(axi_wvalid && !axi_wready && !axi_bready) begin\\n', \"\\t\\t\\taxi_wready = 1'b1;\\n\", \"\\t\\t\\taxi_bvalid = 1'b1;\\n\", '\\t\\t\\t$display (\"AXI: Task: WData\");\\n', '\\t\\t\\taexpect(axi_wdata, xorshift64_state[31:0]);\\n', '\\t\\tend else if(axi_bready) begin\\n', \"\\t\\t\\taxi_awready = 1'b0;\\n\", \"\\t\\t\\taxi_wready = 1'b0;\\n\", \"\\t\\t\\taxi_bvalid = 1'b0;\\n\", '\\t\\tend\\n', '\\tend\\n', '\\n', 'endmodule\\n']"}
{"text": "['// Created by: CKDUR\\n', '`timescale 1ns/1ns\\n', '\\n', 'module spi_axi_slave #\\n', '\\t(\\n', '\\tparameter  \\t\\t\\tsword = 32,\\n', '\\tparameter\\t\\t\\tnumbit_divisor = 1,\\t// The SCLK will be CLK/2^(numbit_divisor-1)\\n', '\\n', '\\t/*\\n', '\\tIMPLEMENTATION SETTINGS\\n', '\\timpl: 0,Classic  1,Simulation\\n', '\\tsyncing: 0,ByCounterAndDecoder  1,ByMirrorShiftRegister\\n', '\\t*/\\n', '\\tparameter\\t\\t\\timpl = 0,\\n', '\\tparameter\\t\\t\\tsyncing = 0\\n', '\\t)\\n', '\\n', '\\t(\\n', '\\t// SPI INTERFACE\\n', '\\toutput\\t\\t\\t\\t\\t\\t\\tCEB,\\n', '\\toutput\\t\\t\\t\\t\\t\\t\\tSCLK,\\n', '\\toutput \\t\\t\\t\\t\\t\\t\\tDATA,\\n', '\\t// MISC\\n', '\\tinput\\t\\t\\t\\t\\t\\t\\tRST,\\n', '\\t// AXI4-lite slave memory interface\\n', '\\t\\n', '\\tinput\\t\\t\\t  CLK,\\n', '\\tinput         \\t  axi_awvalid,\\n', '\\toutput            axi_awready,\\n', '\\tinput [sword-1:0] axi_awaddr,\\n', '\\tinput [3-1:0]     axi_awprot,\\n', '\\n', '\\tinput         \\t  axi_wvalid,\\n', '\\toutput reg        axi_wready,\\n', '\\tinput [sword-1:0] axi_wdata,\\n', '\\tinput [4-1:0]     axi_wstrb,\\n', '\\n', '\\toutput reg        axi_bvalid,\\n', '\\tinput         \\t  axi_bready,\\n', '\\n', '\\tinput         \\t  axi_arvalid,\\n', '\\toutput            axi_arready,\\n', '\\tinput [sword-1:0] axi_araddr,\\n', '\\tinput [3-1:0]     axi_arprot,\\n', '\\n', '\\toutput reg        axi_rvalid,\\n', '\\tinput         \\t  axi_rready,\\n', '\\toutput [sword-1:0] axi_rdata\\n', '    );\\n', '\\n', '\\t// HELPER\\n', '\\tfunction integer clogb2;\\n', '\\t\\tinput integer value;\\n', '\\t\\tinteger \\ti;\\n', '\\t\\tbegin\\n', '\\t\\t\\tclogb2 = 0;\\n', '\\t\\t\\tfor(i = 0; 2**i < value; i = i + 1)\\n', '\\t\\t\\tclogb2 = i + 1;\\n', '\\t\\tend\\n', '\\tendfunction\\n', '\\t\\n', '\\t// CONSTRAINTS\\n', '\\t// This outputs are not used\\n', '\\t// Read Channel:\\n', \"\\tassign axi_rdata = 32'h00000000;\\n\", \"\\tassign axi_arready = 1'b1;\\n\", '\\talways @(posedge CLK ) begin\\t// A simple reactor, we ignore totally the addr, and ignore the result\\n', \"\\t\\tif(RST == 1'b0) begin\\n\", \"\\t\\t\\taxi_rvalid <= 1'b0;\\n\", '\\t\\tend else begin\\n', \"\\t\\t\\tif(axi_rready == 1'b1) begin\\n\", \"\\t\\t\\t\\taxi_rvalid <= 1'b0;\\n\", \"\\t\\t\\tend else if(axi_arvalid == 1'b1) begin\\n\", \"\\t\\t\\t\\taxi_rvalid <= 1'b1;\\n\", '\\t\\t\\tend else begin\\n', '\\t\\t\\t\\taxi_rvalid <= axi_rvalid;\\n', '\\t\\t\\tend\\n', '\\t\\tend\\n', '\\tend\\n', '\\t// Write Channel:\\n', '\\t// CONSIDERATION: Is supposed that the ADDR is unique.\\n', '\\t// If awvalid is triggered, awaddr is ignored\\n', '\\t// But if wvalid is triggered, the data is taken\\n', '\\t// So you will understand why I trigger all time the\\n', '\\t// awready\\n', \"\\tassign axi_awready = 1'b1;\\n\", '\\t\\n', '\\t// Angry CLK divisor for SCLK\\n', '\\treg [numbit_divisor-1:0] divisor;\\n', '\\talways @(posedge CLK ) begin\\n', \"\\t\\tif(RST == 1'b0) begin\\n\", \"\\t\\t\\tdivisor <= {numbit_divisor{1'b0}};\\n\", '\\t\\tend else begin\\n', '\\t\\t\\tdivisor <= divisor + 1;\\n', '\\t\\tend\\n', '\\tend\\n', '\\twire SCLK_EN;\\t// This is an Enable that does the same that the divisor\\n', '\\tlocalparam [numbit_divisor-1:0] div_comp = ~(1 << (numbit_divisor-1));\\n', \"\\tassign SCLK_EN = divisor == div_comp ? 1'b1:1'b0;\\n\", '\\twire SCLKA;\\n', '\\tassign SCLKA = ~divisor[numbit_divisor-1];\\n', '\\t// SCLK Activator (High state thing)\\n', \"\\tassign SCLK = SCLKA;//(~CEB)?SCLKA:1'b0;\\n\", '\\t\\n', '\\t// Counter for SPI SYNC\\n', '\\tlocalparam numbit_sync = clogb2(sword);\\n', '\\tlocalparam [numbit_sync-1:0] sync_stop = sword - 1;\\n', '\\treg [numbit_sync-1:0] sync;\\n', '\\twire stop;\\n', '\\treg transmit;\\n', \"\\tassign stop = sync == sync_stop? 1'b1:1'b0;\\n\", '\\talways @(posedge CLK ) begin\\n', \"\\t\\tif(RST == 1'b0) begin\\n\", \"\\t\\t\\tsync <= {numbit_sync{1'b0}};\\n\", '\\t\\tend else begin\\n', \"\\t\\t\\tif(SCLK_EN == 1'b1) begin\\n\", \"\\t\\t\\tif((transmit == 1'b1 && ~(|sync)) || (|sync)) begin\\n\", \"\\t\\t\\t\\tif(stop == 1'b1) begin\\n\", \"\\t\\t\\t\\t\\tsync <= {numbit_sync{1'b0}};\\n\", '\\t\\t\\t\\tend else begin\\n', '\\t\\t\\t\\t\\tsync <= sync + 1;\\n', '\\t\\t\\t\\tend\\n', '\\t\\t\\tend else begin\\n', '\\t\\t\\t\\tsync <= sync;\\n', '\\t\\t\\tend\\n', '\\t\\t\\tend\\n', '\\t\\tend\\n', '\\tend\\n', '\\t\\n', '\\t// Register that captures and do the Paralell-Serial\\n', '\\treg [sword-1:0] cap_data;\\n', '\\talways @(posedge CLK ) begin\\n', \"\\t\\tif(RST == 1'b0) begin\\n\", \"\\t\\t\\tcap_data <= {sword{1'b0}};\\n\", \"\\t\\t\\ttransmit <= 1'b0;\\n\", \"\\t\\t\\t//CEB <= 1'b1;\\n\", '\\t\\tend else begin\\n', \"\\t\\t\\tif(SCLK_EN == 1'b1) begin\\n\", \"\\t\\t\\tif(stop == 1'b1) begin\\n\", '\\t\\t\\t\\tcap_data <= cap_data;\\n', \"\\t\\t\\t\\ttransmit <= 1'b0;\\n\", \"\\t\\t\\tend else if(axi_wvalid == 1'b1 && transmit == 1'b0) begin\\n\", '\\t\\t\\t\\tcap_data <= axi_wdata;\\n', \"\\t\\t\\t\\ttransmit <= 1'b1;\\n\", \"\\t\\t\\tend else if(transmit == 1'b1) begin\\n\", '\\t\\t\\t\\tcap_data <= cap_data << 1;\\n', '\\t\\t\\t\\ttransmit <= transmit;\\n', '\\t\\t\\tend else begin\\n', '\\t\\t\\t\\tcap_data <= cap_data;\\n', '\\t\\t\\t\\ttransmit <= transmit;\\n', '\\t\\t\\tend\\n', '\\t\\t\\t\\n', \"\\t\\t\\t/*if(stop == 1'b1) begin\\n\", \"\\t\\t\\t\\tCEB <= 1'b1;\\n\", \"\\t\\t\\tend else if(axi_wvalid == 1'b1) begin\\n\", \"\\t\\t\\t\\tCEB <= 1'b0;\\n\", '\\t\\t\\tend else begin\\n', '\\t\\t\\t\\tCEB <= CEB;\\n', '\\t\\t\\tend*/\\n', '\\t\\t\\tend\\n', '\\t\\tend\\n', '\\tend\\n', '\\tassign CEB = ~transmit;\\n', \"\\tassign DATA = (CEB==1'b0) ?cap_data[sword-1]:1'bz;\\n\", '\\t\\n', '\\t// AXI control according to all\\n', '\\talways @(posedge CLK ) begin\\n', \"\\t\\tif(RST == 1'b0) begin\\n\", \"\\t\\t\\taxi_wready <= 1'b0;\\n\", \"\\t\\t\\taxi_bvalid <= 1'b0;\\n\", '\\t\\tend else begin\\n', \"\\t\\t\\tif(axi_bready == 1'b1 && axi_bvalid == 1'b1) begin\\n\", \"\\t\\t\\t\\taxi_wready <= 1'b0;\\n\", \"\\t\\t\\tend else if(transmit == 1'b1) begin\\n\", \"\\t\\t\\t\\taxi_wready <= 1'b1;\\n\", '\\t\\t\\tend else begin\\n', '\\t\\t\\t\\taxi_wready <= axi_wready;\\n', '\\t\\t\\tend\\n', '\\t\\t\\t\\n', \"\\t\\t\\tif(axi_bready == 1'b1 && axi_bvalid == 1'b1) begin\\n\", \"\\t\\t\\t\\taxi_bvalid <= 1'b0;\\n\", \"\\t\\t\\tend else if(stop == 1'b1) begin\\n\", \"\\t\\t\\t\\taxi_bvalid <= 1'b1;\\n\", '\\t\\t\\tend else begin\\n', '\\t\\t\\t\\taxi_bvalid <= axi_bvalid;\\n', '\\t\\t\\tend\\n', '\\t\\tend\\n', '\\tend\\n', ' \\t/*\\n', '\\t// Declare states\\n', '\\tparameter st0_nothing = 0, st1_awvalid = 1, st2_wvalid = 2, st3_wwait = 3, st4_bready = 4, st5_arvalid = 5, st6_rwait = 6, st7_rready = 7, st8_wait_spi = 8;\\n', '\\t\\n', '\\t// Output depends only on the state\\n', '\\talways @ (state) begin\\n', '\\t\\tcase (state)\\n', '\\t\\t\\tst0_nothing: begin\\n', \"\\t\\t\\t\\taxi_arvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_awvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_wvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_rready = 1'b0;\\n\", \"\\t\\t\\t\\taxi_bready = 1'b0;\\n\", \"\\t\\t\\t\\tbusy = 1'b0;\\n\", \"\\t\\t\\t\\trbusy = 1'b0;\\n\", \"\\t\\t\\t\\twbusy = 1'b0;\\n\", \"\\t\\t\\t\\tencap_data = 1'b0; end\\n\", '\\t\\t\\tst1_awvalid: begin\\n', \"\\t\\t\\t\\taxi_arvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_awvalid = 1'b1;\\n\", \"\\t\\t\\t\\taxi_wvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_rready = 1'b0;\\n\", \"\\t\\t\\t\\taxi_bready = 1'b0;\\n\", \"\\t\\t\\t\\tbusy = 1'b1;\\n\", \"\\t\\t\\t\\trbusy = 1'b0;\\n\", \"\\t\\t\\t\\twbusy = 1'b1;\\n\", \"\\t\\t\\t\\tencap_data = 1'b0; end\\n\", '\\t\\t\\tst2_wvalid: begin\\n', \"\\t\\t\\t\\taxi_arvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_awvalid = 1'b1;\\n\", \"\\t\\t\\t\\taxi_wvalid = 1'b1;\\n\", \"\\t\\t\\t\\taxi_rready = 1'b0;\\n\", \"\\t\\t\\t\\taxi_bready = 1'b0;\\n\", \"\\t\\t\\t\\tbusy = 1'b1;\\n\", \"\\t\\t\\t\\trbusy = 1'b0;\\n\", \"\\t\\t\\t\\twbusy = 1'b1;\\n\", \"\\t\\t\\t\\tencap_data = 1'b0; end\\n\", '\\t\\t\\tst3_wwait: begin\\n', \"\\t\\t\\t\\taxi_arvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_awvalid = 1'b1;\\n\", \"\\t\\t\\t\\taxi_wvalid = 1'b1;\\n\", \"\\t\\t\\t\\taxi_rready = 1'b0;\\n\", \"\\t\\t\\t\\taxi_bready = 1'b0;\\n\", \"\\t\\t\\t\\tbusy = 1'b1;\\n\", \"\\t\\t\\t\\trbusy = 1'b0;\\n\", \"\\t\\t\\t\\twbusy = 1'b1;\\n\", \"\\t\\t\\t\\tencap_data = 1'b0; end\\n\", '\\t\\t\\tst4_bready: begin\\n', \"\\t\\t\\t\\taxi_arvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_awvalid = 1'b1;\\n\", \"\\t\\t\\t\\taxi_wvalid = 1'b1;\\n\", \"\\t\\t\\t\\taxi_rready = 1'b0;\\n\", \"\\t\\t\\t\\taxi_bready = 1'b1;\\n\", \"\\t\\t\\t\\tbusy = 1'b1;\\n\", \"\\t\\t\\t\\trbusy = 1'b0;\\n\", \"\\t\\t\\t\\twbusy = 1'b1;\\n\", \"\\t\\t\\t\\tencap_data = 1'b0; end\\n\", '\\t\\t\\tst5_arvalid: begin\\n', \"\\t\\t\\t\\taxi_arvalid = 1'b1;\\n\", \"\\t\\t\\t\\taxi_awvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_wvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_rready = 1'b0;\\n\", \"\\t\\t\\t\\taxi_bready = 1'b0;\\n\", \"\\t\\t\\t\\tbusy = 1'b1;\\n\", \"\\t\\t\\t\\trbusy = 1'b1;\\n\", \"\\t\\t\\t\\twbusy = 1'b0;\\n\", \"\\t\\t\\t\\tencap_data = 1'b0; end\\n\", '\\t\\t\\tst6_rwait: begin\\n', \"\\t\\t\\t\\taxi_arvalid = 1'b1;\\n\", \"\\t\\t\\t\\taxi_awvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_wvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_rready = 1'b0;\\n\", \"\\t\\t\\t\\taxi_bready = 1'b0;\\n\", \"\\t\\t\\t\\tbusy = 1'b1;\\n\", \"\\t\\t\\t\\trbusy = 1'b1;\\n\", \"\\t\\t\\t\\twbusy = 1'b0;\\n\", \"\\t\\t\\t\\tencap_data = 1'b0; end\\n\", '\\t\\t\\tst7_rready: begin\\n', \"\\t\\t\\t\\taxi_arvalid = 1'b1;\\n\", \"\\t\\t\\t\\taxi_awvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_wvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_rready = 1'b1;\\n\", \"\\t\\t\\t\\taxi_bready = 1'b0;\\n\", \"\\t\\t\\t\\tbusy = 1'b1;\\n\", \"\\t\\t\\t\\trbusy = 1'b1;\\n\", \"\\t\\t\\t\\twbusy = 1'b0;\\n\", \"\\t\\t\\t\\tencap_data = 1'b1; end\\n\", '\\t\\t\\tst8_wait_spi: begin\\n', \"\\t\\t\\t\\taxi_arvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_awvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_wvalid = 1'b0;\\n\", \"\\t\\t\\t\\taxi_rready = 1'b0;\\n\", \"\\t\\t\\t\\taxi_bready = 1'b0;\\n\", \"\\t\\t\\t\\tbusy = 1'b1;\\n\", \"\\t\\t\\t\\trbusy = 1'b0;\\n\", \"\\t\\t\\t\\twbusy = 1'b0;\\n\", \"\\t\\t\\t\\tencap_data = 1'b0; end\\n\", '\\t\\tendcase\\n', '\\tend\\n', '\\t\\n', '\\t// Determine the next state\\n', '\\talways @ (posedge CLK ) begin\\n', \"\\t\\tif (RST == 1'b0)\\n\", '\\t\\t\\tstate <= st0_nothing;\\n', '\\t\\telse\\n', '\\t\\t\\tcase (state)\\n', '\\t\\t\\t\\tst0_nothing:\\n', '\\t\\t\\t\\t\\tif(we_clk & ~re_clk & fini_spi_clk)\\n', '\\t\\t\\t\\t\\t\\tstate <= st1_awvalid;\\n', '\\t\\t\\t\\t\\telse if(re_clk & ~we_clk & fini_spi_clk)\\n', '\\t\\t\\t\\t\\t\\tstate <= st5_arvalid;\\n', '\\t\\t\\t\\t\\telse\\n', '\\t\\t\\t\\t\\t\\tstate <= st0_nothing;\\n', '\\t\\t\\t\\tst1_awvalid:\\n', '\\t\\t\\t\\t\\tif (axi_awready)\\n', '\\t\\t\\t\\t\\t\\tstate <= st2_wvalid;\\n', '\\t\\t\\t\\t\\telse\\n', '\\t\\t\\t\\t\\t\\tstate <= st1_awvalid;\\n', '\\t\\t\\t\\tst2_wvalid:\\n', '\\t\\t\\t\\t\\tif (axi_wready)\\n', '\\t\\t\\t\\t\\t\\tstate <= st3_wwait;\\n', '\\t\\t\\t\\t\\telse\\n', '\\t\\t\\t\\t\\t\\tstate <= st2_wvalid;\\n', '\\t\\t\\t\\tst3_wwait:\\n', '\\t\\t\\t\\t\\tif (axi_bvalid)\\n', '\\t\\t\\t\\t\\t\\tstate <= st4_bready;\\n', '\\t\\t\\t\\t\\telse\\n', '\\t\\t\\t\\t\\t\\tstate <= st3_wwait;\\n', '\\t\\t\\t\\tst4_bready:\\n', '\\t\\t\\t\\t\\tstate <= st8_wait_spi;\\n', '\\t\\t\\t\\tst5_arvalid:\\n', '\\t\\t\\t\\t\\tif (axi_arready)\\n', '\\t\\t\\t\\t\\t\\tstate <= st6_rwait;\\n', '\\t\\t\\t\\t\\telse\\n', '\\t\\t\\t\\t\\t\\tstate <= st5_arvalid;\\n', '\\t\\t\\t\\tst6_rwait:\\n', '\\t\\t\\t\\t\\tif (axi_rvalid)\\n', '\\t\\t\\t\\t\\t\\tstate <= st7_rready;\\n', '\\t\\t\\t\\t\\telse\\n', '\\t\\t\\t\\t\\t\\tstate <= st6_rwait;\\n', '\\t\\t\\t\\tst7_rready:\\n', '\\t\\t\\t\\t\\tstate <= st8_wait_spi;\\n', '\\t\\t\\t\\tst8_wait_spi:\\n', '\\t\\t\\t\\t\\tif(~fini_spi_clk)\\n', '\\t\\t\\t\\t\\t\\tstate <= st0_nothing;\\n', '\\t\\t\\t\\t\\telse\\n', '\\t\\t\\t\\t\\t\\tstate <= st8_wait_spi;\\n', '\\t\\t\\t\\tdefault:\\n', '\\t\\t\\t\\t\\tstate <= st0_nothing;\\n', '\\t\\t\\tendcase\\n', '\\tend\\n', '*/\\n', 'endmodule\\n']"}
{"text": "['`timescale 1ns/1ns\\n', '\\n', 'module spi_axi_slave_tb();\\n', '\\n', '// HELPER\\n', '\\tfunction integer clogb2;\\n', '\\t\\tinput integer value;\\n', '\\t\\tinteger \\ti;\\n', '\\t\\tbegin\\n', '\\t\\t\\tclogb2 = 0;\\n', '\\t\\t\\tfor(i = 0; 2**i < value; i = i + 1)\\n', '\\t\\t\\tclogb2 = i + 1;\\n', '\\t\\tend\\n', '\\tendfunction\\n', '\\t\\n', 'localparam\\ttries = 512;\\n', 'localparam  \\t\\t\\tsword = 32;\\n', '\\n', 'localparam\\t\\t\\timpl = 0;\\n', 'localparam\\t\\t\\tsyncing = 0;\\n', '\\n', '// Autogen localparams\\n', '\\n', \"reg \\tCLK = 1'b0;\\n\", 'reg\\t \\tRST;\\n', '\\n', '// AXI4-lite master memory interfaces\\n', '\\n', 'reg         axi_awvalid;\\n', 'wire        axi_awready;\\n', 'reg [sword-1:0] axi_awaddr;\\n', 'reg [3-1:0]     axi_awprot;\\n', '\\n', 'reg         axi_wvalid;\\n', 'wire        axi_wready;\\n', 'reg [sword-1:0] axi_wdata;\\n', 'reg [4-1:0]     axi_wstrb;\\n', '\\n', 'wire        axi_bvalid;\\n', 'reg         axi_bready;\\n', '\\n', 'reg         axi_arvalid;\\n', 'wire        axi_arready;\\n', 'reg [sword-1:0] axi_araddr;\\n', 'reg [3-1:0]     axi_arprot;\\n', '\\n', 'wire        axi_rvalid;\\n', 'reg         axi_rready;\\n', 'wire [sword-1:0] axi_rdata;\\n', '\\n', '// SPI interface\\n', 'wire SCLK;\\n', 'wire CEB;\\n', 'wire DATA;\\n', '\\n', '// Data per capturing\\n', 'reg [sword-1:0] cap;\\n', '\\n', '\\t\\n', '\\tinteger \\tfd1, tmp1, ifstop;\\n', '\\tinteger PERIOD = 20 ;\\n', '\\tinteger i, j, error, l;\\n', '\\t\\n', '\\t\\n', '\\tspi_axi_slave\\n', '\\tinst_spi_axi_slave\\n', '\\t(\\n', '\\t.CLK\\t\\t(CLK),\\n', '\\t.RST\\t(RST),\\n', '\\t.SCLK(SCLK),\\n', '\\t.CEB(CEB),\\n', '\\t.DATA(DATA),\\n', '\\t.axi_awvalid(axi_awvalid),\\n', '\\t.axi_awready(axi_awready),\\n', '\\t.axi_awaddr(axi_awaddr),\\n', '\\t.axi_awprot(axi_awprot),\\n', '\\t.axi_wvalid(axi_wvalid),\\n', '\\t.axi_wready(axi_wready),\\n', '\\t.axi_wdata(axi_wdata),\\n', '\\t.axi_wstrb(axi_wstrb),\\n', '\\t.axi_bvalid(axi_bvalid),\\n', '\\t.axi_bready(axi_bready),\\n', '\\t.axi_arvalid(axi_arvalid),\\n', '\\t.axi_arready(axi_arready),\\n', '\\t.axi_araddr(axi_araddr),\\n', '\\t.axi_arprot(axi_arprot),\\n', '\\t.axi_rvalid(axi_rvalid),\\n', '\\t.axi_rready(axi_rready),\\n', '\\t.axi_rdata(axi_rdata)\\n', '\\t); \\n', '\\t\\n', '\\talways\\n', '\\tbegin #(PERIOD/2) CLK = ~CLK; end \\n', '\\n', '\\ttask aexpect;\\n', '\\t\\tinput [sword-1:0] av, e;\\n', '\\t\\tbegin\\n', '\\t\\t if (av == e)\\n', '\\t\\t\\t$display (\"TIME=%t.\" , $time, \" Actual value of trans=%b, expected is %b. MATCH!\", av, e);\\n', '\\t\\t else\\n', '\\t\\t  begin\\n', '\\t\\t\\t$display (\"TIME=%t.\" , $time, \" Actual value of trans=%b, expected is %b. ERROR!\", av, e);\\n', '\\t\\t\\terror = error + 1;\\n', '\\t\\t  end\\n', '\\t\\tend\\n', '\\tendtask\\n', '\\t\\n', \"\\treg [63:0] xorshift64_state = 64'd88172645463325252;\\n\", '\\n', '\\ttask xorshift64_next;\\n', '\\t\\tbegin\\n', '\\t\\t\\t// see page 4 of Marsaglia, George (July 2003). \"Xorshift RNGs\". Journal of Statistical Software 8 (14).\\n', '\\t\\t\\txorshift64_state = xorshift64_state ^ (xorshift64_state << 13);\\n', '\\t\\t\\txorshift64_state = xorshift64_state ^ (xorshift64_state >>  7);\\n', '\\t\\t\\txorshift64_state = xorshift64_state ^ (xorshift64_state << 17);\\n', '\\t\\tend\\n', '\\tendtask\\n', '\\n', '\\n', '\\tinitial begin\\n', '\\t\\t$sdf_annotate(\"spi_axi_slave.sdf\",inst_spi_axi_slave);\\n', \"\\t\\tCLK \\t= 1'b0;\\n\", \"\\t\\tRST \\t= 1'b0;\\n\", \"\\t\\tcap = {sword{1'b0}};\\n\", '\\t\\terror = 0;\\n', \"\\t\\taxi_awvalid = 1'b0;\\n\", \"\\t\\taxi_wvalid = 1'b0;\\n\", \"\\t\\taxi_bready = 1'b0;\\n\", \"\\t\\taxi_arvalid = 1'b0;\\n\", \"\\t\\taxi_rready = 1'b0;\\n\", \"\\t\\taxi_awaddr = {sword{1'b0}};\\n\", \"\\t\\taxi_awprot = {3{1'b0}};\\n\", \"\\t\\taxi_wdata = {sword{1'b0}};\\n\", \"\\t\\taxi_wstrb = 4'b1111;\\n\", \"\\t\\taxi_araddr = {sword{1'b0}};\\n\", \"\\t\\taxi_arprot = {3{1'b0}};\\n\", '\\t\\t#101;\\n', \"\\t\\tRST \\t= 1'b1;\\n\", '\\t\\t// WRITTING AND READING TEST\\n', '\\t\\t// BASICALLY, WHAT I READ, IS WHAT I WRITE\\n', '\\t\\tfor(i = 0; i < tries; i = i+1) begin\\n', '\\t\\t\\t#(PERIOD*8);\\n', '\\t\\t\\t// WRITTING TEST\\n', \"\\t\\t\\taxi_awvalid = 1'b1;\\n\", '\\t\\t\\t#PERIOD;\\n', '\\t\\t\\twhile(!axi_awready) begin\\n', '\\t\\t\\t\\t#PERIOD; \\n', '\\t\\t\\tend\\n', \"\\t\\t\\taxi_wvalid = 1'b1;\\n\", '\\t\\t\\taxi_wdata = xorshift64_state[sword-1:0];\\n', '\\t\\t\\twhile(!axi_wready) begin\\n', '\\t\\t\\t\\t#PERIOD; \\n', '\\t\\t\\tend\\n', '\\t\\t\\twhile(!axi_bvalid) begin\\n', '\\t\\t\\t\\t#PERIOD; \\n', '\\t\\t\\tend\\n', \"\\t\\t\\taxi_bready = 1'b1;\\n\", '\\t\\t\\t#PERIOD; \\n', \"\\t\\t\\taxi_awvalid = 1'b0;\\n\", \"\\t\\t\\taxi_wvalid = 1'b0;\\n\", \"\\t\\t\\taxi_bready = 1'b0;\\n\", '\\t\\t\\t\\n', '\\t\\t\\t// Waiting the SPI for finishing\\n', '\\t\\t\\twhile(!CEB) begin\\n', '\\t\\t\\t\\t#PERIOD; \\n', '\\t\\t\\tend\\n', '\\t\\t\\taexpect(cap, xorshift64_state[sword-1:0]);\\n', '\\t\\t\\txorshift64_next;\\n', '\\t\\tend\\n', '\\t\\t$timeformat(-9,0,\"ns\",7);\\n', '\\t\\t#(PERIOD*8) if (error == 0)\\n', '\\t\\t\\t\\t\\t$display(\"All match\");\\n', '\\t\\t\\t\\telse\\n', '\\t\\t\\t\\t\\t$display(\"Mismatches = %d\", error);\\n', '\\t\\t$finish;\\n', '\\tend\\n', '\\t\\n', '\\talways @(posedge SCLK) begin\\n', \"\\t\\tif(CEB == 1'b0) begin\\n\", '\\t\\t\\tcap = {cap[sword-2:0], DATA};\\n', '\\t\\tend\\n', '\\tend\\n', '\\n', 'endmodule\\n']"}
{"text": "['module AXI_SP32B1024(\\n', '\\tinput\\t\\t\\tCLK,\\n', '\\tinput\\t\\t\\tRST,\\n', '\\n', '\\t// AXI-4 SLAVE Interface\\n', '\\tinput         \\taxi_awvalid,\\n', '\\toutput        \\taxi_awready,\\n', '\\tinput  [32-1:0] axi_awaddr,\\n', '\\tinput  [3-1:0]  axi_awprot,\\n', '\\n', '\\tinput         \\taxi_wvalid,\\n', '\\toutput        \\taxi_wready,\\n', '\\tinput  [32-1:0] axi_wdata,\\n', '\\tinput  [4-1:0]  axi_wstrb,\\n', '\\n', '\\toutput        \\taxi_bvalid,\\n', '\\tinput         \\taxi_bready,\\n', '\\n', '\\tinput         \\taxi_arvalid,\\n', '\\toutput        \\taxi_arready,\\n', '\\tinput  [32-1:0] axi_araddr,\\n', '\\tinput  [3-1:0]  axi_arprot,\\n', '\\n', '\\toutput        \\taxi_rvalid,\\n', '\\tinput         \\taxi_rready,\\n', '\\toutput [32-1:0] axi_rdata,\\n', '\\t\\n', '\\t// Memory Interface\\n', '\\tinput [31:0] Q,\\n', '\\toutput reg CEN,\\n', '\\toutput reg WEN,\\n', '\\toutput reg [9:0] A,\\n', '\\toutput [31:0] D\\n', '\\t);\\n', '\\t\\n', '\\t// The address capturing is a single operation, we can handle this always 1\\n', \"\\tassign axi_awready = 1'b1;\\n\", \"\\tassign axi_arready = 1'b1;\\n\", \"\\tassign axi_wready = 1'b1;\\n\", '\\t//reg [9:0] A;\\n', '\\treg [31:0] DP;\\n', '\\t//wire [31:0] Q;\\n', '\\tassign axi_rdata = Q;\\n', '\\t// For memory, we provide the signals in negedge, because the setup and hold sh*t\\n', '\\talways @(negedge CLK) begin\\n', \"\\t\\tif (RST==1'b0) begin\\n\", \"\\t\\t\\tA <= {10{1'b0}};\\n\", \"\\t\\t\\tDP <= {32{1'b0}};\\n\", '\\t\\tend else begin \\n', \"\\t\\t\\tif(axi_awvalid == 1'b1) begin\\n\", '\\t\\t\\t\\tA <= axi_awaddr[9:0];\\n', \"\\t\\t\\tend else if(axi_arvalid == 1'b1) begin\\n\", '\\t\\t\\t\\tA <= axi_araddr[9:0];\\n', '\\t\\t\\tend\\n', '\\t\\t\\t\\n', \"\\t\\t\\tif(axi_wvalid == 1'b1) begin\\n\", '\\t\\t\\t\\tDP <= axi_wdata;\\n', '\\t\\t\\tend\\n', ' \\t\\tend\\n', '\\tend\\n', '\\t\\n', '\\t// Flags for reading\\n', '\\treg reading1, reading2;\\n', '\\tassign axi_rvalid = reading2;\\n', '\\talways @(posedge CLK) begin\\n', \"\\t\\tif (RST==1'b0) begin\\n\", \"\\t\\t\\treading1 <= 1'b0;\\n\", \"\\t\\t\\treading2 <= 1'b0;\\n\", '\\t\\tend else begin \\n', \"\\t\\t\\tif(axi_rready == 1'b1 && reading1 == 1'b1 && reading2 == 1'b1) begin\\n\", \"\\t\\t\\t\\treading1 <= 1'b0;\\n\", \"\\t\\t\\tend else if(axi_arvalid == 1'b1) begin\\n\", \"\\t\\t\\t\\treading1 <= 1'b1;\\n\", '\\t\\t\\tend\\n', '\\t\\t\\t\\n', \"\\t\\t\\tif(axi_rready == 1'b1 && reading1 == 1'b1 && reading2 == 1'b1) begin\\n\", \"\\t\\t\\t\\treading2 <= 1'b0;\\n\", \"\\t\\t\\tend else if(reading1 == 1'b1) begin\\n\", \"\\t\\t\\t\\treading2 <= 1'b1;\\n\", '\\t\\t\\tend\\n', '\\t\\tend\\n', '\\tend\\n', '\\t\\n', '\\t// Flags for writting\\n', '\\treg writting1, writting2, writting3;\\n', '\\tassign axi_bvalid = writting3;\\n', '\\talways @(posedge CLK) begin\\n', \"\\t\\tif (RST==1'b0) begin\\n\", \"\\t\\t\\twritting1 <= 1'b0;\\n\", \"\\t\\t\\twritting2 <= 1'b0;\\n\", \"\\t\\t\\twritting3 <= 1'b0;\\n\", '\\t\\tend else begin \\n', '\\t\\t\\t\\n', \"\\t\\t\\tif(axi_bready == 1'b1 && writting1 == 1'b1 && writting2 == 1'b1 && writting3 == 1'b1) begin\\n\", \"\\t\\t\\t\\twritting3 <= 1'b0;\\n\", \"\\t\\t\\tend else if(writting2 == 1'b1) begin\\n\", \"\\t\\t\\t\\twritting3 <= 1'b1;\\n\", '\\t\\t\\tend else begin\\n', '\\t\\t\\t\\twritting3 <= writting3;\\n', '\\t\\t\\tend\\n', '\\t\\t\\t\\n', \"\\t\\t\\tif(axi_bready == 1'b1 && writting1 == 1'b1 && writting2 == 1'b1 && writting3 == 1'b1) begin\\n\", \"\\t\\t\\t\\twritting1 <= 1'b0;\\n\", \"\\t\\t\\tend else if(axi_awvalid == 1'b1) begin\\n\", \"\\t\\t\\t\\twritting1 <= 1'b1;\\n\", '\\t\\t\\tend else begin\\n', '\\t\\t\\t\\twritting1 <= writting1;\\n', '\\t\\t\\tend\\n', '\\t\\t\\t\\n', \"\\t\\t\\tif(axi_bready == 1'b1 && writting1 == 1'b1 && writting2 == 1'b1 && writting3 == 1'b1) begin\\n\", \"\\t\\t\\t\\twritting2 <= 1'b0;\\n\", \"\\t\\t\\tend else if(axi_wvalid == 1'b1) begin\\n\", \"\\t\\t\\t\\twritting2 <= 1'b1;\\n\", '\\t\\t\\tend else begin\\n', '\\t\\t\\t\\twritting2 <= writting2;\\n', '\\t\\t\\tend\\n', '\\t\\tend\\n', '\\tend\\n', '\\t\\n', '\\t// Control of memory based on Flags\\n', '\\t//reg CEN, WEN;\\n', '\\t// For memory, we provide the signals in negedge, because the setup and hold sh*t\\n', '\\talways @(negedge CLK) begin\\n', \"\\t\\tif (RST==1'b0) begin\\n\", \"\\t\\t\\tCEN <= 1'b1;\\n\", \"\\t\\t\\tWEN <= 1'b1;\\n\", '\\t\\tend else begin \\n', '\\t\\t\\tCEN <= ~(reading1 | writting1);\\n', '\\t\\t\\tWEN <= ~writting2;\\n', '\\t\\tend\\n', '\\tend\\n', '\\t//wire [31:0] D;\\n', '\\tassign D[7:0]   = axi_wstrb[0]?DP[7:0]  :Q[7:0];\\n', '\\tassign D[15:8]  = axi_wstrb[1]?DP[15:8] :Q[15:8];\\n', '\\tassign D[23:16] = axi_wstrb[2]?DP[23:16]:Q[23:16];\\n', '\\tassign D[31:24] = axi_wstrb[3]?DP[31:24]:Q[31:24];\\n', '\\t\\n', '\\t// Thanks god, the memory provides their data in posedge.\\n', '\\t/*SP32B1024 THEMEMORY(\\n', '\\t\\t.Q(Q),\\n', '\\t\\t.CLK(CLK),\\n', '\\t\\t.CEN(CEN),\\n', '\\t\\t.WEN(WEN),\\n', '\\t\\t.A(A),\\n', '\\t\\t.D(D)\\n', '\\t);*/\\n', 'endmodule\\n']"}
{"text": "['`timescale 1ns/1ns\\n', '\\n', 'module AXI_SP32B1024_tb();\\n', '\\n', '// HELPER\\n', '\\tfunction integer clogb2;\\n', '\\t\\tinput integer value;\\n', '\\t\\tinteger \\ti;\\n', '\\t\\tbegin\\n', '\\t\\t\\tclogb2 = 0;\\n', '\\t\\t\\tfor(i = 0; 2**i < value; i = i + 1)\\n', '\\t\\t\\tclogb2 = i + 1;\\n', '\\t\\tend\\n', '\\tendfunction\\n', '\\n', '\\n', '// Autogen localparams\\n', '\\n', 'localparam\\t\\t   BITS = 32;\\n', 'localparam\\t\\t   word_depth = 1024;\\n', 'localparam\\t\\t   addr_width = 10;\\n', \"localparam\\t\\t   wordx = {BITS{1'bx}};\\n\", \"localparam\\t\\t   addrx = {addr_width{1'bx}};\\n\", '\\n', \"reg \\tCLK = 1'b0;\\n\", 'reg\\t \\tRST;\\n', '\\n', '// AXI4-lite master memory interfaces\\n', '\\n', 'reg         axi_awvalid;\\n', 'wire        axi_awready;\\n', 'reg [32-1:0] axi_awaddr;\\n', 'reg [3-1:0]     axi_awprot;\\n', '\\n', 'reg         axi_wvalid;\\n', 'wire        axi_wready;\\n', 'reg [32-1:0] axi_wdata;\\n', 'reg [4-1:0]     axi_wstrb;\\n', '\\n', 'wire        axi_bvalid;\\n', 'reg         axi_bready;\\n', '\\n', 'reg         axi_arvalid;\\n', 'wire        axi_arready;\\n', 'reg [32-1:0] axi_araddr;\\n', 'reg [3-1:0]     axi_arprot;\\n', '\\n', 'wire        axi_rvalid;\\n', 'reg         axi_rready;\\n', 'wire [32-1:0] axi_rdata;\\n', '\\n', '\\t\\n', '\\tinteger \\tfd1, tmp1, ifstop;\\n', '\\tinteger PERIOD = 20 ;\\n', '\\tinteger i, j, error, l;\\n', '\\t\\n', '\\t\\n', '\\tAXI_SP32B1024_INTERCONNECT\\n', '\\tinst_AXI_SP32B1024_INTERCONNECT\\n', '\\t(\\n', '\\t.CLK\\t\\t(CLK),\\n', '\\t.RST\\t(RST),\\n', '\\t.axi_awvalid(axi_awvalid),\\n', '\\t.axi_awready(axi_awready),\\n', '\\t.axi_awaddr(axi_awaddr),\\n', '\\t.axi_awprot(axi_awprot),\\n', '\\t.axi_wvalid(axi_wvalid),\\n', '\\t.axi_wready(axi_wready),\\n', '\\t.axi_wdata(axi_wdata),\\n', '\\t.axi_wstrb(axi_wstrb),\\n', '\\t.axi_bvalid(axi_bvalid),\\n', '\\t.axi_bready(axi_bready),\\n', '\\t.axi_arvalid(axi_arvalid),\\n', '\\t.axi_arready(axi_arready),\\n', '\\t.axi_araddr(axi_araddr),\\n', '\\t.axi_arprot(axi_arprot),\\n', '\\t.axi_rvalid(axi_rvalid),\\n', '\\t.axi_rready(axi_rready),\\n', '\\t.axi_rdata(axi_rdata)\\n', '\\t); \\n', '\\t\\n', '\\talways\\n', '\\tbegin #(PERIOD/2) CLK = ~CLK; end \\n', '\\n', '\\ttask aexpect;\\n', '\\t\\tinput [BITS-1:0] av, e;\\n', '\\t\\tbegin\\n', '\\t\\t if (av == e)\\n', '\\t\\t\\t$display (\"TIME=%t.\" , $time, \" Actual value of trans=%b, expected is %b. MATCH!\", av, e);\\n', '\\t\\t else\\n', '\\t\\t  begin\\n', '\\t\\t\\t$display (\"TIME=%t.\" , $time, \" Actual value of trans=%b, expected is %b. ERROR!\", av, e);\\n', '\\t\\t\\terror = error + 1;\\n', '\\t\\t  end\\n', '\\t\\tend\\n', '\\tendtask\\n', '\\t\\n', \"\\treg [63:0] xorshift64_state = 64'd88172645463325252;\\n\", '\\n', '\\ttask xorshift64_next;\\n', '\\t\\tbegin\\n', '\\t\\t\\t// see page 4 of Marsaglia, George (July 2003). \"Xorshift RNGs\". Journal of Statistical Software 8 (14).\\n', '\\t\\t\\txorshift64_state = xorshift64_state ^ (xorshift64_state << 13);\\n', '\\t\\t\\txorshift64_state = xorshift64_state ^ (xorshift64_state >>  7);\\n', '\\t\\t\\txorshift64_state = xorshift64_state ^ (xorshift64_state << 17);\\n', '\\t\\tend\\n', '\\tendtask\\n', '\\n', '\\n', '\\tinitial begin\\n', '\\t\\t$sdf_annotate(\"AXI_SP32B1024.sdf\",inst_AXI_SP32B1024_INTERCONNECT);\\n', \"\\t\\tCLK \\t= 1'b1;\\n\", \"\\t\\tRST \\t= 1'b0;\\n\", '\\t\\terror = 0;\\n', \"\\t\\taxi_awvalid = 1'b0;\\n\", \"\\t\\taxi_wvalid = 1'b0;\\n\", \"\\t\\taxi_bready = 1'b0;\\n\", \"\\t\\taxi_arvalid = 1'b0;\\n\", \"\\t\\taxi_rready = 1'b0;\\n\", \"\\t\\taxi_awaddr = {32{1'b0}};\\n\", \"\\t\\taxi_awprot = {3{1'b0}};\\n\", \"\\t\\taxi_wdata = {32{1'b0}};\\n\", \"\\t\\taxi_wstrb = 4'b1111;\\n\", \"\\t\\taxi_araddr = {32{1'b0}};\\n\", \"\\t\\taxi_arprot = {3{1'b0}};\\n\", '\\t\\t#101;\\n', \"\\t\\tRST \\t= 1'b1;\\n\", '\\t\\t// init the memory (AXI style)\\n', '\\t\\tfor(i = 0; i < word_depth; i = i+1) begin\\n', '\\t\\t\\t#(PERIOD);\\n', '\\t\\t\\t// WRITTING TEST\\n', '\\t\\t\\taxi_awaddr = i & (word_depth-1);\\n', \"\\t\\t\\taxi_awvalid = 1'b1;\\n\", '\\t\\t\\t#PERIOD;\\n', '\\t\\t\\twhile(!axi_awready) begin\\n', '\\t\\t\\t\\t#PERIOD; \\n', '\\t\\t\\tend\\n', \"\\t\\t\\taxi_wvalid = 1'b1;\\n\", '\\t\\t\\taxi_wdata = xorshift64_state[BITS-1:0];\\n', '\\t\\t\\twhile(!axi_wready) begin\\n', '\\t\\t\\t\\t#PERIOD; \\n', '\\t\\t\\tend\\n', '\\t\\t\\twhile(!axi_bvalid) begin\\n', '\\t\\t\\t\\t#PERIOD; \\n', '\\t\\t\\tend\\n', \"\\t\\t\\taxi_bready = 1'b1;\\n\", '\\t\\t\\t#PERIOD; \\n', \"\\t\\t\\taxi_awvalid = 1'b0;\\n\", \"\\t\\t\\taxi_wvalid = 1'b0;\\n\", \"\\t\\t\\taxi_bready = 1'b0;\\n\", '\\t\\t\\txorshift64_next;\\n', '\\t\\tend\\n', '\\t\\t//$stop;\\n', '\\t\\t// WRITTING AND READING TEST\\n', '\\t\\t// BASICALLY, WHAT I READ, IS WHAT I WRITE\\n', '\\t\\tfor(i = 0; i < word_depth; i = i+1) begin\\n', '\\t\\t\\t#(PERIOD*8);\\n', '\\t\\t\\t//axi_wstrb = 1<<(i%4); // Set me ACTIVE if you want to see the behavioral with strobes, but all checking will fail\\n', '\\t\\t\\t// WRITTING TEST\\n', '\\t\\t\\taxi_awaddr = i & (word_depth-1);\\n', \"\\t\\t\\taxi_awvalid = 1'b1;\\n\", '\\t\\t\\t#PERIOD;\\n', '\\t\\t\\twhile(!axi_awready) begin\\n', '\\t\\t\\t\\t#PERIOD; \\n', '\\t\\t\\tend\\n', \"\\t\\t\\taxi_wvalid = 1'b1;\\n\", '\\t\\t\\taxi_wdata = xorshift64_state[BITS-1:0];\\n', '\\t\\t\\twhile(!axi_wready) begin\\n', '\\t\\t\\t\\t#PERIOD; \\n', '\\t\\t\\tend\\n', '\\t\\t\\twhile(!axi_bvalid) begin\\n', '\\t\\t\\t\\t#PERIOD; \\n', '\\t\\t\\tend\\n', \"\\t\\t\\taxi_bready = 1'b1;\\n\", '\\t\\t\\t#PERIOD; \\n', \"\\t\\t\\taxi_awvalid = 1'b0;\\n\", \"\\t\\t\\taxi_wvalid = 1'b0;\\n\", \"\\t\\t\\taxi_bready = 1'b0;\\n\", '\\t\\t\\t// READING TEST\\n', '\\t\\t\\t#(PERIOD*8);\\n', \"\\t\\t\\taxi_arvalid = 1'b1;\\n\", '\\t\\t\\taxi_araddr = i & (word_depth-1);\\n', '\\t\\t\\t#PERIOD;\\n', '\\t\\t\\twhile(!axi_arready) begin\\n', '\\t\\t\\t\\t#PERIOD; \\n', '\\t\\t\\tend\\n', '\\t\\t\\twhile(!axi_rvalid) begin\\n', '\\t\\t\\t\\t#PERIOD; \\n', '\\t\\t\\tend\\n', \"\\t\\t\\taxi_rready = 1'b1;\\n\", '\\t\\t\\taexpect(axi_rdata, xorshift64_state[BITS-1:0]);\\n', '\\t\\t\\t#PERIOD; \\n', \"\\t\\t\\taxi_arvalid = 1'b0;\\n\", \"\\t\\t\\taxi_rready = 1'b0;\\n\", '\\t\\t\\txorshift64_next;\\n', '\\t\\tend\\n', '\\t\\t$timeformat(-9,0,\"ns\",7);\\n', '\\t\\t#(PERIOD*8) if (error == 0)\\n', '\\t\\t\\t\\t\\t$display(\"All match\");\\n', '\\t\\t\\t\\telse\\n', '\\t\\t\\t\\t\\t$display(\"Mismatches = %d\", error);\\n', '\\t\\t$finish;\\n', '\\tend\\n', '\\n', 'endmodule\\n']"}
