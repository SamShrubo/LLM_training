{"text": "module serv_aligner\n   (\n    input wire clk,\n    input wire rst,\n    // serv_top\n    input  wire [31:0]  i_ibus_adr,\n    input  wire         i_ibus_cyc,\n    output wire [31:0]  o_ibus_rdt,\n    output wire         o_ibus_ack,\n    // serv_rf_top\n    output wire [31:0]  o_wb_ibus_adr,\n    output wire         o_wb_ibus_cyc,\n    input  wire [31:0]  i_wb_ibus_rdt,\n    input  wire         i_wb_ibus_ack);\n\n    wire [31:0] ibus_rdt_concat;\n    wire        ack_en;\n\n    reg  [15:0] lower_hw;\n    reg         ctrl_misal ;\n\n    /* From SERV core to Memory\n\n    o_wb_ibus_adr: Carries address of instruction to memory. In case of misaligned access,\n    which is caused by pc+2 due to compressed instruction, next instruction is fetched\n    by pc+4 and concatenation is done to make the instruction aligned.\n\n    o_wb_ibus_cyc: Simply forwarded from SERV to Memory and is only altered by memory or SERV core.\n    */\n    assign o_wb_ibus_adr = ctrl_misal ? (i_ibus_adr+32'b100) : i_ibus_adr;\n    assign o_wb_ibus_cyc = i_ibus_cyc;\n\n    /* From Memory to SERV core\n\n        o_ibus_ack: Instruction bus acknowledge is send to SERV only when the aligned instruction,\n        either compressed or un-compressed, is ready to dispatch.\n\n        o_ibus_rdt: Carries the instruction from memory to SERV core. It can be either aligned\n        instruction coming from memory or made aligned by two bus transactions and concatenation.\n    */\n    assign o_ibus_ack = i_wb_ibus_ack & ack_en;\n    assign o_ibus_rdt = ctrl_misal ? ibus_rdt_concat : i_wb_ibus_rdt;\n\n    /* 16-bit register used to hold the upper half word of the current instruction in-case\n       concatenation will be required with the upper half word of upcoming instruction\n    */\n    always @(posedge clk) begin\n        if(i_wb_ibus_ack)begin\n            lower_hw <= i_wb_ibus_rdt[31:16];\n        end\n    end\n\n    assign ibus_rdt_concat = {i_wb_ibus_rdt[15:0],lower_hw};\n\n    /* Two control signals: ack_en, ctrl_misal are set to control the bus transactions between\n    SERV core and the memory\n    */\n    assign ack_en   = !(i_ibus_adr[1] & !ctrl_misal);\n\n    always @(posedge clk ) begin\n        if(rst)\n            ctrl_misal <= 0;\n        else if(i_wb_ibus_ack & i_ibus_adr[1])\n            ctrl_misal <= !ctrl_misal;\n    end\n\nendmodule\n"}
{"text": "`default_nettype none\nmodule serv_alu\n  #(\n   parameter W = 1,\n   parameter B = W-1\n  )\n  (\n   input wire \t    clk,\n   //State\n   input wire \t    i_en,\n   input wire \t    i_cnt0,\n   output wire \t    o_cmp,\n   //Control\n   input wire \t    i_sub,\n   input wire [1:0] i_bool_op,\n   input wire \t    i_cmp_eq,\n   input wire \t    i_cmp_sig,\n   input wire [2:0] i_rd_sel,\n   //Data\n   input wire  [B:0] i_rs1,\n   input wire  [B:0] i_op_b,\n   input wire  [B:0] i_buf,\n   output wire [B:0] o_rd);\n\n   wire [B:0]  result_add;\n   wire [B:0]  result_slt;\n\n   reg \t       cmp_r;\n\n   wire        add_cy;\n   reg [B:0]   add_cy_r;\n\n   //Sign-extended operands\n   wire rs1_sx  = i_rs1[B] & i_cmp_sig;\n   wire op_b_sx = i_op_b[B]  & i_cmp_sig;\n\n   wire [B:0] add_b = i_op_b^{W{i_sub}};\n\n   assign {add_cy,result_add}   = i_rs1+add_b+add_cy_r;\n\n   wire result_lt = rs1_sx + ~op_b_sx + add_cy;\n\n   wire result_eq = !(|result_add) & (cmp_r | i_cnt0);\n\n   assign o_cmp = i_cmp_eq ? result_eq : result_lt;\n\n   /*\n    The result_bool expression implements the following operations between\n    i_rs1 and i_op_b depending on the value of i_bool_op\n\n    00 xor\n    01 0\n    10 or\n    11 and\n\n    i_bool_op will be 01 during shift operations, so by outputting zero under\n    this condition we can safely or result_bool with i_buf\n    */\n   wire [B:0] result_bool = ((i_rs1 ^ i_op_b) & ~{W{i_bool_op[0]}}) | ({W{i_bool_op[1]}} & i_op_b & i_rs1);\n\n   assign result_slt[0] = cmp_r & i_cnt0;\n   generate\n      if (W>1) begin : gen_w_gt_1\n\t assign result_slt[B:1] = {B{1'b0}};\n      end\n   endgenerate\n\n   assign o_rd = i_buf |\n                 ({W{i_rd_sel[0]}} & result_add) |\n                 ({W{i_rd_sel[1]}} & result_slt) |\n                 ({W{i_rd_sel[2]}} & result_bool);\n\n   always @(posedge clk) begin\n      add_cy_r    <= {W{1'b0}};\n      add_cy_r[0] <= i_en ? add_cy : i_sub;\n\n      if (i_en)\n\tcmp_r <= o_cmp;\n   end\n\nendmodule\n"}
{"text": "module serv_bufreg #(\n      parameter [0:0] MDU = 0,\n      parameter W = 1,\n      parameter B = W-1\n)(\n   input wire \t      i_clk,\n   //State\n   input wire \t      i_cnt0,\n   input wire \t      i_cnt1,\n   input wire \t      i_en,\n   input wire \t      i_init,\n   input wire           i_mdu_op,\n   output wire [1:0]    o_lsb,\n   //Control\n   input wire \t      i_rs1_en,\n   input wire \t      i_imm_en,\n   input wire \t      i_clr_lsb,\n   input wire \t      i_sh_signed,\n   //Data\n   input wire [B:0] i_rs1,\n   input wire [B:0] i_imm,\n   output wire [B:0] o_q,\n   //External\n   output wire [31:0] o_dbus_adr,\n   //Extension\n   output wire [31:0] o_ext_rs1);\n\n   wire\t\t      c;\n   wire [B:0]\t      q;\n   reg [B:0]\t      c_r;\n   reg [31:0]\t      data;\n   wire [B:0]\t      clr_lsb;\n\n   assign clr_lsb[0] = i_cnt0 & i_clr_lsb;\n\n   assign {c,q} = {1'b0,(i_rs1 & {W{i_rs1_en}})} + {1'b0,(i_imm & {W{i_imm_en}} & ~clr_lsb)} + c_r;\n\n   always @(posedge i_clk) begin\n      //Make sure carry is cleared before loading new data\n      c_r    <= {W{1'b0}};\n      c_r[0] <= c & i_en;\n   end\n\n   reg [1:0] lsb;\n\n   generate\n      if (W == 1) begin : gen_w_eq_1\n\t always @(posedge i_clk) begin\n\t    if (i_en)\n\t      data[31:2] <= {i_init ? q : {W{data[31] & i_sh_signed}}, data[31:3]};\n\n\t    if (i_init ? (i_cnt0 | i_cnt1) : i_en)\n\t      data[1:0] <= {i_init ? q : data[2], data[1]};\n\t end\n\t always @(*) lsb = data[1:0];\n\t assign o_q = data[0] & {W{i_en}};\n      end\n   endgenerate\n\n\n   assign o_dbus_adr = {data[31:2], 2'b00};\n   assign o_ext_rs1  = data;\n   assign o_lsb = (MDU & i_mdu_op) ? 2'b00 : lsb;\n\nendmodule\n"}
{"text": "module serv_bufreg2\n  (\n   input wire \t      i_clk,\n   //State\n   input wire \t      i_en,\n   input wire \t      i_init,\n   input wire \t      i_cnt_done,\n   input wire [1:0]   i_lsb,\n   input wire \t      i_byte_valid,\n   output wire \t      o_sh_done,\n   output wire \t      o_sh_done_r,\n   //Control\n   input wire \t      i_op_b_sel,\n   input wire \t      i_shift_op,\n   //Data\n   input wire \t      i_rs2,\n   input wire \t      i_imm,\n   output wire \t      o_op_b,\n   output wire \t      o_q,\n   //External\n   output wire [31:0] o_dat,\n   input wire \t      i_load,\n   input wire [31:0]  i_dat);\n\n   reg [31:0] \t dat;\n\n   assign o_op_b = i_op_b_sel ? i_rs2 : i_imm;\n\n   wire \t dat_en = i_shift_op | (i_en & i_byte_valid);\n\n   /* The dat register has three different use cases for store, load and\n    shift operations.\n    store : Data to be written is shifted to the correct position in dat during\n            init by dat_en and is presented on the data bus as o_wb_dat\n    load  : Data from the bus gets latched into dat during i_wb_ack and is then\n            shifted out at the appropriate time to end up in the correct\n            position in rd\n    shift : Data is shifted in during init. After that, the six LSB are used as\n            a downcounter (with bit 5 initially set to 0) that triggers\n            o_sh_done and o_sh_done_r when they wrap around to indicate that\n            the requested number of shifts have been performed\n    */\n   wire [5:0] dat_shamt = (i_shift_op & !i_init) ?\n\t      //Down counter mode\n\t      dat[5:0]-1 :\n\t      //Shift reg mode with optional clearing of bit 5\n\t      {dat[6] & !(i_shift_op & i_cnt_done),dat[5:1]};\n\n   assign o_sh_done = dat_shamt[5];\n   assign o_sh_done_r = dat[5];\n\n   assign o_q =\n\t       ((i_lsb == 2'd3) & dat[24]) |\n\t       ((i_lsb == 2'd2) & dat[16]) |\n\t       ((i_lsb == 2'd1) & dat[8]) |\n\t       ((i_lsb == 2'd0) & dat[0]);\n\n   assign o_dat = dat;\n\n   always @(posedge i_clk) begin\n      if (dat_en | i_load)\n\tdat <= i_load ? i_dat : {o_op_b, dat[31:7], dat_shamt};\n   end\n\nendmodule\n"}
{"text": "/* Copyright lowRISC contributors.\nCopyright 2018 ETH Zurich and University of Bologna, see also CREDITS.md.\nLicensed under the Apache License, Version 2.0, see LICENSE for details.\nSPDX-License-Identifier: Apache-2.0\n\n* Adapted to SERV by @Abdulwadoodd as part of the project under spring '22 LFX Mentorship program */\n\n/* Decodes RISC-V compressed instructions into their RV32i equivalent. */\n\nmodule serv_compdec\n  (\n   input wire i_clk,\n   input  wire [31:0] i_instr,\n   input  wire i_ack,\n   output wire [31:0] o_instr,\n   output reg o_iscomp);\n\n  localparam OPCODE_LOAD     = 7'h03;\n  localparam OPCODE_OP_IMM   = 7'h13;\n  localparam OPCODE_STORE    = 7'h23;\n  localparam OPCODE_OP       = 7'h33;\n  localparam OPCODE_LUI      = 7'h37;\n  localparam OPCODE_BRANCH   = 7'h63;\n  localparam OPCODE_JALR     = 7'h67;\n  localparam OPCODE_JAL      = 7'h6f;\n\n  reg  [31:0] comp_instr;\n  reg  illegal_instr;\n\n  assign o_instr = illegal_instr ? i_instr : comp_instr;\n\n  always @(posedge i_clk) begin\n    if(i_ack)\n      o_iscomp <= !illegal_instr;\n  end\n\n  always @ (*) begin\n    // By default, forward incoming instruction, mark it as legal.\n    comp_instr    = i_instr;\n    illegal_instr = 1'b0;\n\n    // Check if incoming instruction is compressed.\n    case (i_instr[1:0])\n      // C0\n      2'b00: begin\n        case (i_instr[15:14])\n          2'b00: begin\n            // c.addi4spn -> addi rd', x2, imm\n            comp_instr = {2'b0, i_instr[10:7], i_instr[12:11], i_instr[5],\n                      i_instr[6], 2'b00, 5'h02, 3'b000, 2'b01, i_instr[4:2], {OPCODE_OP_IMM}};\n          end\n\n          2'b01: begin\n            // c.lw -> lw rd', imm(rs1')\n            comp_instr = {5'b0, i_instr[5], i_instr[12:10], i_instr[6],\n                      2'b00, 2'b01, i_instr[9:7], 3'b010, 2'b01, i_instr[4:2], {OPCODE_LOAD}};\n          end\n\n          2'b11: begin\n            // c.sw -> sw rs2', imm(rs1')\n            comp_instr = {5'b0, i_instr[5], i_instr[12], 2'b01, i_instr[4:2],\n                      2'b01, i_instr[9:7], 3'b010, i_instr[11:10], i_instr[6],\n                      2'b00, {OPCODE_STORE}};\n          end\n\n          2'b10: begin\n            illegal_instr = 1'b1;\n          end\n\n        endcase\n      end\n\n      // C1\n\n      // Register address checks for RV32E are performed in the regular instruction decoder.\n      // If this check fails, an illegal instruction exception is triggered and the controller\n      // writes the actual faulting instruction to mtval.\n      2'b01: begin\n        case (i_instr[15:13])\n          3'b000: begin\n            // c.addi -> addi rd, rd, nzimm\n            // c.nop\n            comp_instr = {{6 {i_instr[12]}}, i_instr[12], i_instr[6:2],\n                      i_instr[11:7], 3'b0, i_instr[11:7], {OPCODE_OP_IMM}};\n          end\n\n          3'b001, 3'b101: begin\n            // 001: c.jal -> jal x1, imm\n            // 101: c.j   -> jal x0, imm\n            comp_instr = {i_instr[12], i_instr[8], i_instr[10:9], i_instr[6],\n                      i_instr[7], i_instr[2], i_instr[11], i_instr[5:3],\n                      {9 {i_instr[12]}}, 4'b0, ~i_instr[15], {OPCODE_JAL}};\n          end\n\n          3'b010: begin\n            // c.li -> addi rd, x0, nzimm\n            // (c.li hints are translated into an addi hint)\n            comp_instr = {{6 {i_instr[12]}}, i_instr[12], i_instr[6:2], 5'b0,\n                      3'b0, i_instr[11:7], {OPCODE_OP_IMM}};\n          end\n\n          3'b011: begin\n            // c.lui -> lui rd, imm\n            // (c.lui hints are translated into a lui hint)\n            comp_instr = {{15 {i_instr[12]}}, i_instr[6:2], i_instr[11:7], {OPCODE_LUI}};\n\n            if (i_instr[11:7] == 5'h02) begin\n              // c.addi16sp -> addi x2, x2, nzimm\n              comp_instr = {{3 {i_instr[12]}}, i_instr[4:3], i_instr[5], i_instr[2],\n                        i_instr[6], 4'b0, 5'h02, 3'b000, 5'h02, {OPCODE_OP_IMM}};\n            end\n\n          end\n\n          3'b100: begin\n            case (i_instr[11:10])\n              2'b00,\n              2'b01: begin\n                // 00: c.srli -> srli rd, rd, shamt\n                // 01: c.srai -> srai rd, rd, shamt\n                // (c.srli/c.srai hints are translated into a srli/srai hint)\n                comp_instr = {1'b0, i_instr[10], 5'b0, i_instr[6:2], 2'b01, i_instr[9:7],\n                          3'b101, 2'b01, i_instr[9:7], {OPCODE_OP_IMM}};\n              end\n\n              2'b10: begin\n                // c.andi -> andi rd, rd, imm\n                comp_instr = {{6 {i_instr[12]}}, i_instr[12], i_instr[6:2], 2'b01, i_instr[9:7],\n                          3'b111, 2'b01, i_instr[9:7], {OPCODE_OP_IMM}};\n              end\n\n              2'b11: begin\n                case (i_instr[6:5])\n                  2'b00: begin\n                    // c.sub -> sub rd', rd', rs2'\n                    comp_instr = {2'b01, 5'b0, 2'b01, i_instr[4:2], 2'b01, i_instr[9:7],\n                                  3'b000, 2'b01, i_instr[9:7], {OPCODE_OP}};\n                  end\n\n                  2'b01: begin\n                    // c.xor -> xor rd', rd', rs2'\n                    comp_instr = {7'b0, 2'b01, i_instr[4:2], 2'b01, i_instr[9:7], 3'b100,\n                              2'b01, i_instr[9:7], {OPCODE_OP}};\n                  end\n\n                  2'b10: begin\n                    // c.or  -> or  rd', rd', rs2'\n                    comp_instr = {7'b0, 2'b01, i_instr[4:2], 2'b01, i_instr[9:7], 3'b110,\n                              2'b01, i_instr[9:7], {OPCODE_OP}};\n                  end\n\n                  2'b11: begin\n                    // c.and -> and rd', rd', rs2'\n                    comp_instr = {7'b0, 2'b01, i_instr[4:2], 2'b01, i_instr[9:7], 3'b111,\n                              2'b01, i_instr[9:7], {OPCODE_OP}};\n                  end\n                endcase\n              end\n            endcase\n          end\n\n          3'b110, 3'b111: begin\n            // 0: c.beqz -> beq rs1', x0, imm\n            // 1: c.bnez -> bne rs1', x0, imm\n            comp_instr = {{4 {i_instr[12]}}, i_instr[6:5], i_instr[2], 5'b0, 2'b01,\n                      i_instr[9:7], 2'b00, i_instr[13], i_instr[11:10], i_instr[4:3],\n                      i_instr[12], {OPCODE_BRANCH}};\n          end\n        endcase\n      end\n\n      // C2\n\n      // Register address checks for RV32E are performed in the regular instruction decoder.\n      // If this check fails, an illegal instruction exception is triggered and the controller\n      // writes the actual faulting instruction to mtval.\n      2'b10: begin\n        case (i_instr[15:14])\n          2'b00: begin\n            // c.slli -> slli rd, rd, shamt\n            // (c.ssli hints are translated into a slli hint)\n            comp_instr = {7'b0, i_instr[6:2], i_instr[11:7], 3'b001, i_instr[11:7], {OPCODE_OP_IMM}};\n          end\n\n          2'b01: begin\n            // c.lwsp -> lw rd, imm(x2)\n            comp_instr = {4'b0, i_instr[3:2], i_instr[12], i_instr[6:4], 2'b00, 5'h02,\n                      3'b010, i_instr[11:7], OPCODE_LOAD};\n          end\n\n          2'b10: begin\n            if (i_instr[12] == 1'b0) begin\n              if (i_instr[6:2] != 5'b0) begin\n                // c.mv -> add rd/rs1, x0, rs2\n                // (c.mv hints are translated into an add hint)\n                comp_instr = {7'b0, i_instr[6:2], 5'b0, 3'b0, i_instr[11:7], {OPCODE_OP}};\n              end else begin\n                // c.jr -> jalr x0, rd/rs1, 0\n                comp_instr = {12'b0, i_instr[11:7], 3'b0, 5'b0, {OPCODE_JALR}};\n              end\n            end else begin\n              if (i_instr[6:2] != 5'b0) begin\n                // c.add -> add rd, rd, rs2\n                // (c.add hints are translated into an add hint)\n                comp_instr = {7'b0, i_instr[6:2], i_instr[11:7], 3'b0, i_instr[11:7], {OPCODE_OP}};\n              end else begin\n                if (i_instr[11:7] == 5'b0) begin\n                  // c.ebreak -> ebreak\n                  comp_instr = {32'h00_10_00_73};\n                end else begin\n                  // c.jalr -> jalr x1, rs1, 0\n                  comp_instr = {12'b0, i_instr[11:7], 3'b000, 5'b00001, {OPCODE_JALR}};\n                end\n              end\n            end\n          end\n\n          2'b11: begin\n            // c.swsp -> sw rs2, imm(x2)\n            comp_instr = {4'b0, i_instr[8:7], i_instr[12], i_instr[6:2], 5'h02, 3'b010,\n                      i_instr[11:9], 2'b00, {OPCODE_STORE}};\n          end\n        endcase\n      end\n\n      // Incoming instruction is not compressed.\n      2'b11: illegal_instr = 1'b1;\n\n    endcase\n  end\n\n  endmodule\n"}
{"text": "`default_nettype none\nmodule serv_csr\n  #(\n    parameter RESET_STRATEGY = \"MINI\",\n    parameter W = 1,\n    parameter B = W-1\n  )\n  (\n   input wire \t    i_clk,\n   input wire \t    i_rst,\n   //State\n   input wire \t    i_trig_irq,\n   input wire \t    i_en,\n   input wire \t    i_cnt0to3,\n   input wire \t    i_cnt3,\n   input wire \t    i_cnt7,\n   input wire \t    i_cnt_done,\n   input wire \t    i_mem_op,\n   input wire \t    i_mtip,\n   input wire \t    i_trap,\n   output reg \t    o_new_irq,\n   //Control\n   input wire \t    i_e_op,\n   input wire \t    i_ebreak,\n   input wire \t    i_mem_cmd,\n   input wire \t    i_mstatus_en,\n   input wire \t    i_mie_en,\n   input wire \t    i_mcause_en,\n   input wire [1:0] i_csr_source,\n   input wire \t    i_mret,\n   input wire \t    i_csr_d_sel,\n   //Data\n   input wire \t[B:0]    i_rf_csr_out,\n   output wire \t[B:0]    o_csr_in,\n   input wire \t[B:0]    i_csr_imm,\n   input wire \t[B:0]    i_rs1,\n   output wire \t[B:0]    o_q);\n\n   localparam [1:0]\n     CSR_SOURCE_CSR = 2'b00,\n     CSR_SOURCE_EXT = 2'b01,\n     CSR_SOURCE_SET = 2'b10,\n     CSR_SOURCE_CLR = 2'b11;\n\n   reg \t\t    mstatus_mie;\n   reg \t\t    mstatus_mpie;\n   reg \t\t    mie_mtie;\n\n   reg \t\tmcause31;\n   reg [3:0] \tmcause3_0;\n   wire [B:0]\tmcause;\n\n   wire [B:0]\tcsr_in;\n   wire [B:0]\tcsr_out;\n\n   reg \t\ttimer_irq_r;\n\n   wire [B:0]\td = i_csr_d_sel ? i_csr_imm : i_rs1;\n\n   assign csr_in = (i_csr_source == CSR_SOURCE_EXT) ? d :\n\t\t   (i_csr_source == CSR_SOURCE_SET) ? csr_out | d :\n\t\t   (i_csr_source == CSR_SOURCE_CLR) ? csr_out & ~d :\n\t\t   (i_csr_source == CSR_SOURCE_CSR) ? csr_out :\n\t\t   {W{1'bx}};\n\n   assign csr_out = ({i_mstatus_en & mstatus_mie & i_cnt3 & i_en,{B{1'b0}}}) |\n\t\t    i_rf_csr_out |\n\t\t    ({W{i_mcause_en & i_en}} & mcause);\n\n   assign o_q = csr_out;\n\n   wire \ttimer_irq = i_mtip & mstatus_mie & mie_mtie;\n\n   assign mcause = i_cnt0to3 ? mcause3_0[B:0] : //[3:0]\n\t\t   i_cnt_done ? {mcause31,{B{1'b0}}} //[31]\n\t\t   : {W{1'b0}};\n\n   assign o_csr_in = csr_in;\n\n   always @(posedge i_clk) begin\n      if (i_trig_irq) begin\n\t timer_irq_r <= timer_irq;\n\t o_new_irq   <= timer_irq & !timer_irq_r;\n      end\n\n      if (i_mie_en & i_cnt7)\n\tmie_mtie <= csr_in[B];\n\n      /*\n       The mie bit in mstatus gets updated under three conditions\n\n       When a trap is taken, the bit is cleared\n       During an mret instruction, the bit is restored from mpie\n       During a mstatus CSR access instruction it's assigned when\n        bit 3 gets updated\n\n       These conditions are all mutually exclusibe\n       */\n      if ((i_trap & i_cnt_done) | i_mstatus_en & i_cnt3 & i_en | i_mret)\n\tmstatus_mie <= !i_trap & (i_mret ?  mstatus_mpie : csr_in[B]);\n\n      /*\n       Note: To save resources mstatus_mpie (mstatus bit 7) is not\n       readable or writable from sw\n       */\n      if (i_trap & i_cnt_done)\n\tmstatus_mpie <= mstatus_mie;\n\n      /*\n       The four lowest bits in mcause hold the exception code\n\n       These bits get updated under three conditions\n\n       During an mcause CSR access function, they are assigned when\n       bits 0 to 3 gets updated\n\n       During an external interrupt the exception code is set to\n       7, since SERV only support timer interrupts\n\n       During an exception, the exception code is assigned to indicate\n       if it was caused by an ebreak instruction (3),\n       ecall instruction (11), misaligned load (4), misaligned store (6)\n       or misaligned jump (0)\n\n       The expressions below are derived from the following truth table\n       irq  => 0111 (timer=7)\n       e_op => x011 (ebreak=3, ecall=11)\n       mem  => 01x0 (store=6, load=4)\n       ctrl => 0000 (jump=0)\n       */\n      if (i_mcause_en & i_en & i_cnt0to3 | (i_trap & i_cnt_done)) begin\n\t mcause3_0[3] <= (i_e_op & !i_ebreak) | (!i_trap & csr_in[B]);\n\t mcause3_0[2] <= o_new_irq | i_mem_op | (!i_trap & ((W == 1) ? mcause3_0[3] : csr_in[(W == 1) ? 0 : 2]));\n\t mcause3_0[1] <= o_new_irq | i_e_op | (i_mem_op & i_mem_cmd) | (!i_trap & ((W == 1) ? mcause3_0[2] : csr_in[(W == 1) ? 0 : 1]));\n\t mcause3_0[0] <= o_new_irq | i_e_op | (!i_trap & ((W == 1) ? mcause3_0[1] : csr_in[0]));\n      end\n      if (i_mcause_en & i_cnt_done | i_trap)\n\tmcause31 <= i_trap ? o_new_irq : csr_in[B];\n      if (i_rst)\n\tif (RESET_STRATEGY != \"NONE\") begin\n\t   o_new_irq <= 1'b0;\n\t   mie_mtie <= 1'b0;\n\tend\n   end\n\nendmodule\n"}
{"text": "`default_nettype none\nmodule serv_ctrl\n  #(parameter RESET_STRATEGY = \"MINI\",\n    parameter RESET_PC = 32'd0,\n    parameter WITH_CSR = 1,\n    parameter W = 1,\n    parameter B = W-1\n  )\n  (\n   input wire \t     clk,\n   input wire \t     i_rst,\n   //State\n   input wire \t     i_pc_en,\n   input wire \t     i_cnt12to31,\n   input wire \t     i_cnt0,\n   input wire        i_cnt1,\n   input wire \t     i_cnt2,\n   //Control\n   input wire \t     i_jump,\n   input wire \t     i_jal_or_jalr,\n   input wire \t     i_utype,\n   input wire \t     i_pc_rel,\n   input wire \t     i_trap,\n   input wire        i_iscomp,\n   //Data\n   input wire [B:0] i_imm,\n   input wire [B:0] i_buf,\n   input wire [B:0] i_csr_pc,\n   output wire [B:0] o_rd,\n   output wire [B:0] o_bad_pc,\n   //External\n   output reg [31:0] o_ibus_adr);\n\n   wire [B:0] pc_plus_4;\n   wire       pc_plus_4_cy;\n   reg \t      pc_plus_4_cy_r;\n   wire [B:0] pc_plus_4_cy_r_w;\n   wire [B:0] pc_plus_offset;\n   wire       pc_plus_offset_cy;\n   reg\t      pc_plus_offset_cy_r;\n   wire [B:0] pc_plus_offset_cy_r_w;\n   wire [B:0] pc_plus_offset_aligned;\n   wire [B:0] plus_4;\n\n   wire [B:0] pc = o_ibus_adr[B:0];\n\n   wire [B:0] new_pc;\n\n   wire [B:0] offset_a;\n   wire [B:0] offset_b;\n\n  /*  If i_iscomp=1: increment pc by 2 else increment pc by 4  */\n\n   generate\n      if (W == 1) begin : gen_plus_4_w_eq_1\n\t assign plus_4 = i_iscomp ? i_cnt1 : i_cnt2;\n      end else if (W == 4) begin : gen_plus_4_w_eq_4\n\t assign plus_4 = (i_cnt0 | i_cnt1) ? (i_iscomp ? 2 : 4) : 0;\n      end\n   endgenerate\n\n   assign o_bad_pc = pc_plus_offset_aligned;\n\n   assign {pc_plus_4_cy,pc_plus_4} = pc+plus_4+pc_plus_4_cy_r_w;\n\n   generate\n      if (|WITH_CSR) begin : gen_csr\n\t if (W == 1) begin : gen_new_pc_w_eq_1\n\t    assign new_pc = i_trap ? (i_csr_pc & !(i_cnt0 || i_cnt1)) : i_jump ? pc_plus_offset_aligned : pc_plus_4;\n         end else if (W == 4) begin : gen_new_pc_w_eq_4\n\t    assign new_pc = i_trap ? (i_csr_pc & ((i_cnt0 || i_cnt1) ? 4'b1100 : 4'b1111)) : i_jump ? pc_plus_offset_aligned : pc_plus_4;\n\t end\n      end else begin : gen_no_csr\n\t assign new_pc = i_jump ? pc_plus_offset_aligned : pc_plus_4;\n      end\n   endgenerate\n   assign o_rd  = ({W{i_utype}} & pc_plus_offset_aligned) | (pc_plus_4 & {W{i_jal_or_jalr}});\n\n   assign offset_a = {W{i_pc_rel}} & pc;\n   assign offset_b = i_utype ? (i_imm & {W{i_cnt12to31}}) : i_buf;\n   assign {pc_plus_offset_cy,pc_plus_offset} = offset_a+offset_b+pc_plus_offset_cy_r_w;\n\n   generate\n   if (W>1) begin : gen_w_gt_1\n\t assign pc_plus_offset_aligned[B:1] = pc_plus_offset[B:1];\n\t assign pc_plus_offset_cy_r_w[B:1] = {B{1'b0}};\n\t assign pc_plus_4_cy_r_w[B:1] = {B{1'b0}};\n   end\n   endgenerate\n\n   assign pc_plus_offset_aligned[0] = pc_plus_offset[0] & !i_cnt0;\n   assign pc_plus_offset_cy_r_w[0] = pc_plus_offset_cy_r;\n   assign pc_plus_4_cy_r_w[0] = pc_plus_4_cy_r;\n\n   initial if (RESET_STRATEGY == \"NONE\") o_ibus_adr = RESET_PC;\n\n   always @(posedge clk) begin\n      pc_plus_4_cy_r <= i_pc_en & pc_plus_4_cy;\n      pc_plus_offset_cy_r <= i_pc_en & pc_plus_offset_cy;\n\n      if (RESET_STRATEGY == \"NONE\") begin\n\t if (i_pc_en)\n\t   o_ibus_adr <= {new_pc, o_ibus_adr[31:W]};\n      end else begin\n\t if (i_pc_en | i_rst)\n\t   o_ibus_adr <= i_rst ? RESET_PC : {new_pc, o_ibus_adr[31:W]};\n      end\n   end\nendmodule\n"}
{"text": "`default_nettype none\nmodule serv_decode\n  #(parameter [0:0] PRE_REGISTER = 1,\n    parameter [0:0] MDU = 0)\n  (\n   input wire        clk,\n   //Input\n   input wire [31:2] i_wb_rdt,\n   input wire        i_wb_en,\n   //To state\n   output reg       o_sh_right,\n   output reg       o_bne_or_bge,\n   output reg       o_cond_branch,\n   output reg       o_e_op,\n   output reg       o_ebreak,\n   output reg       o_branch_op,\n   output reg       o_shift_op,\n   output reg       o_slt_or_branch,\n   output reg       o_rd_op,\n   output reg       o_two_stage_op,\n   output reg       o_dbus_en,\n   //MDU\n   output reg       o_mdu_op,\n   //Extension\n   output reg [2:0] o_ext_funct3,\n   //To bufreg\n   output reg       o_bufreg_rs1_en,\n   output reg       o_bufreg_imm_en,\n   output reg       o_bufreg_clr_lsb,\n   output reg       o_bufreg_sh_signed,\n   //To ctrl\n   output reg       o_ctrl_jal_or_jalr,\n   output reg       o_ctrl_utype,\n   output reg       o_ctrl_pc_rel,\n   output reg       o_ctrl_mret,\n   //To alu\n   output reg       o_alu_sub,\n   output reg [1:0] o_alu_bool_op,\n   output reg       o_alu_cmp_eq,\n   output reg       o_alu_cmp_sig,\n   output reg [2:0] o_alu_rd_sel,\n   //To mem IF\n   output reg       o_mem_signed,\n   output reg       o_mem_word,\n   output reg       o_mem_half,\n   output reg       o_mem_cmd,\n   //To CSR\n   output reg       o_csr_en,\n   output reg [1:0] o_csr_addr,\n   output reg       o_csr_mstatus_en,\n   output reg       o_csr_mie_en,\n   output reg       o_csr_mcause_en,\n   output reg [1:0] o_csr_source,\n   output reg       o_csr_d_sel,\n   output reg       o_csr_imm_en,\n   output reg       o_mtval_pc,\n   //To top\n   output reg [3:0] o_immdec_ctrl,\n   output reg [3:0] o_immdec_en,\n   output reg       o_op_b_source,\n   //To RF IF\n   output reg       o_rd_mem_en,\n   output reg       o_rd_csr_en,\n   output reg       o_rd_alu_en);\n\n   reg [4:0] opcode;\n   reg [2:0] funct3;\n   reg        op20;\n   reg        op21;\n   reg        op22;\n   reg        op26;\n\n   reg       imm25;\n   reg       imm30;\n\n   wire co_mdu_op     = MDU & (opcode == 5'b01100) & imm25;\n\n   wire co_two_stage_op =\n\t~opcode[2] | (funct3[0] & ~funct3[1] & ~opcode[0] & ~opcode[4]) |\n\t(funct3[1] & ~funct3[2] & ~opcode[0] & ~opcode[4]) | co_mdu_op;\n   wire co_shift_op = (opcode[2] & ~funct3[1]) & !co_mdu_op;\n   wire co_slt_or_branch = (opcode[4] | (funct3[1] & opcode[2]) | (imm30 & opcode[2] & opcode[3] & ~funct3[2])) & !co_mdu_op;\n   wire co_branch_op = opcode[4];\n   wire co_dbus_en    = ~opcode[2] & ~opcode[4];\n   wire co_mtval_pc   = opcode[4];\n   wire co_mem_word   = funct3[1];\n   wire co_rd_alu_en  = !opcode[0] & opcode[2] & !opcode[4] & !co_mdu_op;\n   wire co_rd_mem_en  = (!opcode[2] & !opcode[0]) | co_mdu_op;\n   wire [2:0] co_ext_funct3 = funct3;\n\n   //jal,branch =     imm\n   //jalr       = rs1+imm\n   //mem        = rs1+imm\n   //shift      = rs1\n   wire co_bufreg_rs1_en = !opcode[4] | (!opcode[1] & opcode[0]);\n   wire co_bufreg_imm_en = !opcode[2];\n\n   //Clear LSB of immediate for BRANCH and JAL ops\n   //True for BRANCH and JAL\n   //False for JALR/LOAD/STORE/OP/OPIMM?\n   wire co_bufreg_clr_lsb = opcode[4] & ((opcode[1:0] == 2'b00) | (opcode[1:0] == 2'b11));\n\n   //Conditional branch\n   //True for BRANCH\n   //False for JAL/JALR\n   wire co_cond_branch = !opcode[0];\n\n   wire co_ctrl_utype       = !opcode[4] & opcode[2] & opcode[0];\n   wire co_ctrl_jal_or_jalr = opcode[4] & opcode[0];\n\n   //PC-relative operations\n   //True for jal, b* auipc, ebreak\n   //False for jalr, lui\n   wire co_ctrl_pc_rel = (opcode[2:0] == 3'b000)  |\n                          (opcode[1:0] == 2'b11)  |\n                          (opcode[4] & opcode[2]) & op20|\n                          (opcode[4:3] == 2'b00);\n   //Write to RD\n   //True for OP-IMM, AUIPC, OP, LUI, SYSTEM, JALR, JAL, LOAD\n   //False for STORE, BRANCH, MISC-MEM\n   wire co_rd_op = (opcode[2] |\n                     (!opcode[2] & opcode[4] & opcode[0]) |\n                     (!opcode[2] & !opcode[3] & !opcode[0]));\n\n   //\n   //funct3\n   //\n\n   wire co_sh_right   = funct3[2];\n   wire co_bne_or_bge = funct3[0];\n\n   //Matches system ops except eceall/ebreak/mret\n   wire csr_op = opcode[4] & opcode[2] & (|funct3);\n\n\n   //op20\n   wire co_ebreak = op20;\n\n\n   //opcode & funct3 & op21\n\n   wire co_ctrl_mret = opcode[4] & opcode[2] & op21 & !(|funct3);\n   //Matches system opcodes except CSR accesses (funct3 == 0)\n   //and mret (!op21)\n   wire co_e_op = opcode[4] & opcode[2] & !op21 & !(|funct3);\n\n   //opcode & funct3 & imm30\n\n   wire co_bufreg_sh_signed = imm30;\n\n   /*\n    True for sub, b*, slt*\n    False for add*\n    op    opcode f3  i30\n    b*    11000  xxx x   t\n    addi  00100  000 x   f\n    slt*  0x100  01x x   t\n    add   01100  000 0   f\n    sub   01100  000 1   t\n    */\n   wire co_alu_sub = funct3[1] | funct3[0] | (opcode[3] & imm30) | opcode[4];\n\n   /*\n    Bits 26, 22, 21 and 20 are enough to uniquely identify the eight supported CSR regs\n    mtvec, mscratch, mepc and mtval are stored externally (normally in the RF) and are\n    treated differently from mstatus, mie and mcause which are stored in serv_csr.\n\n    The former get a 2-bit address as seen below while the latter get a\n    one-hot enable signal each.\n\n    Hex|2 222|Reg     |csr\n    adr|6 210|name    |addr\n    ---|-----|--------|----\n    300|0_000|mstatus | xx\n    304|0_100|mie     | xx\n    305|0_101|mtvec   | 01\n    340|1_000|mscratch| 00\n    341|1_001|mepc    | 10\n    342|1_010|mcause  | xx\n    343|1_011|mtval   | 11\n\n    */\n\n   //true  for mtvec,mscratch,mepc and mtval\n   //false for mstatus, mie, mcause\n   wire csr_valid = op20 | (op26 & !op21);\n\n   wire co_rd_csr_en = csr_op;\n\n   wire co_csr_en         = csr_op & csr_valid;\n   wire co_csr_mstatus_en = csr_op & !op26 & !op22;\n   wire co_csr_mie_en     = csr_op & !op26 &  op22 & !op20;\n   wire co_csr_mcause_en  = csr_op         &  op21 & !op20;\n\n   wire [1:0] co_csr_source = funct3[1:0];\n   wire co_csr_d_sel = funct3[2];\n   wire co_csr_imm_en = opcode[4] & opcode[2] & funct3[2];\n   wire [1:0] co_csr_addr = {op26 & op20, !op26 | op21};\n\n   wire co_alu_cmp_eq = funct3[2:1] == 2'b00;\n\n   wire co_alu_cmp_sig = ~((funct3[0] & funct3[1]) | (funct3[1] & funct3[2]));\n\n   wire co_mem_cmd  = opcode[3];\n   wire co_mem_signed = ~funct3[2];\n   wire co_mem_half   = funct3[0];\n\n   wire [1:0] co_alu_bool_op = funct3[1:0];\n\n   wire [3:0] co_immdec_ctrl;\n   //True for S (STORE) or B (BRANCH) type instructions\n   //False for J type instructions\n   assign co_immdec_ctrl[0] = opcode[3:0] == 4'b1000;\n   //True for OP-IMM, LOAD, STORE, JALR  (I S)\n   //False for LUI, AUIPC, JAL           (U J)\n   assign co_immdec_ctrl[1] = (opcode[1:0] == 2'b00) | (opcode[2:1] == 2'b00);\n   assign co_immdec_ctrl[2] = opcode[4] & !opcode[0];\n   assign co_immdec_ctrl[3] = opcode[4];\n\n   wire [3:0] co_immdec_en;\n   assign co_immdec_en[3] = opcode[4] | opcode[3] | opcode[2] | !opcode[0];                 //B I J S U\n   assign co_immdec_en[2] = (opcode[4] & opcode[2]) | !opcode[3] | opcode[0];               //  I J   U\n   assign co_immdec_en[1] = (opcode[2:1] == 2'b01) | (opcode[2] & opcode[0]) | co_csr_imm_en;//    J   U\n   assign co_immdec_en[0] = ~co_rd_op;                                                       //B     S\n\n   wire [2:0] co_alu_rd_sel;\n   assign co_alu_rd_sel[0] = (funct3 == 3'b000); // Add/sub\n   assign co_alu_rd_sel[1] = (funct3[2:1] == 2'b01); //SLT*\n   assign co_alu_rd_sel[2] = funct3[2]; //Bool\n\n   //0 (OP_B_SOURCE_IMM) when OPIMM\n   //1 (OP_B_SOURCE_RS2) when BRANCH or OP\n   wire co_op_b_source = opcode[3];\n\n   generate\n      if (PRE_REGISTER) begin : gen_pre_register\n\n         always @(posedge clk) begin\n            if (i_wb_en) begin\n               funct3 <= i_wb_rdt[14:12];\n               imm30  <= i_wb_rdt[30];\n               imm25  <= i_wb_rdt[25];\n               opcode <= i_wb_rdt[6:2];\n               op20   <= i_wb_rdt[20];\n               op21   <= i_wb_rdt[21];\n               op22   <= i_wb_rdt[22];\n               op26   <= i_wb_rdt[26];\n            end\n         end\n\n         always @(*) begin\n            o_sh_right         = co_sh_right;\n            o_bne_or_bge       = co_bne_or_bge;\n            o_cond_branch      = co_cond_branch;\n            o_dbus_en          = co_dbus_en;\n            o_mtval_pc         = co_mtval_pc;\n\t    o_two_stage_op     = co_two_stage_op;\n            o_e_op             = co_e_op;\n            o_ebreak           = co_ebreak;\n            o_branch_op        = co_branch_op;\n            o_shift_op         = co_shift_op;\n            o_slt_or_branch    = co_slt_or_branch;\n            o_rd_op            = co_rd_op;\n            o_mdu_op           = co_mdu_op;\n            o_ext_funct3       = co_ext_funct3;\n            o_bufreg_rs1_en    = co_bufreg_rs1_en;\n            o_bufreg_imm_en    = co_bufreg_imm_en;\n            o_bufreg_clr_lsb   = co_bufreg_clr_lsb;\n            o_bufreg_sh_signed = co_bufreg_sh_signed;\n            o_ctrl_jal_or_jalr = co_ctrl_jal_or_jalr;\n            o_ctrl_utype       = co_ctrl_utype;\n            o_ctrl_pc_rel      = co_ctrl_pc_rel;\n            o_ctrl_mret        = co_ctrl_mret;\n            o_alu_sub          = co_alu_sub;\n            o_alu_bool_op      = co_alu_bool_op;\n            o_alu_cmp_eq       = co_alu_cmp_eq;\n            o_alu_cmp_sig      = co_alu_cmp_sig;\n            o_alu_rd_sel       = co_alu_rd_sel;\n            o_mem_signed       = co_mem_signed;\n            o_mem_word         = co_mem_word;\n            o_mem_half         = co_mem_half;\n            o_mem_cmd          = co_mem_cmd;\n            o_csr_en           = co_csr_en;\n            o_csr_addr         = co_csr_addr;\n            o_csr_mstatus_en   = co_csr_mstatus_en;\n            o_csr_mie_en       = co_csr_mie_en;\n            o_csr_mcause_en    = co_csr_mcause_en;\n            o_csr_source       = co_csr_source;\n            o_csr_d_sel        = co_csr_d_sel;\n            o_csr_imm_en       = co_csr_imm_en;\n            o_immdec_ctrl      = co_immdec_ctrl;\n            o_immdec_en        = co_immdec_en;\n            o_op_b_source      = co_op_b_source;\n            o_rd_csr_en        = co_rd_csr_en;\n            o_rd_alu_en        = co_rd_alu_en;\n            o_rd_mem_en        = co_rd_mem_en;\n         end\n\n      end else begin : gen_post_register\n\n         always @(*) begin\n            funct3  = i_wb_rdt[14:12];\n            imm30   = i_wb_rdt[30];\n            imm25   = i_wb_rdt[25];\n            opcode  = i_wb_rdt[6:2];\n            op20    = i_wb_rdt[20];\n            op21    = i_wb_rdt[21];\n            op22    = i_wb_rdt[22];\n            op26    = i_wb_rdt[26];\n         end\n\n         always @(posedge clk) begin\n            if (i_wb_en) begin\n               o_sh_right         <= co_sh_right;\n               o_bne_or_bge       <= co_bne_or_bge;\n               o_cond_branch      <= co_cond_branch;\n               o_e_op             <= co_e_op;\n               o_ebreak           <= co_ebreak;\n               o_two_stage_op     <= co_two_stage_op;\n               o_dbus_en          <= co_dbus_en;\n               o_mtval_pc         <= co_mtval_pc;\n               o_branch_op        <= co_branch_op;\n               o_shift_op         <= co_shift_op;\n               o_slt_or_branch    <= co_slt_or_branch;\n               o_rd_op            <= co_rd_op;\n               o_mdu_op           <= co_mdu_op;\n               o_ext_funct3       <= co_ext_funct3;\n               o_bufreg_rs1_en    <= co_bufreg_rs1_en;\n               o_bufreg_imm_en    <= co_bufreg_imm_en;\n               o_bufreg_clr_lsb   <= co_bufreg_clr_lsb;\n               o_bufreg_sh_signed <= co_bufreg_sh_signed;\n               o_ctrl_jal_or_jalr <= co_ctrl_jal_or_jalr;\n               o_ctrl_utype       <= co_ctrl_utype;\n               o_ctrl_pc_rel      <= co_ctrl_pc_rel;\n               o_ctrl_mret        <= co_ctrl_mret;\n               o_alu_sub          <= co_alu_sub;\n               o_alu_bool_op      <= co_alu_bool_op;\n               o_alu_cmp_eq       <= co_alu_cmp_eq;\n               o_alu_cmp_sig      <= co_alu_cmp_sig;\n               o_alu_rd_sel       <= co_alu_rd_sel;\n               o_mem_signed       <= co_mem_signed;\n               o_mem_word         <= co_mem_word;\n               o_mem_half         <= co_mem_half;\n               o_mem_cmd          <= co_mem_cmd;\n               o_csr_en           <= co_csr_en;\n               o_csr_addr         <= co_csr_addr;\n               o_csr_mstatus_en   <= co_csr_mstatus_en;\n               o_csr_mie_en       <= co_csr_mie_en;\n               o_csr_mcause_en    <= co_csr_mcause_en;\n               o_csr_source       <= co_csr_source;\n               o_csr_d_sel        <= co_csr_d_sel;\n               o_csr_imm_en       <= co_csr_imm_en;\n               o_immdec_ctrl      <= co_immdec_ctrl;\n               o_immdec_en        <= co_immdec_en;\n               o_op_b_source      <= co_op_b_source;\n               o_rd_csr_en        <= co_rd_csr_en;\n               o_rd_alu_en        <= co_rd_alu_en;\n               o_rd_mem_en        <= co_rd_mem_en;\n            end\n         end\n\n      end\n   endgenerate\n\nendmodule\n"}
{"text": "`default_nettype none\nmodule serv_immdec\n  #(parameter SHARED_RFADDR_IMM_REGS = 1)\n  (\n   input wire \t     i_clk,\n   //State\n   input wire \t     i_cnt_en,\n   input wire \t     i_cnt_done,\n   //Control\n   input wire [3:0]  i_immdec_en,\n   input wire \t     i_csr_imm_en,\n   input wire [3:0]  i_ctrl,\n   output wire [4:0] o_rd_addr,\n   output wire [4:0] o_rs1_addr,\n   output wire [4:0] o_rs2_addr,\n   //Data\n   output wire \t     o_csr_imm,\n   output wire \t     o_imm,\n   //External\n   input wire \t     i_wb_en,\n   input wire [31:7] i_wb_rdt);\n\n   reg \t\t     imm31;\n\n   reg [8:0]  imm19_12_20;\n   reg \t      imm7;\n   reg [5:0]  imm30_25;\n   reg [4:0]  imm24_20;\n   reg [4:0]  imm11_7;\n\n   assign o_csr_imm = imm19_12_20[4];\n\n   wire       signbit = imm31 & !i_csr_imm_en;\n\n   generate\n      if (SHARED_RFADDR_IMM_REGS) begin : gen_shared_imm_regs\n\t assign o_rs1_addr = imm19_12_20[8:4];\n\t assign o_rs2_addr = imm24_20;\n\t assign o_rd_addr  = imm11_7;\n\n\t always @(posedge i_clk) begin\n\t    if (i_wb_en) begin\n\t       /* CSR immediates are always zero-extended, hence clear the signbit */\n\t       imm31     <= i_wb_rdt[31];\n\t    end\n\t    if (i_wb_en | (i_cnt_en & i_immdec_en[1]))\n\t      imm19_12_20 <= i_wb_en ? {i_wb_rdt[19:12],i_wb_rdt[20]} : {i_ctrl[3] ? signbit : imm24_20[0], imm19_12_20[8:1]};\n\t    if (i_wb_en | (i_cnt_en))\n\t      imm7        <= i_wb_en ? i_wb_rdt[7]                    : signbit;\n\n\t    if (i_wb_en | (i_cnt_en & i_immdec_en[3]))\n\t      imm30_25    <= i_wb_en ? i_wb_rdt[30:25] : {i_ctrl[2] ? imm7 : i_ctrl[1] ? signbit : imm19_12_20[0], imm30_25[5:1]};\n\n\t    if (i_wb_en | (i_cnt_en & i_immdec_en[2]))\n\t      imm24_20    <= i_wb_en ? i_wb_rdt[24:20] : {imm30_25[0], imm24_20[4:1]};\n\n\t    if (i_wb_en | (i_cnt_en & i_immdec_en[0]))\n\t      imm11_7     <= i_wb_en ? i_wb_rdt[11:7] : {imm30_25[0], imm11_7[4:1]};\n\t end\n      end else begin : gen_separate_imm_regs\n\t reg [4:0]  rd_addr;\n\t reg [4:0]  rs1_addr;\n\t reg [4:0]  rs2_addr;\n\n\t assign o_rd_addr  = rd_addr;\n\t assign o_rs1_addr = rs1_addr;\n\t assign o_rs2_addr = rs2_addr;\n\t always @(posedge i_clk) begin\n\t    if (i_wb_en) begin\n\t       /* CSR immediates are always zero-extended, hence clear the signbit */\n\t       imm31       <= i_wb_rdt[31];\n\t       imm19_12_20 <= {i_wb_rdt[19:12],i_wb_rdt[20]};\n\t       imm7        <= i_wb_rdt[7];\n\t       imm30_25    <= i_wb_rdt[30:25];\n\t       imm24_20    <= i_wb_rdt[24:20];\n\t       imm11_7     <= i_wb_rdt[11:7];\n\n               rd_addr  <= i_wb_rdt[11:7];\n               rs1_addr <= i_wb_rdt[19:15];\n               rs2_addr <= i_wb_rdt[24:20];\n\t    end\n\t    if (i_cnt_en) begin\n\t       imm19_12_20 <= {i_ctrl[3] ? signbit : imm24_20[0], imm19_12_20[8:1]};\n\t       imm7        <= signbit;\n\t       imm30_25    <= {i_ctrl[2] ? imm7 : i_ctrl[1] ? signbit : imm19_12_20[0], imm30_25[5:1]};\n\t       imm24_20    <= {imm30_25[0], imm24_20[4:1]};\n\t       imm11_7     <= {imm30_25[0], imm11_7[4:1]};\n\t    end\n\t end\n      end\n   endgenerate\n\n\t assign o_imm = i_cnt_done ? signbit : i_ctrl[0] ? imm11_7[0] : imm24_20[0];\n\nendmodule\n"}
{"text": "`default_nettype none\nmodule serv_mem_if\n  #(\n    parameter [0:0] WITH_CSR = 1,\n    parameter\t    W = 1,\n    parameter\t    B = W-1\n  )\n  (\n   input wire \t     i_clk,\n   //State\n   input wire [1:0]  i_bytecnt,\n   input wire [1:0]  i_lsb,\n   output wire \t     o_byte_valid,\n   output wire \t     o_misalign,\n   //Control\n   input wire \t     i_signed,\n   input wire \t     i_word,\n   input wire \t     i_half,\n   //MDU\n   input wire \t     i_mdu_op,\n   //Data\n   input wire [B:0] i_bufreg2_q,\n   output wire [B:0] o_rd,\n   //External interface\n   output wire [3:0] o_wb_sel);\n\n   reg signbit;\n\n   /*\n    Before a store operation, the data to be written needs to be shifted into\n    place. Depending on the address alignment, we need to shift different\n    amounts. One formula for calculating this is to say that we shift when\n    i_lsb + i_bytecnt < 4. Unfortunately, the synthesis tools don't seem to be\n    clever enough so the hideous expression below is used to achieve the same\n    thing in a more optimal way.\n    */\n   assign o_byte_valid\n     = (!i_lsb[0] & !i_lsb[1])         |\n       (!i_bytecnt[0] & !i_bytecnt[1]) |\n       (!i_bytecnt[1] & !i_lsb[1])     |\n       (!i_bytecnt[1] & !i_lsb[0])     |\n       (!i_bytecnt[0] & !i_lsb[1]);\n\n   wire dat_valid =\n\ti_mdu_op |\n\ti_word |\n\t(i_bytecnt == 2'b00) |\n\t(i_half & !i_bytecnt[1]);\n\n   assign o_rd = dat_valid ? i_bufreg2_q : {W{i_signed & signbit}};\n\n   assign o_wb_sel[3] = (i_lsb == 2'b11) | i_word | (i_half & i_lsb[1]);\n   assign o_wb_sel[2] = (i_lsb == 2'b10) | i_word;\n   assign o_wb_sel[1] = (i_lsb == 2'b01) | i_word | (i_half & !i_lsb[1]);\n   assign o_wb_sel[0] = (i_lsb == 2'b00);\n\n   always @(posedge i_clk) begin\n      if (dat_valid)\n        signbit <= i_bufreg2_q[B];\n   end\n\n   /*\n    mem_misalign is checked after the init stage to decide whether to do a data\n    bus transaction or go to the trap state. It is only guaranteed to be correct\n    at this time\n    */\n   assign o_misalign = WITH_CSR & ((i_lsb[0] & (i_word | i_half)) | (i_lsb[1] & i_word));\n\nendmodule\n"}
{"text": "`default_nettype none\nmodule serv_rf_if\n  #(parameter WITH_CSR = 1,\n    parameter W = 1,\n    parameter B = W-1\n  )\n  (//RF Interface\n   input wire \t\t      i_cnt_en,\n   output wire [4+WITH_CSR:0] o_wreg0,\n   output wire [4+WITH_CSR:0] o_wreg1,\n   output wire \t\t      o_wen0,\n   output wire \t\t      o_wen1,\n   output wire [B:0]  o_wdata0,\n   output wire [B:0]  o_wdata1,\n   output wire [4+WITH_CSR:0] o_rreg0,\n   output wire [4+WITH_CSR:0] o_rreg1,\n   input wire  [B:0] i_rdata0,\n   input wire  [B:0] i_rdata1,\n\n   //Trap interface\n   input wire \t\t      i_trap,\n   input wire \t\t      i_mret,\n   input wire [B:0] i_mepc,\n   input wire                      i_mtval_pc,\n   input wire [B:0] i_bufreg_q,\n   input wire [B:0] i_bad_pc,\n   output wire [B:0] o_csr_pc,\n   //CSR interface\n   input wire \t\t      i_csr_en,\n   input wire [1:0] \t      i_csr_addr,\n   input wire [B:0] i_csr,\n   output wire [B:0] o_csr,\n   //RD write port\n   input wire \t\t      i_rd_wen,\n   input wire [4:0] \t      i_rd_waddr,\n   input wire [B:0] i_ctrl_rd,\n   input wire [B:0] i_alu_rd,\n   input wire \t\t      i_rd_alu_en,\n   input wire [B:0] i_csr_rd,\n   input wire \t\t      i_rd_csr_en,\n   input wire [B:0] i_mem_rd,\n   input wire \t\t      i_rd_mem_en,\n\n   //RS1 read port\n   input wire [4:0] \t      i_rs1_raddr,\n   output wire [B:0] o_rs1,\n   //RS2 read port\n   input wire [4:0] \t      i_rs2_raddr,\n   output wire [B:0] o_rs2);\n\n\n   /*\n    ********** Write side ***********\n    */\n\n   wire \t     rd_wen = i_rd_wen & (|i_rd_waddr);\n\n   generate\n   if (|WITH_CSR) begin : gen_csr\n   wire [B:0] rd =\n       {W{i_rd_alu_en}} & i_alu_rd |\n       {W{i_rd_csr_en}} & i_csr_rd |\n       {W{i_rd_mem_en}} & i_mem_rd |\n                       i_ctrl_rd;\n\n   wire [B:0]  mtval = i_mtval_pc ? i_bad_pc : i_bufreg_q;\n\n   assign \t     o_wdata0 = i_trap ? mtval  : rd;\n   assign\t     o_wdata1 = i_trap ? i_mepc : i_csr;\n\n   /* Port 0 handles writes to mtval during traps and rd otherwise\n    * Port 1 handles writes to mepc during traps and csr accesses otherwise\n    *\n    * GPR registers are mapped to address 0-31 (bits 0xxxxx).\n    * Following that are four CSR registers\n    * mscratch 100000\n    * mtvec    100001\n    * mepc     100010\n    * mtval    100011\n    */\n\n   assign o_wreg0 = i_trap ? {6'b100011} : {1'b0,i_rd_waddr};\n   assign o_wreg1 = i_trap ? {6'b100010} : {4'b1000,i_csr_addr};\n\n   assign       o_wen0 = i_cnt_en & (i_trap | rd_wen);\n   assign       o_wen1 = i_cnt_en & (i_trap | i_csr_en);\n\n   /*\n    ********** Read side ***********\n    */\n\n   //0 : RS1\n   //1 : RS2 / CSR\n\n   assign o_rreg0 = {1'b0, i_rs1_raddr};\n\n   /*\n    The address of the second read port (o_rreg1) can get assigned from four\n    different sources\n\n    Normal operations : i_rs2_raddr\n    CSR access        : i_csr_addr\n    trap              : MTVEC\n    mret              : MEPC\n\n    Address 0-31 in the RF are assigned to the GPRs. After that follows the four\n    CSRs on addresses 32-35\n\n    32 MSCRATCH\n    33 MTVEC\n    34 MEPC\n    35 MTVAL\n\n    The expression below is an optimized version of this logic\n    */\n   wire sel_rs2 = !(i_trap | i_mret | i_csr_en);\n   assign o_rreg1 = {~sel_rs2,\n\t\t     i_rs2_raddr[4:2] & {3{sel_rs2}},\n\t\t     {1'b0,i_trap} | {i_mret,1'b0} | ({2{i_csr_en}} & i_csr_addr) | ({2{sel_rs2}} & i_rs2_raddr[1:0])};\n\n   assign o_rs1 = i_rdata0;\n   assign o_rs2 = i_rdata1;\n   assign o_csr = i_rdata1 & {W{i_csr_en}};\n   assign o_csr_pc = i_rdata1;\n\n   end else begin : gen_no_csr\n      wire [B:0] rd = (i_ctrl_rd) |\n          i_alu_rd  & {W{i_rd_alu_en}} |\n          i_mem_rd  & {W{i_rd_mem_en}};\n\n      assign \t     o_wdata0 = rd;\n      assign\t     o_wdata1 = {W{1'b0}};\n\n      assign o_wreg0 = i_rd_waddr;\n      assign o_wreg1 = 5'd0;\n\n      assign       o_wen0 = i_cnt_en & rd_wen;\n      assign       o_wen1 = 1'b0;\n\n   /*\n    ********** Read side ***********\n    */\n\n      assign o_rreg0 = i_rs1_raddr;\n      assign o_rreg1 = i_rs2_raddr;\n\n      assign o_rs1 = i_rdata0;\n      assign o_rs2 = i_rdata1;\n      assign o_csr = {W{1'b0}};\n      assign o_csr_pc = {W{1'b0}};\n   end // else: !if(WITH_CSR)\n   endgenerate\nendmodule\n"}
{"text": "module serv_rf_ram\n  #(parameter width=0,\n    parameter csr_regs=4,\n    parameter depth=32*(32+csr_regs)/width)\n   (input wire i_clk,\n    input wire [$clog2(depth)-1:0] i_waddr,\n    input wire [width-1:0] \t   i_wdata,\n    input wire \t\t\t   i_wen,\n    input wire [$clog2(depth)-1:0] i_raddr,\n    input wire\t\t\t   i_ren,\n    output wire [width-1:0] \t   o_rdata);\n\n   reg [width-1:0] \t\t   memory [0:depth-1];\n   reg [width-1:0] \t\t   rdata ;\n\n   always @(posedge i_clk) begin\n      if (i_wen)\n\tmemory[i_waddr] <= i_wdata;\n      rdata <= i_ren ? memory[i_raddr] : {width{1'bx}};\n   end\n\n   /* Reads from reg x0 needs to return 0\n    Check that the part of the read address corresponding to the register\n    is zero and gate the output\n    width LSB of reg index $clog2(width)\n    2     4                1\n    4     3                2\n    8     2                3\n    16    1                4\n    32    0                5\n    */\n   reg regzero;\n\n   always @(posedge i_clk)\n     regzero <= !(|i_raddr[$clog2(depth)-1:5-$clog2(width)]);\n\n   assign o_rdata = rdata & ~{width{regzero}};\n\n`ifdef SERV_CLEAR_RAM\n   integer i;\n   initial\n     for (i=0;i<depth;i=i+1)\n       memory[i] = {width{1'd0}};\n`endif\nendmodule\n"}
{"text": "`default_nettype none\nmodule serv_rf_ram_if\n  #(//Data width. Adjust to preferred width of SRAM data interface\n    parameter width=8,\n\n    parameter W = 1,\n    //Select reset strategy.\n    // \"MINI\" for resetting minimally required FFs\n    // \"NONE\" for relying on FFs having a defined value on startup\n    parameter reset_strategy=\"MINI\",\n\n    //Number of CSR registers. These are allocated after the normal\n    // GPR registers in the RAM.\n    parameter csr_regs=4,\n\n    //Internal parameters calculated from above values. Do not change\n    parameter B=W-1,\n    parameter raw=$clog2(32+csr_regs), //Register address width\n    parameter l2w=$clog2(width), //log2 of width\n    parameter aw=5+raw-l2w) //Address width\n  (\n   //SERV side\n   input wire\t\t   i_clk,\n   input wire\t\t   i_rst,\n   input wire\t\t   i_wreq,\n   input wire\t\t   i_rreq,\n   output wire\t\t   o_ready,\n   input wire [raw-1:0]\t   i_wreg0,\n   input wire [raw-1:0]\t   i_wreg1,\n   input wire\t\t   i_wen0,\n   input wire\t\t   i_wen1,\n   input wire [B:0]\t   i_wdata0,\n   input wire [B:0]\t   i_wdata1,\n   input wire [raw-1:0]\t   i_rreg0,\n   input wire [raw-1:0]\t   i_rreg1,\n   output wire [B:0]\t   o_rdata0,\n   output wire [B:0]\t   o_rdata1,\n   //RAM side\n   output wire [aw-1:0]\t   o_waddr,\n   output wire [width-1:0] o_wdata,\n   output wire\t\t   o_wen,\n   output wire [aw-1:0]\t   o_raddr,\n   output wire\t\t   o_ren,\n   input wire [width-1:0]  i_rdata);\n\n   localparam ratio = width/W;\n   localparam CMSB = 4-$clog2(W); //Counter MSB\n   localparam l2r  = $clog2(ratio);\n\n   reg \t\t\t\t   rgnt;\n   assign o_ready = rgnt | i_wreq;\n   reg [CMSB:0] \t  rcnt;\n\n   reg \t\t  rtrig1;\n   /*\n    ********** Write side ***********\n    */\n\n   wire [CMSB:0] \t     wcnt;\n\n   reg [width-1:0]   wdata0_r;\n   reg [width+W-1:0]   wdata1_r;\n\n   reg \t\t     wen0_r;\n   reg \t\t     wen1_r;\n   wire \t     wtrig0;\n   wire \t     wtrig1;\n\n   assign wtrig0 = rtrig1;\n\n   generate if (ratio == 2) begin : gen_wtrig_ratio_eq_2\n      assign wtrig1 =  wcnt[0];\n   end else begin : gen_wtrig_ratio_neq_2\n      reg wtrig0_r;\n      always @(posedge i_clk) wtrig0_r <= wtrig0;\n      assign wtrig1 = wtrig0_r;\n   end\n   endgenerate\n\n   assign \t     o_wdata = wtrig1 ?\n\t\t\t       wdata1_r[width-1:0] :\n\t\t\t       wdata0_r;\n\n   wire [raw-1:0] wreg  = wtrig1 ? i_wreg1 : i_wreg0;\n   generate if (width == 32) begin : gen_w_eq_32\n      assign o_waddr = wreg;\n   end else begin : gen_w_neq_32\n      assign o_waddr = {wreg, wcnt[CMSB:l2r]};\n   end\n   endgenerate\n\n   assign o_wen = (wtrig0 & wen0_r) | (wtrig1 & wen1_r);\n\n   assign wcnt = rcnt-4;\n\n   always @(posedge i_clk) begin\n      if (wcnt[0]) begin\n\t wen0_r    <= i_wen0;\n\t wen1_r    <= i_wen1;\n      end\n\n      wdata0_r  <= {i_wdata0,wdata0_r[width-1:W]};\n      wdata1_r  <= {i_wdata1,wdata1_r[width+W-1:W]};\n\n   end\n\n   /*\n    ********** Read side ***********\n    */\n\n\n   wire \t  rtrig0;\n\n   wire [raw-1:0] rreg = rtrig0 ? i_rreg1 : i_rreg0;\n   generate if (width == 32) begin : gen_rreg_eq_32\n      assign o_raddr = rreg;\n   end else begin : gen_rreg_neq_32\n      assign o_raddr = {rreg, rcnt[CMSB:l2r]};\n   end\n   endgenerate\n\n   reg [width-1:0]  rdata0;\n   reg [width-1-W:0]  rdata1;\n\n   reg \t\t    rgate;\n\n   assign o_rdata0 = rdata0[B:0];\n   assign o_rdata1 = rtrig1 ? i_rdata[B:0] : rdata1[B:0];\n\n   assign rtrig0 = (rcnt[l2r-1:0] == 1);\n\n   generate if (ratio == 2) begin : gen_ren_w_eq_2\n      assign o_ren = rgate;\n   end else begin : gen_ren_w_neq_2\n      assign o_ren = rgate & (rcnt[l2r-1:1] == 0);\n   end\n   endgenerate\n\n   reg \t      rreq_r;\n\n   generate if (ratio > 2) begin : gen_rdata1_w_neq_2\n      always @(posedge i_clk) begin\n\t rdata1 <= {{W{1'b0}},rdata1[width-W-1:W]};\n\t if (rtrig1)\n\t   rdata1[width-W-1:0] <= i_rdata[width-1:W];\n      end\n   end else begin : gen_rdata1_w_eq_2\n      always @(posedge i_clk) if (rtrig1) rdata1 <= i_rdata[W*2-1:W];\n   end\n   endgenerate\n\n   always @(posedge i_clk) begin\n      if (&rcnt | i_rreq)\n\trgate <= i_rreq;\n\n      rtrig1 <= rtrig0;\n      rcnt <= rcnt+{{CMSB{1'b0}},1'b1};\n      if (i_rreq | i_wreq)\n\t rcnt <= {{CMSB-1{1'b0}},i_wreq,1'b0};\n\n      rreq_r <= i_rreq;\n      rgnt <= rreq_r;\n\n      rdata0 <= {{W{1'b0}}, rdata0[width-1:W]};\n      if (rtrig0)\n\trdata0 <= i_rdata;\n\n      if (i_rst) begin\n\t if (reset_strategy != \"NONE\") begin\n\t    rgate <= 1'b0;\n\t    rgnt <= 1'b0;\n\t    rreq_r <= 1'b0;\n\t    rcnt <= {CMSB+1{1'b0}};\n\t end\n      end\n   end\n\n\n\nendmodule\n"}
{"text": "`default_nettype none\n\nmodule serv_rf_top\n  #(parameter RESET_PC = 32'd0,\n    /*  COMPRESSED=1: Enable the compressed decoder and allowed misaligned jump of pc\n        COMPRESSED=0: Disable the compressed decoder and does not allow the misaligned jump of pc\n    */\n    parameter [0:0] COMPRESSED = 0,\n    /*\n      ALIGN = 1: Fetch the aligned instruction by making two bus transactions if the misaligned address\n      is given to the instruction bus.\n    */\n    parameter [0:0] ALIGN = COMPRESSED,\n    /* Multiplication and Division Unit\n       This parameter enables the interface for connecting SERV and MDU\n    */\n    parameter [0:0] MDU = 0,\n    /* Register signals before or after the decoder\n       0 : Register after the decoder. Faster but uses more resources\n       1 : (default) Register before the decoder. Slower but uses less resources\n     */\n    parameter PRE_REGISTER = 1,\n    /* Amount of reset applied to design\n       \"NONE\" : No reset at all. Relies on a POR to set correct initialization\n                 values and that core isn't reset during runtime\n       \"MINI\" : Standard setting. Resets the minimal amount of FFs needed to\n                 restart execution from the instruction at RESET_PC\n     */\n    parameter RESET_STRATEGY = \"MINI\",\n    parameter WITH_CSR = 1,\n    parameter RF_WIDTH = 2,\n\tparameter RF_L2D   = $clog2((32+(WITH_CSR*4))*32/RF_WIDTH))\n  (\n   input wire \t      clk,\n   input wire \t      i_rst,\n   input wire \t      i_timer_irq,\n`ifdef RISCV_FORMAL\n   output wire \t      rvfi_valid,\n   output wire [63:0] rvfi_order,\n   output wire [31:0] rvfi_insn,\n   output wire \t      rvfi_trap,\n   output wire \t      rvfi_halt,\n   output wire \t      rvfi_intr,\n   output wire [1:0]  rvfi_mode,\n   output wire [1:0]  rvfi_ixl,\n   output wire [4:0]  rvfi_rs1_addr,\n   output wire [4:0]  rvfi_rs2_addr,\n   output wire [31:0] rvfi_rs1_rdata,\n   output wire [31:0] rvfi_rs2_rdata,\n   output wire [4:0]  rvfi_rd_addr,\n   output wire [31:0] rvfi_rd_wdata,\n   output wire [31:0] rvfi_pc_rdata,\n   output wire [31:0] rvfi_pc_wdata,\n   output wire [31:0] rvfi_mem_addr,\n   output wire [3:0]  rvfi_mem_rmask,\n   output wire [3:0]  rvfi_mem_wmask,\n   output wire [31:0] rvfi_mem_rdata,\n   output wire [31:0] rvfi_mem_wdata,\n`endif\n   output wire [31:0] o_ibus_adr,\n   output wire \t      o_ibus_cyc,\n   input wire [31:0]  i_ibus_rdt,\n   input wire \t      i_ibus_ack,\n   output wire [31:0] o_dbus_adr,\n   output wire [31:0] o_dbus_dat,\n   output wire [3:0]  o_dbus_sel,\n   output wire \t      o_dbus_we ,\n   output wire \t      o_dbus_cyc,\n   input wire [31:0]  i_dbus_rdt,\n   input wire \t      i_dbus_ack,\n\n   // Extension\n   output wire [31:0] o_ext_rs1,\n   output wire [31:0] o_ext_rs2,\n   output wire [ 2:0] o_ext_funct3,\n   input  wire [31:0] i_ext_rd,\n   input  wire        i_ext_ready,\n   // MDU\n   output wire        o_mdu_valid);\n\n   localparam CSR_REGS = WITH_CSR*4;\n\n   wire \t      rf_wreq;\n   wire \t      rf_rreq;\n   wire [4+WITH_CSR:0] wreg0;\n   wire [4+WITH_CSR:0] wreg1;\n   wire \t      wen0;\n   wire \t      wen1;\n   wire \t      wdata0;\n   wire \t      wdata1;\n   wire [4+WITH_CSR:0] rreg0;\n   wire [4+WITH_CSR:0] rreg1;\n   wire \t      rf_ready;\n   wire \t      rdata0;\n   wire \t      rdata1;\n\n   wire [RF_L2D-1:0]   waddr;\n   wire [RF_WIDTH-1:0] wdata;\n   wire \t       wen;\n   wire [RF_L2D-1:0]   raddr;\n   wire \t       ren;\n   wire [RF_WIDTH-1:0] rdata;\n\n   serv_rf_ram_if\n     #(.width    (RF_WIDTH),\n       .reset_strategy (RESET_STRATEGY),\n       .csr_regs (CSR_REGS))\n   rf_ram_if\n     (.i_clk    (clk),\n      .i_rst    (i_rst),\n      .i_wreq   (rf_wreq),\n      .i_rreq   (rf_rreq),\n      .o_ready  (rf_ready),\n      .i_wreg0  (wreg0),\n      .i_wreg1  (wreg1),\n      .i_wen0   (wen0),\n      .i_wen1   (wen1),\n      .i_wdata0 (wdata0),\n      .i_wdata1 (wdata1),\n      .i_rreg0  (rreg0),\n      .i_rreg1  (rreg1),\n      .o_rdata0 (rdata0),\n      .o_rdata1 (rdata1),\n      .o_waddr  (waddr),\n      .o_wdata  (wdata),\n      .o_wen    (wen),\n      .o_raddr  (raddr),\n      .o_ren    (ren),\n      .i_rdata  (rdata));\n\n   serv_rf_ram\n     #(.width (RF_WIDTH),\n       .csr_regs (CSR_REGS))\n   rf_ram\n     (.i_clk    (clk),\n      .i_waddr (waddr),\n      .i_wdata (wdata),\n      .i_wen   (wen),\n      .i_raddr (raddr),\n      .i_ren    (ren),\n      .o_rdata (rdata));\n\n   serv_top\n     #(.RESET_PC (RESET_PC),\n       .PRE_REGISTER (PRE_REGISTER),\n       .RESET_STRATEGY (RESET_STRATEGY),\n       .WITH_CSR (WITH_CSR),\n       .MDU(MDU),\n       .COMPRESSED(COMPRESSED),\n       .ALIGN(ALIGN))\n   cpu\n     (\n      .clk      (clk),\n      .i_rst    (i_rst),\n      .i_timer_irq  (i_timer_irq),\n`ifdef RISCV_FORMAL\n      .rvfi_valid     (rvfi_valid    ),\n      .rvfi_order     (rvfi_order    ),\n      .rvfi_insn      (rvfi_insn     ),\n      .rvfi_trap      (rvfi_trap     ),\n      .rvfi_halt      (rvfi_halt     ),\n      .rvfi_intr      (rvfi_intr     ),\n      .rvfi_mode      (rvfi_mode     ),\n      .rvfi_ixl       (rvfi_ixl      ),\n      .rvfi_rs1_addr  (rvfi_rs1_addr ),\n      .rvfi_rs2_addr  (rvfi_rs2_addr ),\n      .rvfi_rs1_rdata (rvfi_rs1_rdata),\n      .rvfi_rs2_rdata (rvfi_rs2_rdata),\n      .rvfi_rd_addr   (rvfi_rd_addr  ),\n      .rvfi_rd_wdata  (rvfi_rd_wdata ),\n      .rvfi_pc_rdata  (rvfi_pc_rdata ),\n      .rvfi_pc_wdata  (rvfi_pc_wdata ),\n      .rvfi_mem_addr  (rvfi_mem_addr ),\n      .rvfi_mem_rmask (rvfi_mem_rmask),\n      .rvfi_mem_wmask (rvfi_mem_wmask),\n      .rvfi_mem_rdata (rvfi_mem_rdata),\n      .rvfi_mem_wdata (rvfi_mem_wdata),\n`endif\n      .o_rf_rreq   (rf_rreq),\n      .o_rf_wreq   (rf_wreq),\n      .i_rf_ready  (rf_ready),\n      .o_wreg0     (wreg0),\n      .o_wreg1     (wreg1),\n      .o_wen0      (wen0),\n      .o_wen1      (wen1),\n      .o_wdata0    (wdata0),\n      .o_wdata1    (wdata1),\n      .o_rreg0     (rreg0),\n      .o_rreg1     (rreg1),\n      .i_rdata0    (rdata0),\n      .i_rdata1    (rdata1),\n\n      .o_ibus_adr   (o_ibus_adr),\n      .o_ibus_cyc   (o_ibus_cyc),\n      .i_ibus_rdt   (i_ibus_rdt),\n      .i_ibus_ack   (i_ibus_ack),\n\n      .o_dbus_adr   (o_dbus_adr),\n      .o_dbus_dat   (o_dbus_dat),\n      .o_dbus_sel   (o_dbus_sel),\n      .o_dbus_we    (o_dbus_we),\n      .o_dbus_cyc   (o_dbus_cyc),\n      .i_dbus_rdt   (i_dbus_rdt),\n      .i_dbus_ack   (i_dbus_ack),\n\n      //Extension\n      .o_ext_funct3 (o_ext_funct3),\n      .i_ext_ready  (i_ext_ready),\n      .i_ext_rd     (i_ext_rd),\n      .o_ext_rs1    (o_ext_rs1),\n      .o_ext_rs2    (o_ext_rs2),\n      //MDU\n      .o_mdu_valid  (o_mdu_valid));\n\nendmodule\n`default_nettype wire\n"}
{"text": "module serv_state\n  #(parameter RESET_STRATEGY = \"MINI\",\n    parameter [0:0] WITH_CSR = 1,\n    parameter [0:0] ALIGN =0,\n    parameter [0:0] MDU = 0,\n    parameter       W = 1\n  )\n  (\n   input wire \t     i_clk,\n   input wire \t     i_rst,\n   //State\n   input wire \t     i_new_irq,\n   input wire \t     i_alu_cmp,\n   output wire \t     o_init,\n   output reg \t     o_cnt_en,\n   output wire \t     o_cnt0to3,\n   output wire \t     o_cnt12to31,\n   output wire \t     o_cnt0,\n   output wire \t     o_cnt1,\n   output wire \t     o_cnt2,\n   output wire \t     o_cnt3,\n   output wire \t     o_cnt7,\n   output wire \t     o_cnt_done,\n   output wire \t     o_bufreg_en,\n   output wire \t     o_ctrl_pc_en,\n   output reg \t     o_ctrl_jump,\n   output wire \t     o_ctrl_trap,\n   input wire \t     i_ctrl_misalign,\n   input wire \t     i_sh_done,\n   input wire \t     i_sh_done_r,\n   output wire [1:0] o_mem_bytecnt,\n   input wire \t     i_mem_misalign,\n   //Control\n   input wire \t     i_bne_or_bge,\n   input wire \t     i_cond_branch,\n   input wire \t     i_dbus_en,\n   input wire \t     i_two_stage_op,\n   input wire \t     i_branch_op,\n   input wire \t     i_shift_op,\n   input wire \t     i_sh_right,\n   input wire \t     i_slt_or_branch,\n   input wire \t     i_e_op,\n   input wire \t     i_rd_op,\n   //MDU\n   input wire \t     i_mdu_op,\n   output wire \t     o_mdu_valid,\n   //Extension\n   input wire \t     i_mdu_ready,\n   //External\n   output wire \t     o_dbus_cyc,\n   input wire \t     i_dbus_ack,\n   output wire \t     o_ibus_cyc,\n   input wire \t     i_ibus_ack,\n   //RF Interface\n   output wire \t     o_rf_rreq,\n   output wire \t     o_rf_wreq,\n   input wire \t     i_rf_ready,\n   output wire \t     o_rf_rd_en);\n\n   reg \tstage_two_req;\n   reg \tinit_done;\n   wire misalign_trap_sync;\n\n   reg [4:2] o_cnt;\n   reg [3:0] cnt_r;\n\n   reg \t     ibus_cyc;\n   //Update PC in RUN or TRAP states\n   assign o_ctrl_pc_en  = o_cnt_en & !o_init;\n\n   assign o_mem_bytecnt = o_cnt[4:3];\n\n   assign o_cnt0to3   = (o_cnt[4:2] == 3'd0);\n   assign o_cnt12to31 = (o_cnt[4] | (o_cnt[3:2] == 2'b11));\n   assign o_cnt0 = (o_cnt[4:2] == 3'd0) & cnt_r[0];\n   assign o_cnt1 = (o_cnt[4:2] == 3'd0) & cnt_r[1];\n   assign o_cnt2 = (o_cnt[4:2] == 3'd0) & cnt_r[2];\n   assign o_cnt3 = (o_cnt[4:2] == 3'd0) & cnt_r[3];\n   assign o_cnt7 = (o_cnt[4:2] == 3'd1) & cnt_r[3];\n\n   //Take branch for jump or branch instructions (opcode == 1x0xx) if\n   //a) It's an unconditional branch (opcode[0] == 1)\n   //b) It's a conditional branch (opcode[0] == 0) of type beq,blt,bltu (funct3[0] == 0) and ALU compare is true\n   //c) It's a conditional branch (opcode[0] == 0) of type bne,bge,bgeu (funct3[0] == 1) and ALU compare is false\n   //Only valid during the last cycle of INIT, when the branch condition has\n   //been calculated.\n   wire      take_branch = i_branch_op & (!i_cond_branch | (i_alu_cmp^i_bne_or_bge));\n\n   //valid signal for mdu\n   assign o_mdu_valid = MDU & !o_cnt_en & init_done & i_mdu_op;\n\n   //Prepare RF for writes when everything is ready to enter stage two\n   // and the first stage didn't cause a misalign exception\n   assign o_rf_wreq = !misalign_trap_sync & !o_cnt_en & init_done &\n\t   \t      ((i_shift_op & (i_sh_done | !i_sh_right)) |\n\t   \t       i_dbus_ack | (MDU & i_mdu_ready) |\n\t   \t       i_slt_or_branch);\n\n   assign o_dbus_cyc = !o_cnt_en & init_done & i_dbus_en & !i_mem_misalign;\n\n   //Prepare RF for reads when a new instruction is fetched\n   // or when stage one caused an exception (rreq implies a write request too)\n   assign o_rf_rreq = i_ibus_ack | (stage_two_req & misalign_trap_sync);\n\n   assign o_rf_rd_en = i_rd_op & !o_init;\n\n   /*\n    bufreg is used during mem. branch and shift operations\n\n    mem : bufreg is used for dbus address. Shift in data during phase 1.\n          Shift out during phase 2 if there was an misalignment exception.\n\n    branch : Shift in during phase 1. Shift out during phase 2\n\n    shift : Shift in during phase 1. Continue shifting between phases (except\n            for the first cycle after init). Shift out during phase 2\n    */\n   assign o_bufreg_en = (o_cnt_en & (o_init | ((o_ctrl_trap | i_branch_op) & i_two_stage_op))) | (i_shift_op & !stage_two_req & (i_sh_right | i_sh_done_r) & init_done);\n\n   assign o_ibus_cyc = ibus_cyc & !i_rst;\n\n   assign o_init = i_two_stage_op & !i_new_irq & !init_done;\n\n   assign o_cnt_done = (o_cnt[4:2] == 3'b111) & cnt_r[3];\n\n   always @(posedge i_clk) begin\n      //ibus_cyc changes on three conditions.\n      //1. i_rst is asserted. Together with the async gating above, o_ibus_cyc\n      //   will be asserted as soon as the reset is released. This is how the\n      //   first instruction is fetced\n      //2. o_cnt_done and o_ctrl_pc_en are asserted. This means that SERV just\n      //   finished updating the PC, is done with the current instruction and\n      //   o_ibus_cyc gets asserted to fetch a new instruction\n      //3. When i_ibus_ack, a new instruction is fetched and o_ibus_cyc gets\n      //   deasserted to finish the transaction\n      if (i_ibus_ack | o_cnt_done | i_rst)\n\tibus_cyc <= o_ctrl_pc_en | i_rst;\n\n      if (o_cnt_done) begin\n\t init_done <= o_init & !init_done;\n\t o_ctrl_jump <= o_init & take_branch;\n      end\n\n      //Need a strobe for the first cycle in the IDLE state after INIT\n      stage_two_req <= o_cnt_done & o_init;\n\n      if (i_rst) begin\n\t if (RESET_STRATEGY != \"NONE\") begin\n\t    init_done <= 1'b0;\n\t    o_ctrl_jump <= 1'b0;\n\t    stage_two_req <= 1'b0;\n\t end\n      end\n   end\n\n   always @(posedge i_clk) begin\n      /*\n       Because SERV is 32-bit bit-serial we need a counter than can count 0-31\n       to keep track of which bit we are currently processing. o_cnt and cnt_r\n       are used together to create such a counter.\n       The top three bits (o_cnt) are implemented as a normal counter, but\n       instead of the two LSB, cnt_r is a 4-bit shift register which loops 0-3\n       When cnt_r[3] is 1, o_cnt will be increased.\n\n       The counting starts when the core is idle and the i_rf_ready signal\n       comes in from the RF module by shifting in the i_rf_ready bit as LSB of\n       the shift register. Counting is stopped by using o_cnt_done to block the\n       bit that was supposed to be shifted into bit 0 of cnt_r.\n\n       There are two benefit of doing the counter this way\n       1. We only need to check four bits instead of five when we want to check\n       if the counter is at a certain value. For 4-LUT architectures this means\n       we only need one LUT instead of two for each comparison.\n       2. We don't need a separate enable signal to turn on and off the counter\n       between stages, which saves an extra FF and a unique control signal. We\n       just need to check if cnt_r is not zero to see if the counter is\n       currently running\n       */\n      if (W == 4) begin\n          if (i_rf_ready) o_cnt_en <= 1; else\n          if (o_cnt_done) o_cnt_en <= 0;\n          o_cnt <= o_cnt + { 2'b0, o_cnt_en };\n      end else if (W == 1) begin\n          o_cnt <= o_cnt + {2'd0,cnt_r[3]};\n          cnt_r <= {cnt_r[2:0],(cnt_r[3] & !o_cnt_done) | (i_rf_ready & !o_cnt_en)};\n      end\n      if (i_rst) begin\n         if (RESET_STRATEGY != \"NONE\") begin\n            o_cnt   <= 3'd0;\n            if (W == 1)\n                cnt_r <= 4'b0000;\n            else if (W == 4)\n                o_cnt_en <= 1'b0;\n         end\n      end\n   end\n\n   always @(*)\n   if (W == 1)\n     o_cnt_en = |cnt_r;\n   else if (W == 4)\n     cnt_r = 4'b1111;\n\n   assign o_ctrl_trap = WITH_CSR & (i_e_op | i_new_irq | misalign_trap_sync);\n\n   generate\n      if (WITH_CSR) begin : gen_csr\n\t reg \tmisalign_trap_sync_r;\n\n\t //trap_pending is only guaranteed to have correct value during the\n\t // last cycle of the init stage\n\t wire trap_pending = WITH_CSR & ((take_branch & i_ctrl_misalign & !ALIGN) |\n\t\t\t\t\t (i_dbus_en   & i_mem_misalign));\n\n\t always @(posedge i_clk) begin\n\t    if (i_ibus_ack | o_cnt_done | i_rst)\n\t      misalign_trap_sync_r <= !(i_ibus_ack | i_rst) & ((trap_pending & o_init) | misalign_trap_sync_r);\n\t end\n\t assign misalign_trap_sync = misalign_trap_sync_r;\n      end else begin : gen_no_csr\n\t assign misalign_trap_sync = 1'b0;\n      end\n   endgenerate\nendmodule\n"}
{"text": "`default_nettype none\n\nmodule serv_synth_wrapper\n  #(\n    /* Register signals before or after the decoder\n     0 : Register after the decoder. Faster but uses more resources\n     1 : (default) Register before the decoder. Slower but uses less resources\n     */\n    parameter PRE_REGISTER = 1,\n    /* Amount of reset applied to design\n       \"NONE\" : No reset at all. Relies on a POR to set correct initialization\n                 values and that core isn't reset during runtime\n       \"MINI\" : Standard setting. Resets the minimal amount of FFs needed to\n                 restart execution from the instruction at RESET_PC\n     */\n    parameter RESET_STRATEGY = \"MINI\",\n    parameter WITH_CSR = 1,\n    parameter RF_WIDTH = 2,\n\tparameter RF_L2D   = $clog2((32+(WITH_CSR*4))*32/RF_WIDTH))\n  (\n   input wire \t\t      clk,\n   input wire \t\t      i_rst,\n   input wire \t\t      i_timer_irq,\n   output wire [31:0] \t      o_ibus_adr,\n   output wire \t\t      o_ibus_cyc,\n   input wire [31:0] \t      i_ibus_rdt,\n   input wire \t\t      i_ibus_ack,\n   output wire [31:0] \t      o_dbus_adr,\n   output wire [31:0] \t      o_dbus_dat,\n   output wire [3:0] \t      o_dbus_sel,\n   output wire \t\t      o_dbus_we ,\n   output wire \t\t      o_dbus_cyc,\n   input wire [31:0] \t      i_dbus_rdt,\n   input wire \t\t      i_dbus_ack,\n\n   output wire [RF_L2D-1:0]   o_waddr,\n   output wire [RF_WIDTH-1:0] o_wdata,\n   output wire \t\t      o_wen,\n   output wire [RF_L2D-1:0]   o_raddr,\n   input wire [RF_WIDTH-1:0]  i_rdata);\n\n   localparam CSR_REGS = WITH_CSR*4;\n\n   wire \t      rf_wreq;\n   wire \t      rf_rreq;\n   wire [4+WITH_CSR:0] wreg0;\n   wire [4+WITH_CSR:0] wreg1;\n   wire \t      wen0;\n   wire \t      wen1;\n   wire \t      wdata0;\n   wire \t      wdata1;\n   wire [4+WITH_CSR:0] rreg0;\n   wire [4+WITH_CSR:0] rreg1;\n   wire \t      rf_ready;\n   wire \t      rdata0;\n   wire \t      rdata1;\n\n   serv_rf_ram_if\n     #(.width    (RF_WIDTH),\n       .reset_strategy (RESET_STRATEGY),\n       .csr_regs (CSR_REGS))\n   rf_ram_if\n     (.i_clk    (clk),\n      .i_rst    (i_rst),\n      .i_wreq   (rf_wreq),\n      .i_rreq   (rf_rreq),\n      .o_ready  (rf_ready),\n      .i_wreg0  (wreg0),\n      .i_wreg1  (wreg1),\n      .i_wen0   (wen0),\n      .i_wen1   (wen1),\n      .i_wdata0 (wdata0),\n      .i_wdata1 (wdata1),\n      .i_rreg0  (rreg0),\n      .i_rreg1  (rreg1),\n      .o_rdata0 (rdata0),\n      .o_rdata1 (rdata1),\n      .o_waddr  (o_waddr),\n      .o_wdata  (o_wdata),\n      .o_wen    (o_wen),\n      .o_raddr  (o_raddr),\n      .i_rdata  (i_rdata));\n\n   serv_top\n     #(.RESET_PC (32'd0),\n       .PRE_REGISTER (PRE_REGISTER),\n       .RESET_STRATEGY (RESET_STRATEGY),\n       .WITH_CSR (WITH_CSR),\n       .MDU(1'b0))\n   cpu\n     (\n      .clk      (clk),\n      .i_rst    (i_rst),\n      .i_timer_irq  (i_timer_irq),\n      .o_rf_rreq   (rf_rreq),\n      .o_rf_wreq   (rf_wreq),\n      .i_rf_ready  (rf_ready),\n      .o_wreg0     (wreg0),\n      .o_wreg1     (wreg1),\n      .o_wen0      (wen0),\n      .o_wen1      (wen1),\n      .o_wdata0    (wdata0),\n      .o_wdata1    (wdata1),\n      .o_rreg0     (rreg0),\n      .o_rreg1     (rreg1),\n      .i_rdata0    (rdata0),\n      .i_rdata1    (rdata1),\n\n      .o_ibus_adr   (o_ibus_adr),\n      .o_ibus_cyc   (o_ibus_cyc),\n      .i_ibus_rdt   (i_ibus_rdt),\n      .i_ibus_ack   (i_ibus_ack),\n\n      .o_dbus_adr   (o_dbus_adr),\n      .o_dbus_dat   (o_dbus_dat),\n      .o_dbus_sel   (o_dbus_sel),\n      .o_dbus_we    (o_dbus_we),\n      .o_dbus_cyc   (o_dbus_cyc),\n      .i_dbus_rdt   (i_dbus_rdt),\n      .i_dbus_ack   (i_dbus_ack),\n\n      //Extension\n      .o_ext_funct3 (),\n      .i_ext_ready  (1'b0),\n      .i_ext_rd     (32'd0),\n      .o_ext_rs1    (),\n      .o_ext_rs2    (),\n      //MDU\n      .o_mdu_valid  ());\n\nendmodule\n`default_nettype wire\n"}
{"text": "`default_nettype none\n\nmodule serv_top\n  #(parameter WITH_CSR = 1,\n    parameter PRE_REGISTER = 1,\n    parameter RESET_STRATEGY = \"MINI\",\n    parameter RESET_PC = 32'd0,\n    parameter [0:0] MDU = 1'b0,\n    parameter [0:0] COMPRESSED=0,\n    parameter [0:0] ALIGN = COMPRESSED)\n   (\n   input wire \t\t      clk,\n   input wire \t\t      i_rst,\n   input wire \t\t      i_timer_irq,\n`ifdef RISCV_FORMAL\n   output reg \t\t      rvfi_valid = 1'b0,\n   output reg [63:0] \t      rvfi_order = 64'd0,\n   output reg [31:0] \t      rvfi_insn = 32'd0,\n   output reg \t\t      rvfi_trap = 1'b0,\n   output reg \t\t      rvfi_halt = 1'b0,\n   output reg \t\t      rvfi_intr = 1'b0,\n   output reg [1:0] \t      rvfi_mode = 2'b11,\n   output reg [1:0] \t      rvfi_ixl = 2'b01,\n   output reg [4:0] \t      rvfi_rs1_addr,\n   output reg [4:0] \t      rvfi_rs2_addr,\n   output reg [31:0] \t      rvfi_rs1_rdata,\n   output reg [31:0] \t      rvfi_rs2_rdata,\n   output reg [4:0] \t      rvfi_rd_addr,\n   output reg [31:0] \t      rvfi_rd_wdata,\n   output reg [31:0] \t      rvfi_pc_rdata,\n   output reg [31:0] \t      rvfi_pc_wdata,\n   output reg [31:0] \t      rvfi_mem_addr,\n   output reg [3:0] \t      rvfi_mem_rmask,\n   output reg [3:0] \t      rvfi_mem_wmask,\n   output reg [31:0] \t      rvfi_mem_rdata,\n   output reg [31:0] \t      rvfi_mem_wdata,\n`endif\n   //RF Interface\n   output wire \t\t      o_rf_rreq,\n   output wire \t\t      o_rf_wreq,\n   input wire \t\t      i_rf_ready,\n   output wire [4+WITH_CSR:0] o_wreg0,\n   output wire [4+WITH_CSR:0] o_wreg1,\n   output wire \t\t      o_wen0,\n   output wire \t\t      o_wen1,\n   output wire \t\t      o_wdata0,\n   output wire \t\t      o_wdata1,\n   output wire [4+WITH_CSR:0] o_rreg0,\n   output wire [4+WITH_CSR:0] o_rreg1,\n   input wire \t\t      i_rdata0,\n   input wire \t\t      i_rdata1,\n\n   output wire [31:0] \t      o_ibus_adr,\n   output wire \t\t      o_ibus_cyc,\n   input wire [31:0] \t      i_ibus_rdt,\n   input wire \t\t      i_ibus_ack,\n   output wire [31:0] \t      o_dbus_adr,\n   output wire [31:0] \t      o_dbus_dat,\n   output wire [3:0] \t      o_dbus_sel,\n   output wire \t\t      o_dbus_we ,\n   output wire \t\t      o_dbus_cyc,\n   input wire [31:0] \t      i_dbus_rdt,\n   input wire \t\t      i_dbus_ack,\n   //Extension\n   output wire [ 2:0] o_ext_funct3,\n   input  wire        i_ext_ready,\n   input wire  [31:0] i_ext_rd,\n   output wire [31:0] o_ext_rs1,\n   output wire [31:0] o_ext_rs2,\n   //MDU\n   output wire        o_mdu_valid);\n\n   wire [4:0]    rd_addr;\n   wire [4:0]    rs1_addr;\n   wire [4:0]    rs2_addr;\n\n   wire [3:0] \t immdec_ctrl;\n   wire [3:0] \timmdec_en;\n\n   wire          sh_right;\n   wire \t bne_or_bge;\n   wire \t cond_branch;\n   wire \t two_stage_op;\n   wire \t e_op;\n   wire \t ebreak;\n   wire \t branch_op;\n   wire \t shift_op;\n   wire \t slt_or_branch;\n   wire \t rd_op;\n   wire   mdu_op;\n\n   wire \t rd_alu_en;\n   wire \t rd_csr_en;\n   wire \t rd_mem_en;\n   wire          ctrl_rd;\n   wire          alu_rd;\n   wire          mem_rd;\n   wire          csr_rd;\n   wire \t mtval_pc;\n\n   wire          ctrl_pc_en;\n   wire          jump;\n   wire          jal_or_jalr;\n   wire          utype;\n   wire \t mret;\n   wire          imm;\n   wire \t trap;\n   wire \t pc_rel;\n   wire          iscomp;\n\n   wire          init;\n   wire          cnt_en;\n   wire \t cnt0to3;\n   wire \t cnt12to31;\n   wire          cnt0;\n   wire          cnt1;\n   wire          cnt2;\n   wire          cnt3;\n   wire          cnt7;\n\n   wire \t cnt_done;\n\n   wire \t bufreg_en;\n   wire          bufreg_sh_signed;\n   wire \t bufreg_rs1_en;\n   wire \t bufreg_imm_en;\n   wire \t bufreg_clr_lsb;\n   wire \t bufreg_q;\n   wire \t bufreg2_q;\n   wire [31:0] dbus_rdt;\n   wire        dbus_ack;\n\n   wire          alu_sub;\n   wire [1:0] \t alu_bool_op;\n   wire          alu_cmp_eq;\n   wire          alu_cmp_sig;\n   wire          alu_cmp;\n   wire [2:0]    alu_rd_sel;\n\n   wire          rs1;\n   wire          rs2;\n   wire          rd_en;\n\n   wire          op_b;\n   wire          op_b_sel;\n\n   wire          mem_signed;\n   wire          mem_word;\n   wire          mem_half;\n   wire [1:0] \t mem_bytecnt;\n   wire \t sh_done;\n   wire \t sh_done_r;\n   wire \t byte_valid;\n\n   wire \t mem_misalign;\n\n   wire \t bad_pc;\n\n   wire \t csr_mstatus_en;\n   wire \t csr_mie_en;\n   wire \t csr_mcause_en;\n   wire [1:0]\t csr_source;\n   wire \t csr_imm;\n   wire \t csr_d_sel;\n   wire \t csr_en;\n   wire [1:0] \t csr_addr;\n   wire \t csr_pc;\n   wire \t csr_imm_en;\n   wire \t csr_in;\n   wire \t rf_csr_out;\n   wire \t dbus_en;\n\n   wire \t new_irq;\n\n   wire [1:0]   lsb;\n\n   wire [31:0] i_wb_rdt;\n\n   wire [31:0] wb_ibus_adr;\n   wire        wb_ibus_cyc;\n   wire [31:0] wb_ibus_rdt;\n   wire        wb_ibus_ack;\n\n   generate\n      if (ALIGN) begin : gen_align\n         serv_aligner  align\n           (\n            .clk(clk),\n            .rst(i_rst),\n            // serv_rf_top\n            .i_ibus_adr(wb_ibus_adr),\n            .i_ibus_cyc(wb_ibus_cyc),\n            .o_ibus_rdt(wb_ibus_rdt),\n            .o_ibus_ack(wb_ibus_ack),\n            // servant_arbiter\n            .o_wb_ibus_adr(o_ibus_adr),\n            .o_wb_ibus_cyc(o_ibus_cyc),\n            .i_wb_ibus_rdt(i_ibus_rdt),\n            .i_wb_ibus_ack(i_ibus_ack));\n      end else begin : gen_no_align\n         assign  o_ibus_adr  = wb_ibus_adr;\n         assign  o_ibus_cyc  = wb_ibus_cyc;\n         assign  wb_ibus_rdt = i_ibus_rdt;\n         assign  wb_ibus_ack = i_ibus_ack;\n        end\n   endgenerate\n\n   generate\n      if (COMPRESSED) begin : gen_compressed\n         serv_compdec compdec\n           (\n            .i_clk(clk),\n            .i_instr(wb_ibus_rdt),\n            .i_ack(wb_ibus_ack),\n            .o_instr(i_wb_rdt),\n            .o_iscomp(iscomp));\n      end else begin : gen_no_compressed\n         assign i_wb_rdt =  wb_ibus_rdt;\n         assign iscomp   =  1'b0;\n      end\n   endgenerate\n\n   serv_state\n     #(.RESET_STRATEGY (RESET_STRATEGY),\n       .WITH_CSR (WITH_CSR[0:0]),\n       .MDU(MDU),\n       .ALIGN(ALIGN))\n   state\n     (\n      .i_clk (clk),\n      .i_rst          (i_rst),\n      //State\n      .i_new_irq      (new_irq),\n      .i_alu_cmp      (alu_cmp),\n      .o_init         (init),\n      .o_cnt_en       (cnt_en),\n      .o_cnt0to3      (cnt0to3),\n      .o_cnt12to31    (cnt12to31),\n      .o_cnt0         (cnt0),\n      .o_cnt1         (cnt1),\n      .o_cnt2         (cnt2),\n      .o_cnt3         (cnt3),\n      .o_cnt7         (cnt7),\n      .o_cnt_done     (cnt_done),\n      .o_bufreg_en    (bufreg_en),\n      .o_ctrl_pc_en   (ctrl_pc_en),\n      .o_ctrl_jump    (jump),\n      .o_ctrl_trap    (trap),\n      .i_ctrl_misalign(lsb[1]),\n      .i_sh_done      (sh_done),\n      .i_sh_done_r    (sh_done_r),\n      .o_mem_bytecnt  (mem_bytecnt),\n      .i_mem_misalign (mem_misalign),\n      //Control\n      .i_bne_or_bge   (bne_or_bge),\n      .i_cond_branch  (cond_branch),\n      .i_dbus_en      (dbus_en),\n      .i_two_stage_op (two_stage_op),\n      .i_branch_op    (branch_op),\n      .i_shift_op     (shift_op),\n      .i_sh_right     (sh_right),\n      .i_slt_or_branch (slt_or_branch),\n      .i_e_op         (e_op),\n      .i_rd_op        (rd_op),\n      //MDU\n      .i_mdu_op       (mdu_op),\n      .o_mdu_valid    (o_mdu_valid),\n      //Extension\n      .i_mdu_ready    (i_ext_ready),\n      //External\n      .o_dbus_cyc     (o_dbus_cyc),\n      .i_dbus_ack     (i_dbus_ack),\n      .o_ibus_cyc     (wb_ibus_cyc),\n      .i_ibus_ack     (wb_ibus_ack),\n      //RF Interface\n      .o_rf_rreq      (o_rf_rreq),\n      .o_rf_wreq      (o_rf_wreq),\n      .i_rf_ready     (i_rf_ready),\n      .o_rf_rd_en     (rd_en));\n\n   serv_decode\n     #(.PRE_REGISTER (PRE_REGISTER),\n       .MDU(MDU))\n   decode\n     (\n      .clk (clk),\n      //Input\n      .i_wb_rdt           (i_wb_rdt[31:2]),\n      .i_wb_en            (wb_ibus_ack),\n      //To state\n      .o_bne_or_bge       (bne_or_bge),\n      .o_cond_branch      (cond_branch),\n      .o_dbus_en          (dbus_en),\n      .o_e_op             (e_op),\n      .o_ebreak           (ebreak),\n      .o_branch_op        (branch_op),\n      .o_shift_op         (shift_op),\n      .o_slt_or_branch    (slt_or_branch),\n      .o_rd_op            (rd_op),\n      .o_sh_right         (sh_right),\n      .o_mdu_op           (mdu_op),\n      .o_two_stage_op     (two_stage_op),\n      //Extension\n      .o_ext_funct3       (o_ext_funct3),\n\n      //To bufreg\n      .o_bufreg_rs1_en    (bufreg_rs1_en),\n      .o_bufreg_imm_en    (bufreg_imm_en),\n      .o_bufreg_clr_lsb   (bufreg_clr_lsb),\n      .o_bufreg_sh_signed (bufreg_sh_signed),\n      //To bufreg2\n      .o_op_b_source      (op_b_sel),\n      //To ctrl\n      .o_ctrl_jal_or_jalr (jal_or_jalr),\n      .o_ctrl_utype       (utype),\n      .o_ctrl_pc_rel      (pc_rel),\n      .o_ctrl_mret        (mret),\n      //To alu\n      .o_alu_sub          (alu_sub),\n      .o_alu_bool_op      (alu_bool_op),\n      .o_alu_cmp_eq       (alu_cmp_eq),\n      .o_alu_cmp_sig      (alu_cmp_sig),\n      .o_alu_rd_sel       (alu_rd_sel),\n      //To mem IF\n      .o_mem_cmd          (o_dbus_we),\n      .o_mem_signed       (mem_signed),\n      .o_mem_word         (mem_word),\n      .o_mem_half         (mem_half),\n      //To CSR\n      .o_csr_en           (csr_en),\n      .o_csr_addr         (csr_addr),\n      .o_csr_mstatus_en   (csr_mstatus_en),\n      .o_csr_mie_en       (csr_mie_en),\n      .o_csr_mcause_en    (csr_mcause_en),\n      .o_csr_source       (csr_source),\n      .o_csr_d_sel        (csr_d_sel),\n      .o_csr_imm_en       (csr_imm_en),\n      .o_mtval_pc         (mtval_pc      ),\n      //To top\n      .o_immdec_ctrl      (immdec_ctrl),\n      .o_immdec_en        (immdec_en),\n      //To RF IF\n      .o_rd_mem_en        (rd_mem_en),\n      .o_rd_csr_en        (rd_csr_en),\n      .o_rd_alu_en        (rd_alu_en));\n\n   serv_immdec immdec\n     (\n      .i_clk        (clk),\n      //State\n      .i_cnt_en     (cnt_en),\n      .i_cnt_done   (cnt_done),\n      //Control\n      .i_immdec_en        (immdec_en),\n      .i_csr_imm_en (csr_imm_en),\n      .i_ctrl       (immdec_ctrl),\n      .o_rd_addr    (rd_addr),\n      .o_rs1_addr   (rs1_addr),\n      .o_rs2_addr   (rs2_addr),\n      //Data\n      .o_csr_imm    (csr_imm),\n      .o_imm        (imm),\n      //External\n      .i_wb_en      (wb_ibus_ack),\n      .i_wb_rdt     (i_wb_rdt[31:7]));\n\n   serv_bufreg\n      #(.MDU(MDU))\n   bufreg\n     (\n      .i_clk    (clk),\n      //State\n      .i_cnt0   (cnt0),\n      .i_cnt1   (cnt1),\n      .i_en     (bufreg_en),\n      .i_init   (init),\n      .i_mdu_op (mdu_op),\n      .o_lsb    (lsb),\n      //Control\n      .i_sh_signed (bufreg_sh_signed),\n      .i_rs1_en    (bufreg_rs1_en),\n      .i_imm_en    (bufreg_imm_en),\n      .i_clr_lsb   (bufreg_clr_lsb),\n      //Data\n      .i_rs1    (rs1),\n      .i_imm    (imm),\n      .o_q      (bufreg_q),\n      //External\n      .o_dbus_adr (o_dbus_adr),\n      .o_ext_rs1  (o_ext_rs1));\n\n   serv_bufreg2 bufreg2\n     (\n      .i_clk        (clk),\n      //State\n      .i_en         (cnt_en),\n      .i_init       (init),\n      .i_cnt_done   (cnt_done),\n      .i_lsb        (lsb),\n      .i_byte_valid (byte_valid),\n      .o_sh_done    (sh_done),\n      .o_sh_done_r  (sh_done_r),\n      //Control\n      .i_op_b_sel   (op_b_sel),\n      .i_shift_op   (shift_op),\n      //Data\n      .i_rs2        (rs2),\n      .i_imm        (imm),\n      .o_op_b       (op_b),\n      .o_q          (bufreg2_q),\n      //External\n      .o_dat        (o_dbus_dat),\n      .i_load       (dbus_ack),\n      .i_dat        (dbus_rdt));\n\n   serv_ctrl\n     #(.RESET_PC (RESET_PC),\n       .RESET_STRATEGY (RESET_STRATEGY),\n       .WITH_CSR (WITH_CSR))\n   ctrl\n     (\n      .clk        (clk),\n      .i_rst      (i_rst),\n      //State\n      .i_pc_en    (ctrl_pc_en),\n      .i_cnt12to31 (cnt12to31),\n      .i_cnt0     (cnt0),\n      .i_cnt1     (cnt1),\n      .i_cnt2     (cnt2),\n      //Control\n      .i_jump     (jump),\n      .i_jal_or_jalr (jal_or_jalr),\n      .i_utype    (utype),\n      .i_pc_rel   (pc_rel),\n      .i_trap     (trap | mret),\n      .i_iscomp    (iscomp),\n      //Data\n      .i_imm      (imm),\n      .i_buf      (bufreg_q),\n      .i_csr_pc   (csr_pc),\n      .o_rd       (ctrl_rd),\n      .o_bad_pc   (bad_pc),\n      //External\n      .o_ibus_adr (wb_ibus_adr));\n\n   serv_alu alu\n     (\n      .clk        (clk),\n      //State\n      .i_en       (cnt_en),\n      .i_cnt0     (cnt0),\n      .o_cmp      (alu_cmp),\n      //Control\n      .i_sub      (alu_sub),\n      .i_bool_op  (alu_bool_op),\n      .i_cmp_eq   (alu_cmp_eq),\n      .i_cmp_sig  (alu_cmp_sig),\n      .i_rd_sel   (alu_rd_sel),\n      //Data\n      .i_rs1      (rs1),\n      .i_op_b     (op_b),\n      .i_buf      (bufreg_q),\n      .o_rd       (alu_rd));\n\n   serv_rf_if\n     #(.WITH_CSR (WITH_CSR))\n   rf_if\n     (//RF interface\n      .i_cnt_en    (cnt_en),\n      .o_wreg0     (o_wreg0),\n      .o_wreg1     (o_wreg1),\n      .o_wen0      (o_wen0),\n      .o_wen1      (o_wen1),\n      .o_wdata0    (o_wdata0),\n      .o_wdata1    (o_wdata1),\n      .o_rreg0     (o_rreg0),\n      .o_rreg1     (o_rreg1),\n      .i_rdata0    (i_rdata0),\n      .i_rdata1    (i_rdata1),\n\n      //Trap interface\n      .i_trap      (trap),\n      .i_mret      (mret),\n      .i_mepc      (wb_ibus_adr[0]),\n      .i_mtval_pc  (mtval_pc),\n      .i_bufreg_q  (bufreg_q),\n      .i_bad_pc    (bad_pc),\n      .o_csr_pc    (csr_pc),\n      //CSR write port\n      .i_csr_en    (csr_en),\n      .i_csr_addr  (csr_addr),\n      .i_csr       (csr_in),\n      //RD write port\n      .i_rd_wen    (rd_en),\n      .i_rd_waddr  (rd_addr),\n      .i_ctrl_rd   (ctrl_rd),\n      .i_alu_rd    (alu_rd),\n      .i_rd_alu_en (rd_alu_en),\n      .i_csr_rd    (csr_rd),\n      .i_rd_csr_en (rd_csr_en),\n      .i_mem_rd    (mem_rd),\n      .i_rd_mem_en (rd_mem_en),\n\n      //RS1 read port\n      .i_rs1_raddr (rs1_addr),\n      .o_rs1       (rs1),\n      //RS2 read port\n      .i_rs2_raddr (rs2_addr),\n      .o_rs2       (rs2),\n\n      //CSR read port\n      .o_csr       (rf_csr_out));\n\n   serv_mem_if\n     #(.WITH_CSR (WITH_CSR[0:0]))\n   mem_if\n     (\n      .i_clk        (clk),\n      //State\n      .i_bytecnt    (mem_bytecnt),\n      .i_lsb        (lsb),\n      .o_byte_valid (byte_valid),\n      .o_misalign   (mem_misalign),\n      //Control\n      .i_mdu_op     (mdu_op),\n      .i_signed     (mem_signed),\n      .i_word       (mem_word),\n      .i_half       (mem_half),\n      //Data\n      .i_bufreg2_q  (bufreg2_q),\n      .o_rd         (mem_rd),\n      //External interface\n      .o_wb_sel     (o_dbus_sel));\n\n   generate\n      if (|WITH_CSR) begin : gen_csr\n\t serv_csr\n\t   #(.RESET_STRATEGY (RESET_STRATEGY))\n\t csr\n\t   (\n\t    .i_clk        (clk),\n\t    .i_rst        (i_rst),\n\t    //State\n\t    .i_trig_irq   (wb_ibus_ack),\n\t    .i_en         (cnt_en),\n\t    .i_cnt0to3    (cnt0to3),\n\t    .i_cnt3       (cnt3),\n\t    .i_cnt7       (cnt7),\n\t    .i_cnt_done   (cnt_done),\n\t    .i_mem_op     (!mtval_pc),\n\t    .i_mtip       (i_timer_irq),\n\t    .i_trap       (trap),\n\t    .o_new_irq    (new_irq),\n\t    //Control\n\t    .i_e_op       (e_op),\n\t    .i_ebreak     (ebreak),\n\t    .i_mem_cmd    (o_dbus_we),\n\t    .i_mstatus_en (csr_mstatus_en),\n\t    .i_mie_en     (csr_mie_en    ),\n\t    .i_mcause_en  (csr_mcause_en ),\n\t    .i_csr_source (csr_source),\n\t    .i_mret       (mret),\n\t    .i_csr_d_sel  (csr_d_sel),\n\t    //Data\n\t    .i_rf_csr_out (rf_csr_out),\n\t    .o_csr_in     (csr_in),\n\t    .i_csr_imm    (csr_imm),\n\t    .i_rs1        (rs1),\n\t    .o_q          (csr_rd));\n      end else begin : gen_no_csr\n\t assign csr_in = 1'b0;\n\t assign csr_rd = 1'b0;\n\t assign new_irq = 1'b0;\n      end\n   endgenerate\n\n\n`ifdef RISCV_FORMAL\n   reg [31:0] \t pc = RESET_PC;\n\n   wire rs_en = two_stage_op ? init : ctrl_pc_en;\n\n   always @(posedge clk) begin\n      /* End of instruction */\n      rvfi_valid <= cnt_done & ctrl_pc_en & !i_rst;\n      rvfi_order <= rvfi_order + {63'd0,rvfi_valid};\n\n      /* Get instruction word when it's fetched from ibus */\n      if (wb_ibus_cyc & wb_ibus_ack)\n\trvfi_insn <= i_wb_rdt;\n\n      /* Store data written to rd */\n      if (o_wen0)\n        rvfi_rd_wdata <= {o_wdata0,rvfi_rd_wdata[31:1]};\n\n      if (cnt_done & ctrl_pc_en) begin\n         rvfi_pc_rdata <= pc;\n\t if (!(rd_en & (|rd_addr))) begin\n\t   rvfi_rd_addr <= 5'd0;\n\t   rvfi_rd_wdata <= 32'd0;\n\t end\n      end\n      rvfi_trap <= trap;\n      if (rvfi_valid) begin\n         rvfi_trap <= 1'b0;\n         pc <= rvfi_pc_wdata;\n      end\n\n      /* Not used */\n      rvfi_halt <= 1'b0;\n      rvfi_intr <= 1'b0;\n      rvfi_mode <= 2'd3;\n      rvfi_ixl = 2'd1;\n\n      /* RS1 not valid during J, U instructions (immdec_en[1]) */\n      /* RS2 not valid during I, J, U instructions (immdec_en[2]) */\n      if (i_rf_ready) begin\n\t rvfi_rs1_addr <= !immdec_en[1] ? rs1_addr : 5'd0;\n         rvfi_rs2_addr <= !immdec_en[2] /*rs2_valid*/ ? rs2_addr : 5'd0;\n\t rvfi_rd_addr  <= rd_addr;\n      end\n      if (rs_en) begin\n         rvfi_rs1_rdata <= {!immdec_en[1] & rs1,rvfi_rs1_rdata[31:1]};\n         rvfi_rs2_rdata <= {!immdec_en[2] & rs2,rvfi_rs2_rdata[31:1]};\n      end\n\n      if (i_dbus_ack) begin\n         rvfi_mem_addr <= o_dbus_adr;\n         rvfi_mem_rmask <= o_dbus_we ? 4'b0000 : o_dbus_sel;\n         rvfi_mem_wmask <= o_dbus_we ? o_dbus_sel : 4'b0000;\n         rvfi_mem_rdata <= i_dbus_rdt;\n         rvfi_mem_wdata <= o_dbus_dat;\n      end\n      if (wb_ibus_ack) begin\n         rvfi_mem_rmask <= 4'b0000;\n         rvfi_mem_wmask <= 4'b0000;\n      end\n   end\n   /* verilator lint_off COMBDLY */\n   always @(wb_ibus_adr)\n     rvfi_pc_wdata <= wb_ibus_adr;\n   /* verilator lint_on COMBDLY */\n\n\n`endif\n\ngenerate\n  if (MDU) begin: gen_mdu\n    assign dbus_rdt = i_ext_ready ? i_ext_rd:i_dbus_rdt;\n    assign dbus_ack = i_dbus_ack | i_ext_ready;\n  end else begin : gen_no_mdu\n    assign dbus_rdt = i_dbus_rdt;\n    assign dbus_ack = i_dbus_ack;\n  end\n  assign o_ext_rs2 = o_dbus_dat;\nendgenerate\n\nendmodule\n`default_nettype wire\n"}
