{"text": "// file: clock_wizard.v\n// \n// (c) Copyright 2008 - 2013 Xilinx, Inc. All rights reserved.\n// \n// This file contains confidential and proprietary information\n// of Xilinx, Inc. and is protected under U.S. and\n// international copyright and other intellectual property\n// laws.\n// \n// DISCLAIMER\n// This disclaimer is not a license and does not grant any\n// rights to the materials distributed herewith. Except as\n// otherwise provided in a valid license issued to you by\n// Xilinx, and to the maximum extent permitted by applicable\n// law: (1) THESE MATERIALS ARE MADE AVAILABLE \"AS IS\" AND\n// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES\n// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING\n// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-\n// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and\n// (2) Xilinx shall not be liable (whether in contract or tort,\n// including negligence, or under any other theory of\n// liability) for any loss or damage of any kind or nature\n// related to, arising under or in connection with these\n// materials, including for any direct, or any indirect,\n// special, incidental, or consequential loss or damage\n// (including loss of data, profits, goodwill, or any type of\n// loss or damage suffered as a result of any action brought\n// by a third party) even if such damage or loss was\n// reasonably foreseeable or Xilinx had been advised of the\n// possibility of the same.\n// \n// CRITICAL APPLICATIONS\n// Xilinx products are not designed or intended to be fail-\n// safe, or for use in any application requiring fail-safe\n// performance, such as life-support or safety devices or\n// systems, Class III medical devices, nuclear facilities,\n// applications related to the deployment of airbags, or any\n// other applications that could lead to death, personal\n// injury, or severe property or environmental damage\n// (individually and collectively, \"Critical\n// Applications\"). Customer assumes the sole risk and\n// liability of any use of Xilinx products in Critical\n// Applications, subject only to applicable laws and\n// regulations governing limitations on product liability.\n// \n// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS\n// PART OF THIS FILE AT ALL TIMES.\n// \n//----------------------------------------------------------------------------\n// User entered comments\n//----------------------------------------------------------------------------\n// None\n//\n//----------------------------------------------------------------------------\n//  Output     Output      Phase    Duty Cycle   Pk-to-Pk     Phase\n//   Clock     Freq (MHz)  (degrees)    (%)     Jitter (ps)  Error (ps)\n//----------------------------------------------------------------------------\n// clk_out1___100.000______0.000______50.0______107.111_____85.928\n//\n//----------------------------------------------------------------------------\n// Input Clock   Freq (MHz)    Input Jitter (UI)\n//----------------------------------------------------------------------------\n// __primary__________250.00____________0.010\n\n`timescale 1ps / 1ps\n\nmodule clock_wizard #(\n   parameter OUTPUT_PER = 10,\n   parameter INPUT_PER  = 4\n) (  // Clock in ports\n     // Clock out ports\n   output clk_out1,\n   input  clk_in1_p,\n   input  clk_in1_n\n);\n   // Input buffering\n   //------------------------------------\n   wire clk_in1_clock_wizard;\n   wire clk_in2_clock_wizard;\n   IBUFDS clkin1_ibufds (\n      .O (clk_in1_clock_wizard),\n      .I (clk_in1_p),\n      .IB(clk_in1_n)\n   );\n\n\n\n\n   // Clocking PRIMITIVE\n   //------------------------------------\n\n   // Instantiation of the MMCM PRIMITIVE\n   //    * Unused inputs are tied off\n   //    * Unused outputs are labeled unused\n\n   wire        clk_out1_clock_wizard;\n   wire        clk_out2_clock_wizard;\n   wire        clk_out3_clock_wizard;\n   wire        clk_out4_clock_wizard;\n   wire        clk_out5_clock_wizard;\n   wire        clk_out6_clock_wizard;\n   wire        clk_out7_clock_wizard;\n\n   wire [15:0] do_unused;\n   wire        drdy_unused;\n   wire        psdone_unused;\n   wire        locked_int;\n   wire        clkfbout_clock_wizard;\n   wire        clkfboutb_unused;\n   wire        clkout0b_unused;\n   wire        clkout1_unused;\n   wire        clkout1b_unused;\n   wire        clkfbstopped_unused;\n   wire        clkinstopped_unused;\n\n\n\n   // Auto Instantiation//\n\n\n   PLLE3_ADV #(\n      .COMPENSATION      (\"AUTO\"),\n      .STARTUP_WAIT      (\"FALSE\"),\n      .DIVCLK_DIVIDE     (1),\n      .CLKFBOUT_MULT     (4),\n      .CLKFBOUT_PHASE    (0.000),\n      .CLKOUT0_DIVIDE    (4 * OUTPUT_PER / INPUT_PER),\n      .CLKOUT0_PHASE     (0.000),\n      .CLKOUT0_DUTY_CYCLE(0.500),\n      .CLKIN_PERIOD      (INPUT_PER)\n   ) plle3_adv_inst\n   // Output clocks\n   (\n      .CLKFBOUT   (clkfbout_clock_wizard),\n      .CLKOUT0    (clk_out1_clock_wizard),\n      .CLKOUT0B   (clkout0b_unused),\n      .CLKOUT1    (clkout1_unused),\n      .CLKOUT1B   (clkout1b_unused),\n      // Input clock control\n      .CLKFBIN    (clkfbout_clock_wizard),\n      .CLKIN      (clk_in1_clock_wizard),\n      // Ports for dynamic reconfiguration\n      .DADDR      (7'h0),\n      .DCLK       (1'b0),\n      .DEN        (1'b0),\n      .DI         (16'h0),\n      .DO         (do_unused),\n      .DRDY       (drdy_unused),\n      .DWE        (1'b0),\n      .CLKOUTPHYEN(1'b0),\n      .CLKOUTPHY  (),\n      // Other control and status signals\n      .LOCKED     (locked_int),\n      .PWRDWN     (1'b0),\n      .RST        (1'b0)\n   );\n\n\n\n   // Clock Monitor clock assigning\n   //--------------------------------------\n   // Output buffering\n   //-----------------------------------\n\n\n\n\n\n\n   BUFG clkout1_buf (\n      .O(clk_out1),\n      .I(clk_out1_clock_wizard)\n   );\n\n\n\n\nendmodule\n"}
{"text": "`timescale 1 ns / 1 ps\n\n`include \"bsp.vh\"\n`include \"iob_soc_conf.vh\"\n`include \"iob_utils.vh\"\n\n//Peripherals _swreg_def.vh file includes.\n`include \"iob_soc_periphs_swreg_def.vs\"\n\nmodule iob_soc #(\n   `include \"iob_soc_params.vs\"\n) (\n   //rom\n   output                           rom_r_valid_o,\n   output   [BOOTROM_ADDR_W-3:0]    rom_r_addr_o,\n   input       [DATA_W-1:0]         rom_r_rdata_i,\n`ifdef USE_SPRAM\n   output                       valid_spram_o,\n   output     [SRAM_ADDR_W-3:0] addr_spram_o,\n   output     [DATA_W/8-1:0]    wstrb_spram_o,\n   output     [DATA_W-1:0]      wdata_spram_o,\n   input      [DATA_W-1:0]      rdata_spram_i,\n`endif \n   //\n   //sram\n   output                           i_valid_o,\n   output      [SRAM_ADDR_W-3:0]    i_addr_o,\n   output      [     DATA_W-1:0]    i_wdata_o,\n   output      [   DATA_W/8-1:0]    i_wstrb_o,\n   input       [     DATA_W-1:0]    i_rdata_i,\n\n   output                           d_valid_o,\n   output      [SRAM_ADDR_W-3:0]    d_addr_o,\n   output      [     DATA_W-1:0]    d_wdata_o,\n   output      [   DATA_W/8-1:0]    d_wstrb_o,\n   input       [     DATA_W-1:0]    d_rdata_i,\n   //\n   `include \"iob_soc_io.vs\"\n);\n\n   `include \"iob_soc_pwires.vs\"\n\n   //\n   // SYSTEM RESET\n   //\n\n   wire boot;\n   wire cpu_reset;\n\n   //\n   //  CPU\n   //\n\n   // instruction bus\n   wire [ `REQ_W-1:0] cpu_i_req;\n   wire [`RESP_W-1:0] cpu_i_resp;\n\n   // data cat bus\n   wire [ `REQ_W-1:0] cpu_d_req;\n   wire [`RESP_W-1:0] cpu_d_resp;\n\n   //instantiate the cpu\n   iob_picorv32 #(\n      .ADDR_W        (ADDR_W),\n      .DATA_W        (DATA_W),\n      .USE_COMPRESSED(`IOB_SOC_USE_COMPRESSED),\n      .USE_MUL_DIV   (`IOB_SOC_USE_MUL_DIV),\n`ifdef IOB_SOC_USE_EXTMEM\n      .USE_EXTMEM    (1)\n`else\n      .USE_EXTMEM    (0)\n`endif\n   ) cpu (\n      .clk_i (clk_i),\n      .arst_i (cpu_reset),\n      .cke_i (cke_i),\n      .boot_i(boot),\n      .trap_o(cpu_trap_o),\n\n      //instruction bus\n      .ibus_req_o (cpu_i_req),\n      .ibus_resp_i(cpu_i_resp),\n\n      //data bus\n      .dbus_req_o (cpu_d_req),\n      .dbus_resp_i(cpu_d_resp)\n   );\n\n\n   //\n   // SPLIT CPU BUSES TO ACCESS INTERNAL OR EXTERNAL MEMORY\n   //\n\n   //internal memory instruction bus\n   wire [ `REQ_W-1:0] int_mem_i_req;\n   wire [`RESP_W-1:0] int_mem_i_resp;\n   //external memory instruction bus\n`ifdef IOB_SOC_USE_EXTMEM\n   wire [ `REQ_W-1:0] ext_mem_i_req;\n   wire [`RESP_W-1:0] ext_mem_i_resp;\n\n   // INSTRUCTION BUS\n   iob_split #(\n      .ADDR_W  (ADDR_W),\n      .DATA_W  (DATA_W),\n      .N_SLAVES(2),\n      .P_SLAVES(`REQ_W - 2)\n   ) ibus_split (\n      .clk_i   (clk_i),\n      .arst_i  (cpu_reset),\n      // master interface\n      .m_req_i (cpu_i_req),\n      .m_resp_o(cpu_i_resp),\n      // slaves interface\n      .s_req_o ({ext_mem_i_req, int_mem_i_req}),\n      .s_resp_i({ext_mem_i_resp, int_mem_i_resp})\n   );\n`else\n   assign int_mem_i_req = cpu_i_req;\n   assign cpu_i_resp    = int_mem_i_resp;\n`endif\n\n\n   // DATA BUS\n\n   //internal data bus\n   wire [ `REQ_W-1:0] int_d_req;\n   wire [`RESP_W-1:0] int_d_resp;\n`ifdef IOB_SOC_USE_EXTMEM\n   //external memory data bus\n   wire [ `REQ_W-1:0] ext_mem_d_req;\n   wire [`RESP_W-1:0] ext_mem_d_resp;\n\n   iob_split #(\n      .ADDR_W  (ADDR_W),\n      .DATA_W  (DATA_W),\n      .N_SLAVES(2),       //E,{P,I}\n      .P_SLAVES(`REQ_W - 2)\n   ) dbus_split (\n      .clk_i   (clk_i),\n      .arst_i  (cpu_reset),\n      // master interface\n      .m_req_i (cpu_d_req),\n      .m_resp_o(cpu_d_resp),\n      // slaves interface\n      .s_req_o ({ext_mem_d_req, int_d_req}),\n      .s_resp_i({ext_mem_d_resp, int_d_resp})\n   );\n`else\n   assign int_d_req  = cpu_d_req;\n   assign cpu_d_resp = int_d_resp;\n`endif\n\n   //\n   // SPLIT INTERNAL MEMORY AND PERIPHERALS BUS\n   //\n\n   //slaves bus (includes internal memory + periphrals)\n   wire [ (`IOB_SOC_N_SLAVES)*`REQ_W-1:0] slaves_req;\n   wire [(`IOB_SOC_N_SLAVES)*`RESP_W-1:0] slaves_resp;\n\n   iob_split #(\n      .ADDR_W  (ADDR_W),\n      .DATA_W  (DATA_W),\n      .N_SLAVES(`IOB_SOC_N_SLAVES),\n      .P_SLAVES(`REQ_W - 3)\n   ) pbus_split (\n      .clk_i   (clk_i),\n      .arst_i  (cpu_reset),\n      // master interface\n      .m_req_i (int_d_req),\n      .m_resp_o(int_d_resp),\n      // slaves interface\n      .s_req_o (slaves_req),\n      .s_resp_i(slaves_resp)\n   );\n\n\n   //\n   // INTERNAL SRAM MEMORY\n   //\n\n   iob_soc_int_mem #(\n      .ADDR_W        (ADDR_W),\n      .DATA_W        (DATA_W),\n      .HEXFILE       (\"iob_soc_firmware\"),\n      .BOOT_HEXFILE  (\"iob_soc_boot\"),\n      .SRAM_ADDR_W   (SRAM_ADDR_W),\n      .BOOTROM_ADDR_W(BOOTROM_ADDR_W),\n      .B_BIT         (`REQ_W - (ADDR_W-`IOB_SOC_B+1))\n   ) int_mem0 (\n      .clk_i    (clk_i),\n      .arst_i   (arst_i),\n      .cke_i    (cke_i),\n      .boot     (boot),\n      .cpu_reset(cpu_reset),\n\n      // instruction bus\n      .i_req_i (int_mem_i_req),\n      .i_resp_o(int_mem_i_resp),\n\n      //data bus\n      .d_req_i (slaves_req[0+:`REQ_W]),\n      .d_resp_o(slaves_resp[0+:`RESP_W]),\n   `ifdef USE_SPRAM\n      .valid_spram_o(valid_spram_o),\n      .addr_spram_o(addr_spram_o),\n      .wstrb_spram_o(wstrb_spram_o),\n      .wdata_spram_o(wdata_spram_o),\n      .rdata_spram_i(rdata_spram_i),\n   `endif \n\n\n      //rom\n      .rom_r_valid_o(rom_r_valid_o),\n      .rom_r_addr_o(rom_r_addr_o),\n      .rom_r_rdata_i(rom_r_rdata_i),\n      //\n\n      //ram\n      .i_valid_o(i_valid_o),\n      .i_addr_o(i_addr_o),\n      .i_wdata_o(i_wdata_o),\n      .i_wstrb_o(i_wstrb_o),\n      .i_rdata_i(i_rdata_i),\n      .d_valid_o(d_valid_o),\n      .d_addr_o(d_addr_o),\n      .d_wdata_o(d_wdata_o),\n      .d_wstrb_o(d_wstrb_o),\n      .d_rdata_i(d_rdata_i)\n   //\n   );\n\n`ifdef IOB_SOC_USE_EXTMEM\n   //\n   // EXTERNAL DDR MEMORY\n   //\n\n   wire [ 1+MEM_ADDR_W-2+DATA_W+DATA_W/8-1:0] ext_mem0_i_req;\n   wire [1+MEM_ADDR_W+1-2+DATA_W+DATA_W/8-1:0] ext_mem0_d_req;\n\n   assign ext_mem0_i_req = {\n      ext_mem_i_req[`VALID(0)],\n      ext_mem_i_req[`ADDRESS(0, MEM_ADDR_W)-2],\n      ext_mem_i_req[`WRITE(0)]\n   };\n   assign ext_mem0_d_req = {\n      ext_mem_d_req[`VALID(0)],\n      ext_mem_d_req[`ADDRESS(0, MEM_ADDR_W+1)-2],\n      ext_mem_d_req[`WRITE(0)]\n   };\n\n   wire [AXI_ADDR_W-1:0] internal_axi_awaddr_o;\n   wire [AXI_ADDR_W-1:0] internal_axi_araddr_o;\n\n   iob_soc_ext_mem #(\n      .ADDR_W     (ADDR_W),\n      .DATA_W     (DATA_W),\n      .FIRM_ADDR_W(MEM_ADDR_W),\n      .MEM_ADDR_W (MEM_ADDR_W),\n      .DDR_ADDR_W (`DDR_ADDR_W),\n      .DDR_DATA_W (`DDR_DATA_W),\n      .AXI_ID_W   (AXI_ID_W),\n      .AXI_LEN_W  (AXI_LEN_W),\n      .AXI_ADDR_W (AXI_ADDR_W),\n      .AXI_DATA_W (AXI_DATA_W)\n   ) ext_mem0 (\n      // instruction bus\n      .i_req_i (ext_mem0_i_req),\n      .i_resp_o(ext_mem_i_resp),\n\n      //data bus\n      .d_req_i (ext_mem0_d_req),\n      .d_resp_o(ext_mem_d_resp),\n\n      //AXI INTERFACE\n      //address write\n      .axi_awid_o   (axi_awid_o[0+:AXI_ID_W]),\n      .axi_awaddr_o (internal_axi_awaddr_o[0+:AXI_ADDR_W]),\n      .axi_awlen_o  (axi_awlen_o[0+:AXI_LEN_W]),\n      .axi_awsize_o (axi_awsize_o[0+:3]),\n      .axi_awburst_o(axi_awburst_o[0+:2]),\n      .axi_awlock_o (axi_awlock_o[0+:2]),\n      .axi_awcache_o(axi_awcache_o[0+:4]),\n      .axi_awprot_o (axi_awprot_o[0+:3]),\n      .axi_awqos_o  (axi_awqos_o[0+:4]),\n      .axi_awvalid_o(axi_awvalid_o[0+:1]),\n      .axi_awready_i(axi_awready_i[0+:1]),\n      //write\n      .axi_wdata_o  (axi_wdata_o[0+:AXI_DATA_W]),\n      .axi_wstrb_o  (axi_wstrb_o[0+:(AXI_DATA_W/8)]),\n      .axi_wlast_o  (axi_wlast_o[0+:1]),\n      .axi_wvalid_o (axi_wvalid_o[0+:1]),\n      .axi_wready_i (axi_wready_i[0+:1]),\n      //write response\n      .axi_bid_i    (axi_bid_i[0+:AXI_ID_W]),\n      .axi_bresp_i  (axi_bresp_i[0+:2]),\n      .axi_bvalid_i (axi_bvalid_i[0+:1]),\n      .axi_bready_o (axi_bready_o[0+:1]),\n      //address read\n      .axi_arid_o   (axi_arid_o[0+:AXI_ID_W]),\n      .axi_araddr_o (internal_axi_araddr_o[0+:AXI_ADDR_W]),\n      .axi_arlen_o  (axi_arlen_o[0+:AXI_LEN_W]),\n      .axi_arsize_o (axi_arsize_o[0+:3]),\n      .axi_arburst_o(axi_arburst_o[0+:2]),\n      .axi_arlock_o (axi_arlock_o[0+:2]),\n      .axi_arcache_o(axi_arcache_o[0+:4]),\n      .axi_arprot_o (axi_arprot_o[0+:3]),\n      .axi_arqos_o  (axi_arqos_o[0+:4]),\n      .axi_arvalid_o(axi_arvalid_o[0+:1]),\n      .axi_arready_i(axi_arready_i[0+:1]),\n      //read\n      .axi_rid_i    (axi_rid_i[0+:AXI_ID_W]),\n      .axi_rdata_i  (axi_rdata_i[0+:AXI_DATA_W]),\n      .axi_rresp_i  (axi_rresp_i[0+:2]),\n      .axi_rlast_i  (axi_rlast_i[0+:1]),\n      .axi_rvalid_i (axi_rvalid_i[0+:1]),\n      .axi_rready_o (axi_rready_o[0+:1]),\n\n      .clk_i (clk_i),\n      .cke_i (cke_i),\n      .arst_i(cpu_reset)\n   );\n\n   assign axi_awaddr_o[AXI_ADDR_W-1:0] = internal_axi_awaddr_o + MEM_ADDR_OFFSET;\n   assign axi_araddr_o[AXI_ADDR_W-1:0] = internal_axi_araddr_o + MEM_ADDR_OFFSET;\n`endif\n\n   `include \"iob_soc_periphs_inst.vs\"\n\nendmodule\n"}
{"text": "`timescale 1 ns / 1 ps\n\nmodule iob_soc_boot_ctr #(\n   parameter HEXFILE        = \"boot.hex\",\n   parameter DATA_W         = 0,\n   parameter ADDR_W         = 0,\n   parameter BOOTROM_ADDR_W = 0,\n   parameter SRAM_ADDR_W    = 0\n) (\n   output cpu_rst_o,\n   output boot_o,\n\n   //cpu interface\n   input                     cpu_valid_i,\n   input      [         1:0] cpu_wdata_i,\n   input      [DATA_W/8-1:0] cpu_wstrb_i,\n   output     [  DATA_W-1:0] cpu_rdata_o,\n   output                    cpu_rvalid_o,\n   output                    cpu_ready_o,\n\n\n   //sram master write interface\n   output                    sram_valid_o,\n   output     [  ADDR_W-1:0] sram_addr_o,\n   output     [  DATA_W-1:0] sram_wdata_o,\n   output     [DATA_W/8-1:0] sram_wstrb_o,\n\n   //rom\n   output                           rom_r_valid_o,\n   output      [BOOTROM_ADDR_W-3:0] rom_r_addr_o,\n   input       [DATA_W-1:0]         rom_r_rdata_i,\n   //\n   `include \"clk_en_rst_s_port.vs\"\n);\n\n\n   //cpu interface: rdata and ready\n   assign cpu_rdata_o = {{(DATA_W - 1) {1'b0}}, boot_o};\n   iob_reg #(\n      .DATA_W (1),\n      .RST_VAL(0)\n   ) rvalid_reg (\n      .clk_i (clk_i),\n      .arst_i(arst_i),\n      .cke_i (cke_i),\n      .data_i(cpu_valid_i & ~(|cpu_wstrb_i)),\n      .data_o(cpu_rvalid_o)\n   );\n   assign cpu_ready_o = 1'b1;\n\n   //boot register: (1) load bootloader to sram and run it: (0) run program\n   wire boot_wr = cpu_valid_i & |cpu_wstrb_i;\n   wire                                     boot_nxt;\n   iob_reg_re #(\n      .DATA_W (1),\n      .RST_VAL(1)\n   ) bootnxt (\n      .clk_i (clk_i),\n      .arst_i(arst_i),\n      .cke_i (cke_i),\n      .rst_i (1'b0),\n      .en_i  (boot_wr),\n      .data_i(cpu_wdata_i[0]),\n      .data_o(boot_nxt)\n   );\n   iob_reg_r #(\n      .DATA_W (1),\n      .RST_VAL(1)\n   ) bootreg (\n      .clk_i (clk_i),\n      .arst_i(arst_i),\n      .cke_i (cke_i),\n      .rst_i (1'b0),\n      .data_i(boot_nxt),\n      .data_o(boot_o)\n   );\n\n\n   //create CPU reset pulse\n   wire cpu_rst_req;\n   assign cpu_rst_req = cpu_valid_i & (|cpu_wstrb_i) & cpu_wdata_i[1];\n   wire cpu_rst_pulse;\n\n   iob_pulse_gen #(\n      .START   (0),\n      .DURATION(100)\n   ) reset_pulse (\n      .clk_i  (clk_i),\n      .arst_i (arst_i),\n      .cke_i  (cke_i),\n      .start_i(cpu_rst_req),\n      .pulse_o(cpu_rst_pulse)\n   );\n\n   wire loading;\n   assign cpu_rst_o = loading | cpu_rst_pulse;\n\n   //\n   // READ BOOT ROM \n   //\n\n   wire                       rom_r_valid_o_nxt;\n\n   assign rom_r_valid_o_nxt = (boot_o && rom_r_addr_o != ({BOOTROM_ADDR_W - 2{1'b1}}-1) && rom_r_valid_o != 1'b0) ? 1'b1 : 1'b0;\n   \n   wire [BOOTROM_ADDR_W-3:0] rom_r_addr_o_nxt;\n\n   assign rom_r_addr_o_nxt = (boot_o && rom_r_addr_o != ({BOOTROM_ADDR_W - 2{1'b1}}-1)) ? rom_r_addr_o + 1'b1 : {(BOOTROM_ADDR_W - 2) {1'b0}};\n\n   iob_reg #(\n      .DATA_W (BOOTROM_ADDR_W-2),\n      .RST_VAL({(BOOTROM_ADDR_W - 2) {1'b0}})\n   )rom_r_addr_o_reg (\n      .clk_i (clk_i),\n      .arst_i(arst_i),\n      .cke_i (cke_i),\n      .data_i(rom_r_addr_o_nxt),\n      .data_o(rom_r_addr_o)\n   );\n\n   iob_reg #(\n      .DATA_W (1),\n      .RST_VAL(1'b1)\n   )rom_r_valid_o_reg (\n      .clk_i (clk_i),\n      .arst_i(arst_i),\n      .cke_i (cke_i),\n      .data_i(rom_r_valid_o_nxt),\n      .data_o(rom_r_valid_o)\n   );\n\n   //\n   // WRITE SRAM\n   //\n\n   wire                    sram_w_valid;\n   wire                    sram_w_valid_nxt;\n\n   assign sram_w_valid_nxt = boot_o ? rom_r_valid_o : 1'b0;\n\n\n\n   wire [SRAM_ADDR_W-2-1:0] sram_w_addr;\n   wire [SRAM_ADDR_W-2-1:0] sram_w_addr_nxt;\n\n   assign sram_w_addr_nxt = boot_o ? (1'b1<<(SRAM_ADDR_W-2))-(1'b1<<(BOOTROM_ADDR_W-2)) + rom_r_addr_o : (1'b1<<(SRAM_ADDR_W-2))-(1'b1<<(BOOTROM_ADDR_W-2));\n\n\n   wire [DATA_W/8-1:0] sram_wstrb_o_nxt;\n\n\n   assign sram_wstrb_o_nxt = boot_o ? {DATA_W / 8{rom_r_valid_o}} : {DATA_W / 8{1'b0}};\n\n\n   iob_reg #(\n      .DATA_W (1),\n      .RST_VAL(1'b0)\n   )sram_w_valid_reg (\n      .clk_i (clk_i),\n      .arst_i(arst_i),\n      .cke_i (cke_i),\n      .data_i(sram_w_valid_nxt),\n      .data_o(sram_w_valid)\n   );\n\n   iob_reg #(\n      .DATA_W (SRAM_ADDR_W-2),\n      .RST_VAL((1'b1<<(SRAM_ADDR_W-2))-(1'b1<<(BOOTROM_ADDR_W-2)))\n   )sram_w_addr_reg (\n      .clk_i (clk_i),\n      .arst_i(arst_i),\n      .cke_i (cke_i),\n      .data_i(sram_w_addr_nxt),\n      .data_o(sram_w_addr)\n   );\n\n\n    iob_reg #(\n      .DATA_W (DATA_W/8),\n      .RST_VAL({DATA_W / 8{1'b0}})\n   )sram_wstrb_o_reg (\n      .clk_i (clk_i),\n      .arst_i(arst_i),\n      .cke_i (cke_i),\n      .data_i(sram_wstrb_o_nxt),\n      .data_o(sram_wstrb_o)\n   );\n\n   assign loading     = rom_r_valid_o | sram_w_valid;\n   assign sram_valid_o = sram_w_valid;\n   assign sram_addr_o   = {sram_w_addr, 2'b00};\n   assign sram_wdata_o  = rom_r_rdata_i;\n\n\nendmodule\n"}
{"text": "`timescale 1 ns / 1 ps\n\n`include \"iob_utils.vh\"\n\nmodule iob_soc_ext_mem #(\n   parameter ADDR_W      = 0,\n   parameter DATA_W      = 0,\n   parameter FIRM_ADDR_W = 0,\n   parameter MEM_ADDR_W  = 0,\n   parameter DDR_ADDR_W  = 0,\n   parameter DDR_DATA_W  = 0,\n   parameter AXI_ID_W    = 0,\n   parameter AXI_LEN_W   = 0,\n   parameter AXI_ADDR_W  = 0,\n   parameter AXI_DATA_W  = 0\n) (\n   // Instruction bus\n   input  [1+FIRM_ADDR_W-2+`WRITE_W-1:0] i_req_i,\n   output [                 `RESP_W-1:0] i_resp_o,\n\n   // Data bus\n   input  [1+1+MEM_ADDR_W-2+`WRITE_W-1:0] d_req_i,\n   output [                  `RESP_W-1:0] d_resp_o,\n\n   // AXI interface\n   `include \"axi_m_port.vs\"\n   `include \"clk_en_rst_s_port.vs\"\n);\n\n   //\n   // INSTRUCTION CACHE\n   //\n\n   // Back-end bus\n   wire [1+MEM_ADDR_W+`WRITE_W-1:0] icache_be_req;\n   wire [              `RESP_W-1:0] icache_be_resp;\n\n\n   // Instruction cache instance\n   iob_cache_iob #(\n      .FE_ADDR_W    (FIRM_ADDR_W),\n      .BE_ADDR_W    (MEM_ADDR_W),\n      .NWAYS_W      (1),            //Number of ways\n      .NLINES_W     (7),            //Cache Line Offset (number of lines)\n      .WORD_OFFSET_W(3),            //Word Offset (number of words per line)\n      .WTBUF_DEPTH_W(5),            //FIFO's depth -- 5 minimum for BRAM implementation\n      .USE_CTRL     (0),            //Cache-Control can't be accessed\n      .USE_CTRL_CNT (0)             //Remove counters\n   ) icache (\n      .clk_i (clk_i),\n      .cke_i (cke_i),\n      .arst_i(arst_i),\n\n      // Front-end interface\n      .iob_valid_i        (i_req_i[1+FIRM_ADDR_W-2+`WRITE_W-1]),\n      .iob_addr_i          (i_req_i[`ADDRESS(0, FIRM_ADDR_W-2)]),\n      .iob_wdata_i         (i_req_i[`WDATA(0)]),\n      .iob_wstrb_i         (i_req_i[`WSTRB(0)]),\n      .iob_rdata_o         (i_resp_o[`RDATA(0)]),\n      .iob_rvalid_o        (i_resp_o[`RVALID(0)]),\n      .iob_ready_o         (i_resp_o[`READY(0)]),\n      //Control IO\n      .invalidate_i (1'b0),\n      .invalidate_o(),\n      .wtb_empty_i  (1'b1),\n      .wtb_empty_o (),\n      // Back-end interface\n      .be_valid_o     (icache_be_req[1+MEM_ADDR_W+`WRITE_W-1]),\n      .be_addr_o       (icache_be_req[`ADDRESS(0, MEM_ADDR_W)]),\n      .be_wdata_o      (icache_be_req[`WDATA(0)]),\n      .be_wstrb_o      (icache_be_req[`WSTRB(0)]),\n      .be_rdata_i      (icache_be_resp[`RDATA(0)]),\n      .be_rvalid_i     (icache_be_resp[`RVALID(0)]),\n      .be_ready_i      (icache_be_resp[`READY(0)])\n   );\n\n   //l2 cache interface signals\n   wire [1+MEM_ADDR_W+`WRITE_W-1:0] l2cache_req;\n   wire [`RESP_W-1:0] l2cache_resp;\n\n   //ext_mem control signals\n   wire l2_wtb_empty;\n   wire invalidate;\n   reg invalidate_reg;\n   wire l2_valid = l2cache_req[1+MEM_ADDR_W+`WRITE_W-1];\n   //Necessary logic to avoid invalidating L2 while it's being accessed by a request\n   always @(posedge clk_i, posedge arst_i)\n      if (arst_i) invalidate_reg <= 1'b0;\n      else if (invalidate) invalidate_reg <= 1'b1;\n      else if (~l2_valid) invalidate_reg <= 1'b0;\n      else invalidate_reg <= invalidate_reg;\n\n   //\n   // DATA CACHE\n   //\n\n   // IOb ready and rvalid signals\n\n   // Back-end bus\n   wire [1+MEM_ADDR_W+`WRITE_W-1:0] dcache_be_req;\n   wire [              `RESP_W-1:0] dcache_be_resp;\n\n   // Data cache instance\n   iob_cache_iob #(\n      .FE_ADDR_W    (MEM_ADDR_W),\n      .BE_ADDR_W    (MEM_ADDR_W),\n      .NWAYS_W      (1),           //Number of ways\n      .NLINES_W     (7),           //Cache Line Offset (number of lines)\n      .WORD_OFFSET_W(3),           //Word Offset (number of words per line)\n      .WTBUF_DEPTH_W(5),           //FIFO's depth -- 5 minimum for BRAM implementation\n      .USE_CTRL     (1),           //Either 1 to enable cache-control or 0 to disable\n      .USE_CTRL_CNT (0)            //do not change (it's implementation depends on the previous)\n   ) dcache (\n      .clk_i (clk_i),\n      .cke_i (cke_i),\n      .arst_i(arst_i),\n\n      // Front-end interface\n      .iob_valid_i        (d_req_i[2+MEM_ADDR_W-2+`WRITE_W-1]),\n      .iob_addr_i          (d_req_i[`ADDRESS(0, 1+MEM_ADDR_W-2)]),\n      .iob_wdata_i         (d_req_i[`WDATA(0)]),\n      .iob_wstrb_i         (d_req_i[`WSTRB(0)]),\n      .iob_rdata_o         (d_resp_o[`RDATA(0)]),\n      .iob_rvalid_o        (d_resp_o[`RVALID(0)]),\n      .iob_ready_o         (d_resp_o[`READY(0)]),\n      //Control IO\n      .invalidate_i (1'b0),\n      .invalidate_o(invalidate),\n      .wtb_empty_i  (l2_wtb_empty),\n      .wtb_empty_o (),\n      // Back-end interface\n      .be_valid_o     (dcache_be_req[1+MEM_ADDR_W+`WRITE_W-1]),\n      .be_addr_o       (dcache_be_req[`ADDRESS(0, MEM_ADDR_W)]),\n      .be_wdata_o      (dcache_be_req[`WDATA(0)]),\n      .be_wstrb_o      (dcache_be_req[`WSTRB(0)]),\n      .be_rdata_i      (dcache_be_resp[`RDATA(0)]),\n      .be_rvalid_i     (dcache_be_resp[`RVALID(0)]),\n      .be_ready_i      (dcache_be_resp[`READY(0)])\n   );\n\n   // Merge cache back-ends\n   iob_merge #(\n      .ADDR_W   (MEM_ADDR_W),\n      .N_MASTERS(2)\n   ) merge_i_d_buses_into_l2 (\n      .clk_i   (clk_i),\n      .arst_i  (arst_i),\n      // masters\n      .m_req_i ({icache_be_req, dcache_be_req}),\n      .m_resp_o({icache_be_resp, dcache_be_resp}),\n      // slave\n      .s_req_o (l2cache_req),\n      .s_resp_i(l2cache_resp)\n   );\n\n   wire                  l2cache_valid;\n   wire [MEM_ADDR_W-3:0] l2cache_addr;\n   wire [    DATA_W-1:0] l2cache_wdata;\n   wire [  DATA_W/8-1:0] l2cache_wstrb;\n   wire [    DATA_W-1:0] l2cache_rdata;\n   wire                  l2cache_rvalid;\n   wire                  l2cache_ready;\n\n   assign l2cache_valid            = l2cache_req[1+MEM_ADDR_W+`WRITE_W-1];\n   assign l2cache_addr             = l2cache_req[`ADDRESS(0, MEM_ADDR_W)-2];\n   assign l2cache_wdata            = l2cache_req[`WDATA(0)];\n   assign l2cache_wstrb            = l2cache_req[`WSTRB(0)];\n   assign l2cache_resp[`RDATA(0)]  = l2cache_rdata;\n   assign l2cache_resp[`RVALID(0)] = l2cache_rvalid;\n   assign l2cache_resp[`READY(0)]  = l2cache_ready;\n\n   // L2 cache instance\n   iob_cache_axi #(\n      .AXI_ID_W     (AXI_ID_W),\n      .AXI_LEN_W    (AXI_LEN_W),\n      .FE_ADDR_W    (MEM_ADDR_W),\n      .BE_ADDR_W    (DDR_ADDR_W),\n      .BE_DATA_W    (DDR_DATA_W),\n      .NWAYS_W      (2),           //Number of Ways\n      .NLINES_W     (7),           //Cache Line Offset (number of lines)\n      .WORD_OFFSET_W(3),           //Word Offset (number of words per line)\n      .WTBUF_DEPTH_W(5),           //FIFO's depth -- 5 minimum for BRAM implementation\n      .USE_CTRL     (0),           //Cache-Control can't be accessed\n      .USE_CTRL_CNT (0)            //Remove counters\n   ) l2cache (\n      // Native interface\n      .iob_valid_i        (l2cache_valid),\n      .iob_addr_i          (l2cache_addr),\n      .iob_wdata_i         (l2cache_wdata),\n      .iob_wstrb_i         (l2cache_wstrb),\n      .iob_rdata_o         (l2cache_rdata),\n      .iob_rvalid_o        (l2cache_rvalid),\n      .iob_ready_o         (l2cache_ready),\n      //Control IO\n      .invalidate_i (invalidate_reg & ~l2_valid),\n      .invalidate_o(),\n      .wtb_empty_i  (1'b1),\n      .wtb_empty_o (l2_wtb_empty),\n      // AXI interface\n      `include \"axi_m_m_portmap.vs\"\n      .clk_i         (clk_i),\n      .cke_i         (cke_i),\n      .arst_i        (arst_i)\n   );\n\nendmodule\n"}
{"text": "`timescale 1ns / 1ps\n\nmodule iob_soc_fpga_wrapper (\n    input clk,\n    input reset,\n\n    //uart\n    output txd_o,\n    input  rxd_i\n);\n\n  //\n  // RESET MANAGEMENT\n  //\n\n  //system reset\n\n  wire        sys_rst;\n\n  reg  [15:0] rst_cnt;\n  reg         sys_rst_int;\n\n  always @(posedge clk, posedge reset)\n    if (reset) begin\n      sys_rst_int <= 1'b0;\n      rst_cnt     <= 16'hFFFF;\n    end else begin\n      if (rst_cnt != 16'h0) rst_cnt <= rst_cnt - 1'b1;\n      sys_rst_int <= (rst_cnt != 16'h0);\n    end\n\n  assign sys_rst = sys_rst_int;\n\n  //\n  // SYSTEM\n  //\n  iob_soc_mwrap iob_soc (\n      `include \"iob_soc_pportmaps.vs\"\n      .clk_i (clk),\n      .cke_i (1'b1),\n      .arst_i(sys_rst),\n      .trap_o(trap)\n  );\n\n  // UART\n  assign txd_o = uart_txd_o;\n  assign uart_rxd_i = rxd_i;\n  assign uart_cts_i = 1'b1;\n  // uart_rts_o unconnected\n\nendmodule\n"}
{"text": "`timescale 1 ns / 1 ps\n\n`include \"iob_soc_conf.vh\"\n`include \"iob_utils.vh\"\n\nmodule iob_soc_int_mem #(\n   parameter ADDR_W         = 0,\n   parameter DATA_W         = 0,\n   parameter HEXFILE        = \"firmware\",\n   parameter BOOT_HEXFILE   = \"boot\",\n   parameter SRAM_ADDR_W    = 0,\n   parameter BOOTROM_ADDR_W = 0,\n   parameter B_BIT          = 0\n) (\n\n   output boot,\n   output cpu_reset,\n\n   //instruction bus\n   input  [ `REQ_W-1:0] i_req_i,\n   output [`RESP_W-1:0] i_resp_o,\n\n   //data bus\n   input  [ `REQ_W-1:0] d_req_i,\n   output [`RESP_W-1:0] d_resp_o,\n`ifdef USE_SPRAM\n   output                       valid_spram_o,\n   output     [SRAM_ADDR_W-3:0] addr_spram_o,\n   output     [DATA_W/8-1:0]    wstrb_spram_o,\n   output     [DATA_W-1:0]      wdata_spram_o,\n   input      [DATA_W-1:0]      rdata_spram_i,\n`endif \n   //rom\n   output                           rom_r_valid_o,\n   output      [BOOTROM_ADDR_W-3:0] rom_r_addr_o,\n   input       [DATA_W-1:0]         rom_r_rdata_i,\n   //\n\n   //sram\n   output                           i_valid_o,\n   output      [SRAM_ADDR_W-3:0]    i_addr_o,\n   output      [     DATA_W-1:0]    i_wdata_o,\n   output      [   DATA_W/8-1:0]    i_wstrb_o,\n   input       [     DATA_W-1:0]    i_rdata_i,\n\n   output                           d_valid_o,\n   output      [SRAM_ADDR_W-3:0]    d_addr_o,\n   output      [     DATA_W-1:0]    d_wdata_o,\n   output      [   DATA_W/8-1:0]    d_wstrb_o,\n   input       [     DATA_W-1:0]    d_rdata_i,\n   //\n\n   `include \"clk_en_rst_s_port.vs\"\n);\n\n   wire [ `REQ_W-1:0] ram_i_req;\n   wire [`RESP_W-1:0] ram_i_resp;\n\n    //sram data bus  interface\n   wire [     `REQ_W-1:0] ram_d_req;\n   wire [    `RESP_W-1:0] ram_d_resp;\n\n\n   //modified ram address during boot\n   wire [SRAM_ADDR_W-3:0] ram_d_addr;\n\n\n   `ifdef USE_SPRAM\n      assign ram_d_resp[`RDATA(0)] = rdata_spram_i;\n      assign ram_i_resp[`RDATA(0)] = rdata_spram_i;\n   \n   `else\n      assign ram_i_resp[`RDATA(0)] = i_rdata_i;\n      assign ram_d_resp[`RDATA(0)] = d_rdata_i;\n   `endif \n\n   assign i_valid_o  = ram_i_req[`VALID(0)];\n   assign i_addr_o   = ram_i_req[`ADDRESS(0, SRAM_ADDR_W)-2];\n   assign i_wdata_o  = ram_i_req[`WDATA(0)];\n   assign i_wstrb_o  = ram_i_req[`WSTRB(0)];\n\n   assign d_valid_o  = ram_d_req[`VALID(0)];\n   assign d_addr_o   = ram_d_addr;\n   assign d_wdata_o  = ram_d_req[`WDATA(0)];\n   assign d_wstrb_o  = ram_d_req[`WSTRB(0)];\n\n\n\n\n\n\n\n  \n\n\n   ////////////////////////////////////////////////////////\n   // BOOT HARDWARE\n   //\n   //boot controller bus to write program in sram\n   wire [     `REQ_W-1:0] boot_ctr_req;\n   wire [    `RESP_W-1:0] boot_ctr_resp;\n\n   //\n   // SPLIT DATA BUS BETWEEN SRAM AND BOOT CONTROLLER\n   //\n   iob_split #(\n      .ADDR_W  (ADDR_W),\n      .DATA_W  (DATA_W),\n      .N_SLAVES(2),\n      .P_SLAVES(B_BIT)\n   ) data_bootctr_split (\n      .clk_i   (clk_i),\n      .arst_i  (arst_i),\n      // master interface\n      .m_req_i (d_req_i),\n      .m_resp_o(d_resp_o),\n\n      // slaves interface\n      .s_req_o ({boot_ctr_req, ram_d_req}),\n      .s_resp_i({boot_ctr_resp, ram_d_resp})\n   );\n\n\n   //\n   // BOOT CONTROLLER\n   //\n\n   //sram instruction write bus\n   wire [ `REQ_W-1:0] ram_w_req;\n   wire [`RESP_W-1:0] ram_w_resp;\n\n   iob_soc_boot_ctr #(\n      .HEXFILE       ({BOOT_HEXFILE, \".hex\"}),\n      .DATA_W        (DATA_W),\n      .ADDR_W        (ADDR_W),\n      .BOOTROM_ADDR_W(BOOTROM_ADDR_W),\n      .SRAM_ADDR_W   (SRAM_ADDR_W)\n   ) boot_ctr0 (\n      .clk_i    (clk_i),\n      .arst_i   (arst_i),\n      .cke_i    (cke_i),\n      .cpu_rst_o(cpu_reset),\n      .boot_o   (boot),\n\n      //cpu slave interface\n      //no address bus since single address\n      .cpu_valid_i(boot_ctr_req[`VALID(0)]),\n      .cpu_wdata_i (boot_ctr_req[`WDATA(0)-(DATA_W-2)]),\n      .cpu_wstrb_i (boot_ctr_req[`WSTRB(0)]),\n      .cpu_rdata_o (boot_ctr_resp[`RDATA(0)]),\n      .cpu_rvalid_o(boot_ctr_resp[`RVALID(0)]),\n      .cpu_ready_o (boot_ctr_resp[`READY(0)]),\n\n      //sram write master interface\n      .sram_valid_o(ram_w_req[`VALID(0)]),\n      .sram_addr_o  (ram_w_req[`ADDRESS(0, ADDR_W)]),\n      .sram_wdata_o (ram_w_req[`WDATA(0)]),\n      .sram_wstrb_o (ram_w_req[`WSTRB(0)]),\n      //rom\n      .rom_r_valid_o(rom_r_valid_o),\n      .rom_r_addr_o(rom_r_addr_o),\n      .rom_r_rdata_i(rom_r_rdata_i)\n      //\n   );\n\n   //\n   //MODIFY INSTRUCTION READ ADDRESS DURING BOOT\n   //\n\n   //instruction read bus\n   wire [     `REQ_W-1:0] ram_r_req;\n   wire [    `RESP_W-1:0] ram_r_resp;\n   wire [     ADDR_W-1:0] ram_r_addr;\n   wire [     ADDR_W-1:0] boot_i_addr;\n   wire [     ADDR_W-1:0] i_addr;\n   wire [SRAM_ADDR_W-3:0] boot_ram_d_addr;\n   wire [SRAM_ADDR_W-3:0] ram_d_addr_int;\n\n   //\n   //modify addresses to run  boot program\n   //\n   localparam boot_offset = -('b1 << BOOTROM_ADDR_W);\n\n   //instruction bus: connect directly but address\n   assign ram_r_req[`ADDRESS(0, ADDR_W)] = ram_r_addr;\n   assign boot_i_addr = i_req_i[`ADDRESS(0, ADDR_W)] + boot_offset;\n   assign i_addr = i_req_i[`ADDRESS(0, ADDR_W)];\n\n   assign ram_r_req[`VALID(0)] = i_req_i[`VALID(0)];\n   assign ram_r_addr = boot ? boot_i_addr : i_addr;\n   assign ram_r_req[`WRITE(0)] = i_req_i[`WRITE(0)];\n   assign i_resp_o[`RESP(0)] = ram_r_resp[`RESP(0)];\n\n   //data bus: just replace address\n   assign boot_ram_d_addr = ram_d_req[`ADDRESS(0, SRAM_ADDR_W)-2] + boot_offset[SRAM_ADDR_W-1:2];\n   assign ram_d_addr_int = ram_d_req[`ADDRESS(0, SRAM_ADDR_W)-2];\n   assign ram_d_addr = boot ? boot_ram_d_addr : ram_d_addr_int;\n\n   //\n   //MERGE BOOT WRITE BUS AND CPU READ BUS\n   //\n\n   //sram instruction bus\n   \n\n   iob_merge #(\n      .N_MASTERS(2)\n   ) ibus_merge (\n      .clk_i (clk_i),\n      .arst_i(arst_i),\n\n      //master\n      .m_req_i ({ram_w_req, ram_r_req}),\n      .m_resp_o({ram_w_resp, ram_r_resp}),\n\n      //slave\n      .s_req_o (ram_i_req),\n      .s_resp_i(ram_i_resp)\n   );\n\n   //\n   // INSTANTIATE RAM\n   //\n   iob_soc_sram #(\n`ifndef IOB_SOC_USE_EXTMEM\n`ifdef IOB_SOC_INIT_MEM\n      .HEXFILE    (HEXFILE),\n`endif\n`endif\n      .DATA_W     (DATA_W),\n      .SRAM_ADDR_W(SRAM_ADDR_W)\n   ) int_sram (\n      .clk_i (clk_i),\n      .cke_i (cke_i),\n      .arst_i(arst_i),\n   `ifdef USE_SPRAM\n      .valid_spram_o(valid_spram_o),\n      .addr_spram_o(addr_spram_o),\n      .wstrb_spram_o_o(wstrb_spram_o_o),\n      .wdata_spram_o(wdata_spram_o),\n      .rdata_spram_i(rdata_spram_i),\n   `endif \n      //instruction bus\n      .i_valid_i(i_valid_o),\n      .i_addr_i  (i_addr_o),\n      .i_wdata_i (i_wdata_o),\n      .i_wstrb_i (i_wstrb_o),\n      .i_rdata_o (),\n      .i_rvalid_o(ram_i_resp[`RVALID(0)]),\n      .i_ready_o (ram_i_resp[`READY(0)]),\n\n      //data bus\n      .d_valid_i(d_valid_o),\n      .d_addr_i  (d_addr_o),\n      .d_wdata_i (d_wdata_o),\n      .d_wstrb_i (d_wstrb_o),\n      .d_rdata_o (),\n      .d_rvalid_o(ram_d_resp[`RVALID(0)]),\n      .d_ready_o (ram_d_resp[`READY(0)])\n   );\n\nendmodule\n"}
{"text": "`timescale 1 ns / 1 ps\n\n`include \"bsp.vh\"\n`include \"iob_soc_conf.vh\"\n`include \"iob_utils.vh\"\n\n//Peripherals _swreg_def.vh file includes.\n`include \"iob_soc_periphs_swreg_def.vs\"\n\nmodule iob_soc_mwrap #(\n\n`ifdef IOB_SOC_INIT_MEM\n    parameter HEXFILE  = \"iob_soc_firmware\",\n`else\n    parameter HEXFILE  = \"none\",\n`endif\n    parameter BOOT_HEXFILE = \"iob_soc_boot\",\n    parameter MEM_NO_READ_ON_WRITE = 1,        //no simultaneous read/write\n   `include \"iob_soc_params.vs\"\n) (\n   `include \"iob_soc_io.vs\"\n);\n\n\n//rom wires\nwire rom_r_valid;\nwire [BOOTROM_ADDR_W-3:0] rom_r_addr;\nwire [DATA_W-1:0] rom_r_rdata;\n\n\n//ram wires\nwire                               i_valid;\nwire          [SRAM_ADDR_W-3:0]    i_addr;\nwire          [     DATA_W-1:0]    i_wdata;\nwire          [   DATA_W/8-1:0]    i_wstrb;\nwire          [     DATA_W-1:0]    i_rdata;\nwire                               d_valid;\nwire          [SRAM_ADDR_W-3:0]    d_addr;\nwire          [     DATA_W-1:0]    d_wdata;\nwire          [   DATA_W/8-1:0]    d_wstrb;\nwire          [     DATA_W-1:0]    d_rdata;\n//\n\n`ifdef USE_SPRAM\n    wire                       en;\n    wire     [SRAM_ADDR_W-3:0] addr;\n    wire     [DATA_W/8-1:0]    we;\n    wire     [DATA_W-1:0]      di;\n    wire     [DATA_W-1:0]      do;\n`endif\n\niob_soc #(\n    .BOOTROM_ADDR_W(           BOOTROM_ADDR_W),\n    .SRAM_ADDR_W(                 SRAM_ADDR_W),\n    .MEM_ADDR_W(                   MEM_ADDR_W),\n    .ADDR_W(                           ADDR_W),\n    .DATA_W(                           DATA_W),\n    .AXI_ID_W(                       AXI_ID_W),\n    .AXI_ADDR_W(                   AXI_ADDR_W),\n    .AXI_DATA_W(                   AXI_DATA_W),\n    .AXI_LEN_W(                     AXI_LEN_W),\n    .MEM_ADDR_OFFSET(         MEM_ADDR_OFFSET),\n    .UART0_DATA_W(               UART0_DATA_W),\n    .UART0_ADDR_W(               UART0_ADDR_W),\n    .UART0_UART_DATA_W(     UART0_UART_DATA_W),\n    .TIMER0_DATA_W(             TIMER0_DATA_W),\n    .TIMER0_ADDR_W(             TIMER0_ADDR_W),\n    .TIMER0_WDATA_W(           TIMER0_WDATA_W)\n)iob_soc(\n    .clk_i(                             clk_i),\n    .cke_i(                             cke_i),\n    .arst_i(                           arst_i),\n    .trap_o(                           trap_o),\n    `ifdef IOB_SOC_USE_EXTMEM\n    .axi_awid_o(                   axi_awid_o),\n    .axi_awaddr_o(               axi_awaddr_o),\n    .axi_awlen_o(                 axi_awlen_o),\n    .axi_awsize_o(               axi_awsize_o),\n    .axi_awburst_o(             axi_awburst_o),\n    .axi_awlock_o(               axi_awlock_o),\n    .axi_awcache_o(             axi_awcache_o),\n    .axi_awprot_o(               axi_awprot_o),\n    .axi_awqos_o(                 axi_awqos_o),\n    .axi_awvalid_o(             axi_awvalid_o),\n    .axi_awready_i(             axi_awready_i),\n    .axi_wdata_o(                 axi_wdata_o),\n    .axi_wstrb_o(                 axi_wstrb_o),\n    .axi_wlast_o(                 axi_wlast_o),\n    .axi_wvalid_o(               axi_wvalid_o),\n    .axi_wready_i(               axi_wready_i),\n    .axi_bid_i(                     axi_bid_i),\n    .axi_bresp_i(                 axi_bresp_i),\n    .axi_bvalid_i(               axi_bvalid_i),\n    .axi_bready_o(               axi_bready_o),\n    .axi_arid_o(                   axi_arid_o),\n    .axi_araddr_o(               axi_araddr_o),\n    .axi_arlen_o(                 axi_arlen_o),\n    .axi_arsize_o(               axi_arsize_o),\n    .axi_arburst_o(             axi_arburst_o),\n    .axi_arlock_o(               axi_arlock_o),\n    .axi_arcache_o(             axi_arcache_o),\n    .axi_arprot_o(               axi_arprot_o),\n    .axi_arqos_o(                 axi_arqos_o),\n    .axi_arvalid_o(             axi_arvalid_o),\n    .axi_arready_i(             axi_arready_i),\n    .axi_rid_i(                     axi_rid_i),\n    .axi_rdata_i(                 axi_rdata_i),\n    .axi_rresp_i(                 axi_rresp_i),\n    .axi_rlast_i(                 axi_rlast_i),\n    .axi_rvalid_i(               axi_rvalid_i),\n    .axi_rready_o(               axi_rready_o),\n    `endif\n    .uart_txd_o(                   uart_txd_o),\n    .uart_rxd_i(                   uart_rxd_i),\n    .uart_cts_i(                   uart_cts_i),\n    .uart_rts_o(                   uart_rts_o),\n        //SPRAM  \n`ifdef USE_SPRAM\n    .valid_spram_o(en),\n    .addr_spram_o(addr),\n    .wstrb_spram_o(we),\n    .wdata_spram_o(di),\n    .rdata_spram_i(do),\n`endif\n\n    //rom\n    .rom_r_valid_o(rom_r_valid),\n    .rom_r_addr_o(rom_r_addr),\n    .rom_r_rdata_i(rom_r_rdata),\n    //\n\n    //ram\n    .i_valid_o(i_valid),\n    .i_addr_o(i_addr),\n    .i_wdata_o(i_wdata),\n    .i_wstrb_o(i_wstrb),\n    .i_rdata_i(i_rdata),\n    .d_valid_o(d_valid),\n    .d_addr_o(d_addr),\n    .d_wdata_o(d_wdata),\n    .d_wstrb_o(d_wstrb),\n    .d_rdata_i(d_rdata)\n   //\n\n);\n\n\n    `ifdef USE_SPRAM\n        iob_ram_sp_be #(\n            .HEXFILE(HEXFILE),\n            .ADDR_W (SRAM_ADDR_W - 2),\n            .DATA_W (DATA_W)\n        ) main_mem_byte (\n            .clk_i(clk_i),\n            // data port\n            .en_i  (en),\n            .addr_i(addr),\n            .we_i  (wstrb),\n            .d_i   (wdata),\n            .dt_o  (rdata)\n        );\n    `else\n        `ifdef IOB_MEM_NO_READ_ON_WRITE\n            iob_ram_dp_be #(\n            .HEXFILE             (HEXFILE),\n            .ADDR_W              (SRAM_ADDR_W - 2),\n            .DATA_W              (DATA_W),\n            .MEM_NO_READ_ON_WRITE(1)\n            ) main_mem_byte (\n            .clk_i(clk_i),\n            // data port\n            .enA_i  (d_valid),\n            .addrA_i(d_addr),\n            .weA_i  (d_wstrb),\n            .dA_i   (d_wdata),\n            .dA_o   (d_rdata),\n\n            // instruction port\n            .enB_i  (i_valid),\n            .addrB_i(i_addr),\n            .weB_i  (i_wstrb),\n            .dB_i   (i_wdata),\n            .dB_o   (i_rdata)\n        );\n        `else  // !`ifdef IOB_MEM_NO_READ_ON_WRITE\n            iob_ram_dp_be_xil #(\n                .HEXFILE(HEXFILE),\n                .ADDR_W (SRAM_ADDR_W - 2),\n                .DATA_W (DATA_W)\n            ) main_mem_byte (\n                .clk_i(clk_i),\n\n                // data port\n                .enA_i  (d_valid),\n                .addrA_i(d_addr),\n                .weA_i  (d_wstrb),\n                .dA_i   (d_wdata),\n                .dA_o   (d_rdata),\n                // instruction port\n                .enB_i  (i_valid),\n                .addrB_i(i_addr),\n                .weB_i  (i_wstrb),\n                .dB_i   (i_wdata),\n                .dB_o   (i_rdata)\n            );\n        `endif\n    `endif \n\n\n    //rom instatiation\n    iob_rom_sp #(\n        .DATA_W (DATA_W),\n        .ADDR_W (BOOTROM_ADDR_W - 2),\n        .HEXFILE({BOOT_HEXFILE, \".hex\"})\n    ) sp_rom0 (\n        .clk_i   (clk_i),\n        .r_en_i  (rom_r_valid),\n        .addr_i  (rom_r_addr),\n        .r_data_o(rom_r_rdata)\n    );\nendmodule"}
{"text": "`timescale 1ns / 1ps\n\n`include \"bsp.vh\"\n`include \"iob_soc_conf.vh\"\n\n//Peripherals _swreg_def.vh file includes.\n`include \"iob_soc_periphs_swreg_def.vs\"\n\n`ifndef IOB_UART_SWREG_ADDR_W\n`define IOB_UART_SWREG_ADDR_W 16\n`endif\n`ifndef IOB_SOC_DATA_W\n`define IOB_SOC_DATA_W 32\n`endif\n`ifndef IOB_ETH_SWREG_ADDR_W\n`define IOB_ETH_SWREG_ADDR_W 12\n`endif\n\nmodule iob_soc_sim_wrapper (\n`include \"clk_rst_s_port.vs\"\n   output                             trap_o,\n\n`ifdef IOB_SOC_USE_ETHERNET\n   // Ethernet for testbench\n   input                              ethernet_valid_i,\n   input [`IOB_ETH_SWREG_ADDR_W-1:0]  ethernet_addr_i,\n   input [`IOB_SOC_DATA_W-1:0]        ethernet_wdata_i,\n   input [3:0]                        ethernet_wstrb_i,\n   output [`IOB_SOC_DATA_W-1:0]       ethernet_rdata_o,\n   output                             ethernet_ready_o,\n   output                             ethernet_rvalid_o,\n`endif\n\n   // UART for testbench\n   input                              uart_valid_i,\n   input [`IOB_UART_SWREG_ADDR_W-1:0] uart_addr_i,\n   input [`IOB_SOC_DATA_W-1:0]        uart_wdata_i,\n   input [3:0]                        uart_wstrb_i,\n   output [`IOB_SOC_DATA_W-1:0]       uart_rdata_o,\n   output                             uart_ready_o,\n   output                             uart_rvalid_o\n);\n\n   localparam AXI_ID_W = 4;\n   localparam AXI_LEN_W = 8;\n   localparam AXI_ADDR_W = `DDR_ADDR_W;\n   localparam AXI_DATA_W = `DDR_DATA_W;\n\n   `include \"iob_soc_wrapper_pwires.vs\"\n\n   /////////////////////////////////////////////\n   // TEST PROCEDURE\n   //\n   initial begin\n`ifdef VCD\n      $dumpfile(\"uut.vcd\");\n      $dumpvars();\n`endif\n   end\n\n   //\n   // INSTANTIATE COMPONENTS\n   //\n\n   //\n   // IOb-SoC (may also include Unit Under Test)\n   //\n   iob_soc_mwrap #(\n      .AXI_ID_W  (AXI_ID_W),\n      .AXI_LEN_W (AXI_LEN_W),\n      .AXI_ADDR_W(AXI_ADDR_W),\n      .AXI_DATA_W(AXI_DATA_W)\n   ) iob_soc0 (\n      `include \"iob_soc_pportmaps.vs\"\n      .clk_i (clk_i),\n      .cke_i (1'b1),\n      .arst_i(arst_i),\n      .trap_o(trap_o)\n   );\n\n\n    // interconnect clk and arst\n    wire clk_interconnect;\n    wire arst_interconnect;\n    assign clk_interconnect = clk_i;\n    assign arst_interconnect = arst_i;\n\n   `include \"iob_soc_interconnect.vs\"\n\n`ifdef IOB_SOC_USE_EXTMEM\n   //instantiate the axi memory\n   //IOb-SoC and SUT access the same memory.\n   axi_ram #(\n`ifdef IOB_SOC_INIT_MEM\n      .FILE      (\"init_ddr_contents.hex\"),  //This file contains firmware for both systems\n      .FILE_SIZE (2 ** (AXI_ADDR_W - 2)),\n`endif\n      .ID_WIDTH  (AXI_ID_W),\n      .DATA_WIDTH(AXI_DATA_W),\n      .ADDR_WIDTH(AXI_ADDR_W)\n   ) ddr_model_mem (\n      `include \"iob_memory_axi_s_portmap.vs\"\n\n      .clk_i(clk_i),\n      .rst_i(arst_i)\n   );\n`endif\n \n   //Manually added testbench uart core. RS232 pins attached to the same pins\n   //of the iob_soc UART0 instance to communicate with it\n   // The interface of iob_soc UART0 is assumed to be the first portmapped interface (UART_*)\n   iob_uart uart_tb (\n      .clk_i (clk_i),\n      .cke_i (1'b1),\n      .arst_i(arst_i),\n\n      .iob_valid_i(uart_valid_i),\n      .iob_addr_i  (uart_addr_i),\n      .iob_wdata_i (uart_wdata_i),\n      .iob_wstrb_i (uart_wstrb_i),\n      .iob_rdata_o (uart_rdata_o),\n      .iob_rvalid_o(uart_rvalid_o),\n      .iob_ready_o (uart_ready_o),\n\n      .txd_o(uart_rxd_i),\n      .rxd_i(uart_txd_o),\n      .rts_o(uart_cts_i),\n      .cts_i(uart_rts_o)\n   );\n\n   //Ethernet\n`ifdef IOB_SOC_USE_ETHERNET\n   //ethernet clock: 4x slower than system clock\n   reg [1:0] eth_cnt = 2'b0;\n   reg       eth_clk;\n\n   always @(posedge clk_i) begin\n      eth_cnt <= eth_cnt + 1'b1;\n      eth_clk <= eth_cnt[1];\n   end\n\n   // Ethernet Interface signals\n   assign ETH0_MRxClk     = eth_clk;\n   assign ETH0_MTxClk     = eth_clk;\n\n   //Manually added testbench ethernet core. MII pins attached to the same pins\n   //of the iob_soc ETH0 instance to communicate with it\n   // The interface of iob_soc ETH0 is assumed to be the first portmapped interface (ETH_*)\n   iob_eth\n     #(\n      .AXI_ID_W(AXI_ID_W),\n      .AXI_ADDR_W(AXI_ADDR_W),\n      .AXI_DATA_W(AXI_DATA_W),\n      .AXI_LEN_W(AXI_LEN_W)\n   ) eth_tb (\n      .inta_o(),\n      .MTxClk(eth_clk),\n      .MTxD(ETH0_MRxD),\n      .MTxEn(ETH0_MRxDv),\n      .MTxErr(ETH0_MRxErr),\n      .MRxClk(eth_clk),\n      .MRxDv(ETH0_MTxEn),\n      .MRxD(ETH0_MTxD),\n      .MRxErr(ETH0_MTxErr),\n      .MColl(1'b0),\n      .MCrS(1'b0),\n      .MDC(),\n      .MDIO(),\n      .iob_valid_i(ethernet_valid_i),\n      .iob_addr_i  (ethernet_addr_i),\n      .iob_wdata_i (ethernet_wdata_i),\n      .iob_wstrb_i (ethernet_wstrb_i),\n      .iob_rvalid_o(ethernet_rvalid_o),\n      .iob_rdata_o (ethernet_rdata_o),\n      .iob_ready_o (ethernet_ready_o),\n      .axi_awid_o        (),\n      .axi_awaddr_o      (),\n      .axi_awlen_o       (),\n      .axi_awsize_o      (),\n      .axi_awburst_o     (),\n      .axi_awlock_o      (),\n      .axi_awcache_o     (),\n      .axi_awprot_o      (),\n      .axi_awqos_o       (),\n      .axi_awvalid_o     (),\n      .axi_awready_i     (1'b0),\n      .axi_wdata_o       (),\n      .axi_wstrb_o       (),\n      .axi_wlast_o       (),\n      .axi_wvalid_o      (),\n      .axi_wready_i      (1'b0),\n      .axi_bid_i         ({AXI_ID_W{1'b0}}),\n      .axi_bresp_i       (2'b0),\n      .axi_bvalid_i      (1'b0),\n      .axi_bready_o      (),\n      .axi_arid_o        (),\n      .axi_araddr_o      (),\n      .axi_arlen_o       (),\n      .axi_arsize_o      (),\n      .axi_arburst_o     (),\n      .axi_arlock_o      (),\n      .axi_arcache_o     (),\n      .axi_arprot_o      (),\n      .axi_arqos_o       (),\n      .axi_arvalid_o     (),\n      .axi_arready_i     (1'b0),\n      .axi_rid_i         ({AXI_ID_W{1'b0}}),\n      .axi_rdata_i       ({AXI_DATA_W{1'b0}}),\n      .axi_rresp_i       (2'b0),\n      .axi_rlast_i       (1'b0),\n      .axi_rvalid_i      (1'b0),\n      .axi_rready_o      (),\n      .clk_i(clk_i),\n      .arst_i(arst_i),\n      .cke_i(1'b1)\n      );\n`endif\n\nendmodule\n"}
{"text": "`timescale 1ns / 1ps\n`include \"iob_soc_conf.vh\"\n`include \"bsp.vh\"\n\nmodule iob_soc_sram #(\n   parameter DATA_W      = `IOB_SOC_DATA_W,\n   parameter SRAM_ADDR_W = `IOB_SOC_SRAM_ADDR_W,\n   parameter HEXFILE     = \"none\"\n) (\n`ifdef USE_SPRAM\n   output                       valid_spram_o,\n   output     [SRAM_ADDR_W-3:0] addr_spram_o,\n   output     [DATA_W/8-1:0]    wstrb_spram_o,\n   output     [DATA_W-1:0]      wdata_spram_o,\n   input      [DATA_W-1:0]      rdata_spram_i,\n`endif \n   // intruction bus\n   input                        i_valid_i,\n   input      [SRAM_ADDR_W-3:0] i_addr_i,\n   input      [     DATA_W-1:0] i_wdata_i,   //used for booting\n   input      [   DATA_W/8-1:0] i_wstrb_i,   //used for booting\n   output     [     DATA_W-1:0] i_rdata_o,\n   output                       i_rvalid_o,\n   output                       i_ready_o,\n\n   // data bus\n   input                        d_valid_i,\n   input      [SRAM_ADDR_W-3:0] d_addr_i,\n   input      [     DATA_W-1:0] d_wdata_i,\n   input      [   DATA_W/8-1:0] d_wstrb_i,\n   output     [     DATA_W-1:0] d_rdata_o,\n   output                       d_rvalid_o,\n   output                       d_ready_o,\n\n   `include \"clk_en_rst_s_port.vs\"\n);\n\n`ifdef USE_SPRAM\n   wire d_valid_int = i_valid_i ? 1'b0 : d_valid_i;\n   assign valid_spram_o = i_valid_i ? i_valid_i : d_valid_i;\n   assign addr_spram_o = i_valid_i ? i_addr_i : d_addr_i;\n   assign wdata_spram_o = i_valid_i ? i_wdata_i : d_wdata_i;\n   assign wstrb_spram_o = i_valid_i ? i_wstrb_i : d_wstrb_i;\n`endif\n\n   // reply with ready \n   wire i_rvalid_nxt;\n   assign i_rvalid_nxt = i_valid_i & ~(|i_wstrb_i);\n\n   iob_reg #(\n      .DATA_W (1),\n      .RST_VAL(0)\n   ) i_rvalid_reg (\n      .clk_i (clk_i),\n      .arst_i(arst_i),\n      .cke_i (cke_i),\n      .data_i(i_rvalid_nxt),\n      .data_o(i_rvalid_o)\n   );\n\n   wire d_rvalid_nxt;\n   assign d_rvalid_nxt = d_valid_i & ~(|d_wstrb_i);\n\n   iob_reg #(\n      .DATA_W (1),\n      .RST_VAL(0)\n   ) d_rvalid_reg (\n      .clk_i (clk_i),\n      .arst_i(arst_i),\n      .cke_i (cke_i),\n      .data_i(d_rvalid_nxt),\n      .data_o(d_rvalid_o)\n   );\n   assign i_ready_o = 1'b1;  // SRAM ready is supposed to always be 1 since requests can be continuous\n   assign d_ready_o = 1'b1;\n\nendmodule\n"}
{"text": "`timescale 1ns / 1ps\n\n`include \"bsp.vh\"\n`include \"iob_utils.vh\"\n`include \"iob_soc_conf.vh\"\n`include \"iob_uart_conf.vh\"\n`include \"iob_uart_swreg_def.vh\"\n`include \"iob_reg_conf.vh\"\n\n//Peripherals _swreg_def.vh file includes.\n`include \"iob_soc_periphs_swreg_def.vs\"\n\nmodule iob_soc_tb;\n\n   parameter realtime CLK_PER = 1s / `FREQ;\n\n   localparam ADDR_W = `IOB_SOC_ADDR_W;\n   localparam DATA_W = `IOB_SOC_DATA_W;\n   localparam UART_DATA_W = `IOB_UART_UART_DATA_W;\n\n   //clock\n   reg                clk = 1;\n   `IOB_CLOCK(clk, CLK_PER)\n\n   //reset\n   reg                arst = 0;\n\n   //received by getchar\n   reg                rxread_reg;\n   reg                txread_reg;\n   reg [7:0]          cpu_char;\n   integer            soc2cnsl_fd = 0, cnsl2soc_fd = 0;\n\n\n   //IOb-SoC uart\n   reg                iob_valid_i;\n   reg [`IOB_UART_SWREG_ADDR_W-1:0] iob_addr_i;\n   reg [       `IOB_SOC_DATA_W-1:0] iob_wdata_i;\n   reg [                       3:0] iob_wstrb_i;\n   wire [       `IOB_SOC_DATA_W-1:0] iob_rdata_o;\n   wire                              iob_ready_o;\n   wire                              iob_rvalid_o;\n\n   //iterator\n   integer                           i = 0, n = 0;\n   integer                           error, n_byte = 0;\n\n   //cpu trap signal\n   wire                              trap;\n\n   initial begin\n      //init cpu bus signals\n      iob_valid_i = 0;\n      iob_wstrb_i  = 0;\n\n      //reset system\n      `IOB_RESET(clk, arst, 100, 1_000, 100);\n\n      // configure uart\n      cpu_inituart();\n\n      cpu_char    = 0;\n      rxread_reg  = 0;\n      txread_reg  = 0;\n\n\n      cnsl2soc_fd = $fopen(\"cnsl2soc\", \"r\");\n      while (!cnsl2soc_fd) begin\n         $display(\"Could not open \\\"cnsl2soc\\\"\");\n         cnsl2soc_fd = $fopen(\"cnsl2soc\", \"r\");\n      end\n      $fclose(cnsl2soc_fd);\n      soc2cnsl_fd = $fopen(\"soc2cnsl\", \"w\");\n\n      while (1) begin\n         while (!rxread_reg && !txread_reg) begin\n            iob_read(`IOB_UART_RXREADY_ADDR, rxread_reg, `IOB_UART_RXREADY_W);\n            iob_read(`IOB_UART_TXREADY_ADDR, txread_reg, `IOB_UART_TXREADY_W);\n         end\n         if (rxread_reg) begin\n            iob_read(`IOB_UART_RXDATA_ADDR, cpu_char, `IOB_UART_RXDATA_W);\n            $fwriteh(soc2cnsl_fd, \"%c\", cpu_char);\n            $fflush(soc2cnsl_fd);\n            rxread_reg = 0;\n         end\n         if (txread_reg) begin\n            cnsl2soc_fd = $fopen(\"cnsl2soc\", \"r\");\n            if (!cnsl2soc_fd) begin\n               //wait 1 ms and try again\n               #1_000_000 cnsl2soc_fd = $fopen(\"cnsl2soc\", \"r\");\n               if (!cnsl2soc_fd) begin\n                  $fclose(soc2cnsl_fd);\n                  $finish();\n               end\n            end\n            n = $fscanf(cnsl2soc_fd, \"%c\", cpu_char);\n            if (n > 0) begin\n               iob_write(`IOB_UART_TXDATA_ADDR, cpu_char, `IOB_UART_TXDATA_W);\n               $fclose(cnsl2soc_fd);\n               cnsl2soc_fd = $fopen(\"./cnsl2soc\", \"w\");\n            end\n            $fclose(cnsl2soc_fd);\n            txread_reg = 0;\n         end\n      end\n   end\n   \n`ifdef IOB_SOC_USE_ETHERNET\n   //IOb-SoC ethernet\n   reg                               ethernet_valid_i;\n   reg  [`IOB_ETH_SWREG_ADDR_W-1:0]  ethernet_addr_i;\n   reg  [       `IOB_SOC_DATA_W-1:0] ethernet_wdata_i;\n   reg  [                       3:0] ethernet_wstrb_i;\n   wire [       `IOB_SOC_DATA_W-1:0] ethernet_rdata_o;\n   wire                              ethernet_ready_o;\n   wire                              ethernet_rvalid_o;\n`endif\n\n\n   iob_soc_sim_wrapper iob_soc_sim_wrapper (\n      .clk_i (clk),\n      .arst_i (arst),\n      .trap_o(trap),\n\n`ifdef IOB_SOC_USE_ETHERNET\n      .ethernet_valid_i (1'b0),\n      .ethernet_addr_i  (`IOB_ETH_SWREG_ADDR_W'b0),\n      .ethernet_wdata_i (`IOB_SOC_DATA_W'b0),\n      .ethernet_wstrb_i (4'b0),\n      .ethernet_rdata_o (),\n      .ethernet_ready_o (),\n      .ethernet_rvalid_o(),\n`endif\n\n      .uart_valid_i (iob_valid_i),\n      .uart_addr_i  (iob_addr_i),\n      .uart_wdata_i (iob_wdata_i),\n      .uart_wstrb_i (iob_wstrb_i),\n      .uart_rdata_o (iob_rdata_o),\n      .uart_ready_o (iob_ready_o),\n      .uart_rvalid_o(iob_rvalid_o)\n   );\n\n   task cpu_inituart;\n      begin\n         //pulse reset uart\n         iob_write(`IOB_UART_SOFTRESET_ADDR, 1, `IOB_UART_SOFTRESET_W);\n         iob_write(`IOB_UART_SOFTRESET_ADDR, 0, `IOB_UART_SOFTRESET_W);\n         //config uart div factor\n         iob_write(`IOB_UART_DIV_ADDR, `FREQ / `BAUD, `IOB_UART_DIV_W);\n         //enable uart for receiving\n         iob_write(`IOB_UART_RXEN_ADDR, 1, `IOB_UART_RXEN_W);\n         iob_write(`IOB_UART_TXEN_ADDR, 1, `IOB_UART_TXEN_W);\n      end\n   endtask\n\n   `include \"iob_tasks.vs\"\n\n   //finish simulation on trap\n   always @(posedge trap) begin\n      #10 $display(\"Found CPU trap condition\");\n      $finish();\n   end\n\nendmodule\n"}
