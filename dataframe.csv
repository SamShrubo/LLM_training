text
"['// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '//********************************************************************************\n', '// $Id$\n', '//\n', '// Function: Top level VEER core file to control the debug mode\n', '// Comments: Responsible to put the rest of the core in quiesce mode,\n', '//           Send the commands/address. sends WrData and Recieve read Data.\n', '//           And then Resume the core to do the normal mode\n', '// Author  :\n', '//********************************************************************************\n', 'module dbg (\n', '   // outputs to the core for command and data interface\n', '   output logic [31:0]                 dbg_cmd_addr,\n', '   output logic [31:0]                 dbg_cmd_wrdata,\n', '   output logic                        dbg_cmd_valid,\n', '   output logic                        dbg_cmd_write, // 1: write command, 0: read_command\n', '   output logic [1:0]                  dbg_cmd_type, // 0:gpr 1:csr 2: memory\n', '   output logic [1:0]                  dbg_cmd_size, // size of the abstract mem access debug command\n', '   output logic                        dbg_core_rst_l, // core reset from dm\n', '\n', '   // inputs back from the core/dec\n', '   input logic [31:0]                  core_dbg_rddata,\n', '   input logic                         core_dbg_cmd_done, // This will be treated like a valid signal\n', '   input logic                         core_dbg_cmd_fail, // Exception during command run\n', '\n', '   // Signals to dma to get a bubble\n', '   output logic                        dbg_dma_bubble,   // Debug needs a bubble to send a valid\n', '   input  logic                        dma_dbg_ready,    // DMA is ready to accept debug request\n', '\n', '   // interface with the rest of the core to halt/resume handshaking\n', '   output logic                        dbg_halt_req, // This is a pulse\n', '   output logic                        dbg_resume_req, // Debug sends a resume requests. Pulse\n', '   input  logic                        dec_tlu_debug_mode,        // Core is in debug mode\n', '   input  logic                        dec_tlu_dbg_halted, // The core has finished the queiscing sequence. Core is halted now\n', '   input  logic                        dec_tlu_mpc_halted_only,   // Only halted due to MPC\n', '   input  logic                        dec_tlu_resume_ack, // core sends back an ack for the resume (pulse)\n', '\n', '   // inputs from the JTAG\n', '   input logic                         dmi_reg_en, // read or write\n', '   input logic [6:0]                   dmi_reg_addr, // address of DM register\n', '   input logic                         dmi_reg_wr_en, // write instruction\n', '   input logic [31:0]                  dmi_reg_wdata, // write data\n', '   // output\n', '   output logic [31:0]                 dmi_reg_rdata, // read data\n', '//   output logic                        dmi_reg_ack,\n', '\n', '   // AXI signals\n', '   // AXI Write Channels\n', '   output logic                        sb_axi_awvalid,\n', '   input  logic                        sb_axi_awready,\n', '   output logic [`RV_SB_BUS_TAG-1:0]   sb_axi_awid,\n', '   output logic [31:0]                 sb_axi_awaddr,\n', '   output logic [3:0]                  sb_axi_awregion,\n', '   output logic [7:0]                  sb_axi_awlen,\n', '   output logic [2:0]                  sb_axi_awsize,\n', '   output logic [1:0]                  sb_axi_awburst,\n', '   output logic                        sb_axi_awlock,\n', '   output logic [3:0]                  sb_axi_awcache,\n', '   output logic [2:0]                  sb_axi_awprot,\n', '   output logic [3:0]                  sb_axi_awqos,\n', '\n', '   output logic                        sb_axi_wvalid,\n', '   input  logic                        sb_axi_wready,\n', '   output logic [63:0]                 sb_axi_wdata,\n', '   output logic [7:0]                  sb_axi_wstrb,\n', '   output logic                        sb_axi_wlast,\n', '\n', '   input  logic                        sb_axi_bvalid,\n', '   output logic                        sb_axi_bready,\n', '   input  logic [1:0]                  sb_axi_bresp,\n', '   input  logic [`RV_SB_BUS_TAG-1:0]   sb_axi_bid,\n', '\n', '   // AXI Read Channels\n', '   output logic                        sb_axi_arvalid,\n', '   input  logic                        sb_axi_arready,\n', '   output logic [`RV_SB_BUS_TAG-1:0]   sb_axi_arid,\n', '   output logic [31:0]                 sb_axi_araddr,\n', '   output logic [3:0]                  sb_axi_arregion,\n', '   output logic [7:0]                  sb_axi_arlen,\n', '   output logic [2:0]                  sb_axi_arsize,\n', '   output logic [1:0]                  sb_axi_arburst,\n', '   output logic                        sb_axi_arlock,\n', '   output logic [3:0]                  sb_axi_arcache,\n', '   output logic [2:0]                  sb_axi_arprot,\n', '   output logic [3:0]                  sb_axi_arqos,\n', '\n', '   input  logic                        sb_axi_rvalid,\n', '   output logic                        sb_axi_rready,\n', '   input  logic [`RV_SB_BUS_TAG-1:0]   sb_axi_rid,\n', '   input  logic [63:0]                 sb_axi_rdata,\n', '   input  logic [1:0]                  sb_axi_rresp,\n', '   input  logic                        sb_axi_rlast,\n', '\n', '   input logic                         dbg_bus_clk_en,\n', '\n', '   // general inputs\n', '   input logic                         clk,\n', '   input logic                         free_clk,\n', '   input logic                         rst_l,            // This includes both top rst and dbg rst\n', '   input logic                         dbg_rst_l,\n', '   input logic                         clk_override,\n', '   input logic                         scan_mode\n', ');\n', '\n', '`include ""global.h""\n', '\n', ""   typedef enum logic [3:0] {IDLE=4'h0, HALTING=4'h1, HALTED=4'h2, CORE_CMD_START=4'h3, CORE_CMD_WAIT=4'h4, SB_CMD_START=4'h5, SB_CMD_SEND=4'h6, SB_CMD_RESP=4'h7, CMD_DONE=4'h8, RESUMING=4'h9} state_t;\n"", ""   typedef enum logic [3:0] {SBIDLE=4'h0, WAIT_RD=4'h1, WAIT_WR=4'h2, CMD_RD=4'h3, CMD_WR=4'h4, CMD_WR_ADDR=4'h5, CMD_WR_DATA=4'h6, RSP_RD=4'h7, RSP_WR=4'h8, DONE=4'h9} sb_state_t;\n"", '\n', '   `ifdef RV_ICCM_ENABLE\n', ""      localparam ICCM_ENABLE = 1'b1;\n"", '   `else\n', ""       localparam ICCM_ENABLE = 1'b0;\n"", '   `endif\n', '\n', '   `ifdef RV_DCCM_ENABLE\n', ""      localparam DCCM_ENABLE = 1'b1;\n"", '   `else\n', ""       localparam DCCM_ENABLE = 1'b0;\n"", '   `endif\n', '\n', '   state_t       dbg_state;\n', '   state_t       dbg_nxtstate;\n', '   logic         dbg_state_en;\n', '   // these are the registers that the debug module implements\n', '   logic [31:0]  dmstatus_reg;        // [26:24]-dmerr, [17:16]-resume ack, [9:8]-halted, [3:0]-version\n', '   logic [31:0]  dmcontrol_reg;       // dmcontrol register has only 6 bits implemented. 31: haltreq, 30: resumereq, 29: haltreset, 28: ackhavereset, 1: ndmreset, 0: dmactive.\n', '   logic [31:0]  command_reg;\n', '   logic [31:0]  abstractcs_reg;      // bits implemted are [12] - busy and [10:8]= command error\n', '   logic [31:0]  haltsum0_reg;\n', '   logic [31:0]  data0_reg;\n', '   logic [31:0]  data1_reg;\n', '\n', '   // data 0\n', '   logic [31:0]  data0_din;\n', '   logic         data0_reg_wren, data0_reg_wren0, data0_reg_wren1, data0_reg_wren2;\n', '   // data 1\n', '   logic [31:0]  data1_din;\n', '   logic         data1_reg_wren, data1_reg_wren0, data1_reg_wren1;\n', '   // abstractcs\n', '   logic         abstractcs_busy_wren;\n', '   logic         abstractcs_busy_din;\n', '   logic [2:0]   abstractcs_error_din;\n', '   logic         abstractcs_error_sel0, abstractcs_error_sel1, abstractcs_error_sel2, abstractcs_error_sel3, abstractcs_error_sel4, abstractcs_error_sel5, abstractcs_error_sel6;\n', '   logic         dbg_sb_bus_error;\n', '   // abstractauto\n', '   logic         abstractauto_reg_wren;\n', '   logic [1:0]   abstractauto_reg;\n', '\n', '   // dmstatus\n', '   //logic         dmstatus_wren;\n', '   logic         dmstatus_dmerr_wren;\n', '   logic         dmstatus_resumeack_wren;\n', '   logic         dmstatus_resumeack_din;\n', '   logic         dmstatus_haveresetn_wren;\n', '   logic         dmstatus_resumeack;\n', '   logic         dmstatus_unavail;\n', '   logic         dmstatus_running;\n', '   logic         dmstatus_halted;\n', '   logic         dmstatus_havereset, dmstatus_haveresetn;\n', '\n', '   // dmcontrol\n', '   logic         resumereq;\n', '   logic         dmcontrol_wren, dmcontrol_wren_Q;\n', '   // command\n', '   logic         execute_command_ns, execute_command;\n', '   logic         command_wren, command_regno_wren;\n', '   logic         command_transfer_din;\n', '   logic         command_postexec_din;\n', '   logic [31:0]  command_din;\n', '   logic [3:0]   dbg_cmd_addr_incr;\n', '   logic [31:0]  dbg_cmd_curr_addr;\n', '   logic [31:0]  dbg_cmd_next_addr;\n', '   // needed to send the read data back for dmi reads\n', '   logic  [31:0] dmi_reg_rdata_din;\n', '\n', '   sb_state_t    sb_state;\n', '   sb_state_t    sb_nxtstate;\n', '   logic         sb_state_en;\n', '\n', '   //System bus section\n', '   logic              sbcs_wren;\n', '   logic              sbcs_sbbusy_wren;\n', '   logic              sbcs_sbbusy_din;\n', '   logic              sbcs_sbbusyerror_wren;\n', '   logic              sbcs_sbbusyerror_din;\n', '\n', '   logic              sbcs_sberror_wren;\n', '   logic [2:0]        sbcs_sberror_din;\n', '   logic              sbcs_unaligned;\n', '   logic              sbcs_illegal_size;\n', '   logic [19:15]      sbcs_reg_int;\n', '\n', '   // data\n', '   logic              sbdata0_reg_wren0;\n', '   logic              sbdata0_reg_wren1;\n', '   logic              sbdata0_reg_wren;\n', '   logic [31:0]       sbdata0_din;\n', '\n', '   logic              sbdata1_reg_wren0;\n', '   logic              sbdata1_reg_wren1;\n', '   logic              sbdata1_reg_wren;\n', '   logic [31:0]       sbdata1_din;\n', '\n', '   logic              sbaddress0_reg_wren0;\n', '   logic              sbaddress0_reg_wren1;\n', '   logic              sbaddress0_reg_wren;\n', '   logic [31:0]       sbaddress0_reg_din;\n', '   logic [3:0]        sbaddress0_incr;\n', '   logic              sbreadonaddr_access;\n', '   logic              sbreadondata_access;\n', '   logic              sbdata0wr_access;\n', '\n', '   logic              sb_abmem_cmd_done_in, sb_abmem_data_done_in;\n', '   logic              sb_abmem_cmd_done_en, sb_abmem_data_done_en;\n', '   logic              sb_abmem_cmd_done, sb_abmem_data_done;\n', '   logic [31:0]       abmem_addr;\n', '   logic              abmem_addr_in_dccm_region, abmem_addr_in_iccm_region, abmem_addr_in_pic_region;\n', '   logic              abmem_addr_core_local;\n', '   logic              abmem_addr_external;\n', '\n', '   logic              sb_cmd_pending, sb_abmem_cmd_pending;\n', '   logic              sb_abmem_cmd_arvalid, sb_abmem_cmd_awvalid, sb_abmem_cmd_wvalid;\n', '   logic              sb_abmem_read_pend;\n', '   logic              sb_abmem_cmd_write;\n', '   logic [2:0]        sb_abmem_cmd_size;\n', '   logic [31:0]       sb_abmem_cmd_addr;\n', '   logic [31:0]       sb_abmem_cmd_wdata;\n', '\n', '   logic              sb_cmd_awvalid, sb_cmd_wvalid, sb_cmd_arvalid;\n', '   logic              sb_read_pend;\n', '   logic [2:0]        sb_cmd_size;\n', '   logic [31:0]       sb_cmd_addr;\n', '   logic [63:0]       sb_cmd_wdata;\n', '\n', '   logic [31:0]       sb_axi_addr;\n', '   logic [63:0]       sb_axi_wrdata;\n', '   logic [2:0]        sb_axi_size;\n', '\n', '   logic              sb_axi_awvalid_q, sb_axi_awready_q;\n', '   logic              sb_axi_wvalid_q, sb_axi_wready_q;\n', '   logic              sb_axi_arvalid_q, sb_axi_arready_q;\n', '   logic              sb_axi_bvalid_q, sb_axi_bready_q;\n', '   logic              sb_axi_rvalid_q, sb_axi_rready_q;\n', '   logic [1:0]        sb_axi_bresp_q, sb_axi_rresp_q;\n', '\n', '   logic [63:0]       sb_bus_rdata;\n', '\n', '   //registers\n', '   logic [31:0]       sbcs_reg;\n', '   logic [31:0]       sbaddress0_reg;\n', '   logic [31:0]       sbdata0_reg;\n', '   logic [31:0]       sbdata1_reg;\n', '\n', '   logic              dbg_dm_rst_l;\n', '\n', '   //clken\n', '   logic              dbg_free_clken;\n', '   logic              dbg_free_clk;\n', '\n', '   logic              sb_free_clken;\n', '   logic              sb_free_clk;\n', '\n', '   logic              bus_clken;\n', '   logic              bus_clk;\n', '\n', '   // clocking\n', '   // used for the abstract commands.\n', '   assign dbg_free_clken  = dmi_reg_en | execute_command | (dbg_state != IDLE) | dbg_state_en | dec_tlu_dbg_halted | clk_override;\n', '\n', '   // used for the system bus\n', '   assign sb_free_clken = dmi_reg_en | execute_command | sb_state_en | (sb_state != SBIDLE) | clk_override;\n', '   assign bus_clken = (sb_axi_awvalid | sb_axi_wvalid | sb_axi_arvalid | sb_axi_bvalid | sb_axi_rvalid | clk_override) & dbg_bus_clk_en;\n', '\n', '   rvoclkhdr dbg_free_cgc     (.en(dbg_free_clken), .l1clk(dbg_free_clk), .*);\n', '   rvoclkhdr sb_free_cgc     (.en(sb_free_clken), .l1clk(sb_free_clk), .*);\n', '\n', '`ifndef RV_FPGA_OPTIMIZE\n', '   rvclkhdr bus_cgc (.en(bus_clken), .l1clk(bus_clk), .*);  // ifndef FPGA_OPTIMIZE\n', '`endif\n', '\n', '   // end clocking section\n', '\n', '   // Reset logic\n', '   assign dbg_dm_rst_l = dbg_rst_l & (dmcontrol_reg[0] | scan_mode);\n', '   assign dbg_core_rst_l = ~dmcontrol_reg[1] | scan_mode;\n', '\n', '   // system bus register\n', '   // sbcs[31:29], sbcs - [22]:sbbusyerror, [21]: sbbusy, [20]:sbreadonaddr, [19:17]:sbaccess, [16]:sbautoincrement, [15]:sbreadondata, [14:12]:sberror, sbsize=32, 128=0, 64/32/16/8 are legal\n', ""   assign        sbcs_reg[31:29] = 3'b1;\n"", ""   assign        sbcs_reg[28:23] = '0;\n"", '   assign        sbcs_reg[19:15] = {sbcs_reg_int[19], ~sbcs_reg_int[18], sbcs_reg_int[17:15]};\n', ""   assign        sbcs_reg[11:5]  = 7'h20;\n"", ""   assign        sbcs_reg[4:0]   = 5'b01111;\n"", ""   assign        sbcs_wren = (dmi_reg_addr ==  7'h38) & dmi_reg_en & dmi_reg_wr_en & (sb_state == SBIDLE); // & (sbcs_reg[14:12] == 3'b000);\n"", '   assign        sbcs_sbbusyerror_wren = (sbcs_wren & dmi_reg_wdata[22]) |\n', ""                                         (sbcs_reg[21] & dmi_reg_en & ((dmi_reg_wr_en & (dmi_reg_addr == 7'h39)) | (dmi_reg_addr == 7'h3c) | (dmi_reg_addr == 7'h3d)));\n"", '   assign        sbcs_sbbusyerror_din = ~(sbcs_wren & dmi_reg_wdata[22]);   // Clear when writing one\n', '\n', '   rvdffs #(1) sbcs_sbbusyerror_reg  (.din(sbcs_sbbusyerror_din),  .dout(sbcs_reg[22]),    .en(sbcs_sbbusyerror_wren), .rst_l(dbg_dm_rst_l), .clk(sb_free_clk));\n', '   rvdffs #(1) sbcs_sbbusy_reg       (.din(sbcs_sbbusy_din),       .dout(sbcs_reg[21]),    .en(sbcs_sbbusy_wren),      .rst_l(dbg_dm_rst_l), .clk(sb_free_clk));\n', '   rvdffs #(1) sbcs_sbreadonaddr_reg (.din(dmi_reg_wdata[20]),     .dout(sbcs_reg[20]),    .en(sbcs_wren),             .rst_l(dbg_dm_rst_l), .clk(sb_free_clk));\n', '   rvdffs #(5) sbcs_misc_reg         (.din({dmi_reg_wdata[19],~dmi_reg_wdata[18],dmi_reg_wdata[17:15]}),\n', '                                      .dout(sbcs_reg_int[19:15]), .en(sbcs_wren),             .rst_l(dbg_dm_rst_l), .clk(sb_free_clk));\n', '   rvdffs #(3) sbcs_error_reg        (.din(sbcs_sberror_din[2:0]), .dout(sbcs_reg[14:12]), .en(sbcs_sberror_wren),     .rst_l(dbg_dm_rst_l), .clk(sb_free_clk));\n', '\n', ""   assign sbcs_unaligned =    ((sbcs_reg[19:17] == 3'b001) &  sbaddress0_reg[0]) |\n"", ""                              ((sbcs_reg[19:17] == 3'b010) &  (|sbaddress0_reg[1:0])) |\n"", ""                              ((sbcs_reg[19:17] == 3'b011) &  (|sbaddress0_reg[2:0]));\n"", '\n', '   assign sbcs_illegal_size = sbcs_reg[19];    // Anything bigger than 64 bits is illegal\n', '\n', ""   assign sbaddress0_incr[3:0] = ({4{(sbcs_reg[19:17] == 3'h0)}} &  4'b0001) |\n"", ""                                 ({4{(sbcs_reg[19:17] == 3'h1)}} &  4'b0010) |\n"", ""                                 ({4{(sbcs_reg[19:17] == 3'h2)}} &  4'b0100) |\n"", ""                                 ({4{(sbcs_reg[19:17] == 3'h3)}} &  4'b1000);\n"", '\n', '   // sbdata\n', ""   //assign        sbdata0_reg_wren0   = dmi_reg_en & dmi_reg_wr_en & (dmi_reg_addr == 32'h3c);\n"", ""   assign        sbdata0_reg_wren0   = dmi_reg_en & dmi_reg_wr_en & (dmi_reg_addr == 7'h3c);   // write data only when single read is 0\n"", '   assign        sbdata0_reg_wren1   = (sb_state == RSP_RD) & sb_state_en & ~sbcs_sberror_wren;\n', '   assign        sbdata0_reg_wren    = sbdata0_reg_wren0 | sbdata0_reg_wren1;\n', '\n', ""   assign        sbdata1_reg_wren0   = dmi_reg_en & dmi_reg_wr_en & (dmi_reg_addr == 7'h3d);   // write data only when single read is 0;\n"", '   assign        sbdata1_reg_wren1   = (sb_state == RSP_RD) & sb_state_en & ~sbcs_sberror_wren;\n', '   assign        sbdata1_reg_wren    = sbdata1_reg_wren0 | sbdata1_reg_wren1;\n', '\n', '   assign        sbdata0_din[31:0]   = ({32{sbdata0_reg_wren0}} & dmi_reg_wdata[31:0]) |\n', '                                       ({32{sbdata0_reg_wren1}} & sb_bus_rdata[31:0]);\n', '   assign        sbdata1_din[31:0]   = ({32{sbdata1_reg_wren0}} & dmi_reg_wdata[31:0]) |\n', '                                       ({32{sbdata1_reg_wren1}} & sb_bus_rdata[63:32]);\n', '\n', '   rvdffe #(32)    dbg_sbdata0_reg    (.*, .din(sbdata0_din[31:0]), .dout(sbdata0_reg[31:0]), .en(sbdata0_reg_wren), .rst_l(dbg_dm_rst_l));\n', '   rvdffe #(32)    dbg_sbdata1_reg    (.*, .din(sbdata1_din[31:0]), .dout(sbdata1_reg[31:0]), .en(sbdata1_reg_wren), .rst_l(dbg_dm_rst_l));\n', '\n', '    // sbaddress\n', ""   assign        sbaddress0_reg_wren0   = dmi_reg_en & dmi_reg_wr_en & (dmi_reg_addr == 7'h39);\n"", '   assign        sbaddress0_reg_wren    = sbaddress0_reg_wren0 | sbaddress0_reg_wren1;\n', '   assign        sbaddress0_reg_din[31:0]= ({32{sbaddress0_reg_wren0}} & dmi_reg_wdata[31:0]) |\n', ""                                           ({32{sbaddress0_reg_wren1}} & (sbaddress0_reg[31:0] + {28'b0,sbaddress0_incr[3:0]}));\n"", '   rvdffe #(32)    dbg_sbaddress0_reg    (.*, .din(sbaddress0_reg_din[31:0]), .dout(sbaddress0_reg[31:0]), .en(sbaddress0_reg_wren), .rst_l(dbg_dm_rst_l));\n', '\n', ""   assign sbreadonaddr_access = dmi_reg_en & dmi_reg_wr_en & (dmi_reg_addr == 7'h39) & sbcs_reg[20];   // if readonaddr is set the next command will start upon writing of addr0\n"", ""   assign sbreadondata_access = dmi_reg_en & ~dmi_reg_wr_en & (dmi_reg_addr == 7'h3c) & sbcs_reg[15];  // if readondata is set the next command will start upon reading of data0\n"", ""   assign sbdata0wr_access  = dmi_reg_en &  dmi_reg_wr_en & (dmi_reg_addr == 7'h3c);                   // write to sbdata0 will start write command to system bus\n"", '\n', '   // memory mapped registers\n', '   // dmcontrol register has only 6 bits implemented. 31: haltreq, 30: resumereq, 28: ackhavereset, 1: ndmreset, 0: dmactive.\n', '   // rest all the bits are zeroed out\n', '   // dmactive flop is reset based on core rst_l, all other flops use dm_rst_l\n', ""   assign dmcontrol_wren      = (dmi_reg_addr ==  7'h10) & dmi_reg_en & dmi_reg_wr_en;\n"", ""   assign dmcontrol_reg[29]   = '0;\n"", ""   assign dmcontrol_reg[27:2] = '0;\n"", '   assign resumereq           = dmcontrol_reg[30] & ~dmcontrol_reg[31] & dmcontrol_wren_Q;\n', '   rvdffs #(4) dmcontrolff (.din({dmi_reg_wdata[31:30],dmi_reg_wdata[28],dmi_reg_wdata[1]}), .dout({dmcontrol_reg[31:30], dmcontrol_reg[28], dmcontrol_reg[1]}), .en(dmcontrol_wren), .rst_l(dbg_dm_rst_l), .clk(dbg_free_clk));\n', '   rvdffs #(1) dmcontrol_dmactive_ff (.din(dmi_reg_wdata[0]), .dout(dmcontrol_reg[0]), .en(dmcontrol_wren), .rst_l(dbg_rst_l), .clk(dbg_free_clk));\n', '   rvdff  #(1) dmcontrol_wrenff(.din(dmcontrol_wren), .dout(dmcontrol_wren_Q), .rst_l(dbg_dm_rst_l), .clk(dbg_free_clk));\n', '\n', '   // dmstatus register bits that are implemented\n', '   // [19:18]-havereset,[17:16]-resume ack, [9:8]-halted, [3:0]-version\n', '   // rest all the bits are zeroed out\n', ""   assign dmstatus_reg[31:20] = '0;\n"", '   assign dmstatus_reg[19:18] = {2{dmstatus_havereset}};\n', ""   assign dmstatus_reg[15:14] = '0;\n"", ""   assign dmstatus_reg[7]     = '1;\n"", ""   assign dmstatus_reg[6:4]   = '0;\n"", '   assign dmstatus_reg[17:16] = {2{dmstatus_resumeack}};\n', '   assign dmstatus_reg[13:12] = {2{dmstatus_unavail}};\n', '   assign dmstatus_reg[11:10] = {2{dmstatus_running}};\n', '   assign dmstatus_reg[9:8]   = {2{dmstatus_halted}};\n', ""   assign dmstatus_reg[3:0]   = 4'h2;\n"", '\n', '   assign dmstatus_resumeack_wren = ((dbg_state == RESUMING) & dec_tlu_resume_ack) | (dmstatus_resumeack & resumereq & dmstatus_halted);\n', '   assign dmstatus_resumeack_din  = (dbg_state == RESUMING) & dec_tlu_resume_ack;\n', '\n', ""   assign dmstatus_haveresetn_wren  = (dmi_reg_addr == 7'h10) & dmi_reg_wdata[28] & dmi_reg_en & dmi_reg_wr_en & dmcontrol_reg[0];   // clear the havereset\n"", '   assign dmstatus_havereset        = ~dmstatus_haveresetn;\n', '\n', '   assign dmstatus_unavail = dmcontrol_reg[1] | ~rst_l;\n', '   assign dmstatus_running = ~(dmstatus_unavail | dmstatus_halted);\n', '\n', '   rvdffs  #(1) dmstatus_resumeack_reg (.din(dmstatus_resumeack_din), .dout(dmstatus_resumeack), .en(dmstatus_resumeack_wren), .rst_l(dbg_dm_rst_l), .clk(dbg_free_clk));\n', '   rvdff   #(1) dmstatus_halted_reg    (.din(dec_tlu_dbg_halted & ~dec_tlu_mpc_halted_only),     .dout(dmstatus_halted), .rst_l(dbg_dm_rst_l), .clk(dbg_free_clk));\n', ""   rvdffs  #(1) dmstatus_haveresetn_reg (.din(1'b1), .dout(dmstatus_haveresetn), .en(dmstatus_haveresetn_wren), .rst_l(rst_l), .clk(dbg_free_clk));\n"", '\n', '   // haltsum0 register\n', ""   assign haltsum0_reg[31:1] = '0;\n"", '   assign haltsum0_reg[0]    = dmstatus_halted;\n', '\n', '   // abstractcs register\n', '   // bits implemted are [12] - busy and [10:8]= command error\n', ""   assign        abstractcs_reg[31:13] = '0;\n"", ""   assign        abstractcs_reg[11]    = '0;\n"", ""   assign        abstractcs_reg[7:4]   = '0;\n"", ""   assign        abstractcs_reg[3:0]   = 4'h2;    // One data register\n"", ""   assign        abstractcs_error_sel0 = abstractcs_reg[12] & ~(|abstractcs_reg[10:8]) & dmi_reg_en & ((dmi_reg_wr_en & ((dmi_reg_addr == 7'h16) | (dmi_reg_addr == 7'h17)) | (dmi_reg_addr == 7'h18)) |\n"", ""                                                                                                       (dmi_reg_addr == 7'h4) | (dmi_reg_addr == 7'h5));\n"", '   assign        abstractcs_error_sel1 = execute_command & ~(|abstractcs_reg[10:8]) &\n', ""                                         ((~((command_reg[31:24] == 8'b0) | (command_reg[31:24] == 8'h2)))                      |   // Illegal command\n"", ""                                          (((command_reg[22:20] == 3'b011) | (command_reg[22])) & (command_reg[31:24] == 8'h2)) |   // Illegal abstract memory size (can't be DW or higher)\n"", ""                                          ((command_reg[22:20] != 3'b010) & ((command_reg[31:24] == 8'h0) & command_reg[17]))   |   // Illegal abstract reg size\n"", ""                                          ((command_reg[31:24] == 8'h0) & command_reg[18]));                                          //postexec for abstract register access\n"", '   assign        abstractcs_error_sel2 = ((core_dbg_cmd_done & core_dbg_cmd_fail) |                   // exception from core\n', ""                                          (execute_command & (command_reg[31:24] == 8'h0) &  // unimplemented regs\n"", ""                                                (((command_reg[15:12] == 4'h1) & (command_reg[11:5] != 0)) | (command_reg[15:13] != 0)))) & ~(|abstractcs_reg[10:8]);\n"", '   assign        abstractcs_error_sel3 = execute_command & (dbg_state != HALTED) & ~(|abstractcs_reg[10:8]);\n', '   assign        abstractcs_error_sel4 = dbg_sb_bus_error & dbg_bus_clk_en & ~(|abstractcs_reg[10:8]);// sb bus error for abstract memory command\n', ""   assign        abstractcs_error_sel5 = execute_command & (command_reg[31:24] == 8'h2) & ~(|abstractcs_reg[10:8]) &\n"", ""                                         (((command_reg[22:20] == 3'b001) & data1_reg[0]) | ((command_reg[22:20] == 3'b010) & (|data1_reg[1:0])));  //Unaligned address for abstract memory\n"", '\n', ""   assign        abstractcs_error_sel6 = (dmi_reg_addr ==  7'h16) & dmi_reg_en & dmi_reg_wr_en;\n"", '\n', ""   assign        abstractcs_error_din[2:0]  = abstractcs_error_sel0 ? 3'b001 :                  // writing command or abstractcs while a command was executing. Or accessing data0\n"", ""                                                 abstractcs_error_sel1 ? 3'b010 :               // writing a illegal command type to cmd field of command\n"", ""                                                    abstractcs_error_sel2 ? 3'b011 :            // exception while running command\n"", ""                                                       abstractcs_error_sel3 ? 3'b100 :         // writing a comnand when not in the halted state\n"", ""                                                          abstractcs_error_sel4 ? 3'b101 :      // Bus error\n"", ""                                                             abstractcs_error_sel5 ? 3'b111 :   // unaligned or illegal size abstract memory command\n"", '                                                                abstractcs_error_sel6 ? (~dmi_reg_wdata[10:8] & abstractcs_reg[10:8]) :   //W1C\n', '                                                                                        abstractcs_reg[10:8];                             //hold\n', '\n', '   rvdffs #(1) dmabstractcs_busy_reg  (.din(abstractcs_busy_din), .dout(abstractcs_reg[12]), .en(abstractcs_busy_wren), .rst_l(dbg_dm_rst_l), .clk(dbg_free_clk));\n', '   rvdff  #(3) dmabstractcs_error_reg (.din(abstractcs_error_din[2:0]), .dout(abstractcs_reg[10:8]), .rst_l(dbg_dm_rst_l), .clk(dbg_free_clk));\n', '\n', '    // abstract auto reg\n', ""   assign abstractauto_reg_wren  = dmi_reg_en & dmi_reg_wr_en & (dmi_reg_addr == 7'h18) & ~abstractcs_reg[12];\n"", '   rvdffs #(2) dbg_abstractauto_reg (.*, .din(dmi_reg_wdata[1:0]), .dout(abstractauto_reg[1:0]), .en(abstractauto_reg_wren), .rst_l(dbg_dm_rst_l), .clk(dbg_free_clk));\n', '\n', '   // command register - implemented all the bits in this register\n', '   // command[16] = 1: write, 0: read\n', '   assign execute_command_ns = command_wren |\n', ""                               (dmi_reg_en & ~abstractcs_reg[12] & (((dmi_reg_addr == 7'h4) & abstractauto_reg[0]) | ((dmi_reg_addr == 7'h5) & abstractauto_reg[1])));\n"", ""   assign command_wren = (dmi_reg_addr ==  7'h17) & dmi_reg_en & dmi_reg_wr_en;\n"", ""   //assign command_wren = (dmi_reg_addr ==  7'h17) & dmi_reg_en & dmi_reg_wr_en & (dbg_state == HALTED) & ~abstractcs_reg[12];\n"", ""   assign command_regno_wren = command_wren | ((command_reg[31:24] == 8'h0) & command_reg[19] & (dbg_state == CMD_DONE) & ~(|abstractcs_reg[10:8]));  // aarpostincrement\n"", ""   assign command_postexec_din = (dmi_reg_wdata[31:24] == 8'h0) & dmi_reg_wdata[18];\n"", ""   assign command_transfer_din = (dmi_reg_wdata[31:24] == 8'h0) & dmi_reg_wdata[17];\n"", ""   assign command_din[31:16] = {dmi_reg_wdata[31:24],1'b0,dmi_reg_wdata[22:19],command_postexec_din,command_transfer_din, dmi_reg_wdata[16]};\n"", '   assign command_din[15:0] =  command_wren ? dmi_reg_wdata[15:0] : dbg_cmd_next_addr[15:0];\n', '   rvdff  #(1)  execute_commandff   (.*, .din(execute_command_ns), .dout(execute_command), .clk(dbg_free_clk), .rst_l(dbg_dm_rst_l));\n', '   rvdffe #(16) dmcommand_reg       (.*, .din(command_din[31:16]), .dout(command_reg[31:16]), .en(command_wren), .rst_l(dbg_dm_rst_l));\n', '   rvdffe #(16) dmcommand_regno_reg (.*, .din(command_din[15:0]),  .dout(command_reg[15:0]),  .en(command_regno_wren), .rst_l(dbg_dm_rst_l));\n', '\n', '   // data0 reg\n', ""   assign data0_reg_wren0   = (dmi_reg_en & dmi_reg_wr_en & (dmi_reg_addr == 7'h4) & (dbg_state == HALTED) & ~abstractcs_reg[12]);\n"", '   assign data0_reg_wren1   = core_dbg_cmd_done & (dbg_state == CORE_CMD_WAIT) & ~command_reg[16];\n', '   assign data0_reg_wren    = data0_reg_wren0 | data0_reg_wren1 | data0_reg_wren2;\n', '\n', '   assign data0_din[31:0]   = ({32{data0_reg_wren0}} & dmi_reg_wdata[31:0])   |\n', '                              ({32{data0_reg_wren1}} & core_dbg_rddata[31:0]) |\n', '                              ({32{data0_reg_wren2}} & sb_bus_rdata[31:0]);\n', '\n', '   rvdffe #(32) dbg_data0_reg (.*, .din(data0_din[31:0]), .dout(data0_reg[31:0]), .en(data0_reg_wren), .rst_l(dbg_dm_rst_l));\n', '\n', '   // data 1\n', ""   assign data1_reg_wren0   = (dmi_reg_en & dmi_reg_wr_en & (dmi_reg_addr == 7'h5) & (dbg_state == HALTED) & ~abstractcs_reg[12]);\n"", ""   assign data1_reg_wren1   = (dbg_state == CMD_DONE) & (command_reg[31:24] == 8'h2) & command_reg[19] & ~(|abstractcs_reg[10:8]);   // aampostincrement\n"", '   assign data1_reg_wren    = data1_reg_wren0 | data1_reg_wren1;\n', '\n', '   assign data1_din[31:0]   = ({32{data1_reg_wren0}} & dmi_reg_wdata[31:0]) |\n', '                              ({32{data1_reg_wren1}} & dbg_cmd_next_addr[31:0]);\n', '\n', '   rvdffe #(32)    dbg_data1_reg    (.*, .din(data1_din[31:0]), .dout(data1_reg[31:0]), .en(data1_reg_wren), .rst_l(dbg_dm_rst_l));\n', '\n', '   rvdffs #(1) sb_abmem_cmd_doneff  (.din(sb_abmem_cmd_done_in),  .dout(sb_abmem_cmd_done),  .en(sb_abmem_cmd_done_en),  .clk(dbg_free_clk), .rst_l(dbg_dm_rst_l), .*);\n', '   rvdffs #(1) sb_abmem_data_doneff (.din(sb_abmem_data_done_in), .dout(sb_abmem_data_done), .en(sb_abmem_data_done_en), .clk(dbg_free_clk), .rst_l(dbg_dm_rst_l), .*);\n', '\n', '   // FSM to control the debug mode entry, command send/recieve, and Resume flow.\n', '   always_comb begin\n', '      dbg_nxtstate            = IDLE;\n', ""      dbg_state_en            = 1'b0;\n"", ""      abstractcs_busy_wren    = 1'b0;\n"", ""      abstractcs_busy_din     = 1'b0;\n"", '      dbg_halt_req            = dmcontrol_wren_Q & dmcontrol_reg[31] & ~dmcontrol_reg[1];      // single pulse output to the core. Need to drive every time this register is written since core might be halted due to MPC\n', ""      dbg_resume_req          = 1'b0;         // single pulse output to the core\n"", ""      dbg_sb_bus_error        = 1'b0;\n"", ""      data0_reg_wren2         = 1'b0;\n"", ""      sb_abmem_cmd_done_in    = 1'b0;\n"", ""      sb_abmem_data_done_in   = 1'b0;\n"", ""      sb_abmem_cmd_done_en    = 1'b0;\n"", ""      sb_abmem_data_done_en   = 1'b0;\n"", '\n', '       case (dbg_state)\n', '            IDLE: begin\n', '                     dbg_nxtstate         = (dmstatus_reg[9] | dec_tlu_mpc_halted_only) ? HALTED : HALTING;         // initiate the halt command to the core\n', '                     dbg_state_en         = ((dmcontrol_reg[31] & ~dec_tlu_debug_mode) | dmstatus_reg[9] | dec_tlu_mpc_halted_only) & ~dmcontrol_reg[1];      // when the jtag writes the halt bit in the DM register, OR when the status indicates Halted\n', '                     dbg_halt_req         = dmcontrol_reg[31] & ~dmcontrol_reg[1];                        // Removed debug mode qualification during MPC changes\n', '            end\n', '            HALTING : begin\n', '                     dbg_nxtstate         = dmcontrol_reg[1] ? IDLE : HALTED;                             // Goto HALTED once the core sends an ACK\n', '                     dbg_state_en         = dmstatus_reg[9] | dmcontrol_reg[1];                           // core indicates halted\n', '            end\n', '            HALTED: begin\n', '                     // wait for halted to go away before send to resume. Else start of new command\n', ""                     dbg_nxtstate         = (dmstatus_reg[9] & ~dmcontrol_reg[1]) ? (resumereq ? RESUMING : (((command_reg[31:24] == 8'h2) & abmem_addr_external) ? SB_CMD_START : CORE_CMD_START)) :\n"", '                                                                                    (dmcontrol_reg[31] ? HALTING : IDLE);       // This is MPC halted case\n', '                     dbg_state_en         = (dmstatus_reg[9] & resumereq) | execute_command | dmcontrol_reg[1] | ~(dmstatus_reg[9] | dec_tlu_mpc_halted_only);\n', '                     abstractcs_busy_wren = dbg_state_en & ((dbg_nxtstate == CORE_CMD_START) | (dbg_nxtstate == SB_CMD_START));                 // write busy when a new command was written by jtag\n', ""                     abstractcs_busy_din  = 1'b1;\n"", '                     dbg_resume_req       = dbg_state_en & (dbg_nxtstate == RESUMING);                       // single cycle pulse to core if resuming\n', '            end\n', '            CORE_CMD_START: begin\n', ""                     // Don't execute the command if cmderror or transfer=0 for abstract register access\n"", ""                     dbg_nxtstate         = dmcontrol_reg[1] ? IDLE : ((|abstractcs_reg[10:8]) | ((command_reg[31:24] == 8'h0) & ~command_reg[17])) ? CMD_DONE : CORE_CMD_WAIT;     // new command sent to the core\n"", ""                     dbg_state_en         = dbg_cmd_valid | (|abstractcs_reg[10:8]) | ((command_reg[31:24] == 8'h0) & ~command_reg[17]) | dmcontrol_reg[1];\n"", '            end\n', '            CORE_CMD_WAIT: begin\n', '                     dbg_nxtstate         = dmcontrol_reg[1] ? IDLE : CMD_DONE;\n', '                     dbg_state_en         = core_dbg_cmd_done | dmcontrol_reg[1];              // go to done state for one cycle after completing current command\n', '            end\n', '            SB_CMD_START: begin\n', '                     dbg_nxtstate         = dmcontrol_reg[1] ? IDLE : (|abstractcs_reg[10:8]) ? CMD_DONE : SB_CMD_SEND;\n', '                     dbg_state_en         = (dbg_bus_clk_en & ~sb_cmd_pending) | (|abstractcs_reg[10:8]) | dmcontrol_reg[1];\n', '            end\n', '            SB_CMD_SEND: begin\n', ""                     sb_abmem_cmd_done_in = 1'b1;\n"", ""                     sb_abmem_data_done_in= 1'b1;\n"", '                     sb_abmem_cmd_done_en = ((sb_axi_awvalid & sb_axi_awready) | (sb_axi_arvalid & sb_axi_arready)) & dbg_bus_clk_en;\n', '                     sb_abmem_data_done_en= ((sb_axi_wvalid  & sb_axi_wready)  | (sb_axi_arvalid & sb_axi_arready)) & dbg_bus_clk_en;\n', '                     dbg_nxtstate         = dmcontrol_reg[1] ? IDLE : SB_CMD_RESP;\n', '                     dbg_state_en         = (sb_abmem_cmd_done | sb_abmem_cmd_done_en) & (sb_abmem_data_done | sb_abmem_data_done_en) & dbg_bus_clk_en;\n', '            end\n', '            SB_CMD_RESP: begin\n', '                     dbg_nxtstate         = dmcontrol_reg[1] ? IDLE : CMD_DONE;\n', '                     dbg_state_en         = ((sb_axi_rvalid & sb_axi_rready) | (sb_axi_bvalid & sb_axi_bready)) & dbg_bus_clk_en;\n', '                     dbg_sb_bus_error     = ((sb_axi_rvalid & sb_axi_rready & sb_axi_rresp[1]) | (sb_axi_bvalid & sb_axi_bready & sb_axi_bresp[1])) & dbg_bus_clk_en;\n', '                     data0_reg_wren2      = dbg_state_en & ~sb_abmem_cmd_write & ~dbg_sb_bus_error;\n', '            end\n', '            CMD_DONE: begin\n', '                     dbg_nxtstate         = dmcontrol_reg[1] ? IDLE : HALTED;\n', ""                     dbg_state_en         = 1'b1;\n"", '                     abstractcs_busy_wren = dbg_state_en;                    // remove the busy bit from the abstracts ( bit 12 )\n', ""                     abstractcs_busy_din  = 1'b0;\n"", ""                     sb_abmem_cmd_done_in = 1'b0;\n"", ""                     sb_abmem_data_done_in= 1'b0;\n"", ""                     sb_abmem_cmd_done_en = 1'b1;\n"", ""                     sb_abmem_data_done_en= 1'b1;\n"", '            end\n', '            RESUMING : begin\n', '                     dbg_nxtstate            = IDLE;\n', '                     dbg_state_en            = dmstatus_reg[17] | dmcontrol_reg[1];             // resume ack has been updated in the dmstatus register\n', '           end\n', '           default : begin\n', '                     dbg_nxtstate            = IDLE;\n', ""                     dbg_state_en            = 1'b0;\n"", ""                     abstractcs_busy_wren    = 1'b0;\n"", ""                     abstractcs_busy_din     = 1'b0;\n"", ""                     dbg_halt_req            = 1'b0;         // single pulse output to the core\n"", ""                     dbg_resume_req          = 1'b0;         // single pulse output to the core\n"", '          end\n', '         endcase\n', '   end // always_comb begin\n', '\n', ""   assign dmi_reg_rdata_din[31:0] = ({32{dmi_reg_addr == 7'h4}}  & data0_reg[31:0])      |\n"", ""                                    ({32{dmi_reg_addr == 7'h5}}  & data1_reg[31:0])      |\n"", ""                                    ({32{dmi_reg_addr == 7'h10}} & {2'b0,dmcontrol_reg[29],1'b0,dmcontrol_reg[27:0]})  |  // Read0 to Write only bits\n"", ""                                    ({32{dmi_reg_addr == 7'h11}} & dmstatus_reg[31:0])   |\n"", ""                                    ({32{dmi_reg_addr == 7'h16}} & abstractcs_reg[31:0]) |\n"", ""                                    ({32{dmi_reg_addr == 7'h17}} & command_reg[31:0])    |\n"", ""                                    ({32{dmi_reg_addr == 7'h18}} & {30'h0,abstractauto_reg[1:0]})    |\n"", ""                                    ({32{dmi_reg_addr == 7'h40}} & haltsum0_reg[31:0])   |\n"", ""                                    ({32{dmi_reg_addr == 7'h38}} & sbcs_reg[31:0])       |\n"", ""                                    ({32{dmi_reg_addr == 7'h39}} & sbaddress0_reg[31:0]) |\n"", ""                                    ({32{dmi_reg_addr == 7'h3c}} & sbdata0_reg[31:0])    |\n"", ""                                    ({32{dmi_reg_addr == 7'h3d}} & sbdata1_reg[31:0]);\n"", '\n', '\n', '   rvdffs #($bits(state_t)) dbg_state_reg    (.din(dbg_nxtstate), .dout({dbg_state}), .en(dbg_state_en), .rst_l(dbg_dm_rst_l & rst_l), .clk(dbg_free_clk));  // Reset for both core/dbg reset\n', ""   // Ack will use the power on reset only otherwise there won't be any ack until dmactive is 1\n"", '//   rvdff  #(1)              dmi_ack_reg      (.din(dmi_reg_en), .dout(dmi_reg_ack), .rst_l(rst_l), .clk(free_clk));\n', '   rvdffs  #(32) dmi_rddata_reg(.din(dmi_reg_rdata_din), .dout(dmi_reg_rdata), .en(dmi_reg_en), .rst_l(dbg_dm_rst_l), .clk(dbg_free_clk));\n', '\n', '   assign abmem_addr[31:0] = data1_reg[31:0];\n', '   assign abmem_addr_core_local = (abmem_addr_in_dccm_region | abmem_addr_in_iccm_region | abmem_addr_in_pic_region);\n', '   assign abmem_addr_external   = ~abmem_addr_core_local;\n', '\n', '   assign abmem_addr_in_dccm_region = (abmem_addr[31:28] == `RV_DCCM_REGION) & DCCM_ENABLE;\n', '   assign abmem_addr_in_iccm_region = (abmem_addr[31:28] == `RV_ICCM_REGION) & ICCM_ENABLE;\n', '   assign abmem_addr_in_pic_region  = (abmem_addr[31:28] == `RV_PIC_REGION);\n', '\n', '   // interface for the core\n', ""   assign dbg_cmd_addr[31:0]    = (command_reg[31:24] == 8'h2) ? data1_reg[31:0]  : {20'b0, command_reg[11:0]};\n"", '   assign dbg_cmd_wrdata[31:0]  = data0_reg[31:0];\n', ""   assign dbg_cmd_valid         = (dbg_state == CORE_CMD_START) & ~((|abstractcs_reg[10:8]) | ((command_reg[31:24] == 8'h0) & ~command_reg[17]) | ((command_reg[31:24] == 8'h2) & abmem_addr_external)) & dma_dbg_ready;\n"", '   assign dbg_cmd_write         = command_reg[16];\n', ""   assign dbg_cmd_type[1:0]     = (command_reg[31:24] == 8'h2) ? 2'b10 : {1'b0, (command_reg[15:12] == 4'b0)};\n"", '   assign dbg_cmd_size[1:0]     = command_reg[21:20];\n', '\n', ""   assign dbg_cmd_addr_incr[3:0]  = (command_reg[31:24] == 8'h2) ? (4'h1 << sb_abmem_cmd_size[1:0]) : 4'h1;\n"", ""   assign dbg_cmd_curr_addr[31:0] = (command_reg[31:24] == 8'h2) ? data1_reg[31:0]  : {16'b0, command_reg[15:0]};\n"", ""   assign dbg_cmd_next_addr[31:0] = dbg_cmd_curr_addr[31:0] + {28'h0,dbg_cmd_addr_incr[3:0]};\n"", '\n', '   assign sb_abmem_cmd_awvalid    = (dbg_state == SB_CMD_SEND) & sb_abmem_cmd_write & ~sb_abmem_cmd_done;\n', '   assign sb_abmem_cmd_wvalid     = (dbg_state == SB_CMD_SEND) & sb_abmem_cmd_write & ~sb_abmem_data_done;\n', '   assign sb_abmem_cmd_arvalid    = (dbg_state == SB_CMD_SEND) & ~sb_abmem_cmd_write & ~sb_abmem_cmd_done & ~sb_abmem_data_done;\n', '   assign sb_abmem_read_pend      = (dbg_state == SB_CMD_RESP) & ~sb_abmem_cmd_write;\n', '   assign sb_abmem_cmd_write      = command_reg[16];\n', ""   assign sb_abmem_cmd_size[2:0]  = {1'b0, command_reg[21:20]};\n"", '   assign sb_abmem_cmd_addr[31:0] = abmem_addr[31:0];\n', '   assign sb_abmem_cmd_wdata[31:0] = data0_reg[31:0];\n', '\n', '   // Ask DMA to stop taking bus trxns since debug request is done\n', '   assign dbg_dma_bubble = ((dbg_state == CORE_CMD_START) & ~(|abstractcs_reg[10:8])) | (dbg_state == CORE_CMD_WAIT);\n', '\n', '   assign sb_cmd_pending       = (sb_state == CMD_RD) | (sb_state == CMD_WR) | (sb_state == CMD_WR_ADDR) | (sb_state == CMD_WR_DATA) | (sb_state == RSP_RD) | (sb_state == RSP_WR);\n', '   assign sb_abmem_cmd_pending = (dbg_state == SB_CMD_START) | (dbg_state == SB_CMD_SEND) | (dbg_state== SB_CMD_RESP);\n', '\n', '  // system bus FSM\n', '  always_comb begin\n', '      sb_nxtstate            = SBIDLE;\n', ""      sb_state_en            = 1'b0;\n"", ""      sbcs_sbbusy_wren       = 1'b0;\n"", ""      sbcs_sbbusy_din        = 1'b0;\n"", ""      sbcs_sberror_wren      = 1'b0;\n"", ""      sbcs_sberror_din[2:0]  = 3'b0;\n"", ""      sbaddress0_reg_wren1   = 1'b0;\n"", '      case (sb_state)\n', '            SBIDLE: begin\n', '                     sb_nxtstate            = sbdata0wr_access ? WAIT_WR : WAIT_RD;\n', '                     sb_state_en            = (sbdata0wr_access | sbreadondata_access | sbreadonaddr_access) & ~(|sbcs_reg[14:12]) & ~sbcs_reg[22];\n', '                     sbcs_sbbusy_wren       = sb_state_en;                                                 // set the single read bit if it is a singlread command\n', ""                     sbcs_sbbusy_din        = 1'b1;\n"", '                     sbcs_sberror_wren      = sbcs_wren & (|dmi_reg_wdata[14:12]);                                            // write to clear the error bits\n', '                     sbcs_sberror_din[2:0]  = ~dmi_reg_wdata[14:12] & sbcs_reg[14:12];\n', '            end\n', '            WAIT_RD: begin\n', '                     sb_nxtstate           = (sbcs_unaligned | sbcs_illegal_size) ? DONE : CMD_RD;\n', '                     sb_state_en           = (dbg_bus_clk_en & ~sb_abmem_cmd_pending) | sbcs_unaligned | sbcs_illegal_size;\n', '                     sbcs_sberror_wren     = sbcs_unaligned | sbcs_illegal_size;\n', ""                     sbcs_sberror_din[2:0] = sbcs_unaligned ? 3'b011 : 3'b100;\n"", '            end\n', '            WAIT_WR: begin\n', '                     sb_nxtstate           = (sbcs_unaligned | sbcs_illegal_size) ? DONE : CMD_WR;\n', '                     sb_state_en           = (dbg_bus_clk_en & ~sb_abmem_cmd_pending) | sbcs_unaligned | sbcs_illegal_size;\n', '                     sbcs_sberror_wren     = sbcs_unaligned | sbcs_illegal_size;\n', ""                     sbcs_sberror_din[2:0] = sbcs_unaligned ? 3'b011 : 3'b100;\n"", '            end\n', '            CMD_RD : begin\n', '                     sb_nxtstate           = RSP_RD;\n', '                     sb_state_en           = sb_axi_arvalid & sb_axi_arready & dbg_bus_clk_en;\n', '            end\n', '            CMD_WR : begin\n', '                     sb_nxtstate           = (sb_axi_awready & sb_axi_wready) ? RSP_WR : (sb_axi_awready ? CMD_WR_DATA : CMD_WR_ADDR);\n', '                     sb_state_en           = ((sb_axi_awvalid & sb_axi_awready) | (sb_axi_wvalid & sb_axi_wready)) & dbg_bus_clk_en;\n', '            end\n', '            CMD_WR_ADDR : begin\n', '                     sb_nxtstate           = RSP_WR;\n', '                     sb_state_en           = sb_axi_awvalid & sb_axi_awready & dbg_bus_clk_en;\n', '            end\n', '            CMD_WR_DATA : begin\n', '                     sb_nxtstate           = RSP_WR;\n', '                     sb_state_en           = sb_axi_wvalid & sb_axi_wready & dbg_bus_clk_en;\n', '            end\n', '            RSP_RD: begin\n', '                     sb_nxtstate           = DONE;\n', '                     sb_state_en           = sb_axi_rvalid & sb_axi_rready & dbg_bus_clk_en;\n', '                     sbcs_sberror_wren     = sb_state_en & sb_axi_rresp[1];\n', ""                     sbcs_sberror_din[2:0] = 3'b010;\n"", '            end\n', '            RSP_WR: begin\n', '                     sb_nxtstate           = DONE;\n', '                     sb_state_en           = sb_axi_bvalid & sb_axi_bready & dbg_bus_clk_en;\n', '                     sbcs_sberror_wren     = sb_state_en & sb_axi_bresp[1];\n', ""                     sbcs_sberror_din[2:0] = 3'b010;\n"", '            end\n', '            DONE: begin\n', '                     sb_nxtstate            = SBIDLE;\n', ""                     sb_state_en            = 1'b1;\n"", ""                     sbcs_sbbusy_wren       = 1'b1;                           // reset the single read\n"", ""                     sbcs_sbbusy_din        = 1'b0;\n"", ""                     sbaddress0_reg_wren1   = sbcs_reg[16] & (sbcs_reg[14:12] == 3'b0);    // auto increment was set and no error. Update to new address after completing the current command\n"", '            end\n', '            default : begin\n', '                     sb_nxtstate            = SBIDLE;\n', ""                     sb_state_en            = 1'b0;\n"", ""                     sbcs_sbbusy_wren       = 1'b0;\n"", ""                     sbcs_sbbusy_din        = 1'b0;\n"", ""                     sbcs_sberror_wren      = 1'b0;\n"", ""                     sbcs_sberror_din[2:0]  = 3'b0;\n"", ""                     sbaddress0_reg_wren1   = 1'b0;\n"", '           end\n', '         endcase\n', '   end // always_comb begin\n', '\n', '   rvdffs #($bits(sb_state_t)) sb_state_reg (.din(sb_nxtstate), .dout({sb_state}), .en(sb_state_en), .rst_l(dbg_dm_rst_l), .clk(sb_free_clk));\n', '\n', '   rvdff_fpga  #(2) axi_bresp_ff (.din(sb_axi_bresp[1:0]), .dout(sb_axi_bresp_q[1:0]), .rst_l(dbg_dm_rst_l), .clk(bus_clk), .clken(bus_clken), .rawclk(clk), .*);\n', '   rvdff_fpga  #(2) axi_rresp_ff (.din(sb_axi_rresp[1:0]), .dout(sb_axi_rresp_q[1:0]), .rst_l(dbg_dm_rst_l), .clk(bus_clk), .clken(bus_clken), .rawclk(clk), .*);\n', '\n', '   rvdffs #(.WIDTH(1)) axi_awvalid_ff (.din(sb_axi_awvalid), .dout(sb_axi_awvalid_q), .en(dbg_bus_clk_en), .rst_l(dbg_dm_rst_l), .clk(sb_free_clk), .*);\n', '   rvdffs #(.WIDTH(1)) axi_awready_ff (.din(sb_axi_awready), .dout(sb_axi_awready_q), .en(dbg_bus_clk_en), .rst_l(dbg_dm_rst_l), .clk(sb_free_clk), .*);\n', '   rvdffs #(.WIDTH(1)) axi_wvalid_ff (.din(sb_axi_wvalid), .dout(sb_axi_wvalid_q), .en(dbg_bus_clk_en), .rst_l(dbg_dm_rst_l), .clk(sb_free_clk), .*);\n', '   rvdffs #(.WIDTH(1)) axi_wready_ff (.din(sb_axi_wready), .dout(sb_axi_wready_q), .en(dbg_bus_clk_en), .rst_l(dbg_dm_rst_l), .clk(sb_free_clk), .*);\n', '   rvdffs #(.WIDTH(1)) axi_arvalid_ff (.din(sb_axi_arvalid), .dout(sb_axi_arvalid_q), .en(dbg_bus_clk_en), .rst_l(dbg_dm_rst_l), .clk(sb_free_clk), .*);\n', '   rvdffs #(.WIDTH(1)) axi_arready_ff (.din(sb_axi_arready), .dout(sb_axi_arready_q), .en(dbg_bus_clk_en), .rst_l(dbg_dm_rst_l), .clk(sb_free_clk), .*);\n', '\n', '   rvdffs #(.WIDTH(1)) axi_bvalid_ff (.din(sb_axi_bvalid), .dout(sb_axi_bvalid_q), .en(dbg_bus_clk_en), .rst_l(dbg_dm_rst_l), .clk(sb_free_clk), .*);\n', '   rvdffs #(.WIDTH(1)) axi_bready_ff (.din(sb_axi_bready), .dout(sb_axi_bready_q), .en(dbg_bus_clk_en), .rst_l(dbg_dm_rst_l), .clk(sb_free_clk), .*);\n', '   rvdffs #(.WIDTH(1)) axi_rvalid_ff (.din(sb_axi_rvalid), .dout(sb_axi_rvalid_q), .en(dbg_bus_clk_en), .rst_l(dbg_dm_rst_l), .clk(sb_free_clk), .*);\n', '   rvdffs #(.WIDTH(1)) axi_rready_ff (.din(sb_axi_rready), .dout(sb_axi_rready_q), .en(dbg_bus_clk_en), .rst_l(dbg_dm_rst_l), .clk(sb_free_clk), .*);\n', '\n', '   assign sb_cmd_awvalid     = ((sb_state == CMD_WR) | (sb_state == CMD_WR_ADDR));\n', '   assign sb_cmd_wvalid      = ((sb_state == CMD_WR) | (sb_state == CMD_WR_DATA));\n', '   assign sb_cmd_arvalid     = (sb_state == CMD_RD);\n', '   assign sb_read_pend       = (sb_state == RSP_RD);\n', '   assign sb_cmd_size[2:0]   = sbcs_reg[19:17];\n', '   assign sb_cmd_wdata[63:0] = {sbdata1_reg[31:0], sbdata0_reg[31:0]};\n', '   assign sb_cmd_addr[31:0]  = sbaddress0_reg[31:0];\n', '\n', '   assign sb_axi_size[2:0]    = (sb_abmem_cmd_awvalid | sb_abmem_cmd_wvalid | sb_abmem_cmd_arvalid | sb_abmem_read_pend) ? sb_abmem_cmd_size[2:0] : sb_cmd_size[2:0];\n', '   assign sb_axi_addr[31:0]   = (sb_abmem_cmd_awvalid | sb_abmem_cmd_wvalid | sb_abmem_cmd_arvalid | sb_abmem_read_pend) ? sb_abmem_cmd_addr[31:0] : sb_cmd_addr[31:0];\n', '   assign sb_axi_wrdata[63:0] = (sb_abmem_cmd_awvalid | sb_abmem_cmd_wvalid) ? {2{sb_abmem_cmd_wdata[31:0]}} : sb_cmd_wdata[63:0];\n', '\n', '   // AXI Request signals\n', '   assign sb_axi_awvalid              = sb_abmem_cmd_awvalid | sb_cmd_awvalid;\n', '   assign sb_axi_awaddr[31:0]         = sb_axi_addr[31:0];\n', ""   assign sb_axi_awid[SB_BUS_TAG-1:0] = '0;\n"", '   assign sb_axi_awsize[2:0]          = sb_axi_size[2:0];\n', ""   assign sb_axi_awprot[2:0]          = '0;\n"", ""   assign sb_axi_awcache[3:0]         = 4'b1111;\n"", '   assign sb_axi_awregion[3:0]        = sb_axi_addr[31:28];\n', ""   assign sb_axi_awlen[7:0]           = '0;\n"", ""   assign sb_axi_awburst[1:0]         = 2'b01;\n"", ""   assign sb_axi_awqos[3:0]           = '0;\n"", ""   assign sb_axi_awlock               = '0;\n"", '\n', '   assign sb_axi_wvalid       = sb_abmem_cmd_wvalid | sb_cmd_wvalid;\n', ""   assign sb_axi_wdata[63:0]  = ({64{(sb_axi_size[2:0] == 3'h0)}} & {8{sb_axi_wrdata[7:0]}}) |\n"", ""                                ({64{(sb_axi_size[2:0] == 3'h1)}} & {4{sb_axi_wrdata[15:0]}}) |\n"", ""                                ({64{(sb_axi_size[2:0] == 3'h2)}} & {2{sb_axi_wrdata[31:0]}}) |\n"", ""                                ({64{(sb_axi_size[2:0] == 3'h3)}} & {sb_axi_wrdata[63:0]});\n"", ""   assign sb_axi_wstrb[7:0]   = ({8{(sb_axi_size[2:0] == 3'h0)}} & (8'h1 << sb_axi_addr[2:0])) |\n"", ""                                ({8{(sb_axi_size[2:0] == 3'h1)}} & (8'h3 << {sb_axi_addr[2:1],1'b0})) |\n"", ""                                ({8{(sb_axi_size[2:0] == 3'h2)}} & (8'hf << {sb_axi_addr[2],2'b0})) |\n"", ""                                ({8{(sb_axi_size[2:0] == 3'h3)}} & 8'hff);\n"", ""   assign sb_axi_wlast        = '1;\n"", '\n', '   assign sb_axi_arvalid              = sb_abmem_cmd_arvalid | sb_cmd_arvalid;\n', '   assign sb_axi_araddr[31:0]         = sb_axi_addr[31:0];\n', ""   assign sb_axi_arid[SB_BUS_TAG-1:0] = '0;\n"", '   assign sb_axi_arsize[2:0]          = sb_axi_size[2:0];\n', ""   assign sb_axi_arprot[2:0]          = '0;\n"", ""   assign sb_axi_arcache[3:0]         = 4'b0;\n"", '   assign sb_axi_arregion[3:0]        = sb_axi_addr[31:28];\n', ""   assign sb_axi_arlen[7:0]           = '0;\n"", ""   assign sb_axi_arburst[1:0]         = 2'b01;\n"", ""   assign sb_axi_arqos[3:0]           = '0;\n"", ""   assign sb_axi_arlock               = '0;\n"", '\n', '   // AXI Response signals\n', ""   assign sb_axi_bready = 1'b1;\n"", '\n', ""   assign sb_axi_rready = 1'b1;\n"", ""   assign sb_bus_rdata[63:0] = ({64{sb_axi_size == 3'h0}} & ((sb_axi_rdata[63:0] >>  8*sb_axi_addr[2:0]) & 64'hff))       |\n"", ""                               ({64{sb_axi_size == 3'h1}} & ((sb_axi_rdata[63:0] >> 16*sb_axi_addr[2:1]) & 64'hffff))    |\n"", ""                               ({64{sb_axi_size == 3'h2}} & ((sb_axi_rdata[63:0] >> 32*sb_axi_addr[2]) & 64'hffff_ffff)) |\n"", ""                               ({64{sb_axi_size == 3'h3}} & sb_axi_rdata[63:0]);\n"", '\n', '`ifdef ASSERT_ON\n', '// assertion.\n', '//  when the resume_ack is asserted then the dec_tlu_dbg_halted should be 0\n', '   dm_check_resume_and_halted: assert property (@(posedge clk)  disable iff(~rst_l) (~dec_tlu_resume_ack | ~dec_tlu_dbg_halted));\n', '`endif\n', 'endmodule\n']"
"['// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '\n', '// dec: decode unit - decode, bypassing, ARF, interrupts\n', '//\n', '//********************************************************************************\n', '// $Id$\n', '//\n', '//\n', '// Function: Decode\n', '// Comments: Decode, dependency scoreboard, ARF\n', '//\n', '//\n', '// A -> D -> EX1 ... WB\n', '//\n', '//********************************************************************************\n', '\n', 'module dec\n', '   import veer_types::*;\n', '(\n', '   input logic clk,\n', '   input logic free_clk,\n', '   input logic active_clk,\n', '\n', '\n', '   output logic       dec_pause_state_cg,           // pause state for clock-gating\n', '\n', '   input logic rst_l,                        // reset, active low\n', '   input logic [31:1] rst_vec,               // reset vector, from core pins\n', '\n', '   input logic        nmi_int,               // NMI pin\n', '   input logic [31:1] nmi_vec,               // NMI vector, from pins\n', '\n', '   input logic  i_cpu_halt_req,              // Asynchronous Halt request to CPU\n', '   input logic  i_cpu_run_req,               // Asynchronous Restart request to CPU\n', '\n', '   output logic o_cpu_halt_status,           // Halt status of core (pmu/fw)\n', '   output logic o_cpu_halt_ack,              // Halt request ack\n', '   output logic o_cpu_run_ack,               // Run request ack\n', '   output logic o_debug_mode_status,         // Core to the PMU that core is in debug mode. When core is in debug mode, the PMU should refrain from sendng a halt or run request\n', '\n', '   // external MPC halt/run interface\n', '   input logic mpc_debug_halt_req, // Async halt request\n', '   input logic mpc_debug_run_req, // Async run request\n', '   input logic mpc_reset_run_req, // Run/halt after reset\n', '   output logic mpc_debug_halt_ack, // Halt ack\n', '   output logic mpc_debug_run_ack, // Run ack\n', '   output logic debug_brkpt_status, // debug breakpoint\n', '\n', '\n', '   output logic dec_ib0_valid_eff_d,         // effective valid taking decode into account\n', '   output logic dec_ib1_valid_eff_d,\n', '\n', '   input logic       exu_pmu_i0_br_misp,     // slot 0 branch misp\n', '   input logic       exu_pmu_i0_br_ataken,   // slot 0 branch actual taken\n', '   input logic       exu_pmu_i0_pc4,         // slot 0 4 byte branch\n', '   input logic       exu_pmu_i1_br_misp,     // slot 1 branch misp\n', '   input logic       exu_pmu_i1_br_ataken,   // slot 1 branch actual taken\n', '   input logic       exu_pmu_i1_pc4,         // slot 1 4 byte branch\n', '\n', '\n', '   input logic                                 lsu_nonblock_load_valid_dc3,      // valid nonblock load at dc3\n', '   input logic [`RV_LSU_NUM_NBLOAD_WIDTH-1:0]  lsu_nonblock_load_tag_dc3,        // -> corresponding tag\n', '   input logic                                 lsu_nonblock_load_inv_dc5,        // invalidate request for nonblock load dc5\n', '   input logic [`RV_LSU_NUM_NBLOAD_WIDTH-1:0]  lsu_nonblock_load_inv_tag_dc5,    // -> corresponding tag\n', '   input logic                                 lsu_nonblock_load_data_valid,     // valid nonblock load data back\n', '   input logic                                 lsu_nonblock_load_data_error,     // nonblock load bus error\n', '   input logic [`RV_LSU_NUM_NBLOAD_WIDTH-1:0]  lsu_nonblock_load_data_tag,       // -> corresponding tag\n', '   input logic [31:0]                          lsu_nonblock_load_data,           // nonblock load data\n', '\n', '   input logic       lsu_pmu_bus_trxn,       // D side bus transaction\n', '   input logic       lsu_pmu_bus_misaligned, // D side bus misaligned\n', '   input logic       lsu_pmu_bus_error,      // D side bus error\n', '   input logic       lsu_pmu_bus_busy,       // D side bus busy\n', '   input logic       lsu_pmu_misaligned_dc3, // D side load or store misaligned\n', '\n', '   input logic [1:0] ifu_pmu_instr_aligned,  // aligned instructions\n', '   input logic       ifu_pmu_align_stall,    // aligner stalled\n', '   input logic       ifu_pmu_fetch_stall,    // fetch unit stalled\n', '   input logic       ifu_pmu_ic_miss,        // icache miss\n', '   input logic       ifu_pmu_ic_hit,         // icache hit\n', '   input logic       ifu_pmu_bus_error,      // Instruction side bus error\n', '   input logic       ifu_pmu_bus_busy,       // Instruction side bus busy\n', '   input logic       ifu_pmu_bus_trxn,       // Instruction side bus transaction\n', '\n', '   input logic [3:0]  lsu_trigger_match_dc3,\n', '   input logic        dbg_cmd_valid,   // debugger abstract command valid\n', '   input logic  [1:0] dbg_cmd_size,    // size of the abstract mem access debug command\n', '   input logic        dbg_cmd_write,   // command is a write\n', '   input logic  [1:0] dbg_cmd_type,    // command type\n', '   input logic [31:0] dbg_cmd_addr,    // command address\n', '   input logic  [1:0] dbg_cmd_wrdata,  // command write data, for fence/fence_i\n', '\n', '\n', '   input logic   ifu_i0_icaf,          // icache access fault\n', '   input logic   ifu_i1_icaf,\n', '   input logic   ifu_i0_icaf_second,       // i0 has access fault on second 2B of 4B inst\n', '   input logic   ifu_i1_icaf_second,\n', '   input logic   ifu_i0_perr,          // icache parity error\n', '   input logic   ifu_i1_perr,\n', '   input logic   ifu_i0_sbecc,         // icache/iccm single-bit error\n', '   input logic   ifu_i1_sbecc,\n', '   input logic   ifu_i0_dbecc,         // icache/iccm double-bit error\n', '   input logic   ifu_i1_dbecc,\n', '\n', '   input logic lsu_freeze_dc3,         // freeze pipe: decode -> dc3\n', '   input logic lsu_idle_any,      // lsu idle for fence instructions\n', '   input logic lsu_halt_idle_any,      // lsu idle for halting\n', '\n', '   input br_pkt_t i0_brp,              // branch packet\n', '   input br_pkt_t i1_brp,\n', '\n', '   input    lsu_error_pkt_t lsu_error_pkt_dc3, // LSU exception/error packet\n', '   input logic         lsu_single_ecc_error_incr,    // Increment the counter for Single ECC error\n', '\n', ""   input logic lsu_load_ecc_stbuf_full_dc3,    // STBUF full, ecc errors should be rfpc'd\n"", '\n', '   input logic         lsu_imprecise_error_load_any,   // LSU imprecise load bus error\n', '   input logic         lsu_imprecise_error_store_any,  // LSU imprecise store bus error\n', '   input logic [31:0]  lsu_imprecise_error_addr_any,   // LSU imprecise bus error address\n', '   input logic         lsu_freeze_external_ints_dc3,   // load to side effect region\n', '\n', '   input logic exu_i0_flush_lower_e4,       // slot 0 flush for mp\n', '   input logic exu_i1_flush_lower_e4,       // slot 1 flush for mp\n', '   input logic [31:1] exu_i0_flush_path_e4, // slot 0 flush target for mp\n', '   input logic [31:1] exu_i1_flush_path_e4, // slot 1 flush target for mp\n', '\n', '   input logic [15:0] ifu_illegal_inst,     // 16b opcode for illegal inst\n', '\n', '   input logic exu_div_stall,               // stall decode for div executing\n', '   input logic [31:0]  exu_div_result,      // final div result\n', '   input logic exu_div_finish,              // cycle div finishes\n', '\n', '   input logic [31:0] exu_mul_result_e3,    // 32b mul result\n', '\n', '   input logic [31:0] exu_csr_rs1_e1,       // rs1 for csr instruction\n', '\n', '   input logic [31:0] lsu_result_dc3,       // load result\n', '   input logic [31:0] lsu_result_corr_dc4, // corrected load result\n', '\n', '   input logic        lsu_load_stall_any,   // This is for blocking loads\n', '   input logic        lsu_store_stall_any,  // This is for blocking stores\n', '   input logic        dma_dccm_stall_any,   // stall any load/store at decode, pmu event\n', '   input logic        dma_iccm_stall_any,   // iccm stalled, pmu event\n', '\n', '   input logic       iccm_dma_sb_error,     // ICCM DMA single bit error\n', '\n', '   input logic        dma_mem_dccm_req,\n', '\n', '   input logic exu_i0_flush_final,          // slot0 flush\n', '   input logic exu_i1_flush_final,          // slot1 flush\n', '\n', '   input logic [31:1] exu_npc_e4,           // next PC\n', '\n', '   input logic exu_flush_final,             // final flush\n', '\n', '   input logic [31:0] exu_i0_result_e1,     // alu result e1\n', '   input logic [31:0] exu_i1_result_e1,\n', '\n', '   input logic [31:0] exu_i0_result_e4,     // alu result e4\n', '   input logic [31:0] exu_i1_result_e4,\n', '\n', '\n', '   input logic         ifu_i0_valid, ifu_i1_valid,    // fetch valids to instruction buffer\n', ""   input logic [31:0]  ifu_i0_instr, ifu_i1_instr,    // fetch inst's to instruction buffer\n"", ""   input logic [31:1]  ifu_i0_pc, ifu_i1_pc,          // pc's for instruction buffer\n"", '   input logic         ifu_i0_pc4, ifu_i1_pc4,        // indication of 4B or 2B for corresponding inst\n', ""   input logic  [31:1] exu_i0_pc_e1,                  // pc's for e1 from the alu's\n"", '   input logic  [31:1] exu_i1_pc_e1,\n', '\n', '   input logic mexintpend,                            // External interrupt pending\n', '   input logic timer_int,                             // Timer interrupt pending (from pin)\n', '\n', '   input logic [7:0] pic_claimid,                     // PIC claimid\n', '   input logic [3:0] pic_pl,                          // PIC priv level\n', '   input logic       mhwakeup,                        // High priority wakeup\n', '\n', '   output logic [3:0] dec_tlu_meicurpl,               // to PIC, Current priv level\n', '   output logic [3:0] dec_tlu_meipt,                  // to PIC\n', '\n', '`ifdef RV_ICACHE_ECC\n', '   input logic [41:0] ifu_ic_debug_rd_data,           // diagnostic icache read data\n', '`else\n', '   input logic [33:0] ifu_ic_debug_rd_data,           // diagnostic icache read data\n', '`endif\n', '   input logic ifu_ic_debug_rd_data_valid,            // diagnostic icache read data valid\n', '   output cache_debug_pkt_t dec_tlu_ic_diag_pkt,      // packet of DICAWICS, DICAD0/1, DICAGO info for icache diagnostics\n', '\n', '\n', '// Debug start\n', '   input logic dbg_halt_req,                 // DM requests a halt\n', '   input logic dbg_resume_req,               // DM requests a resume\n', '   input logic ifu_miss_state_idle,          // I-side miss buffer empty\n', '\n', '  output logic dec_tlu_flush_noredir_wb ,    // Tell fetch to idle on this flush\n', '   output logic dec_tlu_mpc_halted_only, // Core is halted only due to MPC\n', '   output logic dec_tlu_dbg_halted,          // Core is halted and ready for debug command\n', '   output logic dec_tlu_pmu_fw_halted,       // Core is halted due to Power management unit or firmware halt\n', '   output logic dec_tlu_debug_mode,          // Core is in debug mode\n', '   output logic dec_tlu_resume_ack,          // Resume acknowledge\n', '   output logic dec_tlu_flush_leak_one_wb,   // single step\n', '   output logic dec_tlu_flush_err_wb,        // iside perr/ecc rfpc\n', ""   output logic dec_tlu_stall_dma,           // stall dma access when there's a halt request\n"", '\n', '   output logic dec_debug_wdata_rs1_d,       // insert debug write data into rs1 at decode\n', '\n', '   output logic [31:0] dec_dbg_rddata,       // debug command read data\n', '\n', '   output logic dec_dbg_cmd_done,            // abstract command is done\n', '   output logic dec_dbg_cmd_fail,            // abstract command failed (illegal reg address)\n', '\n', '   output trigger_pkt_t  [3:0] trigger_pkt_any, // info needed by debug trigger blocks\n', '\n', '// Debug end\n', '   // branch info from pipe0 for errors or counter updates\n', '   input logic [`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] exu_i0_br_index_e4, // index\n', '   input logic [1:0]  exu_i0_br_hist_e4,                             // history\n', '   input logic [1:0]  exu_i0_br_bank_e4,                             // bank\n', '   input logic        exu_i0_br_error_e4,                            // error\n', '   input logic        exu_i0_br_start_error_e4,                      // start error\n', '   input logic        exu_i0_br_valid_e4,                            // valid\n', '   input logic        exu_i0_br_mp_e4,                               // mispredict\n', '   input logic        exu_i0_br_middle_e4,                           // middle of bank\n', '   input logic [`RV_BHT_GHR_RANGE]  exu_i0_br_fghr_e4,               // FGHR when predicted\n', '\n', '   // branch info from pipe1 for errors or counter updates\n', '   input logic [`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] exu_i1_br_index_e4, // index\n', '   input logic [1:0]  exu_i1_br_hist_e4,                             // history\n', '   input logic [1:0]  exu_i1_br_bank_e4,                             // bank\n', '   input logic        exu_i1_br_error_e4,                            // error\n', '   input logic        exu_i1_br_start_error_e4,                      // start error\n', '   input logic        exu_i1_br_valid_e4,                            // valid\n', '   input logic        exu_i1_br_mp_e4,                               // mispredict\n', '   input logic        exu_i1_br_middle_e4,                           // middle of bank\n', '   input logic [`RV_BHT_GHR_RANGE]  exu_i1_br_fghr_e4,               // FGHR when predicted\n', '\n', '\n', '`ifdef RV_BTB_48\n', '   input logic [1:0]       exu_i1_br_way_e4,        // way hit or repl\n', '   input logic [1:0]       exu_i0_br_way_e4,        // way hit or repl\n', '`else\n', '   input logic        exu_i1_br_way_e4,             // way hit or repl\n', '   input logic        exu_i0_br_way_e4,             // way hit or repl\n', '`endif\n', '\n', '   output logic  [31:0] gpr_i0_rs1_d,               // gpr rs1 data\n', '   output logic  [31:0] gpr_i0_rs2_d,               // gpr rs2 data\n', '   output logic  [31:0] gpr_i1_rs1_d,\n', '   output logic  [31:0] gpr_i1_rs2_d,\n', '\n', '   output logic [31:0] dec_i0_immed_d,              // immediate data\n', '   output logic [31:0] dec_i1_immed_d,\n', '\n', '   output logic [12:1] dec_i0_br_immed_d,           // br immediate data\n', '   output logic [12:1] dec_i1_br_immed_d,\n', '\n', '   output        alu_pkt_t i0_ap,                   // alu packet\n', '   output        alu_pkt_t i1_ap,\n', '\n', '   output logic          dec_i0_alu_decode_d,       // alu schedule on primary alu\n', '   output logic          dec_i1_alu_decode_d,\n', '\n', ""   output logic          dec_i0_select_pc_d,        // select pc onto rs1 for jal's\n"", '   output logic          dec_i1_select_pc_d,\n', '\n', ""   output logic [31:1] dec_i0_pc_d, dec_i1_pc_d,    // pc's at decode\n"", '   output logic         dec_i0_rs1_bypass_en_d,     // rs1 bypass enable\n', '   output logic         dec_i0_rs2_bypass_en_d,     // rs2 bypass enable\n', '   output logic         dec_i1_rs1_bypass_en_d,\n', '   output logic         dec_i1_rs2_bypass_en_d,\n', '\n', '   output logic [31:0] i0_rs1_bypass_data_d,       // rs1 bypass data\n', '   output logic [31:0] i0_rs2_bypass_data_d,       // rs2 bypass data\n', '   output logic [31:0] i1_rs1_bypass_data_d,\n', '   output logic [31:0] i1_rs2_bypass_data_d,\n', '   output logic         dec_ib3_valid_d,           // ib3 buffer valid\n', '   output logic         dec_ib2_valid_d,           // ib2 buffer valid\n', '\n', '   output lsu_pkt_t    lsu_p,                      // lsu packet\n', '   output mul_pkt_t    mul_p,                      // mul packet\n', '   output div_pkt_t    div_p,                      // div packet\n', '\n', '   output logic [11:0] dec_lsu_offset_d,           // 12b offset for load/store addresses\n', '   output logic        dec_i0_lsu_d,               // is load/store\n', '   output logic        dec_i1_lsu_d,\n', '\n', '   output logic        flush_final_e3,             // final flush\n', '   output logic        i0_flush_final_e3,          // final flush from i0\n', '\n', '   output logic        dec_csr_ren_d,              // csr read enable\n', '\n', '   output logic        dec_tlu_cancel_e4,          // Cancel lsu op at DC4 due to future trigger hit\n', '\n', '   output logic        dec_tlu_flush_lower_wb,     // tlu flush due to late mp, exception, rfpc, or int\n', '   output logic [31:1] dec_tlu_flush_path_wb,      // tlu flush target\n', ""   output logic        dec_tlu_i0_kill_writeb_wb,  // I0 is flushed, don't writeback any results to arch state\n"", ""   output logic        dec_tlu_i1_kill_writeb_wb,  // I1 is flushed, don't writeback any results to arch state\n"", '   output logic        dec_tlu_fence_i_wb,         // flush is a fence_i rfnpc, flush icache\n', '\n', '   output logic        dec_i0_mul_d,               // chose which gpr value to use\n', '   output logic        dec_i1_mul_d,\n', '   output logic        dec_i0_div_d,               // chose which gpr value to use\n', '   output logic        dec_i1_div_d,\n', '   output logic        dec_i1_valid_e1,            // i1 valid at e1 stage\n', '   output logic        dec_div_decode_e4,          // div at e4 stage\n', '   output logic [31:1] pred_correct_npc_e2,        // npc if prediction is correct at e2 stage\n', '\n', '   output logic        dec_i0_rs1_bypass_en_e3,    // rs1 bypass enable e3\n', '   output logic        dec_i0_rs2_bypass_en_e3,    // rs2 bypass enable e3\n', '   output logic        dec_i1_rs1_bypass_en_e3,\n', '   output logic        dec_i1_rs2_bypass_en_e3,\n', '   output logic [31:0] i0_rs1_bypass_data_e3,      // rs1 bypass data e3\n', '   output logic [31:0] i0_rs2_bypass_data_e3,      // rs2 bypass data e3\n', '   output logic [31:0] i1_rs1_bypass_data_e3,\n', '   output logic [31:0] i1_rs2_bypass_data_e3,\n', '   output logic        dec_i0_sec_decode_e3,       // secondary decode e3\n', '   output logic        dec_i1_sec_decode_e3,\n', '   output logic [31:1] dec_i0_pc_e3,               // pc at e3\n', '   output logic [31:1] dec_i1_pc_e3,\n', '\n', '   output logic        dec_i0_rs1_bypass_en_e2,    // rs1 bypass enable e2\n', '   output logic        dec_i0_rs2_bypass_en_e2,    // rs2 bypass enable e2\n', '   output logic        dec_i1_rs1_bypass_en_e2,\n', '   output logic        dec_i1_rs2_bypass_en_e2,\n', '   output logic [31:0] i0_rs1_bypass_data_e2,      // rs1 bypass data e2\n', '   output logic [31:0] i0_rs2_bypass_data_e2,      // rs2 bypass data e2\n', '   output logic [31:0] i1_rs1_bypass_data_e2,\n', '   output logic [31:0] i1_rs2_bypass_data_e2,\n', '\n', '   output br_tlu_pkt_t dec_tlu_br0_wb_pkt,         // slot 0 branch predictor update packet\n', '   output br_tlu_pkt_t dec_tlu_br1_wb_pkt,         // slot 1 branch predictor update packet\n', '\n', '   output logic [1:0] dec_tlu_perfcnt0,                  // toggles when perf counter 0 has an event inc\n', '   output logic [1:0] dec_tlu_perfcnt1,                  // toggles when perf counter 1 has an event inc\n', '   output logic [1:0] dec_tlu_perfcnt2,                  // toggles when perf counter 2 has an event inc\n', '   output logic [1:0] dec_tlu_perfcnt3,                  // toggles when perf counter 3 has an event inc\n', '\n', '   output predict_pkt_t  i0_predict_p_d,           // prediction packet to alus\n', '   output predict_pkt_t  i1_predict_p_d,\n', '\n', '   output logic dec_i0_lsu_decode_d,               // load/store decode\n', '\n', '   output logic [31:0] i0_result_e4_eff,           // alu result e4\n', '   output logic [31:0] i1_result_e4_eff,\n', '\n', '   output   logic dec_tlu_i0_valid_e4,             // slot 0 instruction is valid at e4\n', '   output   logic dec_tlu_i1_valid_e4,             // slot 1 instruction is valid at e4, implies i0_valid_e4\n', '\n', '   output logic [31:0] i0_result_e2,               // i0 result data e2\n', '   output logic [31:0] dec_tlu_mrac_ff,            // CSR for memory region control\n', '\n', '   output logic [31:1] dec_tlu_i0_pc_e4,           // pc e4\n', '   output logic [31:1] dec_tlu_i1_pc_e4,\n', '\n', '   output logic [4:2] dec_i0_data_en,              // clock-gate control logic\n', '   output logic [4:1] dec_i0_ctl_en,\n', '   output logic [4:2] dec_i1_data_en,\n', '   output logic [4:1] dec_i1_ctl_en,\n', '\n', '   output logic       dec_nonblock_load_freeze_dc2,  // lsu must freeze nonblock load due to younger dependency in pipe\n', '\n', '   input logic [15:0] ifu_i0_cinst,                  // 16b compressed instruction\n', '   input logic [15:0] ifu_i1_cinst,\n', '\n', '   output trace_pkt_t  trace_rv_trace_pkt,             // trace packet\n', '\n', '   // feature disable from mfdc\n', '   output logic  dec_tlu_sideeffect_posted_disable,    // disable posted writes to side-effect address\n', '   output logic  dec_tlu_core_ecc_disable,           // disable core ECC\n', '   output logic  dec_tlu_sec_alu_disable,            // disable secondary ALU\n', '   output logic  dec_tlu_dccm_nonblock_dma_disable, // disable dma nonblock\n', '   output logic  dec_tlu_non_blocking_disable,       // disable non blocking loads\n', '   output logic  dec_tlu_fast_div_disable,           // disable fast divider\n', '   output logic  dec_tlu_bpred_disable,              // disable branch prediction\n', '   output logic  dec_tlu_wb_coalescing_disable,      // disable writebuffer coalescing\n', '   output logic  dec_tlu_ld_miss_byp_wb_disable,     // disable loads miss bypass write buffer\n', '   output logic [2:0]  dec_tlu_dma_qos_prty,         // DMA QoS priority coming from MFDC [18:16]\n', '\n', '   // clock gating overrides from mcgc\n', '   output logic  dec_tlu_misc_clk_override,          // override misc clock domain gating\n', '   output logic  dec_tlu_exu_clk_override,           // override exu clock domain gating\n', '   output logic  dec_tlu_ifu_clk_override,           // override fetch clock domain gating\n', '   output logic  dec_tlu_lsu_clk_override,           // override load/store clock domain gating\n', '   output logic  dec_tlu_bus_clk_override,           // override bus clock domain gating\n', '   output logic  dec_tlu_pic_clk_override,           // override PIC clock domain gating\n', '   output logic  dec_tlu_dccm_clk_override,          // override DCCM clock domain gating\n', '   output logic  dec_tlu_icm_clk_override,           // override ICCM clock domain gating\n', '\n', '   input  logic        scan_mode\n', '\n', '   );\n', '\n', '   localparam GPR_BANKS = 1;\n', '   localparam GPR_BANKS_LOG2 = (GPR_BANKS == 1) ? 1 : $clog2(GPR_BANKS);\n', '\n', '   logic  dec_tlu_dec_clk_override; // to and from dec blocks\n', '   logic  clk_override;\n', '\n', '   logic               dec_ib1_valid_d;\n', '   logic               dec_ib0_valid_d;\n', '\n', '   logic [1:0]         dec_pmu_instr_decoded;\n', '   logic               dec_pmu_decode_stall;\n', '   logic               dec_pmu_presync_stall;\n', '   logic               dec_pmu_postsync_stall;\n', '\n', '   logic dec_tlu_wr_pause_wb;           // CSR write to pause reg is at WB.\n', '\n', '   logic        dec_i0_rs1_en_d;\n', '   logic        dec_i0_rs2_en_d;\n', '   logic        dec_fence_pending; // tell TLU to stall DMA\n', '\n', '   logic [4:0]  dec_i0_rs1_d;\n', '   logic [4:0]  dec_i0_rs2_d;\n', '\n', '\n', '   logic        dec_i1_rs1_en_d;\n', '   logic        dec_i1_rs2_en_d;\n', '\n', '   logic [4:0]  dec_i1_rs1_d;\n', '   logic [4:0]  dec_i1_rs2_d;\n', '\n', '\n', '   logic [31:0] dec_i0_instr_d, dec_i1_instr_d;\n', '\n', '   logic  dec_tlu_pipelining_disable;\n', '   logic  dec_tlu_dual_issue_disable;\n', '\n', '\n', '   logic [4:0]  dec_i0_waddr_wb;\n', '   logic        dec_i0_wen_wb;\n', '   logic [31:0] dec_i0_wdata_wb;\n', '\n', '   logic [4:0]  dec_i1_waddr_wb;\n', '   logic        dec_i1_wen_wb;\n', '   logic [31:0] dec_i1_wdata_wb;\n', '\n', '   logic        dec_csr_wen_wb;      // csr write enable at wb\n', '   logic [11:0] dec_csr_rdaddr_d;      // read address for csr\n', '   logic [11:0] dec_csr_wraddr_wb;      // write address for csryes\n', '\n', '   logic [31:0] dec_csr_wrdata_wb;    // csr write data at wb\n', '\n', '   logic [31:0] dec_csr_rddata_d;    // csr read data at wb\n', '   logic        dec_csr_legal_d;            // csr indicates legal operation\n', '\n', '   logic        dec_csr_wen_unq_d;       // valid csr with write - for csr legal\n', '   logic        dec_csr_any_unq_d;       // valid csr - for csr legal\n', '   logic        dec_csr_stall_int_ff;    // csr is mie/mstatus\n', '\n', '\n', '\n', '   trap_pkt_t dec_tlu_packet_e4;\n', '\n', '   logic        dec_i0_pc4_d, dec_i1_pc4_d;\n', '   logic        dec_tlu_presync_d;\n', '   logic        dec_tlu_postsync_d;\n', '   logic        dec_tlu_debug_stall;\n', '\n', '   logic [31:0] dec_illegal_inst;\n', '\n', '\n', '   // GPR Bank ID write signals\n', '   logic                      wen_bank_id;\n', '   logic [GPR_BANKS_LOG2-1:0] wr_bank_id;\n', '\n', '   logic                      dec_i0_icaf_d;\n', '   logic                      dec_i1_icaf_d;\n', '   logic                      dec_i0_perr_d;\n', '   logic                      dec_i1_perr_d;\n', '   logic                      dec_i0_sbecc_d;\n', '   logic                      dec_i1_sbecc_d;\n', '   logic                      dec_i0_dbecc_d;\n', '   logic                      dec_i1_dbecc_d;\n', '\n', '   logic                      dec_i0_icaf_second_d;\n', '\n', '   logic                      dec_i0_decode_d;\n', '   logic                      dec_i1_decode_d;\n', '\n', '   logic [3:0]                dec_i0_trigger_match_d;\n', '   logic [3:0]                dec_i1_trigger_match_d;\n', '\n', '\n', '   logic                      dec_debug_fence_d;\n', '\n', '   logic                      dec_nonblock_load_wen;\n', '   logic [4:0]                dec_nonblock_load_waddr;\n', '   logic                      dec_tlu_flush_pause_wb;\n', '\n', '   logic                      dec_i0_load_e4;\n', '\n', '   logic                      dec_pause_state;\n', '\n', '   br_pkt_t dec_i0_brp;\n', '   br_pkt_t dec_i1_brp;\n', '\n', '   assign clk_override = dec_tlu_dec_clk_override;\n', '\n', '\n', '   assign dec_dbg_rddata[31:0] = dec_i0_wdata_wb[31:0];\n', '\n', '   // Temp hookups\n', ""   assign wen_bank_id = '0;\n"", ""   assign wr_bank_id  = '0;\n"", '\n', '\n', '\n', '   dec_gpr_ctl #(.GPR_BANKS(GPR_BANKS),\n', '                 .GPR_BANKS_LOG2(GPR_BANKS_LOG2)) arf (.*,\n', '                    // inputs\n', '                    .raddr0(dec_i0_rs1_d[4:0]), .rden0(dec_i0_rs1_en_d),\n', '                    .raddr1(dec_i0_rs2_d[4:0]), .rden1(dec_i0_rs2_en_d),\n', '                    .raddr2(dec_i1_rs1_d[4:0]), .rden2(dec_i1_rs1_en_d),\n', '                    .raddr3(dec_i1_rs2_d[4:0]), .rden3(dec_i1_rs2_en_d),\n', '\n', '                    .waddr0(dec_i0_waddr_wb[4:0]),         .wen0(dec_i0_wen_wb),         .wd0(dec_i0_wdata_wb[31:0]),\n', '                    .waddr1(dec_i1_waddr_wb[4:0]),         .wen1(dec_i1_wen_wb),         .wd1(dec_i1_wdata_wb[31:0]),\n', '                    .waddr2(dec_nonblock_load_waddr[4:0]), .wen2(dec_nonblock_load_wen), .wd2(lsu_nonblock_load_data[31:0]),\n', '\n', '                    // outputs\n', '                    .rd0(gpr_i0_rs1_d[31:0]), .rd1(gpr_i0_rs2_d[31:0]),\n', '                    .rd2(gpr_i1_rs1_d[31:0]), .rd3(gpr_i1_rs2_d[31:0])\n', '                    );\n', '\n', '// Trigger\n', '\n', '   dec_trigger dec_trigger (.*);\n', '\n', '\n', '\n', '\n', '\n', '// trace\n', '   logic [15:0] dec_i0_cinst_d;\n', '   logic [15:0] dec_i1_cinst_d;\n', '   logic [31:0]               dec_i0_inst_wb1;\n', '   logic [31:0]               dec_i1_inst_wb1;\n', '   logic [31:1]               dec_i0_pc_wb1;\n', '   logic [31:1]               dec_i1_pc_wb1;\n', '   logic dec_tlu_i1_valid_wb1, dec_tlu_i0_valid_wb1,  dec_tlu_int_valid_wb1;\n', '   logic [4:0] dec_tlu_exc_cause_wb1;\n', '   logic [31:0] dec_tlu_mtval_wb1;\n', '\n', '   logic        dec_tlu_i0_exc_valid_wb1, dec_tlu_i1_exc_valid_wb1;\n', '\n', '   // also need retires_p==3\n', '\n', ""   assign trace_rv_trace_pkt.trace_rv_i_insn_ip    = { 32'b0, dec_i1_inst_wb1[31:0], dec_i0_inst_wb1[31:0] };\n"", ""   assign trace_rv_trace_pkt.trace_rv_i_address_ip = { 32'b0, dec_i1_pc_wb1[31:1], 1'b0, dec_i0_pc_wb1[31:1], 1'b0 };\n"", '\n', '   assign trace_rv_trace_pkt.trace_rv_i_valid_ip =     {dec_tlu_int_valid_wb1,   // always int\n', '                                                    dec_tlu_i1_valid_wb1 | dec_tlu_i1_exc_valid_wb1,  // not interrupts\n', '                                                    dec_tlu_i0_valid_wb1 | dec_tlu_i0_exc_valid_wb1\n', '                                                    };\n', '   assign trace_rv_trace_pkt.trace_rv_i_exception_ip = {dec_tlu_int_valid_wb1, dec_tlu_i1_exc_valid_wb1, dec_tlu_i0_exc_valid_wb1};\n', '   assign trace_rv_trace_pkt.trace_rv_i_ecause_ip =     dec_tlu_exc_cause_wb1[4:0];  // replicate across ports\n', ""   assign trace_rv_trace_pkt.trace_rv_i_interrupt_ip = {dec_tlu_int_valid_wb1,2'b0};\n"", '   assign trace_rv_trace_pkt.trace_rv_i_tval_ip =    dec_tlu_mtval_wb1[31:0];        // replicate across ports\n', '\n', '   dec_ib_ctl instbuff (.*\n', '                        );\n', '\n', '   dec_decode_ctl decode (.*);\n', '\n', '   dec_tlu_ctl tlu (.*);\n', '\n', '\n', '// end trace\n', '\n', 'endmodule // dec\n', '\n']"
"['// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '\n', '\n', 'module dec_decode_ctl\n', '   import veer_types::*;\n', '(\n', '   input logic [15:0] dec_i0_cinst_d,         // 16b compressed instruction\n', '   input logic [15:0] dec_i1_cinst_d,\n', '\n', '   output logic [31:0] dec_i0_inst_wb1,       // 32b instruction at wb+1 for trace encoder\n', '   output logic [31:0] dec_i1_inst_wb1,\n', '\n', '   output logic [31:1] dec_i0_pc_wb1,         // 31b pc at wb+1 for trace encoder\n', '   output logic [31:1] dec_i1_pc_wb1,\n', '\n', '\n', '   input logic                                lsu_nonblock_load_valid_dc3,     // valid nonblock load at dc3\n', '   input logic [`RV_LSU_NUM_NBLOAD_WIDTH-1:0] lsu_nonblock_load_tag_dc3,       // -> corresponding tag\n', '   input logic                                lsu_nonblock_load_inv_dc5,       // invalidate request for nonblock load dc5\n', '   input logic [`RV_LSU_NUM_NBLOAD_WIDTH-1:0] lsu_nonblock_load_inv_tag_dc5,   // -> corresponding tag\n', '   input logic                                lsu_nonblock_load_data_valid,    // valid nonblock load data back\n', '   input logic                                lsu_nonblock_load_data_error,    // nonblock load bus error\n', '   input logic [`RV_LSU_NUM_NBLOAD_WIDTH-1:0] lsu_nonblock_load_data_tag,      // -> corresponding tag\n', '\n', '   input logic [3:0] dec_i0_trigger_match_d,          // i0 decode trigger matches\n', '   input logic [3:0] dec_i1_trigger_match_d,          // i1 decode trigger matches\n', '\n', '   input logic dec_tlu_wr_pause_wb,                   // pause instruction at wb\n', '   input logic dec_tlu_pipelining_disable,            // pipeline disable - presync, i0 decode only\n', '   input logic dec_tlu_dual_issue_disable,            // i0 decode only\n', '\n', '   input logic dec_tlu_sec_alu_disable,               // no alu ops sent to secondary alus\n', '\n', '   input logic [3:0]  lsu_trigger_match_dc3,          // lsu trigger matches\n', '\n', '   input logic lsu_pmu_misaligned_dc3,                // perf mon: load/store misalign\n', '   input logic dec_tlu_debug_stall,                   // debug stall decode\n', '   input logic dec_tlu_flush_leak_one_wb,             // leak1 instruction\n', '\n', '   input logic dec_debug_fence_d,                     // debug fence instruction\n', '\n', '   input logic [1:0] dbg_cmd_wrdata,                  // disambiguate fence, fence_i\n', '\n', '   input logic dec_i0_icaf_d,                         // icache access fault\n', '   input logic dec_i1_icaf_d,\n', '   input logic dec_i0_icaf_second_d,                      // i0 instruction access fault on second 2B of 4B inst\n', '   input logic dec_i0_perr_d,                         // icache parity error\n', '   input logic dec_i1_perr_d,\n', '   input logic dec_i0_sbecc_d,                        // icache/iccm single-bit error\n', '   input logic dec_i1_sbecc_d,\n', '   input logic dec_i0_dbecc_d,                        // icache/iccm double-bit error\n', '   input logic dec_i1_dbecc_d,\n', '\n', '   input br_pkt_t dec_i0_brp,                         // branch packet\n', '   input br_pkt_t dec_i1_brp,\n', '\n', '   input logic [15:0] ifu_illegal_inst,               // 16b illegal inst from aligner\n', '\n', '   input logic [31:1] dec_i0_pc_d,                    // pc\n', '\n', '   input logic lsu_freeze_dc3,                        // freeze pipe: decode -> dc3\n', '   input logic lsu_halt_idle_any,                     // lsu idle: if fence instr & ~lsu_halt_idle_any then stall decode\n', '\n', '   input logic lsu_load_stall_any,                    // stall any store at load\n', '   input logic lsu_store_stall_any,                   // stall any store at decode\n', '   input logic dma_dccm_stall_any,                    // stall any load/store at decode\n', '\n', '   input logic exu_div_finish,                        // div finish this cycle\n', '   input logic exu_div_stall,                         // div executing: stall decode\n', '   input logic [31:0] exu_div_result,                 // div result\n', '\n', ""   input logic dec_tlu_i0_kill_writeb_wb,    // I0 is flushed, don't writeback any results to arch state\n"", ""   input logic dec_tlu_i1_kill_writeb_wb,    // I1 is flushed, don't writeback any results to arch state\n"", '\n', '   input logic dec_tlu_flush_lower_wb,          // trap lower flush\n', ""   input logic dec_tlu_flush_pause_wb,          // don't clear pause state on initial lower flush\n"", ""   input logic dec_tlu_presync_d,               // CSR read needs to be presync'd\n"", ""   input logic dec_tlu_postsync_d,              // CSR ops that need to be postsync'd\n"", '\n', '   input logic [31:0] exu_mul_result_e3,        // multiply result\n', '\n', '   input logic dec_i0_pc4_d,               // inst is 4B inst else 2B\n', '   input logic dec_i1_pc4_d,\n', '\n', '   input logic [31:0] dec_csr_rddata_d,    // csr read data at wb\n', '   input logic dec_csr_legal_d,            // csr indicates legal operation\n', '\n', '   input logic [31:0] exu_csr_rs1_e1,      // rs1 for csr instr\n', '\n', '   input logic [31:0] lsu_result_dc3,      // load result\n', '   input logic [31:0] lsu_result_corr_dc4, // corrected load result\n', '\n', '   input logic exu_i0_flush_final,         // lower flush or i0 flush at e2\n', '   input logic exu_i1_flush_final,         // lower flush or i1 flush at e2\n', '\n', '   input logic [31:1] exu_i0_pc_e1,        // pcs at e1\n', '   input logic [31:1] exu_i1_pc_e1,\n', '\n', '   input logic [31:0] dec_i0_instr_d,      // inst at decode\n', '   input logic [31:0] dec_i1_instr_d,\n', '\n', '   input logic  dec_ib0_valid_d,          // inst valid at decode\n', '   input logic  dec_ib1_valid_d,\n', '\n', ""   input logic [31:0] exu_i0_result_e1,    // from primary alu's\n"", '   input logic [31:0] exu_i1_result_e1,\n', '\n', ""   input logic [31:0] exu_i0_result_e4,    // from secondary alu's\n"", '   input logic [31:0] exu_i1_result_e4,\n', '\n', ""   input logic  clk,                       // for rvdffe's\n"", '   input logic  active_clk,                // clk except for halt / pause\n', '   input logic  free_clk,                  // free running clock\n', '\n', '   input logic  clk_override,              // test stuff\n', '   input logic  rst_l,\n', '\n', '\n', '   output logic         dec_i0_rs1_en_d,   // rs1 enable at decode\n', '   output logic         dec_i0_rs2_en_d,\n', '\n', '   output logic [4:0] dec_i0_rs1_d,        // rs1 logical source\n', '   output logic [4:0] dec_i0_rs2_d,\n', '\n', '\n', '\n', '   output logic [31:0] dec_i0_immed_d,     // 32b immediate data decode\n', '\n', '   output logic          dec_i1_rs1_en_d,\n', '   output logic          dec_i1_rs2_en_d,\n', '\n', '   output logic [4:0]  dec_i1_rs1_d,\n', '   output logic [4:0]  dec_i1_rs2_d,\n', '\n', '\n', '\n', '   output logic [31:0] dec_i1_immed_d,\n', '\n', '   output logic [12:1] dec_i0_br_immed_d,    // 12b branch immediate\n', '   output logic [12:1] dec_i1_br_immed_d,\n', '\n', '   output alu_pkt_t i0_ap,                   // alu packets\n', '   output alu_pkt_t i1_ap,\n', '\n', '   output logic          dec_i0_decode_d,    // i0 decode\n', '   output logic          dec_i1_decode_d,\n', '\n', '   output logic          dec_ib0_valid_eff_d,   // effective valid taking decode into account\n', '   output logic          dec_ib1_valid_eff_d,\n', '\n', ""   output logic          dec_i0_alu_decode_d,   // decode to primary alu's\n"", '   output logic          dec_i1_alu_decode_d,\n', '\n', '\n', '   output logic [31:0] i0_rs1_bypass_data_d,    // i0 rs1 bypass data\n', '   output logic [31:0] i0_rs2_bypass_data_d,    // i0 rs2 bypass data\n', '   output logic [31:0] i1_rs1_bypass_data_d,\n', '   output logic [31:0] i1_rs2_bypass_data_d,\n', '\n', '\n', ""   output logic [4:0]  dec_i0_waddr_wb,         // i0 logical source to write to gpr's\n"", '   output logic          dec_i0_wen_wb,         // i0 write enable\n', '   output logic [31:0] dec_i0_wdata_wb,         // i0 write data\n', '\n', '   output logic [4:0]  dec_i1_waddr_wb,\n', '   output logic          dec_i1_wen_wb,\n', '   output logic [31:0] dec_i1_wdata_wb,\n', '\n', '   output logic          dec_i0_select_pc_d,    // i0 select pc for rs1 - branches\n', '   output logic          dec_i1_select_pc_d,\n', '\n', '   output logic dec_i0_rs1_bypass_en_d,         // i0 rs1 bypass enable\n', '   output logic dec_i0_rs2_bypass_en_d,         // i0 rs2 bypass enable\n', '   output logic dec_i1_rs1_bypass_en_d,\n', '   output logic dec_i1_rs2_bypass_en_d,\n', '\n', '   output lsu_pkt_t    lsu_p,                   // load/store packet\n', '\n', '   output mul_pkt_t    mul_p,                   // multiply packet\n', '\n', '   output div_pkt_t    div_p,                   // divide packet\n', '\n', '   output logic [11:0] dec_lsu_offset_d,\n', '   output logic        dec_i0_lsu_d,        // chose which gpr value to use\n', '   output logic        dec_i1_lsu_d,\n', '   output logic        dec_i0_mul_d,        // chose which gpr value to use\n', '   output logic        dec_i1_mul_d,\n', '   output logic        dec_i0_div_d,        // chose which gpr value to use\n', '   output logic        dec_i1_div_d,\n', '\n', '   // review\n', '   output logic        flush_final_e3,      // flush final at e3: i0  or i1\n', '   output logic        i0_flush_final_e3,   // i0 flush final at e3\n', '\n', '   output logic        dec_csr_ren_d,       // valid csr decode\n', '   output logic        dec_csr_wen_unq_d,       // valid csr with write - for csr legal\n', '   output logic        dec_csr_any_unq_d,       // valid csr - for csr legal\n', '   output logic        dec_csr_wen_wb,      // csr write enable at wb\n', '   output logic [11:0] dec_csr_rdaddr_d,      // read address for csr\n', '   output logic [11:0] dec_csr_wraddr_wb,     // write address for csr\n', '   output logic [31:0] dec_csr_wrdata_wb,   // csr write data at wb\n', '   output logic        dec_csr_stall_int_ff, // csr is mie/mstatus\n', '\n', '   output              dec_tlu_i0_valid_e4,  // i0 valid inst at e4\n', '   output              dec_tlu_i1_valid_e4,\n', '\n', '   output              trap_pkt_t dec_tlu_packet_e4,   // trap packet\n', '\n', '   output logic        dec_fence_pending, // tell TLU to stall DMA\n', '   output logic [31:1] dec_tlu_i0_pc_e4,  // i0 trap pc\n', '   output logic [31:1] dec_tlu_i1_pc_e4,\n', '\n', '   output logic [31:0] dec_illegal_inst,        // illegal inst\n', '   output logic        dec_i1_valid_e1,         // i1 valid e1\n', '   output logic        dec_div_decode_e4,       // i0 div e4\n', '   output logic [31:1] pred_correct_npc_e2,     // npc e2 if the prediction is correct\n', '   output logic        dec_i0_rs1_bypass_en_e3, // i0 rs1 bypass enables e3\n', '   output logic        dec_i0_rs2_bypass_en_e3, // i1 rs1 bypass enables e3\n', '   output logic        dec_i1_rs1_bypass_en_e3,\n', '   output logic        dec_i1_rs2_bypass_en_e3,\n', '   output logic [31:0] i0_rs1_bypass_data_e3,   // i0 rs1 bypass data e3\n', '   output logic [31:0] i0_rs2_bypass_data_e3,   // i1 rs1 bypass data e3\n', '   output logic [31:0] i1_rs1_bypass_data_e3,\n', '   output logic [31:0] i1_rs2_bypass_data_e3,\n', '   output logic        dec_i0_sec_decode_e3,    // i0 secondary alu e3\n', '   output logic        dec_i1_sec_decode_e3,    // i1 secondary alu e3\n', '   output logic [31:1] dec_i0_pc_e3,            // i0 pc e3\n', '   output logic [31:1] dec_i1_pc_e3,            // i1 pc e3\n', '\n', '   output logic        dec_i0_rs1_bypass_en_e2, // i0 rs1 bypass enable e2\n', '   output logic        dec_i0_rs2_bypass_en_e2, // i0 rs2 bypass enable e2\n', '   output logic        dec_i1_rs1_bypass_en_e2,\n', '   output logic        dec_i1_rs2_bypass_en_e2,\n', '   output logic [31:0] i0_rs1_bypass_data_e2,   // i0 rs1 bypass data e2\n', '   output logic [31:0] i0_rs2_bypass_data_e2,   // i0 rs2 bypass data e2\n', '   output logic [31:0] i1_rs1_bypass_data_e2,\n', '   output logic [31:0] i1_rs2_bypass_data_e2,\n', '\n', '   output predict_pkt_t  i0_predict_p_d,        // i0 predict packet decode\n', '   output predict_pkt_t  i1_predict_p_d,\n', '\n', '   output logic          dec_i0_lsu_decode_d,   // i0 lsu decode\n', '\n', '   output logic [31:0] i0_result_e4_eff,        // i0 e4 result taking freeze into account\n', '   output logic [31:0] i1_result_e4_eff,\n', '   output logic [31:0] i0_result_e2,            // i0 result e2\n', '\n', '   output logic [4:2] dec_i0_data_en,           // clock-gating logic\n', '   output logic [4:1] dec_i0_ctl_en,\n', '   output logic [4:2] dec_i1_data_en,\n', '   output logic [4:1] dec_i1_ctl_en,\n', '\n', '   output logic [1:0] dec_pmu_instr_decoded,    // number of instructions decode this cycle encoded\n', '   output logic       dec_pmu_decode_stall,     // decode is stalled\n', '   output logic       dec_pmu_presync_stall,    // decode has presync stall\n', '   output logic       dec_pmu_postsync_stall,   // decode has postsync stall\n', '\n', '   output logic       dec_nonblock_load_wen,        // write enable for nonblock load\n', '   output logic [4:0] dec_nonblock_load_waddr,      // logical write addr for nonblock load\n', '   output logic       dec_nonblock_load_freeze_dc2, // lsu must freeze nonblock load due to younger dependency in pipe\n', '   output logic       dec_pause_state,              // core in pause state\n', '   output logic       dec_pause_state_cg,           // pause state for clock-gating\n', '\n', '   output logic       dec_i0_load_e4,          // pipe down if load is i0 or not in case of lsu_freeze\n', '\n', '   input  logic        scan_mode\n', '   );\n', '\n', '\n', '\n', '\n', '   dec_pkt_t i0_dp_raw, i0_dp;\n', '   dec_pkt_t i1_dp_raw, i1_dp;\n', '\n', '\n', '\n', '   logic [31:0]        i0, i1;\n', '   logic               i0_valid_d, i1_valid_d;\n', '\n', '   logic [31:0]        i0_result_e1, i1_result_e1;\n', '   logic [31:0]                      i1_result_e2;\n', '   logic [31:0]        i0_result_e3, i1_result_e3;\n', '   logic [31:0]        i0_result_e4, i1_result_e4;\n', '   logic [31:0]        i0_result_wb, i1_result_wb;\n', '\n', '   logic [31:1]        i0_pc_e1, i1_pc_e1;\n', '   logic [31:1]        i0_pc_e2, i1_pc_e2;\n', '   logic [31:1]        i0_pc_e3, i1_pc_e3;\n', '   logic [31:1]        i0_pc_e4, i1_pc_e4;\n', '\n', '   logic [9:0]         i0_rs1bypass, i0_rs2bypass;\n', '   logic [9:0]         i1_rs1bypass, i1_rs2bypass;\n', '\n', '   logic               i0_jalimm20, i1_jalimm20;\n', '   logic               i0_uiimm20, i1_uiimm20;\n', '\n', '   //logic             flush_final_e3;\n', '\n', '   logic               lsu_decode_d;\n', '   logic [31:0]        i0_immed_d;\n', '   logic               i0_presync;\n', '   logic               i0_postsync;\n', '\n', '   logic               postsync_stall;\n', '   logic               ps_stall;\n', '\n', '   logic               prior_inflight, prior_inflight_e1e4, prior_inflight_wb;\n', '\n', '   logic               csr_clr_d, csr_set_d, csr_write_d;\n', '\n', '\n', '   logic        csr_clr_e1,csr_set_e1,csr_write_e1,csr_imm_e1;\n', '   logic [31:0] csr_mask_e1;\n', '   logic [31:0] write_csr_data_e1;\n', '   logic [31:0] write_csr_data_in;\n', '   logic [31:0] write_csr_data;\n', '   logic               csr_data_wen;\n', '\n', '   logic [4:0]         csrimm_e1;\n', '\n', '   logic [31:0]        csr_rddata_e1;\n', '\n', '   logic               flush_lower_wb;\n', '\n', '   logic               i1_load_block_d;\n', '   logic               i1_mul_block_d;\n', '   logic               i1_load2_block_d;\n', '   logic               i1_mul2_block_d;\n', '   logic               mul_decode_d;\n', '   logic               div_decode_d;\n', '   logic [31:1]        div_pc;\n', '   logic               div_stall, div_stall_ff;\n', '   logic [3:0]         div_trigger;\n', '\n', '   logic               i0_legal;\n', '   logic               shift_illegal;\n', '   logic               illegal_inst_en;\n', '   logic [31:0]        illegal_inst;\n', '   logic               illegal_lockout_in, illegal_lockout;\n', '   logic               i0_legal_decode_d;\n', '\n', '   logic               i1_flush_final_e3;\n', '\n', '   logic [31:0]        i0_result_e3_final, i1_result_e3_final;\n', '   logic [31:0]        i0_result_wb_raw,   i1_result_wb_raw;\n', '   logic [12:1] last_br_immed_d;\n', '   logic        i1_depend_i0_d;\n', '   logic        i0_rs1_depend_i0_e1, i0_rs1_depend_i0_e2, i0_rs1_depend_i0_e3, i0_rs1_depend_i0_e4, i0_rs1_depend_i0_wb;\n', '   logic        i0_rs1_depend_i1_e1, i0_rs1_depend_i1_e2, i0_rs1_depend_i1_e3, i0_rs1_depend_i1_e4, i0_rs1_depend_i1_wb;\n', '   logic        i0_rs2_depend_i0_e1, i0_rs2_depend_i0_e2, i0_rs2_depend_i0_e3, i0_rs2_depend_i0_e4, i0_rs2_depend_i0_wb;\n', '   logic        i0_rs2_depend_i1_e1, i0_rs2_depend_i1_e2, i0_rs2_depend_i1_e3, i0_rs2_depend_i1_e4, i0_rs2_depend_i1_wb;\n', '   logic        i1_rs1_depend_i0_e1, i1_rs1_depend_i0_e2, i1_rs1_depend_i0_e3, i1_rs1_depend_i0_e4, i1_rs1_depend_i0_wb;\n', '   logic        i1_rs1_depend_i1_e1, i1_rs1_depend_i1_e2, i1_rs1_depend_i1_e3, i1_rs1_depend_i1_e4, i1_rs1_depend_i1_wb;\n', '   logic        i1_rs2_depend_i0_e1, i1_rs2_depend_i0_e2, i1_rs2_depend_i0_e3, i1_rs2_depend_i0_e4, i1_rs2_depend_i0_wb;\n', '   logic        i1_rs2_depend_i1_e1, i1_rs2_depend_i1_e2, i1_rs2_depend_i1_e3, i1_rs2_depend_i1_e4, i1_rs2_depend_i1_wb;\n', '   logic        i1_rs1_depend_i0_d, i1_rs2_depend_i0_d;\n', '\n', '   logic        i0_secondary_d, i1_secondary_d;\n', '   logic        i0_secondary_block_d, i1_secondary_block_d;\n', '   logic        non_block_case_d;\n', '   logic        i0_div_decode_d;\n', '   logic [31:0] i0_result_e4_final, i1_result_e4_final;\n', '   logic        i0_load_block_d;\n', '   logic        i0_mul_block_d;\n', '   logic [3:0]  i0_rs1_depth_d, i0_rs2_depth_d;\n', '   logic [3:0]  i1_rs1_depth_d, i1_rs2_depth_d;\n', '\n', '   logic        i0_rs1_match_e1_e2, i0_rs1_match_e1_e3;\n', '   logic        i0_rs2_match_e1_e2, i0_rs2_match_e1_e3;\n', '   logic        i1_rs1_match_e1_e2, i1_rs1_match_e1_e3;\n', '   logic        i1_rs2_match_e1_e2, i1_rs2_match_e1_e3;\n', '\n', '   logic        i0_load_stall_d,  i1_load_stall_d;\n', '   logic        i0_store_stall_d, i1_store_stall_d;\n', '\n', '   logic        i0_predict_nt, i0_predict_t;\n', '   logic        i1_predict_nt, i1_predict_t;\n', '\n', '   logic        i0_notbr_error, i0_br_toffset_error;\n', '   logic        i1_notbr_error, i1_br_toffset_error;\n', '   logic        i0_ret_error,   i1_ret_error;\n', '   logic        i0_br_error, i1_br_error;\n', '   logic        i0_br_error_all, i1_br_error_all;\n', '   logic [11:0] i0_br_offset, i1_br_offset;\n', '\n', '   logic        freeze;\n', '\n', ""   logic [20:1] i0_pcall_imm, i1_pcall_imm;    // predicted jal's\n"", '   logic        i0_pcall_12b_offset, i1_pcall_12b_offset;\n', '   logic        i0_pcall_raw,   i1_pcall_raw;\n', '   logic        i0_pcall_case,  i1_pcall_case;\n', '   logic        i0_pcall,  i1_pcall;\n', '\n', '   logic        i0_pja_raw,   i1_pja_raw;\n', '   logic        i0_pja_case,  i1_pja_case;\n', '   logic        i0_pja,  i1_pja;\n', '\n', '   logic        i0_pret_case, i1_pret_case;\n', '   logic        i0_pret_raw, i0_pret;\n', '   logic        i1_pret_raw, i1_pret;\n', '\n', ""   logic        i0_jal, i1_jal;  // jal's that are not predicted\n"", '\n', '\n', '   logic        i0_predict_br, i1_predict_br;\n', '\n', '   logic        freeze_prior1, freeze_prior2;\n', '\n', '   logic [31:0] i0_result_e4_freeze, i1_result_e4_freeze;\n', '   logic [31:0] i0_result_wb_freeze, i1_result_wb_freeze;\n', '   logic [31:0] i1_result_wb_eff, i0_result_wb_eff;\n', '   logic [2:0]  i1rs1_intra, i1rs2_intra;\n', '   logic        i1_rs1_intra_bypass, i1_rs2_intra_bypass;\n', '   logic        store_data_bypass_c1, store_data_bypass_c2;\n', '   logic [1:0]  store_data_bypass_e4_c1, store_data_bypass_e4_c2, store_data_bypass_e4_c3;\n', '   logic        store_data_bypass_i0_e2_c2;\n', '\n', '   class_pkt_t i0_rs1_class_d, i0_rs2_class_d;\n', '   class_pkt_t i1_rs1_class_d, i1_rs2_class_d;\n', '\n', '   class_pkt_t i0_dc, i0_e1c, i0_e2c, i0_e3c, i0_e4c, i0_wbc;\n', '   class_pkt_t i1_dc, i1_e1c, i1_e2c, i1_e3c, i1_e4c, i1_wbc;\n', '\n', '\n', '   logic i0_rs1_match_e1, i0_rs1_match_e2, i0_rs1_match_e3;\n', '   logic i1_rs1_match_e1, i1_rs1_match_e2, i1_rs1_match_e3;\n', '   logic i0_rs2_match_e1, i0_rs2_match_e2, i0_rs2_match_e3;\n', '   logic i1_rs2_match_e1, i1_rs2_match_e2, i1_rs2_match_e3;\n', '\n', '   logic       i0_secondary_stall_d;\n', '\n', '   logic       i0_ap_pc2, i0_ap_pc4;\n', '   logic       i1_ap_pc2, i1_ap_pc4;\n', '\n', '   logic        div_wen_wb;\n', '   logic        i0_rd_en_d;\n', '   logic        i1_rd_en_d;\n', '   logic [4:0]  i1_rd_d;\n', '   logic [4:0]  i0_rd_d;\n', '\n', '   logic        load_ldst_bypass_c1;\n', '   logic        load_mul_rs1_bypass_e1;\n', '   logic        load_mul_rs2_bypass_e1;\n', '\n', '   logic        leak1_i0_stall_in, leak1_i0_stall;\n', '   logic        leak1_i1_stall_in, leak1_i1_stall;\n', '   logic        leak1_mode;\n', '\n', '   logic        i0_csr_write_only_d;\n', '\n', '   logic        prior_inflight_e1e3, prior_inflight_eff;\n', '   logic        any_csr_d;\n', '\n', '   logic        prior_csr_write;\n', '\n', '   logic [5:0] i0_pipe_en;\n', '   logic       i0_e1_ctl_en, i0_e2_ctl_en, i0_e3_ctl_en, i0_e4_ctl_en, i0_wb_ctl_en;\n', '   logic       i0_e1_data_en, i0_e2_data_en, i0_e3_data_en, i0_e4_data_en, i0_wb_data_en, i0_wb1_data_en;\n', '\n', '   logic [5:0] i1_pipe_en;\n', '   logic       i1_e1_ctl_en, i1_e2_ctl_en, i1_e3_ctl_en, i1_e4_ctl_en, i1_wb_ctl_en;\n', '   logic       i1_e1_data_en, i1_e2_data_en, i1_e3_data_en, i1_e4_data_en, i1_wb_data_en, i1_wb1_data_en;\n', '\n', '   logic debug_fence_i;\n', '   logic debug_fence;\n', '\n', '   logic i0_csr_write;\n', '   logic presync_stall;\n', '\n', '   logic i0_instr_error;\n', '   logic i0_icaf_d;\n', '   logic i1_icaf_d;\n', '\n', '   logic i0_not_alu_eff, i1_not_alu_eff;\n', '\n', '   logic disable_secondary;\n', '\n', '   logic clear_pause;\n', '   logic pause_state_in, pause_state;\n', '   logic pause_stall;\n', '\n', '   logic [31:1] i1_pc_wb;\n', '\n', '   logic        i0_brp_valid;\n', '   logic        nonblock_load_cancel;\n', '   logic        lsu_idle;\n', '   logic        csr_read_e1;\n', '   logic        i0_block_d;\n', '   logic        i1_block_d;\n', '   logic        ps_stall_in;\n', '\n', '   logic        freeze_after_unfreeze1;\n', '   logic        freeze_after_unfreeze2;\n', '   logic        unfreeze_cycle1;\n', '   logic        unfreeze_cycle2;\n', '\n', '   logic        tlu_wr_pause_wb1, tlu_wr_pause_wb2;\n', '\n', '   localparam NBLOAD_SIZE     = `RV_LSU_NUM_NBLOAD;\n', '   localparam NBLOAD_SIZE_MSB = `RV_LSU_NUM_NBLOAD-1;\n', '   localparam NBLOAD_TAG_MSB  = `RV_LSU_NUM_NBLOAD_WIDTH-1;\n', '\n', '// non block load cam logic\n', '\n', '   logic                     cam_write, cam_inv_reset, cam_data_reset;\n', '   logic [NBLOAD_TAG_MSB:0]  cam_write_tag, cam_inv_reset_tag, cam_data_reset_tag;\n', '   logic [NBLOAD_SIZE_MSB:0] cam_wen;\n', '\n', '   logic [NBLOAD_TAG_MSB:0]  load_data_tag;\n', '   logic [NBLOAD_SIZE_MSB:0] nonblock_load_write;\n', '\n', '   load_cam_pkt_t [NBLOAD_SIZE_MSB:0] cam;\n', '   load_cam_pkt_t [NBLOAD_SIZE_MSB:0] cam_in;\n', '\n', '   logic [4:0] nonblock_load_rd;\n', '   logic i1_nonblock_load_stall,     i0_nonblock_load_stall;\n', '   logic i1_nonblock_boundary_stall, i0_nonblock_boundary_stall;\n', '   logic i0_depend_load_e1_d, i0_depend_load_e2_d;\n', '   logic i1_depend_load_e1_d, i1_depend_load_e2_d;\n', '   logic    depend_load_e1_d,  depend_load_e2_d,  depend_load_same_cycle_d;\n', '   logic    depend_load_e2_e1,                    depend_load_same_cycle_e1;\n', '   logic                                          depend_load_same_cycle_e2;\n', '\n', '   logic nonblock_load_valid_dc4, nonblock_load_valid_wb;\n', '   logic i0_load_kill_wen, i1_load_kill_wen;\n', '\n', '   logic found;\n', '\n', '   logic cam_reset_same_dest_wb;\n', '   logic [NBLOAD_SIZE_MSB:0] cam_inv_reset_val, cam_data_reset_val;\n', '   logic       i1_wen_wb, i0_wen_wb;\n', '\n', '   inst_t i0_itype, i1_itype;\n', '\n', '   logic csr_read, csr_write;\n', '   logic i0_br_unpred, i1_br_unpred;\n', '\n', '   logic debug_fence_raw;\n', '\n', '   logic freeze_before;\n', '   logic freeze_e3, freeze_e4;\n', '   logic [3:0] e4t_i0trigger;\n', '   logic [3:0] e4t_i1trigger;\n', '   logic       e4d_i0load;\n', '\n', '   logic [4:0] div_waddr_wb;\n', '   logic [12:1] last_br_immed_e1, last_br_immed_e2;\n', '   logic [31:0]        i0_inst_d, i1_inst_d;\n', '   logic [31:0]        i0_inst_e1, i1_inst_e1;\n', '   logic [31:0]        i0_inst_e2, i1_inst_e2;\n', '   logic [31:0]        i0_inst_e3, i1_inst_e3;\n', '   logic [31:0]        i0_inst_e4, i1_inst_e4;\n', '   logic [31:0]        i0_inst_wb, i1_inst_wb;\n', '   logic [31:0]        i0_inst_wb1,i1_inst_wb1;\n', '\n', '   logic [31:0]        div_inst;\n', '   logic [31:1] i0_pc_wb, i0_pc_wb1;\n', '   logic [31:1]           i1_pc_wb1;\n', '   logic [31:1] last_pc_e2;\n', '\n', '   reg_pkt_t i0r, i1r;\n', '\n', '   trap_pkt_t   dt, e1t_in, e1t, e2t_in, e2t, e3t_in, e3t, e4t;\n', '\n', '   class_pkt_t i0_e4c_in, i1_e4c_in;\n', '\n', '   dest_pkt_t  dd, e1d, e2d, e3d, e4d, wbd;\n', '   dest_pkt_t e1d_in, e2d_in, e3d_in, e4d_in;\n', '\n', '\n', '   assign freeze = lsu_freeze_dc3;\n', '\n', '`ifdef RV_NO_SECONDARY_ALU\n', '   assign disable_secondary = 1;\n', '`else\n', '   assign disable_secondary        = dec_tlu_sec_alu_disable;\n', '`endif\n', '\n', '\n', '// branch prediction\n', '\n', '\n', ""   // in leak1_mode, ignore any predictions for i0, treat branch as if we haven't seen it before\n"", '   // in leak1 mode, also ignore branch errors for i0\n', '   assign i0_brp_valid = dec_i0_brp.valid & ~leak1_mode;\n', '\n', ""   assign      i0_predict_p_d.misp    =  '0;\n"", ""   assign      i0_predict_p_d.ataken  =  '0;\n"", ""   assign      i0_predict_p_d.boffset =  '0;\n"", '\n', '   assign      i0_predict_p_d.pcall  =  i0_pcall;  // dont mark as pcall if branch error\n', '   assign      i0_predict_p_d.pja    =  i0_pja;\n', '   assign      i0_predict_p_d.pret   =  i0_pret;\n', '   assign      i0_predict_p_d.prett[31:1] = dec_i0_brp.prett[31:1];\n', '   assign      i0_predict_p_d.pc4 = dec_i0_pc4_d;\n', '   assign      i0_predict_p_d.hist[1:0] = dec_i0_brp.hist[1:0];\n', '   assign      i0_predict_p_d.valid = i0_brp_valid & i0_legal_decode_d;\n', '   assign      i0_notbr_error = i0_brp_valid & ~(i0_dp_raw.condbr | i0_pcall_raw | i0_pja_raw | i0_pret_raw);\n', '\n', '   // no toffset error for a pret\n', '   assign      i0_br_toffset_error = i0_brp_valid & dec_i0_brp.hist[1] & (dec_i0_brp.toffset[11:0] != i0_br_offset[11:0]) & !i0_pret_raw;\n', '   assign      i0_ret_error = i0_brp_valid & dec_i0_brp.ret & ~i0_pret_raw;\n', '   assign      i0_br_error =  dec_i0_brp.br_error | i0_notbr_error | i0_br_toffset_error | i0_ret_error;\n', '   assign      i0_predict_p_d.br_error = i0_br_error & i0_legal_decode_d & ~leak1_mode;\n', '   assign      i0_predict_p_d.br_start_error = dec_i0_brp.br_start_error & i0_legal_decode_d & ~leak1_mode;\n', '   assign      i0_predict_p_d.index[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] = dec_i0_brp.index[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO];\n', '   assign      i0_predict_p_d.bank[1:0] = dec_i0_brp.bank[1:0];\n', '   assign      i0_predict_p_d.btag[`RV_BTB_BTAG_SIZE-1:0] = dec_i0_brp.btag[`RV_BTB_BTAG_SIZE-1:0];\n', '   assign      i0_br_error_all = (i0_br_error | dec_i0_brp.br_start_error) & ~leak1_mode;\n', '   assign      i0_predict_p_d.toffset[11:0] = i0_br_offset[11:0];\n', '   assign      i0_predict_p_d.fghr[`RV_BHT_GHR_RANGE] = dec_i0_brp.fghr[`RV_BHT_GHR_RANGE];\n', '   assign      i0_predict_p_d.way = dec_i0_brp.way;\n', '\n', '\n', ""   assign      i1_predict_p_d.misp    =  '0;\n"", ""   assign      i1_predict_p_d.ataken  =  '0;\n"", ""   assign      i1_predict_p_d.boffset =  '0;\n"", '\n', '   assign      i1_predict_p_d.pcall  =  i1_pcall;\n', '   assign      i1_predict_p_d.pja    =  i1_pja;\n', '   assign      i1_predict_p_d.pret   =  i1_pret;\n', '   assign      i1_predict_p_d.prett[31:1] = dec_i1_brp.prett[31:1];\n', '   assign      i1_predict_p_d.pc4 = dec_i1_pc4_d;\n', '   assign      i1_predict_p_d.hist[1:0] = dec_i1_brp.hist[1:0];\n', '   assign      i1_predict_p_d.valid = dec_i1_brp.valid & dec_i1_decode_d;\n', '   assign      i1_notbr_error = dec_i1_brp.valid & ~(i1_dp_raw.condbr | i1_pcall_raw | i1_pja_raw | i1_pret_raw);\n', '\n', '\n', '   assign      i1_br_toffset_error = dec_i1_brp.valid & dec_i1_brp.hist[1] & (dec_i1_brp.toffset[11:0] != i1_br_offset[11:0]) & !i1_pret_raw;\n', '   assign      i1_ret_error = dec_i1_brp.valid & dec_i1_brp.ret & ~i1_pret_raw;\n', '   assign      i1_br_error = dec_i1_brp.br_error | i1_notbr_error | i1_br_toffset_error | i1_ret_error;\n', '   assign      i1_predict_p_d.br_error = i1_br_error & dec_i1_decode_d;\n', '   assign      i1_predict_p_d.br_start_error = dec_i1_brp.br_start_error & dec_i1_decode_d;\n', '   assign      i1_predict_p_d.index[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] = dec_i1_brp.index[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO];\n', '   assign      i1_predict_p_d.bank[1:0] = dec_i1_brp.bank[1:0];\n', '   assign      i1_predict_p_d.btag[`RV_BTB_BTAG_SIZE-1:0] = dec_i1_brp.btag[`RV_BTB_BTAG_SIZE-1:0];\n', '   assign      i1_br_error_all = (i1_br_error | dec_i1_brp.br_start_error);\n', '   assign      i1_predict_p_d.toffset[11:0] = i1_br_offset[11:0];\n', '   assign      i1_predict_p_d.fghr[`RV_BHT_GHR_RANGE] = dec_i1_brp.fghr[`RV_BHT_GHR_RANGE];\n', '   assign      i1_predict_p_d.way = dec_i1_brp.way;\n', '\n', '   //   end\n', '\n', '   // on br error turn anything into a nop\n', '   // on i0 instruction fetch access fault turn anything into a nop\n', '   // nop =>   alu rs1 imm12 rd lor\n', '\n', '   assign i0_icaf_d = dec_i0_icaf_d | dec_i0_dbecc_d;\n', '   assign i1_icaf_d = dec_i1_icaf_d | dec_i1_dbecc_d;\n', '\n', '   assign i0_instr_error = i0_icaf_d | dec_i0_perr_d | dec_i0_sbecc_d;\n', '\n', '   always_comb begin\n', '      i0_dp = i0_dp_raw;\n', '      if (i0_br_error_all | i0_instr_error) begin\n', ""         i0_dp = '0;\n"", ""         i0_dp.alu = 1'b1;\n"", ""         i0_dp.rs1 = 1'b1;\n"", ""         i0_dp.rs2 = 1'b1;\n"", ""         i0_dp.lor = 1'b1;\n"", ""         i0_dp.legal = 1'b1;\n"", ""         i0_dp.postsync = 1'b1;\n"", '      end\n', '\n', '      i1_dp = i1_dp_raw;\n', '      if (i1_br_error_all) begin\n', ""         i1_dp = '0;\n"", ""         i1_dp.alu = 1'b1;\n"", ""         i1_dp.rs1 = 1'b1;\n"", ""         i1_dp.rs2 = 1'b1;\n"", ""         i1_dp.lor = 1'b1;\n"", ""         i1_dp.legal = 1'b1;\n"", ""         i1_dp.postsync = 1'b1;\n"", '      end\n', '\n', '   end\n', '\n', '   assign flush_lower_wb = dec_tlu_flush_lower_wb;\n', '\n', '   assign i0[31:0] = dec_i0_instr_d[31:0];\n', '\n', '   assign i1[31:0] = dec_i1_instr_d[31:0];\n', '\n', '   assign dec_i0_select_pc_d = i0_dp.pc;\n', '   assign dec_i1_select_pc_d = i1_dp.pc;\n', '\n', '   // branches that can be predicted\n', '\n', '   assign i0_predict_br =  i0_dp.condbr | i0_pcall | i0_pja | i0_pret;\n', '   assign i1_predict_br =  i1_dp.condbr | i1_pcall | i1_pja | i1_pret;\n', '\n', '   assign i0_predict_nt = ~(dec_i0_brp.hist[1] & i0_brp_valid) & i0_predict_br;\n', '   assign i0_predict_t  =  (dec_i0_brp.hist[1] & i0_brp_valid) & i0_predict_br;\n', '\n', '   assign i0_ap.valid =  (i0_dc.sec | i0_dc.alu | i0_dp.alu );\n', '   assign i0_ap.add =    i0_dp.add;\n', '   assign i0_ap.sub =    i0_dp.sub;\n', '   assign i0_ap.land =   i0_dp.land;\n', '   assign i0_ap.lor =    i0_dp.lor;\n', '   assign i0_ap.lxor =   i0_dp.lxor;\n', '   assign i0_ap.sll =    i0_dp.sll;\n', '   assign i0_ap.srl =    i0_dp.srl;\n', '   assign i0_ap.sra =    i0_dp.sra;\n', '   assign i0_ap.slt =    i0_dp.slt;\n', '   assign i0_ap.unsign = i0_dp.unsign;\n', '   assign i0_ap.beq =    i0_dp.beq;\n', '   assign i0_ap.bne =    i0_dp.bne;\n', '   assign i0_ap.blt =    i0_dp.blt;\n', '   assign i0_ap.bge =    i0_dp.bge;\n', '\n', '\n', '\n', '   assign i0_ap.csr_write = i0_csr_write_only_d;\n', '   assign i0_ap.csr_imm = i0_dp.csr_imm;\n', '\n', '\n', '   assign i0_ap.jal    =  i0_jal;\n', '\n', '\n', '   assign i0_ap_pc2 = ~dec_i0_pc4_d;\n', '   assign i0_ap_pc4 =  dec_i0_pc4_d;\n', '\n', '   assign i0_ap.predict_nt = i0_predict_nt;\n', '   assign i0_ap.predict_t  = i0_predict_t;\n', '\n', '   assign i1_predict_nt = ~(dec_i1_brp.hist[1] & dec_i1_brp.valid) & i1_predict_br;\n', '   assign i1_predict_t  =  (dec_i1_brp.hist[1] & dec_i1_brp.valid) & i1_predict_br;\n', '\n', '   assign i1_ap.valid =  (i1_dc.sec | i1_dc.alu | i1_dp.alu);\n', '   assign i1_ap.add =    i1_dp.add;\n', '   assign i1_ap.sub =    i1_dp.sub;\n', '   assign i1_ap.land =   i1_dp.land;\n', '   assign i1_ap.lor =    i1_dp.lor;\n', '   assign i1_ap.lxor =   i1_dp.lxor;\n', '   assign i1_ap.sll =    i1_dp.sll;\n', '   assign i1_ap.srl =    i1_dp.srl;\n', '   assign i1_ap.sra =    i1_dp.sra;\n', '   assign i1_ap.slt =    i1_dp.slt;\n', '   assign i1_ap.unsign = i1_dp.unsign;\n', '   assign i1_ap.beq =    i1_dp.beq;\n', '   assign i1_ap.bne =    i1_dp.bne;\n', '   assign i1_ap.blt =    i1_dp.blt;\n', '   assign i1_ap.bge =    i1_dp.bge;\n', '\n', ""   assign i1_ap.csr_write = 1'b0;\n"", ""   assign i1_ap.csr_imm   = 1'b0;\n"", '\n', '   assign i1_ap.jal    =    i1_jal;\n', '\n', '   assign i1_ap_pc2 = ~dec_i1_pc4_d;\n', '   assign i1_ap_pc4 =  dec_i1_pc4_d;\n', '\n', '   assign i1_ap.predict_nt = i1_predict_nt;\n', '   assign i1_ap.predict_t  = i1_predict_t;\n', '\n', '   always_comb begin\n', '      found = 0;\n', ""      cam_wen[NBLOAD_SIZE_MSB:0] = '0;\n"", '      for (int i=0; i<NBLOAD_SIZE; i++) begin\n', '         if (~found) begin\n', '            if (~cam[i].valid) begin\n', '               cam_wen[i] = cam_write;\n', ""               found = 1'b1;\n"", '            end\n', '         end\n', '      end\n', '   end\n', '\n', '\n', '   assign cam_reset_same_dest_wb = wbd.i0v & wbd.i1v & (wbd.i0rd[4:0] == wbd.i1rd[4:0]) &\n', '                                   wbd.i0load & nonblock_load_valid_wb & ~dec_tlu_i0_kill_writeb_wb & ~dec_tlu_i1_kill_writeb_wb;\n', '\n', '\n', '   assign cam_write          = lsu_nonblock_load_valid_dc3;\n', '   assign cam_write_tag[NBLOAD_TAG_MSB:0] = lsu_nonblock_load_tag_dc3[NBLOAD_TAG_MSB:0];\n', '\n', '   assign cam_inv_reset          = lsu_nonblock_load_inv_dc5 | cam_reset_same_dest_wb;\n', '   assign cam_inv_reset_tag[NBLOAD_TAG_MSB:0] = lsu_nonblock_load_inv_tag_dc5[NBLOAD_TAG_MSB:0];\n', '\n', '   assign cam_data_reset          = lsu_nonblock_load_data_valid | lsu_nonblock_load_data_error;\n', '   assign cam_data_reset_tag[NBLOAD_TAG_MSB:0] = lsu_nonblock_load_data_tag[NBLOAD_TAG_MSB:0];\n', '\n', '   assign nonblock_load_rd[4:0] = (e3d.i0load) ? e3d.i0rd[4:0] : e3d.i1rd[4:0];  // rd data\n', '\n', '\n', '   // checks\n', '\n', '`ifdef ASSERT_ON\n', '   assert_dec_data_valid_data_error_onehot:    assert #0 ($onehot0({lsu_nonblock_load_data_valid,lsu_nonblock_load_data_error}));\n', '\n', '   assert_dec_cam_inv_reset_onehot:    assert #0 ($onehot0(cam_inv_reset_val[NBLOAD_SIZE_MSB:0]));\n', '   assert_dec_cam_data_reset_onehot:   assert #0 ($onehot0(cam_data_reset_val[NBLOAD_SIZE_MSB:0]));\n', '`endif\n', '\n', '    // case of multiple loads to same dest ie. x1 ... you have to invalidate the older one\n', '\n', '   for (genvar i=0; i<NBLOAD_SIZE; i++) begin : cam_array\n', '\n', '      assign cam_inv_reset_val[i] = cam_inv_reset   & (cam_inv_reset_tag[NBLOAD_TAG_MSB:0]  == cam[i].tag[NBLOAD_TAG_MSB:0]) & cam[i].valid;\n', '\n', '      assign cam_data_reset_val[i] = cam_data_reset & (cam_data_reset_tag[NBLOAD_TAG_MSB:0] == cam[i].tag[NBLOAD_TAG_MSB:0]) & cam[i].valid;\n', '\n', '\n', '      always_comb begin\n', ""         cam_in[i] = '0;\n"", '\n', '         if (cam_wen[i]) begin\n', ""            cam_in[i].valid    = 1'b1;\n"", ""            cam_in[i].wb       = 1'b0;\n"", '            cam_in[i].tag[NBLOAD_TAG_MSB:0] = cam_write_tag[NBLOAD_TAG_MSB:0];\n', '            cam_in[i].rd[4:0]  = nonblock_load_rd[4:0];\n', '         end\n', '         else if ( (cam_inv_reset_val[i]) |\n', '                   (cam_data_reset_val[i]) |\n', '                   (i0_wen_wb & (wbd.i0rd[4:0] == cam[i].rd[4:0]) & cam[i].wb) |\n', '                   (i1_wen_wb & (wbd.i1rd[4:0] == cam[i].rd[4:0]) & cam[i].wb) )\n', ""           cam_in[i].valid = 1'b0;\n"", '         else\n', '           cam_in[i] = cam[i];\n', '\n', '\n', '         if (nonblock_load_valid_wb & (lsu_nonblock_load_inv_tag_dc5[NBLOAD_TAG_MSB:0]==cam[i].tag[NBLOAD_TAG_MSB:0]) & cam[i].valid)\n', ""           cam_in[i].wb = 1'b1;\n"", '      end\n', '\n', '   rvdff #( $bits(load_cam_pkt_t) ) cam_ff (.*, .clk(free_clk), .din(cam_in[i]), .dout(cam[i]));\n', '\n', '\n', '\n', '   assign nonblock_load_write[i] = (load_data_tag[NBLOAD_TAG_MSB:0] == cam[i].tag[NBLOAD_TAG_MSB:0]) & cam[i].valid;\n', '\n', '\n', '\n', 'end : cam_array\n', '\n', '\n', '\n', '   assign load_data_tag[NBLOAD_TAG_MSB:0] = lsu_nonblock_load_data_tag[NBLOAD_TAG_MSB:0];\n', '\n', '`ifdef ASSERT_ON\n', '   assert_dec_cam_nonblock_load_write_onehot:   assert #0 ($onehot0(nonblock_load_write[NBLOAD_SIZE_MSB:0]));\n', '`endif\n', '\n', '\n', '   assign nonblock_load_cancel = ((wbd.i0rd[4:0] == dec_nonblock_load_waddr[4:0]) & i0_wen_wb) |    // cancel if any younger inst (including another nonblock) committing this cycle\n', '                                 ((wbd.i1rd[4:0] == dec_nonblock_load_waddr[4:0]) & i1_wen_wb);\n', '\n', '\n', '   assign dec_nonblock_load_wen = lsu_nonblock_load_data_valid & |nonblock_load_write[NBLOAD_SIZE_MSB:0] & ~nonblock_load_cancel;\n', '\n', '   always_comb begin\n', ""      dec_nonblock_load_waddr[4:0] = '0;\n"", '      i0_nonblock_load_stall = i0_nonblock_boundary_stall;\n', '      i1_nonblock_load_stall = i1_nonblock_boundary_stall;\n', '\n', '      for (int i=0; i<NBLOAD_SIZE; i++) begin\n', '         dec_nonblock_load_waddr[4:0] |= ({5{nonblock_load_write[i]}} & cam[i].rd[4:0]);\n', '\n', '         i0_nonblock_load_stall |= dec_i0_rs1_en_d & cam[i].valid & (cam[i].rd[4:0] == i0r.rs1[4:0]);\n', '         i0_nonblock_load_stall |= dec_i0_rs2_en_d & cam[i].valid & (cam[i].rd[4:0] == i0r.rs2[4:0]);\n', '\n', '         i1_nonblock_load_stall |= dec_i1_rs1_en_d & cam[i].valid & (cam[i].rd[4:0] == i1r.rs1[4:0]);\n', '         i1_nonblock_load_stall |= dec_i1_rs2_en_d & cam[i].valid & (cam[i].rd[4:0] == i1r.rs2[4:0]);\n', '\n', '      end\n', '   end\n', '\n', '   assign i0_nonblock_boundary_stall = ((nonblock_load_rd[4:0]==i0r.rs1[4:0]) & lsu_nonblock_load_valid_dc3 & dec_i0_rs1_en_d) |\n', '                                       ((nonblock_load_rd[4:0]==i0r.rs2[4:0]) & lsu_nonblock_load_valid_dc3 & dec_i0_rs2_en_d);\n', '\n', '   assign i1_nonblock_boundary_stall = ((nonblock_load_rd[4:0]==i1r.rs1[4:0]) & lsu_nonblock_load_valid_dc3 & dec_i1_rs1_en_d) |\n', '                                       ((nonblock_load_rd[4:0]==i1r.rs2[4:0]) & lsu_nonblock_load_valid_dc3 & dec_i1_rs2_en_d);\n', '\n', ""   assign i0_depend_load_e1_d = ((i0_rs1_class_d.load & (i0_rs1_depth_d[3:0]==4'd1 | i0_rs1_depth_d[3:0]==4'd2)) |\n"", ""                                 (i0_rs2_class_d.load & (i0_rs2_depth_d[3:0]==4'd1 | i0_rs2_depth_d[3:0]==4'd2))) & dec_i0_decode_d;\n"", '\n', ""   assign i0_depend_load_e2_d = ((i0_rs1_class_d.load & (i0_rs1_depth_d[3:0]==4'd3 | i0_rs1_depth_d[3:0]==4'd4)) |\n"", ""                                 (i0_rs2_class_d.load & (i0_rs2_depth_d[3:0]==4'd3 | i0_rs2_depth_d[3:0]==4'd4))) & dec_i0_decode_d;\n"", '\n', ""   assign i1_depend_load_e1_d = ((i1_rs1_class_d.load & (i1_rs1_depth_d[3:0]==4'd1 | i1_rs1_depth_d[3:0]==4'd2)) |\n"", ""                                 (i1_rs2_class_d.load & (i1_rs2_depth_d[3:0]==4'd1 | i1_rs2_depth_d[3:0]==4'd2))) & dec_i1_decode_d;\n"", '\n', ""   assign i1_depend_load_e2_d = ((i1_rs1_class_d.load & (i1_rs1_depth_d[3:0]==4'd3 | i1_rs1_depth_d[3:0]==4'd4)) |\n"", ""                                 (i1_rs2_class_d.load & (i1_rs2_depth_d[3:0]==4'd3 | i1_rs2_depth_d[3:0]==4'd4))) & dec_i1_decode_d;\n"", '\n', '\n', '\n', '   assign depend_load_e1_d = i0_depend_load_e1_d | i1_depend_load_e1_d;\n', '\n', '   assign depend_load_e2_d = i0_depend_load_e2_d | i1_depend_load_e2_d;\n', '\n', '   assign depend_load_same_cycle_d = i1_depend_i0_d & i0_dp.load & dec_i1_decode_d;\n', '\n', '\n', '   rvdffs #(2) e1loadff (.*,\n', '                         .clk(active_clk),\n', '                         .en(i0_e1_ctl_en),\n', '                         .din( {depend_load_e1_d,  depend_load_same_cycle_d}),\n', '                         .dout({depend_load_e2_e1, depend_load_same_cycle_e1})\n', '                         );\n', '\n', '   rvdffs #(1) e2loadff (.*,\n', '                         .clk(active_clk),\n', '                         .en(i0_e2_ctl_en),\n', '                         .din( depend_load_same_cycle_e1),\n', '                         .dout(depend_load_same_cycle_e2)\n', '                         );\n', '\n', '   assign dec_nonblock_load_freeze_dc2 = depend_load_e2_d | depend_load_e2_e1 | depend_load_same_cycle_e2;\n', '\n', '\n', ""// don't writeback a nonblock load\n"", '\n', '   rvdffs #(1) e4nbloadff (.*, .clk(active_clk), .en(i0_e4_ctl_en), .din(lsu_nonblock_load_valid_dc3),  .dout(nonblock_load_valid_dc4) );\n', '   rvdffs #(1) wbnbloadff (.*, .clk(active_clk), .en(i0_wb_ctl_en), .din(    nonblock_load_valid_dc4),  .dout(nonblock_load_valid_wb) );\n', '\n', '   // illegal for i0load and i1load same time\n', '   assign i0_load_kill_wen = nonblock_load_valid_wb &  wbd.i0load;\n', '   assign i1_load_kill_wen = nonblock_load_valid_wb &  wbd.i1load;\n', '\n', '\n', '\n', '\n', '// end non block load cam logic\n', '\n', '// pmu start\n', '\n', '\n', '\n', '   assign csr_read = dec_csr_ren_d;\n', '   assign csr_write = dec_csr_wen_unq_d;\n', '\n', '   assign i0_br_unpred = (i0_dp.condbr | i0_dp.jal) & ~i0_predict_br;\n', '   assign i1_br_unpred = (i1_dp.condbr | i1_dp.jal) & ~i1_predict_br;\n', '\n', '   // the classes must be mutually exclusive with one another\n', '\n', '   always_comb begin\n', '      i0_itype = NULL;\n', '      i1_itype = NULL;\n', '\n', '      if (i0_legal_decode_d) begin\n', '         if (i0_dp.mul)                  i0_itype = MUL;\n', '         if (i0_dp.load)                 i0_itype = LOAD;\n', '         if (i0_dp.store)                i0_itype = STORE;\n', '         if (i0_dp.pm_alu)               i0_itype = ALU;\n', '         if ( csr_read & ~csr_write)     i0_itype = CSRREAD;\n', '         if (~csr_read &  csr_write)     i0_itype = CSRWRITE;\n', '         if ( csr_read &  csr_write)     i0_itype = CSRRW;\n', '         if (i0_dp.ebreak)               i0_itype = EBREAK;\n', '         if (i0_dp.ecall)                i0_itype = ECALL;\n', '         if (i0_dp.fence)                i0_itype = FENCE;\n', '         if (i0_dp.fence_i)              i0_itype = FENCEI;  // fencei will set this even with fence attribute\n', '         if (i0_dp.mret)                 i0_itype = MRET;\n', '         if (i0_dp.condbr)               i0_itype = CONDBR;\n', '         if (i0_dp.jal)                  i0_itype = JAL;\n', '      end\n', '\n', '      if (dec_i1_decode_d) begin\n', '         if (i1_dp.mul)                  i1_itype = MUL;\n', '         if (i1_dp.load)                 i1_itype = LOAD;\n', '         if (i1_dp.store)                i1_itype = STORE;\n', '         if (i1_dp.pm_alu)               i1_itype = ALU;\n', '         if (i1_dp.condbr)               i1_itype = CONDBR;\n', '         if (i1_dp.jal)                  i1_itype = JAL;\n', '      end\n', '\n', '\n', '   end\n', '\n', '\n', '\n', '\n', '\n', '// end pmu\n', '\n', '   dec_dec_ctl i0_dec (.inst(i0[31:0]),.out(i0_dp_raw));\n', '\n', '   dec_dec_ctl i1_dec (.inst(i1[31:0]),.out(i1_dp_raw));\n', '\n', '   rvdff #(1) lsu_idle_ff (.*, .clk(active_clk), .din(lsu_halt_idle_any), .dout(lsu_idle));\n', '\n', '\n', ""   // can't make this clock active_clock\n"", '   assign leak1_i1_stall_in = (dec_tlu_flush_leak_one_wb | (leak1_i1_stall & ~dec_tlu_flush_lower_wb));\n', '\n', '   rvdff #(1) leak1_i1_stall_ff (.*, .clk(free_clk), .din(leak1_i1_stall_in), .dout(leak1_i1_stall));\n', '\n', '   assign leak1_mode = leak1_i1_stall;\n', '\n', '   assign leak1_i0_stall_in = ((dec_i0_decode_d & leak1_i1_stall) | (leak1_i0_stall & ~dec_tlu_flush_lower_wb));\n', '\n', '   rvdff #(1) leak1_i0_stall_ff (.*, .clk(free_clk), .din(leak1_i0_stall_in), .dout(leak1_i0_stall));\n', '\n', '\n', '\n', ""   // 12b jal's can be predicted - these are calls\n"", '\n', '   assign i0_pcall_imm[20:1] = {i0[31],i0[19:12],i0[20],i0[30:21]};\n', '\n', ""   assign i0_pcall_12b_offset = (i0_pcall_imm[12]) ? (i0_pcall_imm[20:13] == 8'hff) : (i0_pcall_imm[20:13] == 8'h0);\n"", '\n', ""   assign i0_pcall_case  = i0_pcall_12b_offset & i0_dp_raw.imm20 & i0r.rd[4:0]!=5'b0;\n"", ""   assign i0_pja_case    = i0_pcall_12b_offset & i0_dp_raw.imm20 & i0r.rd[4:0]==5'b0;\n"", '\n', '   assign i1_pcall_imm[20:1] = {i1[31],i1[19:12],i1[20],i1[30:21]};\n', '\n', ""   assign i1_pcall_12b_offset = (i1_pcall_imm[12]) ? (i1_pcall_imm[20:13] == 8'hff) : (i1_pcall_imm[20:13] == 8'h0);\n"", '\n', ""   assign i1_pcall_case  = i1_pcall_12b_offset & i1_dp_raw.imm20 & i1r.rd[4:0]!=5'b0;\n"", ""   assign i1_pja_case    = i1_pcall_12b_offset & i1_dp_raw.imm20 & i1r.rd[4:0]==5'b0;\n"", '\n', '\n', '   assign i0_pcall_raw = i0_dp_raw.jal &   i0_pcall_case;   // this includes ja\n', '   assign i0_pcall     = i0_dp.jal     &   i0_pcall_case;\n', '\n', '   assign i1_pcall_raw = i1_dp_raw.jal &   i1_pcall_case;\n', '   assign i1_pcall     = i1_dp.jal     &   i1_pcall_case;\n', '\n', '   assign i0_pja_raw = i0_dp_raw.jal &   i0_pja_case;\n', '   assign i0_pja     = i0_dp.jal     &   i0_pja_case;\n', '\n', '   assign i1_pja_raw = i1_dp_raw.jal &   i1_pja_case;\n', '   assign i1_pja     = i1_dp.jal     &   i1_pja_case;\n', '\n', '\n', '\n', '   assign i0_br_offset[11:0] = (i0_pcall_raw | i0_pja_raw) ? i0_pcall_imm[12:1] : {i0[31],i0[7],i0[30:25],i0[11:8]};\n', '\n', '   assign i1_br_offset[11:0] = (i1_pcall_raw | i1_pja_raw) ? i1_pcall_imm[12:1] : {i1[31],i1[7],i1[30:25],i1[11:8]};\n', '\n', '   //\n', '\n', ""   assign i0_pret_case = (i0_dp_raw.jal & i0_dp_raw.imm12 & i0r.rd[4:0]==5'b0 & i0r.rs1[4:0]==5'b1);  // jalr with rd==0, rs1==1 is a ret\n"", ""   assign i1_pret_case = (i1_dp_raw.jal & i1_dp_raw.imm12 & i1r.rd[4:0]==5'b0 & i1r.rs1[4:0]==5'b1);\n"", '\n', '   assign i0_pret_raw = i0_dp_raw.jal &   i0_pret_case;\n', '   assign i0_pret    = i0_dp.jal     &   i0_pret_case;\n', '\n', '   assign i1_pret_raw = i1_dp_raw.jal &   i1_pret_case;\n', '   assign i1_pret     = i1_dp.jal     &   i1_pret_case;\n', '\n', '   assign i0_jal    = i0_dp.jal  &  ~i0_pcall_case & ~i0_pja_case & ~i0_pret_case;\n', '   assign i1_jal    = i1_dp.jal  &  ~i1_pcall_case & ~i1_pja_case & ~i1_pret_case;\n', '\n', '   // lsu stuff\n', '   // load/store mutually exclusive\n', '   assign dec_lsu_offset_d[11:0] =\n', '                                   ({12{ i0_dp.lsu & i0_dp.load}} &               i0[31:20]) |\n', '                                   ({12{~i0_dp.lsu & i1_dp.lsu & i1_dp.load}} &   i1[31:20]) |\n', '                                   ({12{ i0_dp.lsu & i0_dp.store}} &             {i0[31:25],i0[11:7]}) |\n', '                                   ({12{~i0_dp.lsu & i1_dp.lsu & i1_dp.store}} & {i1[31:25],i1[11:7]});\n', '\n', '\n', '\n', '   assign dec_i0_lsu_d = i0_dp.lsu;\n', '   assign dec_i1_lsu_d = i1_dp.lsu;\n', '\n', '   assign dec_i0_mul_d = i0_dp.mul;\n', '   assign dec_i1_mul_d = i1_dp.mul;\n', '\n', '   assign dec_i0_div_d = i0_dp.div;\n', '   assign dec_i1_div_d = i1_dp.div;\n', '\n', '\n', '   assign div_p.valid = div_decode_d;\n', '\n', '   assign div_p.unsign = (i0_dp.div) ? i0_dp.unsign :   i1_dp.unsign;\n', '   assign div_p.rem  =   (i0_dp.div) ? i0_dp.rem    :   i1_dp.rem;\n', '\n', '\n', '   assign mul_p.valid = mul_decode_d;\n', '\n', '   assign mul_p.rs1_sign =   (i0_dp.mul) ? i0_dp.rs1_sign :   i1_dp.rs1_sign;\n', '   assign mul_p.rs2_sign =   (i0_dp.mul) ? i0_dp.rs2_sign :   i1_dp.rs2_sign;\n', '   assign mul_p.low      =   (i0_dp.mul) ? i0_dp.low      :   i1_dp.low;\n', '\n', '   assign mul_p.load_mul_rs1_bypass_e1 = load_mul_rs1_bypass_e1;\n', '   assign mul_p.load_mul_rs2_bypass_e1 = load_mul_rs2_bypass_e1;\n', '\n', '\n', '   assign lsu_p.valid = lsu_decode_d;\n', '\n', '   assign lsu_p.load =   (i0_dp.lsu) ? i0_dp.load :   i1_dp.load;\n', '   assign lsu_p.store =  (i0_dp.lsu) ? i0_dp.store :  i1_dp.store;\n', '   assign lsu_p.by =     (i0_dp.lsu) ? i0_dp.by :     i1_dp.by;\n', '   assign lsu_p.half =   (i0_dp.lsu) ? i0_dp.half :   i1_dp.half;\n', '   assign lsu_p.word =   (i0_dp.lsu) ? i0_dp.word :   i1_dp.word;\n', ""   assign lsu_p.dword = '0;\n"", ""   assign lsu_p.dma = '0;\n"", '   assign lsu_p.store_data_bypass_i0_e2_c2   = store_data_bypass_i0_e2_c2;  // has priority over all else\n', '   assign lsu_p.load_ldst_bypass_c1 = load_ldst_bypass_c1;\n', '   assign lsu_p.store_data_bypass_c1 = store_data_bypass_c1 & ~store_data_bypass_i0_e2_c2;\n', '   assign lsu_p.store_data_bypass_c2 = store_data_bypass_c2 & ~store_data_bypass_i0_e2_c2;\n', '   assign lsu_p.store_data_bypass_e4_c1[1:0] = store_data_bypass_e4_c1[1:0] & ~{2{store_data_bypass_i0_e2_c2}};\n', '   assign lsu_p.store_data_bypass_e4_c2[1:0] = store_data_bypass_e4_c2[1:0] & ~{2{store_data_bypass_i0_e2_c2}};\n', '   assign lsu_p.store_data_bypass_e4_c3[1:0] = store_data_bypass_e4_c3[1:0] & ~{2{store_data_bypass_i0_e2_c2}};\n', '\n', '   assign lsu_p.unsign = (i0_dp.lsu) ? i0_dp.unsign : i1_dp.unsign;\n', '\n', '   // defined register packet\n', '\n', '\n', '\n', '   assign i0r.rs1[4:0] = i0[19:15];\n', '   assign i0r.rs2[4:0] = i0[24:20];\n', '   assign i0r.rd[4:0] = i0[11:7];\n', '\n', '   assign i1r.rs1[4:0] = i1[19:15];\n', '   assign i1r.rs2[4:0] = i1[24:20];\n', '   assign i1r.rd[4:0] = i1[11:7];\n', '\n', '\n', ""   assign dec_i0_rs1_en_d = i0_dp.rs1 & (i0r.rs1[4:0] != 5'd0);  // if rs1_en=0 then read will be all 0's\n"", ""   assign dec_i0_rs2_en_d = i0_dp.rs2 & (i0r.rs2[4:0] != 5'd0);\n"", ""   assign i0_rd_en_d =  i0_dp.rd & (i0r.rd[4:0] != 5'd0);\n"", '\n', '   assign dec_i0_rs1_d[4:0] = i0r.rs1[4:0];\n', '   assign dec_i0_rs2_d[4:0] = i0r.rs2[4:0];\n', '   assign i0_rd_d[4:0] = i0r.rd[4:0];\n', '\n', '\n', '   assign i0_jalimm20 = i0_dp.jal & i0_dp.imm20;   // jal\n', '   assign i1_jalimm20 = i1_dp.jal & i1_dp.imm20;\n', '\n', '\n', '   assign i0_uiimm20 = ~i0_dp.jal & i0_dp.imm20;\n', '   assign i1_uiimm20 = ~i1_dp.jal & i1_dp.imm20;\n', '\n', '\n', '   // csr logic\n', '\n', '   assign dec_csr_ren_d = i0_dp.csr_read & i0_legal_decode_d;\n', '\n', '   assign csr_clr_d =   i0_dp.csr_clr   & i0_legal_decode_d;\n', '   assign csr_set_d   = i0_dp.csr_set   & i0_legal_decode_d;\n', '   assign csr_write_d = i0_csr_write    & i0_legal_decode_d;\n', '\n', '   assign i0_csr_write_only_d = i0_csr_write & ~i0_dp.csr_read;\n', '\n', ""   assign dec_csr_wen_unq_d = (i0_dp.csr_clr | i0_dp.csr_set | i0_csr_write);   // for csr legal, can't write read-only csr\n"", '\n', '   assign dec_csr_any_unq_d = any_csr_d;\n', '\n', '\n', '   assign dec_csr_rdaddr_d[11:0] = i0[31:20];\n', '   assign dec_csr_wraddr_wb[11:0] = wbd.csrwaddr[11:0];\n', '\n', '\n', ""   // make sure csr doesn't write same cycle as flush_lower_wb\n"", ""   // also use valid so it's flushable\n"", '   assign dec_csr_wen_wb = wbd.csrwen & wbd.i0valid & ~dec_tlu_i0_kill_writeb_wb;\n', '\n', '   // If we are writing MIE or MSTATUS, hold off the external interrupt for a cycle on the write.\n', ""   assign dec_csr_stall_int_ff = ((e4d.csrwaddr[11:0] == 12'h300) | (e4d.csrwaddr[11:0] == 12'h304)) & e4d.csrwen & e4d.i0valid & ~dec_tlu_i0_kill_writeb_wb;\n"", '\n', '\n', '   rvdffs #(5) csrmiscff (.*,\n', '                        .en(~freeze),\n', '                        .clk(active_clk),\n', '                        .din({ dec_csr_ren_d,  csr_clr_d,  csr_set_d,  csr_write_d,  i0_dp.csr_imm}),\n', '                        .dout({csr_read_e1,    csr_clr_e1, csr_set_e1, csr_write_e1, csr_imm_e1})\n', '                       );\n', '\n', '\n', '\n', '\n', '   // perform the update operation if any\n', '\n', '   rvdffe #(37) csr_data_e1ff (.*, .en(i0_e1_data_en), .din( {i0[19:15],dec_csr_rddata_d[31:0]}), .dout({csrimm_e1[4:0],csr_rddata_e1[31:0]}));\n', '\n', '\n', ""   assign csr_mask_e1[31:0] = ({32{ csr_imm_e1}} & {27'b0,csrimm_e1[4:0]}) |\n"", '                              ({32{~csr_imm_e1}} &  exu_csr_rs1_e1[31:0]);\n', '\n', '\n', '   assign write_csr_data_e1[31:0] = ({32{csr_clr_e1}}   & (csr_rddata_e1[31:0] & ~csr_mask_e1[31:0])) |\n', '                                    ({32{csr_set_e1}}   & (csr_rddata_e1[31:0] |  csr_mask_e1[31:0])) |\n', '                                    ({32{csr_write_e1}} & (                       csr_mask_e1[31:0]));\n', '\n', '\n', '// pause instruction\n', '//   logic pause_state_ff;\n', '\n', '   assign clear_pause = (dec_tlu_flush_lower_wb & ~dec_tlu_flush_pause_wb) |\n', ""                        (pause_state & (write_csr_data[31:1] == 31'b0));        // if 0 or 1 then exit pause state - 1 cycle pause\n"", '\n', '   assign pause_state_in = (dec_tlu_wr_pause_wb | pause_state) & ~clear_pause;\n', '\n', '   rvdff #(1) pause_state_f (.*, .clk(free_clk), .din(pause_state_in), .dout(pause_state));\n', '\n', '\n', '   assign dec_pause_state = pause_state;\n', '\n', '   rvdff #(2) pause_state_wb_ff (.*, .clk(free_clk), .din({dec_tlu_wr_pause_wb,tlu_wr_pause_wb1}), .dout({tlu_wr_pause_wb1,tlu_wr_pause_wb2}));\n', '\n', '\n', '   assign dec_pause_state_cg = pause_state & ~tlu_wr_pause_wb1 & ~tlu_wr_pause_wb2;\n', '\n', '\n', '// end pause\n', '\n', '   assign csr_data_wen = ((csr_clr_e1 | csr_set_e1 | csr_write_e1) & csr_read_e1 & ~freeze) | dec_tlu_wr_pause_wb | pause_state;\n', '\n', ""   assign write_csr_data_in[31:0] = (pause_state)         ? (write_csr_data[31:0] - 32'b1) :\n"", '                                    (dec_tlu_wr_pause_wb) ? dec_csr_wrdata_wb[31:0] : write_csr_data_e1[31:0];\n', '\n', '   // will hold until write-back at which time the CSR will be updated while GPR is possibly written with prior CSR\n', '   rvdffe #(32) write_csr_ff (.*, .en(csr_data_wen), .din(write_csr_data_in[31:0]), .dout(write_csr_data[31:0]));\n', '\n', '   assign pause_stall = pause_state;\n', '\n', '   // for csr write only data is produced by the alu\n', '   assign dec_csr_wrdata_wb[31:0] = (wbd.csrwonly) ? i0_result_wb[31:0] : write_csr_data[31:0];\n', '\n', '\n', '\n', '// read the csr value through rs2 immed port\n', '   assign dec_i0_immed_d[31:0] = ({32{ i0_dp.csr_read}} & dec_csr_rddata_d[31:0]) |\n', '                                 ({32{~i0_dp.csr_read}} & i0_immed_d[31:0]);\n', '\n', '// end csr stuff\n', '\n', '   assign     i0_immed_d[31:0] = ({32{i0_dp.imm12}} &   { {20{i0[31]}},i0[31:20] }) |  // jalr\n', ""                                 ({32{i0_dp.shimm5}} &    {27'b0, i0[24:20]}) |\n"", ""                                 ({32{i0_jalimm20}} &   { {12{i0[31]}},i0[19:12],i0[20],i0[30:21],1'b0}) |\n"", ""                                 ({32{i0_uiimm20}}  &     {i0[31:12],12'b0 }) |\n"", ""                                 ({32{i0_csr_write_only_d & i0_dp.csr_imm}} & {27'b0,i0[19:15]});  // for csr's that only write csr, dont read csr\n"", '\n', '\n', '//   assign dec_i0_br_immed_d[12:1] = ({12{ i0_ap.predict_nt }} &           {i0[31],i0[7],i0[30:25],i0[11:8]}) |\n', ""//                                    ({12{ i0_ap.predict_t | i0_ap.jal}} & {10'b0,i0_ap_pc4,i0_ap_pc2});\n"", '\n', '   // all conditional branches are currently predict_nt\n', '   // change this to generate the sequential address for all other cases for NPC requirements at commit\n', ""   assign dec_i0_br_immed_d[12:1] = (i0_ap.predict_nt & ~i0_dp.jal) ? i0_br_offset[11:0] : {10'b0,i0_ap_pc4,i0_ap_pc2};\n"", '\n', '\n', ""   assign dec_i1_rs1_en_d = i1_dp.rs1 & (i1r.rs1[4:0] != 5'd0);\n"", ""   assign dec_i1_rs2_en_d = i1_dp.rs2 & (i1r.rs2[4:0] != 5'd0);\n"", ""   assign i1_rd_en_d =  i1_dp.rd & (i1r.rd[4:0] != 5'd0);\n"", '\n', '   assign dec_i1_rs1_d[4:0] = i1r.rs1[4:0];\n', '   assign dec_i1_rs2_d[4:0] = i1r.rs2[4:0];\n', '   assign i1_rd_d[4:0] = i1r.rd[4:0];\n', '\n', '\n', '   assign dec_i1_immed_d[31:0] = ({32{i1_dp.imm12}} &   { {20{i1[31]}},i1[31:20] }) |\n', ""                                 ({32{i1_dp.shimm5}} &    {27'b0, i1[24:20]}) |\n"", ""                                 ({32{i1_jalimm20}} &   { {12{i1[31]}},i1[19:12],i1[20],i1[30:21],1'b0}) |\n"", ""                                 ({32{i1_uiimm20}}  &     {i1[31:12],12'b0 });\n"", '\n', '\n', '   // jal is always +2 or +4\n', ""   assign dec_i1_br_immed_d[12:1] = (i1_ap.predict_nt & ~i1_dp.jal) ? i1_br_offset[11:0] : {10'b0,i1_ap_pc4,i1_ap_pc2};\n"", '\n', '\n', '\n', '\n', '   assign last_br_immed_d[12:1] = (dec_i1_decode_d) ?\n', ""                                  ((i1_ap.predict_nt) ? {10'b0,i1_ap_pc4,i1_ap_pc2} : i1_br_offset[11:0] ) :\n"", ""                                  ((i0_ap.predict_nt) ? {10'b0,i0_ap_pc4,i0_ap_pc2} : i0_br_offset[11:0] );\n"", '\n', '   assign i0_valid_d = dec_ib0_valid_d;\n', '   assign i1_valid_d = dec_ib1_valid_d;\n', '\n', '\n', '\n', '   assign i0_load_stall_d = i0_dp.load & (lsu_load_stall_any | dma_dccm_stall_any);\n', '   assign i1_load_stall_d = i1_dp.load & (lsu_load_stall_any | dma_dccm_stall_any);\n', '\n', '   assign i0_store_stall_d =  i0_dp.store & (lsu_store_stall_any | dma_dccm_stall_any);\n', '   assign i1_store_stall_d =  i1_dp.store & (lsu_store_stall_any | dma_dccm_stall_any);\n', '\n', '   assign i1_depend_i0_d = (dec_i1_rs1_en_d & i0_dp.rd & (i1r.rs1[4:0] == i0r.rd[4:0])) |\n', '                           (dec_i1_rs2_en_d & i0_dp.rd & (i1r.rs2[4:0] == i0r.rd[4:0]));\n', '\n', '\n', '\n', '   assign i1_load2_block_d = i1_dp.lsu & i0_dp.lsu;\n', '\n', '\n', ""// some CSR reads need to be presync'd\n"", ""   assign i0_presync = i0_dp.presync | dec_tlu_presync_d | debug_fence_i | debug_fence_raw | dec_tlu_pipelining_disable;  // both fence's presync\n"", ""// some CSR writes need to be postsync'd\n"", '   assign i0_postsync = i0_dp.postsync | dec_tlu_postsync_d | debug_fence_i | // only fence_i postsync\n', ""                        (i0_csr_write_only_d & (i0[31:20] == 12'h7c2));   // wr_pause must postsync\n"", '\n', '   assign i1_mul2_block_d  = i1_dp.mul & i0_dp.mul;\n', '\n', '\n', '// debug fence csr\n', '\n', '   assign debug_fence_i     = dec_debug_fence_d & dbg_cmd_wrdata[0];\n', '   assign debug_fence_raw   = dec_debug_fence_d & dbg_cmd_wrdata[1];\n', '\n', '   assign debug_fence = debug_fence_raw | debug_fence_i;    // fence_i causes a fence\n', '\n', '\n', '   assign i0_csr_write = i0_dp.csr_write & ~dec_debug_fence_d;\n', '\n', '\n', '// end debug\n', '\n', '\n', '   // lets make ebreak, ecall, mret postsync, so break sync into pre and post\n', '\n', '   assign presync_stall = (i0_presync & prior_inflight_eff);\n', '\n', '   assign prior_inflight_eff = (i0_dp.div) ? prior_inflight_e1e3 : prior_inflight;\n', '\n', '   // to TLU to set dma_stall\n', '   assign dec_fence_pending = (i0_valid_d & i0_dp.fence) | debug_fence;\n', '\n', '   assign i0_block_d = (i0_dp.csr_read & prior_csr_write) |\n', '                       pause_stall |\n', '                       leak1_i0_stall |\n', '                       dec_tlu_debug_stall |\n', '                       postsync_stall |\n', '                       presync_stall  |\n', '                       ((i0_dp.fence | debug_fence) & ~lsu_idle) |\n', '                       i0_nonblock_load_stall |\n', '                       i0_load_block_d |\n', '                       i0_mul_block_d |\n', '                       i0_store_stall_d |\n', '                       i0_load_stall_d |\n', '                       i0_secondary_stall_d |  // for performance, dont make i0 secondary if i1 not alu and depends on i0\n', '                       i0_secondary_block_d;\n', '\n', '   assign i1_block_d = leak1_i1_stall |\n', '                      (i0_jal) |            // no i1 after a jal, will flush\n', ""              (((|dec_i0_trigger_match_d[3:0]) | ((i0_dp.condbr | i0_dp.jal) & i0_secondary_d)) & i1_dp.load ) | // if branch or branch error then don't allow i1 load\n"", '                       i0_presync | i0_postsync |\n', '                       i1_dp.presync | i1_dp.postsync |\n', '                       i1_icaf_d |        // instruction access fault is i0 only\n', '                       dec_i1_perr_d |    // instruction parity error is i0 only\n', '                       dec_i1_sbecc_d |\n', '                       i0_dp.csr_read |\n', '                       i0_dp.csr_write |\n', '                       i1_dp.csr_read |\n', '                       i1_dp.csr_write |  // optimized csr write with rd==0\n', '                       i1_nonblock_load_stall |\n', '                       i1_store_stall_d |\n', '                       i1_load_block_d |    // load data not ready\n', '                       i1_mul_block_d |     // mul data not ready\n', '                       (i1_depend_i0_d & ~non_block_case_d & ~store_data_bypass_i0_e2_c2) |\n', ""                       i1_load2_block_d |  // back-to-back load's at decode\n"", '                       i1_mul2_block_d |\n', '                       i1_load_stall_d |  // prior stores\n', '                       i1_secondary_block_d | // secondary alu data not ready and op is not alu\n', '                       dec_tlu_dual_issue_disable; // dual issue is disabled\n', '\n', '   // all legals go here\n', '\n', '   // block reads if there is a prior csr write in the pipeline\n', '   assign prior_csr_write = e1d.csrwonly |\n', '                            e2d.csrwonly |\n', '                            e3d.csrwonly |\n', '                            e4d.csrwonly |\n', '                            wbd.csrwonly;\n', '\n', '\n', '   assign any_csr_d = i0_dp.csr_read | i0_csr_write;\n', '\n', '\n', '   assign i0_legal = i0_dp.legal & (~any_csr_d | dec_csr_legal_d);\n', '\n', '   // illegal inst handling\n', '\n', '\n', '   assign shift_illegal = dec_i0_decode_d & ~i0_legal;\n', '\n', '   assign illegal_inst_en = shift_illegal & ~illegal_lockout & ~freeze;\n', '\n', ""   assign illegal_inst[31:0] = (dec_i0_pc4_d) ? i0[31:0] : { 16'b0, ifu_illegal_inst[15:0] };\n"", '\n', '   rvdffe #(32) illegal_any_ff (.*, .en(illegal_inst_en), .din(illegal_inst[31:0]), .dout(dec_illegal_inst[31:0]));\n', '\n', '   assign illegal_lockout_in = (shift_illegal | illegal_lockout) & ~flush_final_e3;\n', '\n', '   rvdffs #(1) illegal_lockout_any_ff (.*, .clk(active_clk), .en(~freeze), .din(illegal_lockout_in), .dout(illegal_lockout));\n', '\n', '\n', '\n', '   // allow illegals to flow down the pipe\n', '   assign dec_i0_decode_d = i0_valid_d & ~i0_block_d & ~flush_lower_wb & ~flush_final_e3 & ~freeze;\n', '\n', '   // define i0 legal decode\n', '   assign i0_legal_decode_d = dec_i0_decode_d & i0_legal & ~freeze;\n', '\n', ""   // only decode i1 if legal and i0 not illegal - csr's cant decode as i1\n"", '   //\n', '   assign dec_i1_decode_d = i0_legal_decode_d & i1_valid_d & i1_dp.legal & ~i1_block_d & ~freeze;\n', '\n', '   assign dec_ib0_valid_eff_d = i0_valid_d & ~dec_i0_decode_d;\n', '   assign dec_ib1_valid_eff_d = i1_valid_d & ~dec_i1_decode_d;\n', '\n', '\n', '\n', '   // performance monitor signals\n', '   assign dec_pmu_instr_decoded[1:0] = { dec_i1_decode_d, dec_i0_decode_d };\n', '\n', '   assign dec_pmu_decode_stall = i0_valid_d & ~dec_i0_decode_d;\n', '\n', '   assign dec_pmu_postsync_stall = postsync_stall;\n', '   assign dec_pmu_presync_stall  = presync_stall;\n', '\n', '\n', '\n', '   // illegals will postsync\n', ""   // jal's will flush, so postsync\n"", '   assign ps_stall_in =  (dec_i0_decode_d & (i0_jal | (i0_postsync) | ~i0_legal))  |\n', '                         (dec_i1_decode_d &  i1_jal ) |\n', '                         ((ps_stall & prior_inflight_e1e4) & ~div_wen_wb);\n', '\n', '\n', '    rvdffs #(1) postsync_stallff (.*, .clk(free_clk), .en(~freeze), .din(ps_stall_in), .dout(ps_stall));\n', '\n', '   assign postsync_stall = (ps_stall | div_stall);\n', '\n', '\n', '\n', '   assign prior_inflight_e1e3 =       |{ e1d.i0valid,\n', '                                         e2d.i0valid,\n', '                                         e3d.i0valid,\n', '                                         e1d.i1valid,\n', '                                         e2d.i1valid,\n', '                                         e3d.i1valid\n', '                                         };\n', '\n', '\n', '\n', '   assign prior_inflight_e1e4 =       |{ e1d.i0valid,\n', '                                         e2d.i0valid,\n', '                                         e3d.i0valid,\n', '                                         e4d.i0valid,\n', '                                         e1d.i1valid,\n', '                                         e2d.i1valid,\n', '                                         e3d.i1valid,\n', '                                         e4d.i1valid\n', '                                         };\n', '\n', '\n', '   assign prior_inflight_wb =            |{\n', '                                           wbd.i0valid,\n', '                                           wbd.i1valid\n', '                                           };\n', '\n', '   assign prior_inflight = prior_inflight_e1e4 | prior_inflight_wb;\n', '\n', '   assign dec_i0_alu_decode_d = i0_legal_decode_d & i0_dp.alu & ~i0_secondary_d;\n', '   assign dec_i1_alu_decode_d = dec_i1_decode_d & i1_dp.alu & ~i1_secondary_d;\n', '\n', '   assign dec_i0_lsu_decode_d = i0_legal_decode_d & i0_dp.lsu;\n', '\n', '   assign lsu_decode_d = (i0_legal_decode_d & i0_dp.lsu) |\n', '                         (dec_i1_decode_d & i1_dp.lsu);\n', '\n', '   assign mul_decode_d = (i0_legal_decode_d & i0_dp.mul) |\n', '                         (dec_i1_decode_d & i1_dp.mul);\n', '\n', '   assign div_decode_d = (i0_legal_decode_d & i0_dp.div) |\n', '                         (dec_i1_decode_d & i1_dp.div);\n', '\n', '\n', '\n', '\n', '   rvdffs #(2) flushff (.*, .en(~freeze), .clk(free_clk), .din({exu_i0_flush_final,exu_i1_flush_final}), .dout({i0_flush_final_e3, i1_flush_final_e3}));\n', '\n', '\n', '   assign flush_final_e3 = i0_flush_final_e3 | i1_flush_final_e3;\n', '\n', '\n', '\n', '\n', '\n', ""// scheduling logic for primary and secondary alu's\n"", '\n', '\n', '\n', '   assign i0_rs1_depend_i0_e1 = dec_i0_rs1_en_d & e1d.i0v & (e1d.i0rd[4:0] == i0r.rs1[4:0]);\n', '   assign i0_rs1_depend_i0_e2 = dec_i0_rs1_en_d & e2d.i0v & (e2d.i0rd[4:0] == i0r.rs1[4:0]);\n', '   assign i0_rs1_depend_i0_e3 = dec_i0_rs1_en_d & e3d.i0v & (e3d.i0rd[4:0] == i0r.rs1[4:0]);\n', '   assign i0_rs1_depend_i0_e4 = dec_i0_rs1_en_d & e4d.i0v & (e4d.i0rd[4:0] == i0r.rs1[4:0]);\n', '   assign i0_rs1_depend_i0_wb = dec_i0_rs1_en_d & wbd.i0v & (wbd.i0rd[4:0] == i0r.rs1[4:0]);\n', '\n', '   assign i0_rs1_depend_i1_e1 = dec_i0_rs1_en_d & e1d.i1v & (e1d.i1rd[4:0] == i0r.rs1[4:0]);\n', '   assign i0_rs1_depend_i1_e2 = dec_i0_rs1_en_d & e2d.i1v & (e2d.i1rd[4:0] == i0r.rs1[4:0]);\n', '   assign i0_rs1_depend_i1_e3 = dec_i0_rs1_en_d & e3d.i1v & (e3d.i1rd[4:0] == i0r.rs1[4:0]);\n', '   assign i0_rs1_depend_i1_e4 = dec_i0_rs1_en_d & e4d.i1v & (e4d.i1rd[4:0] == i0r.rs1[4:0]);\n', '   assign i0_rs1_depend_i1_wb = dec_i0_rs1_en_d & wbd.i1v & (wbd.i1rd[4:0] == i0r.rs1[4:0]);\n', '\n', '   assign i0_rs2_depend_i0_e1 = dec_i0_rs2_en_d & e1d.i0v & (e1d.i0rd[4:0] == i0r.rs2[4:0]);\n', '   assign i0_rs2_depend_i0_e2 = dec_i0_rs2_en_d & e2d.i0v & (e2d.i0rd[4:0] == i0r.rs2[4:0]);\n', '   assign i0_rs2_depend_i0_e3 = dec_i0_rs2_en_d & e3d.i0v & (e3d.i0rd[4:0] == i0r.rs2[4:0]);\n', '   assign i0_rs2_depend_i0_e4 = dec_i0_rs2_en_d & e4d.i0v & (e4d.i0rd[4:0] == i0r.rs2[4:0]);\n', '   assign i0_rs2_depend_i0_wb = dec_i0_rs2_en_d & wbd.i0v & (wbd.i0rd[4:0] == i0r.rs2[4:0]);\n', '\n', '   assign i0_rs2_depend_i1_e1 = dec_i0_rs2_en_d & e1d.i1v & (e1d.i1rd[4:0] == i0r.rs2[4:0]);\n', '   assign i0_rs2_depend_i1_e2 = dec_i0_rs2_en_d & e2d.i1v & (e2d.i1rd[4:0] == i0r.rs2[4:0]);\n', '   assign i0_rs2_depend_i1_e3 = dec_i0_rs2_en_d & e3d.i1v & (e3d.i1rd[4:0] == i0r.rs2[4:0]);\n', '   assign i0_rs2_depend_i1_e4 = dec_i0_rs2_en_d & e4d.i1v & (e4d.i1rd[4:0] == i0r.rs2[4:0]);\n', '   assign i0_rs2_depend_i1_wb = dec_i0_rs2_en_d & wbd.i1v & (wbd.i1rd[4:0] == i0r.rs2[4:0]);\n', '\n', '\n', '   assign i1_rs1_depend_i0_e1 = dec_i1_rs1_en_d & e1d.i0v & (e1d.i0rd[4:0] == i1r.rs1[4:0]);\n', '   assign i1_rs1_depend_i0_e2 = dec_i1_rs1_en_d & e2d.i0v & (e2d.i0rd[4:0] == i1r.rs1[4:0]);\n', '   assign i1_rs1_depend_i0_e3 = dec_i1_rs1_en_d & e3d.i0v & (e3d.i0rd[4:0] == i1r.rs1[4:0]);\n', '   assign i1_rs1_depend_i0_e4 = dec_i1_rs1_en_d & e4d.i0v & (e4d.i0rd[4:0] == i1r.rs1[4:0]);\n', '   assign i1_rs1_depend_i0_wb = dec_i1_rs1_en_d & wbd.i0v & (wbd.i0rd[4:0] == i1r.rs1[4:0]);\n', '\n', '   assign i1_rs1_depend_i1_e1 = dec_i1_rs1_en_d & e1d.i1v & (e1d.i1rd[4:0] == i1r.rs1[4:0]);\n', '   assign i1_rs1_depend_i1_e2 = dec_i1_rs1_en_d & e2d.i1v & (e2d.i1rd[4:0] == i1r.rs1[4:0]);\n', '   assign i1_rs1_depend_i1_e3 = dec_i1_rs1_en_d & e3d.i1v & (e3d.i1rd[4:0] == i1r.rs1[4:0]);\n', '   assign i1_rs1_depend_i1_e4 = dec_i1_rs1_en_d & e4d.i1v & (e4d.i1rd[4:0] == i1r.rs1[4:0]);\n', '   assign i1_rs1_depend_i1_wb = dec_i1_rs1_en_d & wbd.i1v & (wbd.i1rd[4:0] == i1r.rs1[4:0]);\n', '\n', '   assign i1_rs2_depend_i0_e1 = dec_i1_rs2_en_d & e1d.i0v & (e1d.i0rd[4:0] == i1r.rs2[4:0]);\n', '   assign i1_rs2_depend_i0_e2 = dec_i1_rs2_en_d & e2d.i0v & (e2d.i0rd[4:0] == i1r.rs2[4:0]);\n', '   assign i1_rs2_depend_i0_e3 = dec_i1_rs2_en_d & e3d.i0v & (e3d.i0rd[4:0] == i1r.rs2[4:0]);\n', '   assign i1_rs2_depend_i0_e4 = dec_i1_rs2_en_d & e4d.i0v & (e4d.i0rd[4:0] == i1r.rs2[4:0]);\n', '   assign i1_rs2_depend_i0_wb = dec_i1_rs2_en_d & wbd.i0v & (wbd.i0rd[4:0] == i1r.rs2[4:0]);\n', '\n', '   assign i1_rs2_depend_i1_e1 = dec_i1_rs2_en_d & e1d.i1v & (e1d.i1rd[4:0] == i1r.rs2[4:0]);\n', '   assign i1_rs2_depend_i1_e2 = dec_i1_rs2_en_d & e2d.i1v & (e2d.i1rd[4:0] == i1r.rs2[4:0]);\n', '   assign i1_rs2_depend_i1_e3 = dec_i1_rs2_en_d & e3d.i1v & (e3d.i1rd[4:0] == i1r.rs2[4:0]);\n', '   assign i1_rs2_depend_i1_e4 = dec_i1_rs2_en_d & e4d.i1v & (e4d.i1rd[4:0] == i1r.rs2[4:0]);\n', '   assign i1_rs2_depend_i1_wb = dec_i1_rs2_en_d & wbd.i1v & (wbd.i1rd[4:0] == i1r.rs2[4:0]);\n', '\n', '\n', '\n', '   rvdff #(2) freezeff (.*, .clk(active_clk), .din({freeze,freeze_prior1}), .dout({freeze_prior1,freeze_prior2}));\n', '\n', '   // take snapshot of e4 and wb\n', '   assign freeze_after_unfreeze1 = freeze & ~freeze_prior1;\n', '   assign freeze_after_unfreeze2 = freeze & ~freeze_prior1 & ~freeze_prior2;\n', '\n', '   assign unfreeze_cycle1 = ~freeze & freeze_prior1;\n', '   assign unfreeze_cycle2 = ~freeze & ~freeze_prior1 & freeze_prior2;\n', '\n', '   rvdffe #(32) freeze_i0_e4ff (.*, .en(freeze_after_unfreeze1), .din(i0_result_e4_final[31:0]), .dout(i0_result_e4_freeze[31:0]));\n', '   rvdffe #(32) freeze_i1_e4ff (.*, .en(freeze_after_unfreeze1), .din(i1_result_e4_final[31:0]), .dout(i1_result_e4_freeze[31:0]));\n', '\n', '\n', '   rvdffe #(32) freeze_i0_wbff (.*,\n', '                              .en(freeze_after_unfreeze1),\n', '                              .din( (freeze_after_unfreeze2) ? i0_result_wb[31:0] : i0_result_e4_freeze[31:0]),\n', '                              .dout(i0_result_wb_freeze[31:0])\n', '                              );\n', '\n', '   rvdffe #(32) freeze_i1_wbff (.*,\n', '                              .en(freeze_after_unfreeze1),\n', '                              .din( (freeze_after_unfreeze2) ? i1_result_wb[31:0] : i1_result_e4_freeze[31:0]),\n', '                              .dout(i1_result_wb_freeze[31:0])\n', '                              );\n', '\n', '\n', '\n', '// define bypasses for e2 stage - 1 is youngest\n', '\n', ""   assign dd.i0rs1bype2[1:0] = {  i0_dp.alu & i0_rs1_depth_d[3:0] == 4'd5 & i0_rs1_class_d.sec,\n"", ""                                  i0_dp.alu & i0_rs1_depth_d[3:0] == 4'd6 & i0_rs1_class_d.sec };\n"", '\n', ""   assign dd.i0rs2bype2[1:0] = {  i0_dp.alu & i0_rs2_depth_d[3:0] == 4'd5 & i0_rs2_class_d.sec,\n"", ""                                  i0_dp.alu & i0_rs2_depth_d[3:0] == 4'd6 & i0_rs2_class_d.sec };\n"", '\n', ""   assign dd.i1rs1bype2[1:0] = {  i1_dp.alu & i1_rs1_depth_d[3:0] == 4'd5 & i1_rs1_class_d.sec,\n"", ""                                  i1_dp.alu & i1_rs1_depth_d[3:0] == 4'd6 & i1_rs1_class_d.sec };\n"", '\n', ""   assign dd.i1rs2bype2[1:0] = {  i1_dp.alu & i1_rs2_depth_d[3:0] == 4'd5 & i1_rs2_class_d.sec,\n"", ""                                  i1_dp.alu & i1_rs2_depth_d[3:0] == 4'd6 & i1_rs2_class_d.sec };\n"", '\n', '\n', '   assign i1_result_wb_eff[31:0] = (unfreeze_cycle1) ? i1_result_wb_freeze[31:0] :\n', '                                   (unfreeze_cycle2) ? i1_result_e4_freeze[31:0] :\n', '                                   i1_result_wb[31:0];\n', '\n', '   assign i0_result_wb_eff[31:0] = (unfreeze_cycle1) ? i0_result_wb_freeze[31:0] :\n', '                                   (unfreeze_cycle2) ? i0_result_e4_freeze[31:0] :\n', '                                   i0_result_wb[31:0];\n', '\n', '\n', '   assign i0_rs1_bypass_data_e2[31:0] = ({32{e2d.i0rs1bype2[1]}} & i1_result_wb_eff[31:0]) |\n', '                                        ({32{e2d.i0rs1bype2[0]}} & i0_result_wb_eff[31:0]);\n', '\n', '   assign i0_rs2_bypass_data_e2[31:0] = ({32{e2d.i0rs2bype2[1]}} & i1_result_wb_eff[31:0]) |\n', '                                        ({32{e2d.i0rs2bype2[0]}} & i0_result_wb_eff[31:0]);\n', '\n', '   assign i1_rs1_bypass_data_e2[31:0] = ({32{e2d.i1rs1bype2[1]}} & i1_result_wb_eff[31:0]) |\n', '                                        ({32{e2d.i1rs1bype2[0]}} & i0_result_wb_eff[31:0]);\n', '\n', '   assign i1_rs2_bypass_data_e2[31:0] = ({32{e2d.i1rs2bype2[1]}} & i1_result_wb_eff[31:0]) |\n', '                                        ({32{e2d.i1rs2bype2[0]}} & i0_result_wb_eff[31:0]);\n', '\n', '\n', '   assign dec_i0_rs1_bypass_en_e2 = |e2d.i0rs1bype2[1:0];\n', '   assign dec_i0_rs2_bypass_en_e2 = |e2d.i0rs2bype2[1:0];\n', '   assign dec_i1_rs1_bypass_en_e2 = |e2d.i1rs1bype2[1:0];\n', '   assign dec_i1_rs2_bypass_en_e2 = |e2d.i1rs2bype2[1:0];\n', '\n', '\n', '\n', '\n', ""// define bypasses for e3 stage before secondary alu's\n"", '\n', '\n', '   assign i1_rs1_depend_i0_d = dec_i1_rs1_en_d & i0_dp.rd & (i1r.rs1[4:0] == i0r.rd[4:0]);\n', '   assign i1_rs2_depend_i0_d = dec_i1_rs2_en_d & i0_dp.rd & (i1r.rs2[4:0] == i0r.rd[4:0]);\n', '\n', '\n', '// i0\n', ""   assign dd.i0rs1bype3[3:0] = { i0_dp.alu & i0_rs1_depth_d[3:0]==4'd1 & (i0_rs1_class_d.sec | i0_rs1_class_d.load | i0_rs1_class_d.mul),\n"", ""                                 i0_dp.alu & i0_rs1_depth_d[3:0]==4'd2 & (i0_rs1_class_d.sec | i0_rs1_class_d.load | i0_rs1_class_d.mul),\n"", ""                                 i0_dp.alu & i0_rs1_depth_d[3:0]==4'd3 & (i0_rs1_class_d.sec | i0_rs1_class_d.load | i0_rs1_class_d.mul),\n"", ""                                 i0_dp.alu & i0_rs1_depth_d[3:0]==4'd4 & (i0_rs1_class_d.sec | i0_rs1_class_d.load | i0_rs1_class_d.mul) };\n"", '\n', ""   assign dd.i0rs2bype3[3:0] = { i0_dp.alu & i0_rs2_depth_d[3:0]==4'd1 & (i0_rs2_class_d.sec | i0_rs2_class_d.load | i0_rs2_class_d.mul),\n"", ""                                 i0_dp.alu & i0_rs2_depth_d[3:0]==4'd2 & (i0_rs2_class_d.sec | i0_rs2_class_d.load | i0_rs2_class_d.mul),\n"", ""                                 i0_dp.alu & i0_rs2_depth_d[3:0]==4'd3 & (i0_rs2_class_d.sec | i0_rs2_class_d.load | i0_rs2_class_d.mul),\n"", ""                                 i0_dp.alu & i0_rs2_depth_d[3:0]==4'd4 & (i0_rs2_class_d.sec | i0_rs2_class_d.load | i0_rs2_class_d.mul) };\n"", '\n', '// i1\n', '\n', '   assign i1rs1_intra[2:0] = {   i1_dp.alu & i0_dp.alu  & i1_rs1_depend_i0_d,\n', '                                 i1_dp.alu & i0_dp.mul  & i1_rs1_depend_i0_d,\n', '                                 i1_dp.alu & i0_dp.load & i1_rs1_depend_i0_d\n', '                                 };\n', '\n', '   assign i1rs2_intra[2:0] = {   i1_dp.alu & i0_dp.alu  & i1_rs2_depend_i0_d,\n', '                                 i1_dp.alu & i0_dp.mul  & i1_rs2_depend_i0_d,\n', '                                 i1_dp.alu & i0_dp.load & i1_rs2_depend_i0_d\n', '                                 };\n', '\n', '   assign i1_rs1_intra_bypass = |i1rs1_intra[2:0];\n', '\n', '   assign i1_rs2_intra_bypass = |i1rs2_intra[2:0];\n', '\n', '\n', '   assign dd.i1rs1bype3[6:0] = { i1rs1_intra[2:0],\n', ""                                 i1_dp.alu & i1_rs1_depth_d[3:0]==4'd1 & (i1_rs1_class_d.sec | i1_rs1_class_d.load | i1_rs1_class_d.mul) & ~i1_rs1_intra_bypass,\n"", ""                                 i1_dp.alu & i1_rs1_depth_d[3:0]==4'd2 & (i1_rs1_class_d.sec | i1_rs1_class_d.load | i1_rs1_class_d.mul) & ~i1_rs1_intra_bypass,\n"", ""                                 i1_dp.alu & i1_rs1_depth_d[3:0]==4'd3 & (i1_rs1_class_d.sec | i1_rs1_class_d.load | i1_rs1_class_d.mul) & ~i1_rs1_intra_bypass,\n"", ""                                 i1_dp.alu & i1_rs1_depth_d[3:0]==4'd4 & (i1_rs1_class_d.sec | i1_rs1_class_d.load | i1_rs1_class_d.mul) & ~i1_rs1_intra_bypass };\n"", '\n', '   assign dd.i1rs2bype3[6:0] = { i1rs2_intra[2:0],\n', ""                                 i1_dp.alu & i1_rs2_depth_d[3:0]==4'd1 & (i1_rs2_class_d.sec | i1_rs2_class_d.load | i1_rs2_class_d.mul) & ~i1_rs2_intra_bypass,\n"", ""                                 i1_dp.alu & i1_rs2_depth_d[3:0]==4'd2 & (i1_rs2_class_d.sec | i1_rs2_class_d.load | i1_rs2_class_d.mul) & ~i1_rs2_intra_bypass,\n"", ""                                 i1_dp.alu & i1_rs2_depth_d[3:0]==4'd3 & (i1_rs2_class_d.sec | i1_rs2_class_d.load | i1_rs2_class_d.mul) & ~i1_rs2_intra_bypass,\n"", ""                                 i1_dp.alu & i1_rs2_depth_d[3:0]==4'd4 & (i1_rs2_class_d.sec | i1_rs2_class_d.load | i1_rs2_class_d.mul) & ~i1_rs2_intra_bypass };\n"", '\n', '\n', '\n', '\n', '   assign dec_i0_rs1_bypass_en_e3 = |e3d.i0rs1bype3[3:0];\n', '   assign dec_i0_rs2_bypass_en_e3 = |e3d.i0rs2bype3[3:0];\n', '   assign dec_i1_rs1_bypass_en_e3 = |e3d.i1rs1bype3[6:0];\n', '   assign dec_i1_rs2_bypass_en_e3 = |e3d.i1rs2bype3[6:0];\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '   assign i1_result_e4_eff[31:0] = (unfreeze_cycle1) ? i1_result_e4_freeze[31:0] :\n', '                                   i1_result_e4_final[31:0];\n', '\n', '   assign i0_result_e4_eff[31:0] = (unfreeze_cycle1) ? i0_result_e4_freeze[31:0] :\n', '                                   i0_result_e4_final[31:0];\n', '\n', '\n', '   assign i0_rs1_bypass_data_e3[31:0] = ({32{e3d.i0rs1bype3[3]}} & i1_result_e4_eff[31:0]) |\n', '                                        ({32{e3d.i0rs1bype3[2]}} & i0_result_e4_eff[31:0]) |\n', '                                        ({32{e3d.i0rs1bype3[1]}} & i1_result_wb_eff[31:0]) |\n', '                                        ({32{e3d.i0rs1bype3[0]}} & i0_result_wb_eff[31:0]);\n', '\n', '   assign i0_rs2_bypass_data_e3[31:0] = ({32{e3d.i0rs2bype3[3]}} & i1_result_e4_eff[31:0]) |\n', '                                        ({32{e3d.i0rs2bype3[2]}} & i0_result_e4_eff[31:0]) |\n', '                                        ({32{e3d.i0rs2bype3[1]}} & i1_result_wb_eff[31:0]) |\n', '                                        ({32{e3d.i0rs2bype3[0]}} & i0_result_wb_eff[31:0]);\n', '\n', '   assign i1_rs1_bypass_data_e3[31:0] = ({32{e3d.i1rs1bype3[6]}} & i0_result_e3[31:0]) |\n', '                                        ({32{e3d.i1rs1bype3[5]}} & exu_mul_result_e3[31:0]) |\n', '                                        ({32{e3d.i1rs1bype3[4]}} & lsu_result_dc3[31:0]) |\n', '                                        ({32{e3d.i1rs1bype3[3]}} & i1_result_e4_eff[31:0]) |\n', '                                        ({32{e3d.i1rs1bype3[2]}} & i0_result_e4_eff[31:0]) |\n', '                                        ({32{e3d.i1rs1bype3[1]}} & i1_result_wb_eff[31:0]) |\n', '                                        ({32{e3d.i1rs1bype3[0]}} & i0_result_wb_eff[31:0]);\n', '\n', '\n', '   assign i1_rs2_bypass_data_e3[31:0] = ({32{e3d.i1rs2bype3[6]}} & i0_result_e3[31:0]) |\n', '                                        ({32{e3d.i1rs2bype3[5]}} & exu_mul_result_e3[31:0]) |\n', '                                        ({32{e3d.i1rs2bype3[4]}} & lsu_result_dc3[31:0]) |\n', '                                        ({32{e3d.i1rs2bype3[3]}} & i1_result_e4_eff[31:0]) |\n', '                                        ({32{e3d.i1rs2bype3[2]}} & i0_result_e4_eff[31:0]) |\n', '                                        ({32{e3d.i1rs2bype3[1]}} & i1_result_wb_eff[31:0]) |\n', '                                        ({32{e3d.i1rs2bype3[0]}} & i0_result_wb_eff[31:0]);\n', '\n', '\n', '\n', '\n', '// order the producers as follows:  i1_e1 - 1, i0_e1 - 2, i1_e2 - 3, ..., i1_wb - 9, i0_wb - 10\n', '\n', '\n', '   assign {i0_rs1_class_d, i0_rs1_depth_d[3:0]} =\n', ""                                                  (i0_rs1_depend_i1_e1) ? { i1_e1c, 4'd1 } :\n"", ""                                                  (i0_rs1_depend_i0_e1) ? { i0_e1c, 4'd2 } :\n"", ""                                                  (i0_rs1_depend_i1_e2) ? { i1_e2c, 4'd3 } :\n"", ""                                                  (i0_rs1_depend_i0_e2) ? { i0_e2c, 4'd4 } :\n"", ""                                                  (i0_rs1_depend_i1_e3) ? { i1_e3c, 4'd5 } :\n"", ""                                                  (i0_rs1_depend_i0_e3) ? { i0_e3c, 4'd6 } :\n"", ""                                                  (i0_rs1_depend_i1_e4) ? { i1_e4c, 4'd7 } :\n"", ""                                                  (i0_rs1_depend_i0_e4) ? { i0_e4c, 4'd8 } :\n"", ""                                                  (i0_rs1_depend_i1_wb) ? { i1_wbc, 4'd9 } :\n"", ""                                                  (i0_rs1_depend_i0_wb) ? { i0_wbc, 4'd10 } : '0;\n"", '\n', '   assign {i0_rs2_class_d, i0_rs2_depth_d[3:0]} =\n', ""                                                  (i0_rs2_depend_i1_e1) ? { i1_e1c, 4'd1 } :\n"", ""                                                  (i0_rs2_depend_i0_e1) ? { i0_e1c, 4'd2 } :\n"", ""                                                  (i0_rs2_depend_i1_e2) ? { i1_e2c, 4'd3 } :\n"", ""                                                  (i0_rs2_depend_i0_e2) ? { i0_e2c, 4'd4 } :\n"", ""                                                  (i0_rs2_depend_i1_e3) ? { i1_e3c, 4'd5 } :\n"", ""                                                  (i0_rs2_depend_i0_e3) ? { i0_e3c, 4'd6 } :\n"", ""                                                  (i0_rs2_depend_i1_e4) ? { i1_e4c, 4'd7 } :\n"", ""                                                  (i0_rs2_depend_i0_e4) ? { i0_e4c, 4'd8 } :\n"", ""                                                  (i0_rs2_depend_i1_wb) ? { i1_wbc, 4'd9 } :\n"", ""                                                  (i0_rs2_depend_i0_wb) ? { i0_wbc, 4'd10 } : '0;\n"", '\n', '   assign {i1_rs1_class_d, i1_rs1_depth_d[3:0]} =\n', ""                                                  (i1_rs1_depend_i1_e1) ? { i1_e1c, 4'd1 } :\n"", ""                                                  (i1_rs1_depend_i0_e1) ? { i0_e1c, 4'd2 } :\n"", ""                                                  (i1_rs1_depend_i1_e2) ? { i1_e2c, 4'd3 } :\n"", ""                                                  (i1_rs1_depend_i0_e2) ? { i0_e2c, 4'd4 } :\n"", ""                                                  (i1_rs1_depend_i1_e3) ? { i1_e3c, 4'd5 } :\n"", ""                                                  (i1_rs1_depend_i0_e3) ? { i0_e3c, 4'd6 } :\n"", ""                                                  (i1_rs1_depend_i1_e4) ? { i1_e4c, 4'd7 } :\n"", ""                                                  (i1_rs1_depend_i0_e4) ? { i0_e4c, 4'd8 } :\n"", ""                                                  (i1_rs1_depend_i1_wb) ? { i1_wbc, 4'd9 } :\n"", ""                                                  (i1_rs1_depend_i0_wb) ? { i0_wbc, 4'd10 } : '0;\n"", '\n', '   assign {i1_rs2_class_d, i1_rs2_depth_d[3:0]} =\n', ""                                                  (i1_rs2_depend_i1_e1) ? { i1_e1c, 4'd1 } :\n"", ""                                                  (i1_rs2_depend_i0_e1) ? { i0_e1c, 4'd2 } :\n"", ""                                                  (i1_rs2_depend_i1_e2) ? { i1_e2c, 4'd3 } :\n"", ""                                                  (i1_rs2_depend_i0_e2) ? { i0_e2c, 4'd4 } :\n"", ""                                                  (i1_rs2_depend_i1_e3) ? { i1_e3c, 4'd5 } :\n"", ""                                                  (i1_rs2_depend_i0_e3) ? { i0_e3c, 4'd6 } :\n"", ""                                                  (i1_rs2_depend_i1_e4) ? { i1_e4c, 4'd7 } :\n"", ""                                                  (i1_rs2_depend_i0_e4) ? { i0_e4c, 4'd8 } :\n"", ""                                                  (i1_rs2_depend_i1_wb) ? { i1_wbc, 4'd9 } :\n"", ""                                                  (i1_rs2_depend_i0_wb) ? { i0_wbc, 4'd10 } : '0;\n"", '\n', '\n', ""   assign i0_rs1_match_e1 = (i0_rs1_depth_d[3:0] == 4'd1 |\n"", ""                             i0_rs1_depth_d[3:0] == 4'd2);\n"", '\n', ""   assign i0_rs1_match_e2 = (i0_rs1_depth_d[3:0] == 4'd3 |\n"", ""                             i0_rs1_depth_d[3:0] == 4'd4);\n"", '\n', ""   assign i0_rs1_match_e3 = (i0_rs1_depth_d[3:0] == 4'd5 |\n"", ""                             i0_rs1_depth_d[3:0] == 4'd6);\n"", '\n', ""   assign i0_rs2_match_e1 = (i0_rs2_depth_d[3:0] == 4'd1 |\n"", ""                             i0_rs2_depth_d[3:0] == 4'd2);\n"", '\n', ""   assign i0_rs2_match_e2 = (i0_rs2_depth_d[3:0] == 4'd3 |\n"", ""                             i0_rs2_depth_d[3:0] == 4'd4);\n"", '\n', ""   assign i0_rs2_match_e3 = (i0_rs2_depth_d[3:0] == 4'd5 |\n"", ""                             i0_rs2_depth_d[3:0] == 4'd6);\n"", '\n', '   assign i0_rs1_match_e1_e2 = i0_rs1_match_e1 | i0_rs1_match_e2;\n', '   assign i0_rs1_match_e1_e3 = i0_rs1_match_e1 | i0_rs1_match_e2 | i0_rs1_match_e3;\n', '\n', '   assign i0_rs2_match_e1_e2 = i0_rs2_match_e1 | i0_rs2_match_e2;\n', '   assign i0_rs2_match_e1_e3 = i0_rs2_match_e1 | i0_rs2_match_e2 | i0_rs2_match_e3;\n', '\n', '\n', '\n', '\n', '\n', '   assign i0_secondary_d = ((i0_dp.alu & (i0_rs1_class_d.load | i0_rs1_class_d.mul) & i0_rs1_match_e1_e2) |\n', '                            (i0_dp.alu & (i0_rs2_class_d.load | i0_rs2_class_d.mul) & i0_rs2_match_e1_e2) |\n', '                            (i0_dp.alu & i0_rs1_class_d.sec & i0_rs1_match_e1_e3) |\n', '                            (i0_dp.alu & i0_rs2_class_d.sec & i0_rs2_match_e1_e3)) & ~disable_secondary;\n', '\n', ""  // stall i0 until it's not a secondary for performance\n"", '   assign i0_secondary_stall_d = ((i0_dp.alu & i1_rs1_depend_i0_d & ~i1_dp.alu & i0_secondary_d) |\n', '                                  (i0_dp.alu & i1_rs2_depend_i0_d & ~i1_dp.alu & ~i1_dp.store & i0_secondary_d)) & ~disable_secondary;\n', '\n', '\n', '\n', ""   assign i1_rs1_match_e1 = (i1_rs1_depth_d[3:0] == 4'd1 |\n"", ""                             i1_rs1_depth_d[3:0] == 4'd2);\n"", '\n', ""   assign i1_rs1_match_e2 = (i1_rs1_depth_d[3:0] == 4'd3 |\n"", ""                             i1_rs1_depth_d[3:0] == 4'd4);\n"", '\n', ""   assign i1_rs1_match_e3 = (i1_rs1_depth_d[3:0] == 4'd5 |\n"", ""                             i1_rs1_depth_d[3:0] == 4'd6);\n"", '\n', ""   assign i1_rs2_match_e1 = (i1_rs2_depth_d[3:0] == 4'd1 |\n"", ""                             i1_rs2_depth_d[3:0] == 4'd2);\n"", '\n', ""   assign i1_rs2_match_e2 = (i1_rs2_depth_d[3:0] == 4'd3 |\n"", ""                             i1_rs2_depth_d[3:0] == 4'd4);\n"", '\n', ""   assign i1_rs2_match_e3 = (i1_rs2_depth_d[3:0] == 4'd5 |\n"", ""                             i1_rs2_depth_d[3:0] == 4'd6);\n"", '\n', '   assign i1_rs1_match_e1_e2 = i1_rs1_match_e1 | i1_rs1_match_e2;\n', '   assign i1_rs1_match_e1_e3 = i1_rs1_match_e1 | i1_rs1_match_e2 | i1_rs1_match_e3;\n', '\n', '   assign i1_rs2_match_e1_e2 = i1_rs2_match_e1 | i1_rs2_match_e2;\n', '   assign i1_rs2_match_e1_e3 = i1_rs2_match_e1 | i1_rs2_match_e2 | i1_rs2_match_e3;\n', '\n', '\n', '\n', '\n', '   assign i1_secondary_d = ((i1_dp.alu & (i1_rs1_class_d.load | i1_rs1_class_d.mul) & i1_rs1_match_e1_e2) |\n', '                            (i1_dp.alu & (i1_rs2_class_d.load | i1_rs2_class_d.mul) & i1_rs2_match_e1_e2) |\n', '                            (i1_dp.alu & (i1_rs1_class_d.sec) & i1_rs1_match_e1_e3) |\n', '                            (i1_dp.alu & (i1_rs2_class_d.sec) & i1_rs2_match_e1_e3) |\n', '                            (non_block_case_d & i1_depend_i0_d)) & ~disable_secondary;\n', '\n', '\n', '\n', '   assign store_data_bypass_i0_e2_c2 = i0_dp.alu & ~i0_secondary_d & i1_rs2_depend_i0_d & ~i1_rs1_depend_i0_d & i1_dp.store;\n', '\n', '   assign non_block_case_d = (  // (i1_dp.alu & i0_dp.alu & ~i0_secondary_d) | - not a good idea, bad for performance\n', '                                (i1_dp.alu & i0_dp.load) |\n', '                                (i1_dp.alu & i0_dp.mul)\n', '                                ) & ~disable_secondary;\n', '\n', '\n', '\n', '\n', ""   assign store_data_bypass_c2 =  ((             i0_dp.store & i0_rs2_depth_d[3:0] == 4'd1 & i0_rs2_class_d.load) |\n"", ""                              (             i0_dp.store & i0_rs2_depth_d[3:0] == 4'd2 & i0_rs2_class_d.load) |\n"", ""                              (~i0_dp.lsu & i1_dp.store & i1_rs2_depth_d[3:0] == 4'd1 & i1_rs2_class_d.load) |\n"", ""                              (~i0_dp.lsu & i1_dp.store & i1_rs2_depth_d[3:0] == 4'd2 & i1_rs2_class_d.load));\n"", '\n', ""   assign store_data_bypass_c1 =  ((             i0_dp.store & i0_rs2_depth_d[3:0] == 4'd3 & i0_rs2_class_d.load) |\n"", ""                              (             i0_dp.store & i0_rs2_depth_d[3:0] == 4'd4 & i0_rs2_class_d.load) |\n"", ""                              (~i0_dp.lsu & i1_dp.store & i1_rs2_depth_d[3:0] == 4'd3 & i1_rs2_class_d.load) |\n"", ""                              (~i0_dp.lsu & i1_dp.store & i1_rs2_depth_d[3:0] == 4'd4 & i1_rs2_class_d.load));\n"", '\n', ""   assign load_ldst_bypass_c1 =  ((         (i0_dp.load | i0_dp.store) & i0_rs1_depth_d[3:0] == 4'd3 & i0_rs1_class_d.load) |\n"", ""                              (             (i0_dp.load | i0_dp.store) & i0_rs1_depth_d[3:0] == 4'd4 & i0_rs1_class_d.load) |\n"", ""                              (~i0_dp.lsu & (i1_dp.load | i1_dp.store) & i1_rs1_depth_d[3:0] == 4'd3 & i1_rs1_class_d.load) |\n"", ""                              (~i0_dp.lsu & (i1_dp.load | i1_dp.store) & i1_rs1_depth_d[3:0] == 4'd4 & i1_rs1_class_d.load));\n"", '\n', ""   assign load_mul_rs1_bypass_e1 =  ((             (i0_dp.mul) & i0_rs1_depth_d[3:0] == 4'd3 & i0_rs1_class_d.load) |\n"", ""                                     (             (i0_dp.mul) & i0_rs1_depth_d[3:0] == 4'd4 & i0_rs1_class_d.load) |\n"", ""                                     (~i0_dp.mul & (i1_dp.mul) & i1_rs1_depth_d[3:0] == 4'd3 & i1_rs1_class_d.load) |\n"", ""                                     (~i0_dp.mul & (i1_dp.mul) & i1_rs1_depth_d[3:0] == 4'd4 & i1_rs1_class_d.load));\n"", '\n', ""   assign load_mul_rs2_bypass_e1 =  ((             (i0_dp.mul) & i0_rs2_depth_d[3:0] == 4'd3 & i0_rs2_class_d.load) |\n"", ""                                     (             (i0_dp.mul) & i0_rs2_depth_d[3:0] == 4'd4 & i0_rs2_class_d.load) |\n"", ""                                     (~i0_dp.mul & (i1_dp.mul) & i1_rs2_depth_d[3:0] == 4'd3 & i1_rs2_class_d.load) |\n"", ""                                     (~i0_dp.mul & (i1_dp.mul) & i1_rs2_depth_d[3:0] == 4'd4 & i1_rs2_class_d.load));\n"", '\n', '\n', '   assign store_data_bypass_e4_c3[1:0] = {\n', ""                                      ( ~i0_dp.lsu & i1_dp.store & i1_rs2_depth_d[3:0] == 4'd1 & i1_rs2_class_d.sec ) |\n"", ""                                      (              i0_dp.store & i0_rs2_depth_d[3:0] == 4'd1 & i0_rs2_class_d.sec ),\n"", '\n', ""                                      ( ~i0_dp.lsu & i1_dp.store & i1_rs2_depth_d[3:0] == 4'd2 & i1_rs2_class_d.sec ) |\n"", ""                                      (              i0_dp.store & i0_rs2_depth_d[3:0] == 4'd2 & i0_rs2_class_d.sec )\n"", '                                     };\n', '\n', '   assign store_data_bypass_e4_c2[1:0] = {\n', ""                                      ( ~i0_dp.lsu & i1_dp.store & i1_rs2_depth_d[3:0] == 4'd3 & i1_rs2_class_d.sec ) |\n"", ""                                      (              i0_dp.store & i0_rs2_depth_d[3:0] == 4'd3 & i0_rs2_class_d.sec ),\n"", '\n', ""                                      ( ~i0_dp.lsu & i1_dp.store & i1_rs2_depth_d[3:0] == 4'd4 & i1_rs2_class_d.sec ) |\n"", ""                                      (              i0_dp.store & i0_rs2_depth_d[3:0] == 4'd4 & i0_rs2_class_d.sec )\n"", '                                     };\n', '\n', '\n', '   assign store_data_bypass_e4_c1[1:0] = {\n', ""                                      ( ~i0_dp.lsu & i1_dp.store & i1_rs2_depth_d[3:0] == 4'd5 & i1_rs2_class_d.sec ) |\n"", ""                                      (              i0_dp.store & i0_rs2_depth_d[3:0] == 4'd5 & i0_rs2_class_d.sec ),\n"", '\n', ""                                      ( ~i0_dp.lsu & i1_dp.store & i1_rs2_depth_d[3:0] == 4'd6 & i1_rs2_class_d.sec ) |\n"", ""                                      (              i0_dp.store & i0_rs2_depth_d[3:0] == 4'd6 & i0_rs2_class_d.sec )\n"", '                                     };\n', '\n', '\n', '\n', '   assign i0_not_alu_eff = (~i0_dp.alu | disable_secondary);\n', '   assign i1_not_alu_eff = (~i1_dp.alu | disable_secondary);\n', '\n', '// stores will bypass load data in the lsu pipe\n', '   assign i0_load_block_d = (i0_not_alu_eff & i0_rs1_class_d.load & i0_rs1_match_e1) |\n', '                            (i0_not_alu_eff & i0_rs1_class_d.load & i0_rs1_match_e2 & ~i0_dp.load & ~i0_dp.store & ~i0_dp.mul) | // can bypass load to address of load/store\n', '                            (i0_not_alu_eff & i0_rs2_class_d.load & i0_rs2_match_e1 & ~i0_dp.store) |\n', '                            (i0_not_alu_eff & i0_rs2_class_d.load & i0_rs2_match_e2 & ~i0_dp.store & ~i0_dp.mul);\n', '\n', '   assign i1_load_block_d = (i1_not_alu_eff & i1_rs1_class_d.load & i1_rs1_match_e1) |\n', '                            (i1_not_alu_eff & i1_rs1_class_d.load & i1_rs1_match_e2 & ~i1_dp.load & ~i1_dp.store & ~i1_dp.mul) |\n', '                            (i1_not_alu_eff & i1_rs2_class_d.load & i1_rs2_match_e1 & ~i1_dp.store) |\n', '                            (i1_not_alu_eff & i1_rs2_class_d.load & i1_rs2_match_e2 & ~i1_dp.store & ~i1_dp.mul);\n', '\n', '   assign i0_mul_block_d = (i0_not_alu_eff & i0_rs1_class_d.mul & i0_rs1_match_e1_e2) |\n', '                           (i0_not_alu_eff & i0_rs2_class_d.mul & i0_rs2_match_e1_e2);\n', '\n', '   assign i1_mul_block_d = (i1_not_alu_eff & i1_rs1_class_d.mul & i1_rs1_match_e1_e2) |\n', '                           (i1_not_alu_eff & i1_rs2_class_d.mul & i1_rs2_match_e1_e2);\n', '\n', '   assign i0_secondary_block_d = ((~i0_dp.alu & i0_rs1_class_d.sec & i0_rs1_match_e1_e3) |\n', '                                  (~i0_dp.alu & i0_rs2_class_d.sec & i0_rs2_match_e1_e3 & ~i0_dp.store)) & ~disable_secondary;\n', '\n', '   assign i1_secondary_block_d = ((~i1_dp.alu & i1_rs1_class_d.sec & i1_rs1_match_e1_e3) |\n', '                                  (~i1_dp.alu & i1_rs2_class_d.sec & i1_rs2_match_e1_e3 & ~i1_dp.store) & ~disable_secondary);\n', '\n', '\n', '   // use this to flop the npc address of a divide for externals\n', '   // this logic will change for delay wb of divides\n', '   assign dec_div_decode_e4 = e4d.i0div;\n', '\n', '\n', '   assign dec_tlu_i0_valid_e4 = (e4d.i0valid & ~e4d.i0div & ~flush_lower_wb) | exu_div_finish;\n', '   assign dec_tlu_i1_valid_e4 = e4d.i1valid & ~flush_lower_wb;\n', '\n', '\n', '\n', '   assign dt.legal     =  i0_legal_decode_d                ;\n', '   assign dt.icaf      =  i0_icaf_d & i0_legal_decode_d;            // dbecc is icaf exception\n', '   assign dt.icaf_second   =  dec_i0_icaf_second_d & i0_legal_decode_d;     // this includes icaf and dbecc\n', '   assign dt.perr      =   dec_i0_perr_d & i0_legal_decode_d;\n', '   assign dt.sbecc     =   dec_i0_sbecc_d & i0_legal_decode_d;\n', '   assign dt.fence_i   = (i0_dp.fence_i | debug_fence_i) & i0_legal_decode_d;\n', '\n', '// put pmu info into the trap packet\n', '   assign dt.pmu_i0_itype = i0_itype;\n', '   assign dt.pmu_i1_itype = i1_itype;\n', '   assign dt.pmu_i0_br_unpred = i0_br_unpred;\n', '   assign dt.pmu_i1_br_unpred = i1_br_unpred;\n', ""   assign dt.pmu_divide = 1'b0;\n"", ""   assign dt.pmu_lsu_misaligned = 1'b0;\n"", '\n', '   assign dt.i0trigger[3:0] = dec_i0_trigger_match_d[3:0] & {4{dec_i0_decode_d & ~i0_div_decode_d}};\n', '   assign dt.i1trigger[3:0] = dec_i1_trigger_match_d[3:0] & {4{dec_i1_decode_d}};\n', '\n', '\n', '\n', '   rvdffe #( $bits(trap_pkt_t) ) trap_e1ff (.*, .en(i0_e1_ctl_en), .din( dt),  .dout(e1t));\n', '\n', '   always_comb begin\n', '      e1t_in = e1t;\n', '      e1t_in.i0trigger[3:0] = e1t.i0trigger & ~{4{flush_final_e3}};\n', '      e1t_in.i1trigger[3:0] = e1t.i1trigger & ~{4{flush_final_e3}};\n', '   end\n', '\n', '   rvdffe #( $bits(trap_pkt_t) ) trap_e2ff (.*, .en(i0_e2_ctl_en), .din(e1t_in),  .dout(e2t));\n', '\n', '   always_comb begin\n', '      e2t_in = e2t;\n', '      e2t_in.i0trigger[3:0] = e2t.i0trigger & ~{4{flush_final_e3 | flush_lower_wb}};\n', '      e2t_in.i1trigger[3:0] = e2t.i1trigger & ~{4{flush_final_e3 | flush_lower_wb}};\n', '   end\n', '\n', '   rvdffe  #($bits(trap_pkt_t) ) trap_e3ff (.*, .en(i0_e3_ctl_en), .din(e2t_in),  .dout(e3t));\n', '\n', '\n', '    always_comb begin\n', '      e3t_in = e3t;\n', '\n', '       e3t_in.i0trigger[3:0] = ({4{(e3d.i0load | e3d.i0store)}} & lsu_trigger_match_dc3[3:0]) | e3t.i0trigger[3:0];\n', '       e3t_in.i1trigger[3:0] = ~{4{i0_flush_final_e3}} & (({4{~(e3d.i0load | e3d.i0store)}} & lsu_trigger_match_dc3[3:0]) | e3t.i1trigger[3:0]);\n', '\n', '       e3t_in.pmu_lsu_misaligned = lsu_pmu_misaligned_dc3;   // only valid if a load/store is valid in e3 stage\n', '\n', ""      if (freeze | flush_lower_wb) e3t_in = '0 ;\n"", '   end\n', '\n', '\n', '   rvdffe #( $bits(trap_pkt_t) ) trap_e4ff (.*, .en(i0_e4_ctl_en), .din(e3t_in),  .dout(e4t));\n', '\n', '\n', '\n', '   assign freeze_e3 = freeze & ~freeze_before;\n', '\n', '   rvdff #(1) freeze_before_ff (.*, .clk(active_clk), .din(freeze), .dout(freeze_before));\n', '\n', '   rvdff #(1) freeze_e4_ff     (.*, .clk(active_clk), .din(freeze_e3), .dout(freeze_e4));\n', '\n', '// these signals pipe down in the event of a freeze at dc3, needed by trap to compute triggers for a load\n', '   rvdffe #(9) e4_trigger_ff   (.*, .en(freeze_e3), .din({e3d.i0load,e3t.i0trigger[3:0],e3t.i1trigger[3:0]}), .dout({e4d_i0load,e4t_i0trigger[3:0],e4t_i1trigger[3:0]}));\n', '\n', '   always_comb begin\n', '\n', '      if (exu_div_finish)    // wipe data for exu_div_finish - safer\n', ""        dec_tlu_packet_e4 = '0;\n"", '      else\n', '        dec_tlu_packet_e4 = e4t;\n', '\n', '      dec_tlu_packet_e4.legal = e4t.legal | exu_div_finish;\n', '      dec_tlu_packet_e4.i0trigger[3:0] = (exu_div_finish) ? div_trigger[3:0] : e4t.i0trigger[3:0];\n', '\n', '      dec_tlu_packet_e4.pmu_divide = exu_div_finish;\n', '\n', '      if (freeze_e4) begin  // in case of freeze, pipe down trigger information\n', '         dec_tlu_packet_e4.i0trigger[3:0] = e4t_i0trigger[3:0];\n', '         dec_tlu_packet_e4.i1trigger[3:0] = e4t_i1trigger[3:0];\n', '      end\n', '\n', '   end\n', '\n', '   assign dec_i0_load_e4 = e4d_i0load;\n', '\n', '\n', '//   assign dec_tlu_packet_e4 = e4t;\n', '\n', '\n', '\n', '// end tlu stuff\n', '\n', '\n', '\n', '   assign i0_dc.mul   = i0_dp.mul & i0_legal_decode_d;\n', '   assign i0_dc.load  = i0_dp.load & i0_legal_decode_d;\n', '   assign i0_dc.sec = i0_dp.alu &  i0_secondary_d & i0_legal_decode_d;\n', '   assign i0_dc.alu = i0_dp.alu & ~i0_secondary_d & i0_legal_decode_d;\n', '\n', '   rvdffs #( $bits(class_pkt_t) ) i0_e1c_ff (.*, .en(i0_e1_ctl_en), .clk(active_clk), .din(i0_dc),   .dout(i0_e1c));\n', '   rvdffs #( $bits(class_pkt_t) ) i0_e2c_ff (.*, .en(i0_e2_ctl_en), .clk(active_clk), .din(i0_e1c),  .dout(i0_e2c));\n', '   rvdffs #( $bits(class_pkt_t) ) i0_e3c_ff (.*, .en(i0_e3_ctl_en), .clk(active_clk), .din(i0_e2c),  .dout(i0_e3c));\n', '\n', ""   assign i0_e4c_in = (freeze) ? '0 : i0_e3c;\n"", '\n', '   rvdffs  #( $bits(class_pkt_t) ) i0_e4c_ff (.*, .en(i0_e4_ctl_en),              .clk(active_clk), .din(i0_e4c_in), .dout(i0_e4c));\n', '\n', '   rvdffs  #( $bits(class_pkt_t) ) i0_wbc_ff (.*, .en(i0_wb_ctl_en),              .clk(active_clk), .din(i0_e4c),    .dout(i0_wbc));\n', '\n', '\n', '   assign i1_dc.mul   = i1_dp.mul & dec_i1_decode_d;\n', '   assign i1_dc.load  = i1_dp.load & dec_i1_decode_d;\n', '   assign i1_dc.sec = i1_dp.alu &  i1_secondary_d & dec_i1_decode_d;\n', '   assign i1_dc.alu = i1_dp.alu & ~i1_secondary_d & dec_i1_decode_d;\n', '\n', '   rvdffs #( $bits(class_pkt_t) ) i1_e1c_ff (.*, .en(i0_e1_ctl_en), .clk(active_clk), .din(i1_dc),   .dout(i1_e1c));\n', '   rvdffs #( $bits(class_pkt_t) ) i1_e2c_ff (.*, .en(i0_e2_ctl_en), .clk(active_clk), .din(i1_e1c),  .dout(i1_e2c));\n', '   rvdffs #( $bits(class_pkt_t) ) i1_e3c_ff (.*, .en(i0_e3_ctl_en), .clk(active_clk), .din(i1_e2c),  .dout(i1_e3c));\n', '\n', ""   assign i1_e4c_in = (freeze) ? '0 : i1_e3c;\n"", '\n', '   rvdffs #( $bits(class_pkt_t) ) i1_e4c_ff (.*, .en(i0_e4_ctl_en), .clk(active_clk), .din(i1_e4c_in), .dout(i1_e4c));\n', '\n', '   rvdffs #( $bits(class_pkt_t) ) i1_wbc_ff (.*, .en(i0_wb_ctl_en), .clk(active_clk), .din(i1_e4c),    .dout(i1_wbc));\n', '\n', '\n', '   assign dd.i0rd[4:0] = i0r.rd[4:0];\n', '   assign dd.i0v = i0_rd_en_d & i0_legal_decode_d;\n', '   assign dd.i0valid =              dec_i0_decode_d;  // has flush_final_e3\n', '\n', '   assign dd.i0mul = i0_dp.mul & i0_legal_decode_d;\n', '   assign dd.i0load = i0_dp.load & i0_legal_decode_d;\n', '   assign dd.i0store = i0_dp.store & i0_legal_decode_d;\n', '   assign dd.i0div = i0_dp.div & i0_legal_decode_d;\n', '   assign dd.i0secondary = i0_secondary_d & i0_legal_decode_d;\n', '\n', '\n', '   assign dd.i1rd[4:0] = i1r.rd[4:0];\n', '   assign dd.i1v = i1_rd_en_d & dec_i1_decode_d;\n', '   assign dd.i1valid =              dec_i1_decode_d;\n', '   assign dd.i1mul = i1_dp.mul;\n', '   assign dd.i1load = i1_dp.load;\n', '   assign dd.i1store = i1_dp.store;\n', '   assign dd.i1secondary = i1_secondary_d & dec_i1_decode_d;\n', '\n', '   assign dd.csrwen = dec_csr_wen_unq_d & i0_legal_decode_d;\n', '   assign dd.csrwonly = i0_csr_write_only_d & dec_i0_decode_d;\n', '   assign dd.csrwaddr[11:0] = i0[31:20];    // csr write address for rd==0 case\n', '\n', '\n', '   assign i0_pipe_en[5] = dec_i0_decode_d;\n', '\n', '   rvdffs #(3) i0cg0ff (.*, .clk(active_clk), .en(~freeze), .din(i0_pipe_en[5:3]), .dout(i0_pipe_en[4:2]));\n', '   rvdff  #(2) i0cg1ff (.*, .clk(active_clk),               .din(i0_pipe_en[2:1]), .dout(i0_pipe_en[1:0]));\n', '\n', '\n', '   assign i0_e1_ctl_en = (|i0_pipe_en[5:4] | clk_override) & ~freeze;\n', '   assign i0_e2_ctl_en = (|i0_pipe_en[4:3] | clk_override) & ~freeze;\n', '   assign i0_e3_ctl_en = (|i0_pipe_en[3:2] | clk_override) & ~freeze;\n', '   assign i0_e4_ctl_en = (|i0_pipe_en[2:1] | clk_override);\n', '   assign i0_wb_ctl_en = (|i0_pipe_en[1:0] | clk_override);\n', '\n', '   assign i0_e1_data_en = (i0_pipe_en[5] | clk_override) & ~freeze;\n', '   assign i0_e2_data_en = (i0_pipe_en[4] | clk_override) & ~freeze;\n', '   assign i0_e3_data_en = (i0_pipe_en[3] | clk_override) & ~freeze;\n', '   assign i0_e4_data_en = (i0_pipe_en[2] | clk_override);\n', '   assign i0_wb_data_en = (i0_pipe_en[1] | clk_override);\n', '   assign i0_wb1_data_en = (i0_pipe_en[0] | clk_override);\n', '\n', '   assign dec_i0_data_en[4:2] = {i0_e1_data_en, i0_e2_data_en, i0_e3_data_en};\n', '   assign dec_i0_ctl_en[4:1]  = {i0_e1_ctl_en, i0_e2_ctl_en, i0_e3_ctl_en, i0_e4_ctl_en};\n', '\n', '\n', '   assign i1_pipe_en[5] = dec_i1_decode_d;\n', '\n', '   rvdffs #(3) i1cg0ff (.*, .clk(free_clk), .en(~freeze), .din(i1_pipe_en[5:3]), .dout(i1_pipe_en[4:2]));\n', '   rvdff  #(2) i1cg1ff (.*, .clk(free_clk),               .din(i1_pipe_en[2:1]), .dout(i1_pipe_en[1:0]));\n', '\n', '\n', '   assign i1_e1_ctl_en = (|i1_pipe_en[5:4] | clk_override) & ~freeze;\n', '   assign i1_e2_ctl_en = (|i1_pipe_en[4:3] | clk_override) & ~freeze;\n', '   assign i1_e3_ctl_en = (|i1_pipe_en[3:2] | clk_override) & ~freeze;\n', '   assign i1_e4_ctl_en = (|i1_pipe_en[2:1] | clk_override);\n', '   assign i1_wb_ctl_en = (|i1_pipe_en[1:0] | clk_override);\n', '\n', '   assign i1_e1_data_en = (i1_pipe_en[5] | clk_override) & ~freeze;\n', '   assign i1_e2_data_en = (i1_pipe_en[4] | clk_override) & ~freeze;\n', '   assign i1_e3_data_en = (i1_pipe_en[3] | clk_override) & ~freeze;\n', '   assign i1_e4_data_en = (i1_pipe_en[2] | clk_override);\n', '   assign i1_wb_data_en = (i1_pipe_en[1] | clk_override);\n', '   assign i1_wb1_data_en = (i1_pipe_en[0] | clk_override);\n', '\n', '   assign dec_i1_data_en[4:2] = {i1_e1_data_en, i1_e2_data_en, i1_e3_data_en};\n', '   assign dec_i1_ctl_en[4:1]  = {i1_e1_ctl_en, i1_e2_ctl_en, i1_e3_ctl_en, i1_e4_ctl_en};\n', '\n', '   rvdffe #( $bits(dest_pkt_t) ) e1ff (.*, .en(i0_e1_ctl_en), .din(dd),  .dout(e1d));\n', '\n', '   always_comb begin\n', '      e1d_in = e1d;\n', '\n', '      e1d_in.i0v = e1d.i0v & ~flush_final_e3;\n', '      e1d_in.i1v = e1d.i1v & ~flush_final_e3;\n', '      e1d_in.i0valid = e1d.i0valid & ~flush_final_e3;\n', '      e1d_in.i1valid = e1d.i1valid & ~flush_final_e3;\n', '      e1d_in.i0secondary = e1d.i0secondary & ~flush_final_e3;\n', '      e1d_in.i1secondary = e1d.i1secondary & ~flush_final_e3;\n', '   end\n', '\n', '   assign dec_i1_valid_e1 = e1d.i1valid;\n', '\n', '\n', '   rvdffe #( $bits(dest_pkt_t) ) e2ff (.*, .en(i0_e2_ctl_en), .din(e1d_in), .dout(e2d));\n', '\n', '   always_comb begin\n', '      e2d_in = e2d;\n', '\n', '      e2d_in.i0v = e2d.i0v &         ~flush_final_e3 & ~flush_lower_wb;\n', '      e2d_in.i1v = e2d.i1v &         ~flush_final_e3 & ~flush_lower_wb;\n', '      e2d_in.i0valid = e2d.i0valid & ~flush_final_e3 & ~flush_lower_wb;\n', '      e2d_in.i1valid = e2d.i1valid & ~flush_final_e3 & ~flush_lower_wb;\n', '      e2d_in.i0secondary = e2d.i0secondary & ~flush_final_e3 & ~flush_lower_wb;\n', '      e2d_in.i1secondary = e2d.i1secondary & ~flush_final_e3 & ~flush_lower_wb;\n', '   end\n', '\n', '   rvdffe #( $bits(dest_pkt_t) ) e3ff (.*, .en(i0_e3_ctl_en), .din(e2d_in), .dout(e3d));\n', '\n', '   always_comb begin\n', '      e3d_in = e3d;\n', '\n', '      e3d_in.i0v = e3d.i0v                              & ~flush_lower_wb;\n', '      e3d_in.i0valid = e3d.i0valid                      & ~flush_lower_wb;\n', '\n', '      e3d_in.i0secondary = e3d.i0secondary & ~flush_lower_wb;\n', '\n', '      e3d_in.i1v = e3d.i1v         & ~i0_flush_final_e3 & ~flush_lower_wb;\n', '      e3d_in.i1valid = e3d.i1valid & ~i0_flush_final_e3 & ~flush_lower_wb;\n', '\n', '      e3d_in.i1secondary = e3d.i1secondary & ~i0_flush_final_e3 & ~flush_lower_wb;\n', '\n', ""      if (freeze) e3d_in = '0;\n"", '\n', '   end\n', '\n', '\n', '   assign dec_i0_sec_decode_e3 = e3d.i0secondary & ~flush_lower_wb & ~freeze;\n', '   assign dec_i1_sec_decode_e3 = e3d.i1secondary & ~i0_flush_final_e3 & ~flush_lower_wb & ~freeze;\n', '\n', '\n', '\n', '   rvdffe #( $bits(dest_pkt_t) ) e4ff (.*, .en(i0_e4_ctl_en), .din(e3d_in), .dout(e4d));\n', '\n', '   always_comb begin\n', '\n', '      if (exu_div_finish)    // wipe data for exu_div_finish - bug where csr_wen was set for fast divide\n', ""        e4d_in = '0;\n"", '      else\n', '        e4d_in = e4d;\n', '\n', '\n', '      e4d_in.i0rd[4:0] = (exu_div_finish) ? div_waddr_wb[4:0] : e4d.i0rd[4:0];\n', '\n', ""      e4d_in.i0v = (e4d.i0v         & ~e4d.i0div & ~flush_lower_wb) | (exu_div_finish & div_waddr_wb[4:0]!=5'b0);\n"", '      e4d_in.i0valid = (e4d.i0valid              & ~flush_lower_wb) | exu_div_finish;\n', '      // qual the following with div finish; necessary for divides with early exit\n', '      e4d_in.i0secondary = e4d.i0secondary & ~flush_lower_wb & ~exu_div_finish;\n', '      e4d_in.i0load = e4d.i0load & ~flush_lower_wb & ~exu_div_finish;\n', '      e4d_in.i0store = e4d.i0store & ~flush_lower_wb & ~exu_div_finish;\n', '\n', '      e4d_in.i1v = e4d.i1v         & ~flush_lower_wb;\n', '      e4d_in.i1valid = e4d.i1valid & ~flush_lower_wb;\n', '      e4d_in.i1secondary = e3d.i1secondary & ~flush_lower_wb;\n', '\n', '   end\n', '\n', '\n', '   rvdffe #( $bits(dest_pkt_t) ) wbff (.*, .en(i0_wb_ctl_en | exu_div_finish | div_wen_wb), .din(e4d_in), .dout(wbd));\n', '\n', '   assign dec_i0_waddr_wb[4:0] = wbd.i0rd[4:0];\n', '\n', ""   // squash same write, take last write assuming we don't kill the I1 write for some reason.\n"", '   assign     i0_wen_wb = wbd.i0v & ~(~dec_tlu_i1_kill_writeb_wb & ~i1_load_kill_wen & wbd.i0v & wbd.i1v & (wbd.i0rd[4:0] == wbd.i1rd[4:0])) & ~dec_tlu_i0_kill_writeb_wb;\n', ""   assign dec_i0_wen_wb = i0_wen_wb & ~i0_load_kill_wen;  // don't write a nonblock load 1st time down the pipe\n"", '\n', '   assign dec_i0_wdata_wb[31:0] = i0_result_wb[31:0];\n', '\n', '   assign dec_i1_waddr_wb[4:0] = wbd.i1rd[4:0];\n', '\n', '   assign     i1_wen_wb = wbd.i1v & ~dec_tlu_i1_kill_writeb_wb;\n', '   assign dec_i1_wen_wb = i1_wen_wb & ~i1_load_kill_wen;\n', '\n', '   assign dec_i1_wdata_wb[31:0] = i1_result_wb[31:0];\n', '\n', '// divide stuff\n', '\n', '\n', '   assign div_stall = exu_div_stall | div_stall_ff;   // hold for 1 extra cycle so wb can happen before next inst\n', '\n', '   rvdff  #(1) divstallff (.*, .clk(active_clk), .din(exu_div_stall), .dout(div_stall_ff));\n', '\n', '\n', '   assign i0_div_decode_d = i0_legal_decode_d & i0_dp.div;\n', '\n', '   rvdffe #(31) divpcff (.*, .en(i0_div_decode_d), .din(dec_i0_pc_d[31:1]), .dout(div_pc[31:1]));\n', '\n', '   rvdffs #(4) divtriggerff (.*, .en(i0_div_decode_d), .clk(active_clk), .din(dec_i0_trigger_match_d[3:0]), .dout(div_trigger[3:0]));\n', '\n', '   rvdffs #(5) divwbaddrff (.*, .en(i0_div_decode_d), .clk(active_clk), .din(i0r.rd[4:0]), .dout(div_waddr_wb[4:0]));\n', '\n', '   // active_clk -> used for clockgating for wb stage ctl logic\n', '   rvdff  #(1) divwbff (.*, .clk(active_clk), .din(exu_div_finish), .dout(div_wen_wb));\n', '\n', '\n', '   assign i0_result_e1[31:0] = exu_i0_result_e1[31:0];\n', '   assign i1_result_e1[31:0] = exu_i1_result_e1[31:0];\n', '\n', '   // pipe the results down the pipe\n', '   rvdffe #(32) i0e2resultff (.*, .en(i0_e2_data_en), .din(i0_result_e1[31:0]), .dout(i0_result_e2[31:0]));\n', '   rvdffe #(32) i1e2resultff (.*, .en(i1_e2_data_en), .din(i1_result_e1[31:0]), .dout(i1_result_e2[31:0]));\n', '\n', '   rvdffe #(32) i0e3resultff (.*, .en(i0_e3_data_en), .din(i0_result_e2[31:0]), .dout(i0_result_e3[31:0]));\n', '   rvdffe #(32) i1e3resultff (.*, .en(i1_e3_data_en), .din(i1_result_e2[31:0]), .dout(i1_result_e3[31:0]));\n', '\n', '\n', '\n', '   assign i0_result_e3_final[31:0] = (e3d.i0v & e3d.i0load) ? lsu_result_dc3[31:0] : (e3d.i0v & e3d.i0mul) ? exu_mul_result_e3[31:0] : i0_result_e3[31:0];\n', '\n', '   assign i1_result_e3_final[31:0] = (e3d.i1v & e3d.i1load) ? lsu_result_dc3[31:0] : (e3d.i1v & e3d.i1mul) ? exu_mul_result_e3[31:0] : i1_result_e3[31:0];\n', '\n', '\n', '\n', '   rvdffe #(32) i0e4resultff (.*, .en(i0_e4_data_en), .din(i0_result_e3_final[31:0]), .dout(i0_result_e4[31:0]));\n', '   rvdffe #(32) i1e4resultff (.*, .en(i1_e4_data_en), .din(i1_result_e3_final[31:0]), .dout(i1_result_e4[31:0]));\n', '\n', '   assign i0_result_e4_final[31:0] =\n', '                                     (          e4d.i0secondary) ? exu_i0_result_e4[31:0] : (e4d.i0v & e4d.i0load) ? lsu_result_corr_dc4[31:0] : i0_result_e4[31:0];\n', '\n', '   assign i1_result_e4_final[31:0] =\n', '                                     (e4d.i1v & e4d.i1secondary) ? exu_i1_result_e4[31:0] : (e4d.i1v & e4d.i1load) ? lsu_result_corr_dc4[31:0] :i1_result_e4[31:0];\n', '\n', '   rvdffe #(32) i0wbresultff (.*, .en(i0_wb_data_en), .din(i0_result_e4_final[31:0]), .dout(i0_result_wb_raw[31:0]));\n', '   rvdffe #(32) i1wbresultff (.*, .en(i1_wb_data_en), .din(i1_result_e4_final[31:0]), .dout(i1_result_wb_raw[31:0]));\n', '\n', '   assign i0_result_wb[31:0] = (div_wen_wb) ? exu_div_result[31:0] : i0_result_wb_raw[31:0];\n', '\n', '   assign i1_result_wb[31:0] = i1_result_wb_raw[31:0];\n', '\n', '\n', '   rvdffe #(12) e1brpcff (.*, .en(i0_e1_data_en), .din(last_br_immed_d[12:1] ), .dout(last_br_immed_e1[12:1]));\n', '   rvdffe #(12) e2brpcff (.*, .en(i0_e2_data_en), .din(last_br_immed_e1[12:1]), .dout(last_br_immed_e2[12:1]));\n', '\n', '\n', '\n', '// trace stuff\n', '\n', '   rvdffe #(32) divinstff   (.*, .en(i0_div_decode_d), .din(i0_inst_d[31:0]), .dout(div_inst[31:0]));\n', '\n', ""   assign i0_inst_d[31:0] = (dec_i0_pc4_d) ? i0[31:0] : {16'b0, dec_i0_cinst_d[15:0] };\n"", '\n', '   rvdffe #(32) i0e1instff  (.*, .en(i0_e1_data_en), .din(i0_inst_d[31:0]),  .dout(i0_inst_e1[31:0]));\n', '   rvdffe #(32) i0e2instff  (.*, .en(i0_e2_data_en), .din(i0_inst_e1[31:0]), .dout(i0_inst_e2[31:0]));\n', '   rvdffe #(32) i0e3instff  (.*, .en(i0_e3_data_en), .din(i0_inst_e2[31:0]), .dout(i0_inst_e3[31:0]));\n', '   rvdffe #(32) i0e4instff  (.*, .en(i0_e4_data_en), .din(i0_inst_e3[31:0]), .dout(i0_inst_e4[31:0]));\n', '   rvdffe #(32) i0wbinstff  (.*, .en(i0_wb_data_en | exu_div_finish), .din( (exu_div_finish) ? div_inst[31:0] : i0_inst_e4[31:0]), .dout(i0_inst_wb[31:0]));\n', '   rvdffe #(32) i0wb1instff (.*, .en(i0_wb1_data_en | div_wen_wb),    .din(i0_inst_wb[31:0]),                                      .dout(i0_inst_wb1[31:0]));\n', '\n', ""   assign i1_inst_d[31:0] = (dec_i1_pc4_d) ? i1[31:0] : {16'b0, dec_i1_cinst_d[15:0] };\n"", '\n', '   rvdffe #(32) i1e1instff  (.*, .en(i1_e1_data_en), .din(i1_inst_d[31:0]),  .dout(i1_inst_e1[31:0]));\n', '   rvdffe #(32) i1e2instff  (.*, .en(i1_e2_data_en), .din(i1_inst_e1[31:0]), .dout(i1_inst_e2[31:0]));\n', '   rvdffe #(32) i1e3instff  (.*, .en(i1_e3_data_en), .din(i1_inst_e2[31:0]), .dout(i1_inst_e3[31:0]));\n', '   rvdffe #(32) i1e4instff  (.*, .en(i1_e4_data_en), .din(i1_inst_e3[31:0]), .dout(i1_inst_e4[31:0]));\n', '   rvdffe #(32) i1wbinstff  (.*, .en(i1_wb_data_en), .din(i1_inst_e4[31:0]), .dout(i1_inst_wb[31:0]));\n', '   rvdffe #(32) i1wb1instff (.*, .en(i1_wb1_data_en),.din(i1_inst_wb[31:0]), .dout(i1_inst_wb1[31:0]));\n', '\n', '   assign dec_i0_inst_wb1[31:0] = i0_inst_wb1[31:0];\n', '   assign dec_i1_inst_wb1[31:0] = i1_inst_wb1[31:0];\n', '\n', '\n', '   rvdffe #(31) i0wbpcff  (.*, .en(i0_wb_data_en | exu_div_finish), .din(dec_tlu_i0_pc_e4[31:1]), .dout(i0_pc_wb[31:1]));\n', '   rvdffe #(31) i0wb1pcff (.*, .en(i0_wb1_data_en | div_wen_wb),    .din(i0_pc_wb[31:1]),         .dout(i0_pc_wb1[31:1]));\n', '\n', '   rvdffe #(31) i1wb1pcff (.*, .en(i1_wb1_data_en),.din(i1_pc_wb[31:1]),         .dout(i1_pc_wb1[31:1]));\n', '\n', '   assign dec_i0_pc_wb1[31:1] = i0_pc_wb1[31:1];\n', '   assign dec_i1_pc_wb1[31:1] = i1_pc_wb1[31:1];\n', '\n', '\n', ""   // pipe the pc's down the pipe\n"", '   assign i0_pc_e1[31:1] = exu_i0_pc_e1[31:1];\n', '   assign i1_pc_e1[31:1] = exu_i1_pc_e1[31:1];\n', '\n', '   rvdffe #(31) i0e2pcff (.*, .en(i0_e2_data_en), .din(i0_pc_e1[31:1]), .dout(i0_pc_e2[31:1]));\n', '   rvdffe #(31) i0e3pcff (.*, .en(i0_e3_data_en), .din(i0_pc_e2[31:1]), .dout(i0_pc_e3[31:1]));\n', '   rvdffe #(31) i0e4pcff (.*, .en(i0_e4_data_en), .din(i0_pc_e3[31:1]), .dout(i0_pc_e4[31:1]));\n', '   rvdffe #(31) i1e2pcff (.*, .en(i1_e2_data_en), .din(i1_pc_e1[31:1]), .dout(i1_pc_e2[31:1]));\n', '   rvdffe #(31) i1e3pcff (.*, .en(i1_e3_data_en), .din(i1_pc_e2[31:1]), .dout(i1_pc_e3[31:1]));\n', '   rvdffe #(31) i1e4pcff (.*, .en(i1_e4_data_en), .din(i1_pc_e3[31:1]), .dout(i1_pc_e4[31:1]));\n', '\n', '   assign dec_i0_pc_e3[31:1] = i0_pc_e3[31:1];\n', '   assign dec_i1_pc_e3[31:1] = i1_pc_e3[31:1];\n', '\n', '\n', '   assign dec_tlu_i0_pc_e4[31:1] = (exu_div_finish) ? div_pc[31:1] : i0_pc_e4[31:1];\n', '   assign dec_tlu_i1_pc_e4[31:1] = i1_pc_e4[31:1];\n', '\n', '   // generate the correct npc for correct br predictions\n', '   assign last_pc_e2[31:1] = (e2d.i1valid) ? i1_pc_e2[31:1] : i0_pc_e2[31:1];\n', '\n', '   rvbradder ibradder_correct (\n', '                     .pc(last_pc_e2[31:1]),\n', '                     .offset(last_br_immed_e2[12:1]),\n', '                     .dout(pred_correct_npc_e2[31:1])\n', '                     );\n', '\n', '\n', '\n', '   // needed for debug triggers\n', '   rvdffe #(31) i1wbpcff (.*, .en(i1_wb_data_en), .din(dec_tlu_i1_pc_e4[31:1]), .dout(i1_pc_wb[31:1]));\n', '\n', '\n', '\n', '\n', '\n', '\n', '   // bit 9 is priority match, bit 0 lowest priority, i1_e1, i0_e1, i1_e2, ... i1_wb, i0_wb\n', '\n', '\n', '\n', ""   assign i0_rs1bypass[9:0] = {   i0_rs1_depth_d[3:0] == 4'd1  &  i0_rs1_class_d.alu,\n"", ""                                  i0_rs1_depth_d[3:0] == 4'd2  &  i0_rs1_class_d.alu,\n"", ""                                  i0_rs1_depth_d[3:0] == 4'd3  &  i0_rs1_class_d.alu,\n"", ""                                  i0_rs1_depth_d[3:0] == 4'd4  &  i0_rs1_class_d.alu,\n"", ""                                  i0_rs1_depth_d[3:0] == 4'd5  & (i0_rs1_class_d.alu | i0_rs1_class_d.load | i0_rs1_class_d.mul),\n"", ""                                  i0_rs1_depth_d[3:0] == 4'd6  & (i0_rs1_class_d.alu | i0_rs1_class_d.load | i0_rs1_class_d.mul),\n"", ""                                  i0_rs1_depth_d[3:0] == 4'd7  & (i0_rs1_class_d.alu | i0_rs1_class_d.load | i0_rs1_class_d.mul | i0_rs1_class_d.sec),\n"", ""                                  i0_rs1_depth_d[3:0] == 4'd8  & (i0_rs1_class_d.alu | i0_rs1_class_d.load | i0_rs1_class_d.mul | i0_rs1_class_d.sec),\n"", ""                                  i0_rs1_depth_d[3:0] == 4'd9  & (i0_rs1_class_d.alu | i0_rs1_class_d.load | i0_rs1_class_d.mul | i0_rs1_class_d.sec),\n"", ""                                  i0_rs1_depth_d[3:0] == 4'd10 & (i0_rs1_class_d.alu | i0_rs1_class_d.load | i0_rs1_class_d.mul | i0_rs1_class_d.sec) };\n"", '\n', '\n', ""   assign i0_rs2bypass[9:0] = {   i0_rs2_depth_d[3:0] == 4'd1  &  i0_rs2_class_d.alu,\n"", ""                                  i0_rs2_depth_d[3:0] == 4'd2  &  i0_rs2_class_d.alu,\n"", ""                                  i0_rs2_depth_d[3:0] == 4'd3  &  i0_rs2_class_d.alu,\n"", ""                                  i0_rs2_depth_d[3:0] == 4'd4  &  i0_rs2_class_d.alu,\n"", ""                                  i0_rs2_depth_d[3:0] == 4'd5  & (i0_rs2_class_d.alu | i0_rs2_class_d.load | i0_rs2_class_d.mul),\n"", ""                                  i0_rs2_depth_d[3:0] == 4'd6  & (i0_rs2_class_d.alu | i0_rs2_class_d.load | i0_rs2_class_d.mul),\n"", ""                                  i0_rs2_depth_d[3:0] == 4'd7  & (i0_rs2_class_d.alu | i0_rs2_class_d.load | i0_rs2_class_d.mul | i0_rs2_class_d.sec),\n"", ""                                  i0_rs2_depth_d[3:0] == 4'd8  & (i0_rs2_class_d.alu | i0_rs2_class_d.load | i0_rs2_class_d.mul | i0_rs2_class_d.sec),\n"", ""                                  i0_rs2_depth_d[3:0] == 4'd9  & (i0_rs2_class_d.alu | i0_rs2_class_d.load | i0_rs2_class_d.mul | i0_rs2_class_d.sec),\n"", ""                                  i0_rs2_depth_d[3:0] == 4'd10 & (i0_rs2_class_d.alu | i0_rs2_class_d.load | i0_rs2_class_d.mul | i0_rs2_class_d.sec) };\n"", '\n', '\n', ""   assign i1_rs1bypass[9:0] = {   i1_rs1_depth_d[3:0] == 4'd1  &  i1_rs1_class_d.alu,\n"", ""                                  i1_rs1_depth_d[3:0] == 4'd2  &  i1_rs1_class_d.alu,\n"", ""                                  i1_rs1_depth_d[3:0] == 4'd3  &  i1_rs1_class_d.alu,\n"", ""                                  i1_rs1_depth_d[3:0] == 4'd4  &  i1_rs1_class_d.alu,\n"", ""                                  i1_rs1_depth_d[3:0] == 4'd5  & (i1_rs1_class_d.alu | i1_rs1_class_d.load | i1_rs1_class_d.mul),\n"", ""                                  i1_rs1_depth_d[3:0] == 4'd6  & (i1_rs1_class_d.alu | i1_rs1_class_d.load | i1_rs1_class_d.mul),\n"", ""                                  i1_rs1_depth_d[3:0] == 4'd7  & (i1_rs1_class_d.alu | i1_rs1_class_d.load | i1_rs1_class_d.mul | i1_rs1_class_d.sec),\n"", ""                                  i1_rs1_depth_d[3:0] == 4'd8  & (i1_rs1_class_d.alu | i1_rs1_class_d.load | i1_rs1_class_d.mul | i1_rs1_class_d.sec),\n"", ""                                  i1_rs1_depth_d[3:0] == 4'd9  & (i1_rs1_class_d.alu | i1_rs1_class_d.load | i1_rs1_class_d.mul | i1_rs1_class_d.sec),\n"", ""                                  i1_rs1_depth_d[3:0] == 4'd10 & (i1_rs1_class_d.alu | i1_rs1_class_d.load | i1_rs1_class_d.mul | i1_rs1_class_d.sec) };\n"", '\n', '\n', ""   assign i1_rs2bypass[9:0] = {   i1_rs2_depth_d[3:0] == 4'd1  &  i1_rs2_class_d.alu,\n"", ""                                  i1_rs2_depth_d[3:0] == 4'd2  &  i1_rs2_class_d.alu,\n"", ""                                  i1_rs2_depth_d[3:0] == 4'd3  &  i1_rs2_class_d.alu,\n"", ""                                  i1_rs2_depth_d[3:0] == 4'd4  &  i1_rs2_class_d.alu,\n"", ""                                  i1_rs2_depth_d[3:0] == 4'd5  & (i1_rs2_class_d.alu | i1_rs2_class_d.load | i1_rs2_class_d.mul),\n"", ""                                  i1_rs2_depth_d[3:0] == 4'd6  & (i1_rs2_class_d.alu | i1_rs2_class_d.load | i1_rs2_class_d.mul),\n"", ""                                  i1_rs2_depth_d[3:0] == 4'd7  & (i1_rs2_class_d.alu | i1_rs2_class_d.load | i1_rs2_class_d.mul | i1_rs2_class_d.sec),\n"", ""                                  i1_rs2_depth_d[3:0] == 4'd8  & (i1_rs2_class_d.alu | i1_rs2_class_d.load | i1_rs2_class_d.mul | i1_rs2_class_d.sec),\n"", ""                                  i1_rs2_depth_d[3:0] == 4'd9  & (i1_rs2_class_d.alu | i1_rs2_class_d.load | i1_rs2_class_d.mul | i1_rs2_class_d.sec),\n"", ""                                  i1_rs2_depth_d[3:0] == 4'd10 & (i1_rs2_class_d.alu | i1_rs2_class_d.load | i1_rs2_class_d.mul | i1_rs2_class_d.sec) };\n"", '\n', '\n', '\n', '\n', '   assign dec_i0_rs1_bypass_en_d = |i0_rs1bypass[9:0];\n', '   assign dec_i0_rs2_bypass_en_d = |i0_rs2bypass[9:0];\n', '   assign dec_i1_rs1_bypass_en_d = |i1_rs1bypass[9:0];\n', '   assign dec_i1_rs2_bypass_en_d = |i1_rs2bypass[9:0];\n', '\n', '\n', '\n', '   assign i0_rs1_bypass_data_d[31:0] = ({32{i0_rs1bypass[9]}} & i1_result_e1[31:0]) |\n', '                                       ({32{i0_rs1bypass[8]}} & i0_result_e1[31:0]) |\n', '                                       ({32{i0_rs1bypass[7]}} & i1_result_e2[31:0]) |\n', '                                       ({32{i0_rs1bypass[6]}} & i0_result_e2[31:0]) |\n', '                                       ({32{i0_rs1bypass[5]}} & i1_result_e3_final[31:0]) |\n', '                                       ({32{i0_rs1bypass[4]}} & i0_result_e3_final[31:0]) |\n', '                                       ({32{i0_rs1bypass[3]}} & i1_result_e4_final[31:0]) |\n', '                                       ({32{i0_rs1bypass[2]}} & i0_result_e4_final[31:0]) |\n', '                                       ({32{i0_rs1bypass[1]}} & i1_result_wb[31:0]) |\n', '                                       ({32{i0_rs1bypass[0]}} & i0_result_wb[31:0]);\n', '\n', '\n', '   assign i0_rs2_bypass_data_d[31:0] = ({32{i0_rs2bypass[9]}} & i1_result_e1[31:0]) |\n', '                                       ({32{i0_rs2bypass[8]}} & i0_result_e1[31:0]) |\n', '                                       ({32{i0_rs2bypass[7]}} & i1_result_e2[31:0]) |\n', '                                       ({32{i0_rs2bypass[6]}} & i0_result_e2[31:0]) |\n', '                                       ({32{i0_rs2bypass[5]}} & i1_result_e3_final[31:0]) |\n', '                                       ({32{i0_rs2bypass[4]}} & i0_result_e3_final[31:0]) |\n', '                                       ({32{i0_rs2bypass[3]}} & i1_result_e4_final[31:0]) |\n', '                                       ({32{i0_rs2bypass[2]}} & i0_result_e4_final[31:0]) |\n', '                                       ({32{i0_rs2bypass[1]}} & i1_result_wb[31:0]) |\n', '                                       ({32{i0_rs2bypass[0]}} & i0_result_wb[31:0]);\n', '\n', '   assign i1_rs1_bypass_data_d[31:0] = ({32{i1_rs1bypass[9]}} & i1_result_e1[31:0]) |\n', '                                       ({32{i1_rs1bypass[8]}} & i0_result_e1[31:0]) |\n', '                                       ({32{i1_rs1bypass[7]}} & i1_result_e2[31:0]) |\n', '                                       ({32{i1_rs1bypass[6]}} & i0_result_e2[31:0]) |\n', '                                       ({32{i1_rs1bypass[5]}} & i1_result_e3_final[31:0]) |\n', '                                       ({32{i1_rs1bypass[4]}} & i0_result_e3_final[31:0]) |\n', '                                       ({32{i1_rs1bypass[3]}} & i1_result_e4_final[31:0]) |\n', '                                       ({32{i1_rs1bypass[2]}} & i0_result_e4_final[31:0]) |\n', '                                       ({32{i1_rs1bypass[1]}} & i1_result_wb[31:0]) |\n', '                                       ({32{i1_rs1bypass[0]}} & i0_result_wb[31:0]);\n', '\n', '\n', '   assign i1_rs2_bypass_data_d[31:0] = ({32{i1_rs2bypass[9]}} & i1_result_e1[31:0]) |\n', '                                       ({32{i1_rs2bypass[8]}} & i0_result_e1[31:0]) |\n', '                                       ({32{i1_rs2bypass[7]}} & i1_result_e2[31:0]) |\n', '                                       ({32{i1_rs2bypass[6]}} & i0_result_e2[31:0]) |\n', '                                       ({32{i1_rs2bypass[5]}} & i1_result_e3_final[31:0]) |\n', '                                       ({32{i1_rs2bypass[4]}} & i0_result_e3_final[31:0]) |\n', '                                       ({32{i1_rs2bypass[3]}} & i1_result_e4_final[31:0]) |\n', '                                       ({32{i1_rs2bypass[2]}} & i0_result_e4_final[31:0]) |\n', '                                       ({32{i1_rs2bypass[1]}} & i1_result_wb[31:0]) |\n', '                                       ({32{i1_rs2bypass[0]}} & i0_result_wb[31:0]);\n', '\n', '\n', '\n', '\n', '\n', '\n', 'endmodule\n', '\n', '// file ""decode"" is human readable file that has all of the instruction decodes defined and is part of git repo\n', '// modify this file as needed\n', '\n', '// to generate all the equations below from ""decode"" except legal equation:\n', '\n', '// 1) coredecode -in decode > coredecode.e\n', '\n', '// 2) espresso -Dso -oeqntott coredecode.e | addassign -pre out.  > equations\n', '\n', '// to generate the legal (32b instruction is legal) equation below:\n', '\n', '// 1) coredecode -in decode -legal > legal.e\n', '\n', '// 2) espresso -Dso -oeqntott legal.e | addassign -pre out. > legal_equation\n', '\n', 'module dec_dec_ctl\n', '   import veer_types::*;\n', '(\n', '   input logic [31:0] inst,\n', '\n', '   output dec_pkt_t out\n', '   );\n', '\n', '   logic [31:0] i;\n', '\n', '\n', '   assign i[31:0] = inst[31:0];\n', '\n', '\n', 'assign out.alu = (i[2]) | (i[6]) | (!i[25]&i[4]) | (!i[5]&i[4]);\n', '\n', 'assign out.rs1 = (!i[14]&!i[13]&!i[2]) | (!i[13]&i[11]&!i[2]) | (i[19]&i[13]&!i[2]) | (\n', '    !i[13]&i[10]&!i[2]) | (i[18]&i[13]&!i[2]) | (!i[13]&i[9]&!i[2]) | (\n', '    i[17]&i[13]&!i[2]) | (!i[13]&i[8]&!i[2]) | (i[16]&i[13]&!i[2]) | (\n', '    !i[13]&i[7]&!i[2]) | (i[15]&i[13]&!i[2]) | (!i[4]&!i[3]) | (!i[6]\n', '    &!i[2]);\n', '\n', 'assign out.rs2 = (i[5]&!i[4]&!i[2]) | (!i[6]&i[5]&!i[2]);\n', '\n', 'assign out.imm12 = (!i[4]&!i[3]&i[2]) | (i[13]&!i[5]&i[4]&!i[2]) | (!i[13]&!i[12]\n', '    &i[6]&i[4]) | (!i[12]&!i[5]&i[4]&!i[2]);\n', '\n', 'assign out.rd = (!i[5]&!i[2]) | (i[5]&i[2]) | (i[4]);\n', '\n', 'assign out.shimm5 = (!i[13]&i[12]&!i[5]&i[4]&!i[2]);\n', '\n', 'assign out.imm20 = (i[5]&i[3]) | (i[4]&i[2]);\n', '\n', 'assign out.pc = (!i[5]&!i[3]&i[2]) | (i[5]&i[3]);\n', '\n', 'assign out.load = (!i[5]&!i[4]&!i[2]);\n', '\n', 'assign out.store = (!i[6]&i[5]&!i[4]);\n', '\n', 'assign out.lsu = (!i[6]&!i[4]&!i[2]);\n', '\n', 'assign out.add = (!i[14]&!i[13]&!i[12]&!i[5]&i[4]) | (!i[5]&!i[3]&i[2]) | (!i[30]\n', '    &!i[25]&!i[14]&!i[13]&!i[12]&!i[6]&i[4]&!i[2]);\n', '\n', 'assign out.sub = (i[30]&!i[12]&!i[6]&i[5]&i[4]&!i[2]) | (!i[25]&!i[14]&i[13]&!i[6]\n', '    &i[4]&!i[2]) | (!i[14]&i[13]&!i[5]&i[4]&!i[2]) | (i[6]&!i[4]&!i[2]);\n', '\n', 'assign out.land = (i[14]&i[13]&i[12]&!i[5]&!i[2]) | (!i[25]&i[14]&i[13]&i[12]&!i[6]\n', '    &!i[2]);\n', '\n', 'assign out.lor = (!i[6]&i[3]) | (!i[25]&i[14]&i[13]&!i[12]&i[4]&!i[2]) | (i[5]&i[4]\n', '    &i[2]) | (!i[12]&i[6]&i[4]) | (i[13]&i[6]&i[4]) | (i[14]&i[13]&!i[12]\n', '    &!i[5]&!i[2]) | (i[7]&i[6]&i[4]) | (i[8]&i[6]&i[4]) | (i[9]&i[6]&i[4]) | (\n', '    i[10]&i[6]&i[4]) | (i[11]&i[6]&i[4]);\n', '\n', 'assign out.lxor = (!i[25]&i[14]&!i[13]&!i[12]&i[4]&!i[2]) | (i[14]&!i[13]&!i[12]\n', '    &!i[5]&i[4]&!i[2]);\n', '\n', 'assign out.sll = (!i[25]&!i[14]&!i[13]&i[12]&!i[6]&i[4]&!i[2]);\n', '\n', 'assign out.sra = (i[30]&!i[13]&i[12]&!i[6]&i[4]&!i[2]);\n', '\n', 'assign out.srl = (!i[30]&!i[25]&i[14]&!i[13]&i[12]&!i[6]&i[4]&!i[2]);\n', '\n', 'assign out.slt = (!i[25]&!i[14]&i[13]&!i[6]&i[4]&!i[2]) | (!i[14]&i[13]&!i[5]&i[4]\n', '    &!i[2]);\n', '\n', 'assign out.unsign = (!i[14]&i[13]&i[12]&!i[5]&!i[2]) | (i[13]&i[6]&!i[4]&!i[2]) | (\n', '    i[14]&!i[5]&!i[4]) | (!i[25]&!i[14]&i[13]&i[12]&!i[6]&!i[2]) | (\n', '    i[25]&i[14]&i[12]&!i[6]&i[5]&!i[2]);\n', '\n', 'assign out.condbr = (i[6]&!i[4]&!i[2]);\n', '\n', 'assign out.beq = (!i[14]&!i[12]&i[6]&!i[4]&!i[2]);\n', '\n', 'assign out.bne = (!i[14]&i[12]&i[6]&!i[4]&!i[2]);\n', '\n', 'assign out.bge = (i[14]&i[12]&i[5]&!i[4]&!i[2]);\n', '\n', 'assign out.blt = (i[14]&!i[12]&i[5]&!i[4]&!i[2]);\n', '\n', 'assign out.jal = (i[6]&i[2]);\n', '\n', 'assign out.by = (!i[13]&!i[12]&!i[6]&!i[4]&!i[2]);\n', '\n', 'assign out.half = (i[12]&!i[6]&!i[4]&!i[2]);\n', '\n', 'assign out.word = (i[13]&!i[6]&!i[4]);\n', '\n', 'assign out.csr_read = (i[13]&i[6]&i[4]) | (i[7]&i[6]&i[4]) | (i[8]&i[6]&i[4]) | (\n', '    i[9]&i[6]&i[4]) | (i[10]&i[6]&i[4]) | (i[11]&i[6]&i[4]);\n', '\n', 'assign out.csr_clr = (i[15]&i[13]&i[12]&i[6]&i[4]) | (i[16]&i[13]&i[12]&i[6]&i[4]) | (\n', '    i[17]&i[13]&i[12]&i[6]&i[4]) | (i[18]&i[13]&i[12]&i[6]&i[4]) | (\n', '    i[19]&i[13]&i[12]&i[6]&i[4]);\n', '\n', 'assign out.csr_set = (i[15]&!i[12]&i[6]&i[4]) | (i[16]&!i[12]&i[6]&i[4]) | (i[17]\n', '    &!i[12]&i[6]&i[4]) | (i[18]&!i[12]&i[6]&i[4]) | (i[19]&!i[12]&i[6]\n', '    &i[4]);\n', '\n', 'assign out.csr_write = (!i[13]&i[12]&i[6]&i[4]);\n', '\n', 'assign out.csr_imm = (i[14]&!i[13]&i[6]&i[4]) | (i[15]&i[14]&i[6]&i[4]) | (i[16]\n', '    &i[14]&i[6]&i[4]) | (i[17]&i[14]&i[6]&i[4]) | (i[18]&i[14]&i[6]&i[4]) | (\n', '    i[19]&i[14]&i[6]&i[4]);\n', '\n', 'assign out.presync = (!i[5]&i[3]) | (i[25]&i[14]&!i[6]&i[5]&!i[2]) | (!i[13]&i[7]\n', '    &i[6]&i[4]) | (!i[13]&i[8]&i[6]&i[4]) | (!i[13]&i[9]&i[6]&i[4]) | (\n', '    !i[13]&i[10]&i[6]&i[4]) | (!i[13]&i[11]&i[6]&i[4]) | (i[15]&i[13]\n', '    &i[6]&i[4]) | (i[16]&i[13]&i[6]&i[4]) | (i[17]&i[13]&i[6]&i[4]) | (\n', '    i[18]&i[13]&i[6]&i[4]) | (i[19]&i[13]&i[6]&i[4]);\n', '\n', 'assign out.postsync = (i[12]&!i[5]&i[3]) | (!i[22]&!i[13]&!i[12]&i[6]&i[4]) | (\n', '    i[25]&i[14]&!i[6]&i[5]&!i[2]) | (!i[13]&i[7]&i[6]&i[4]) | (!i[13]\n', '    &i[8]&i[6]&i[4]) | (!i[13]&i[9]&i[6]&i[4]) | (!i[13]&i[10]&i[6]&i[4]) | (\n', '    !i[13]&i[11]&i[6]&i[4]) | (i[15]&i[13]&i[6]&i[4]) | (i[16]&i[13]&i[6]\n', '    &i[4]) | (i[17]&i[13]&i[6]&i[4]) | (i[18]&i[13]&i[6]&i[4]) | (i[19]\n', '    &i[13]&i[6]&i[4]);\n', '\n', 'assign out.ebreak = (!i[22]&i[20]&!i[13]&!i[12]&i[6]&i[4]);\n', '\n', 'assign out.ecall = (!i[21]&!i[20]&!i[13]&!i[12]&i[6]&i[4]);\n', '\n', 'assign out.mret = (i[29]&!i[13]&!i[12]&i[6]&i[4]);\n', '\n', 'assign out.mul = (i[25]&!i[14]&!i[6]&i[5]&i[4]&!i[2]);\n', '\n', 'assign out.rs1_sign = (i[25]&!i[14]&i[13]&!i[12]&!i[6]&i[5]&i[4]&!i[2]) | (i[25]\n', '    &!i[14]&!i[13]&i[12]&!i[6]&i[4]&!i[2]);\n', '\n', 'assign out.rs2_sign = (i[25]&!i[14]&!i[13]&i[12]&!i[6]&i[4]&!i[2]);\n', '\n', 'assign out.low = (i[25]&!i[14]&!i[13]&!i[12]&i[5]&i[4]&!i[2]);\n', '\n', 'assign out.div = (i[25]&i[14]&!i[6]&i[5]&!i[2]);\n', '\n', 'assign out.rem = (i[25]&i[14]&i[13]&!i[6]&i[5]&!i[2]);\n', '\n', 'assign out.fence = (!i[5]&i[3]);\n', '\n', 'assign out.fence_i = (i[12]&!i[5]&i[3]);\n', '\n', 'assign out.pm_alu = (i[28]&i[22]&!i[13]&!i[12]&i[4]) | (i[4]&i[2]) | (!i[25]&!i[6]\n', '    &i[4]) | (!i[5]&i[4]);\n', '\n', '\n', 'assign out.legal = (!i[31]&!i[30]&i[29]&i[28]&!i[27]&!i[26]&!i[25]&!i[24]&!i[23]\n', '    &!i[22]&i[21]&!i[20]&!i[19]&!i[18]&!i[17]&!i[16]&!i[15]&!i[14]&!i[11]\n', '    &!i[10]&!i[9]&!i[8]&!i[7]&i[6]&i[5]&i[4]&!i[3]&!i[2]&i[1]&i[0]) | (\n', '    !i[31]&!i[30]&!i[29]&i[28]&!i[27]&!i[26]&!i[25]&!i[24]&!i[23]&i[22]\n', '    &!i[21]&i[20]&!i[19]&!i[18]&!i[17]&!i[16]&!i[15]&!i[14]&!i[11]&!i[10]\n', '    &!i[9]&!i[8]&!i[7]&i[6]&i[5]&i[4]&!i[3]&!i[2]&i[1]&i[0]) | (!i[31]\n', '    &!i[30]&!i[29]&!i[28]&!i[27]&!i[26]&!i[25]&!i[24]&!i[23]&!i[22]&!i[21]\n', '    &!i[19]&!i[18]&!i[17]&!i[16]&!i[15]&!i[14]&!i[11]&!i[10]&!i[9]&!i[8]\n', '    &!i[7]&i[5]&i[4]&!i[3]&!i[2]&i[1]&i[0]) | (!i[31]&!i[30]&!i[29]&!i[28]\n', '    &!i[27]&!i[26]&!i[25]&!i[6]&i[4]&!i[3]&i[1]&i[0]) | (!i[31]&!i[29]\n', '    &!i[28]&!i[27]&!i[26]&!i[25]&!i[14]&!i[13]&!i[12]&!i[6]&!i[3]&!i[2]\n', '    &i[1]&i[0]) | (!i[31]&!i[29]&!i[28]&!i[27]&!i[26]&!i[25]&i[14]&!i[13]\n', '    &i[12]&!i[6]&i[4]&!i[3]&i[1]&i[0]) | (!i[31]&!i[30]&!i[29]&!i[28]\n', '    &!i[27]&!i[26]&!i[6]&i[5]&i[4]&!i[3]&i[1]&i[0]) | (!i[14]&!i[13]\n', '    &!i[12]&i[6]&i[5]&!i[4]&!i[3]&i[1]&i[0]) | (i[14]&i[6]&i[5]&!i[4]\n', '    &!i[3]&!i[2]&i[1]&i[0]) | (!i[12]&!i[6]&!i[5]&i[4]&!i[3]&i[1]&i[0]) | (\n', '    !i[14]&!i[13]&i[5]&!i[4]&!i[3]&!i[2]&i[1]&i[0]) | (i[12]&i[6]&i[5]\n', '    &i[4]&!i[3]&!i[2]&i[1]&i[0]) | (!i[31]&!i[30]&!i[29]&!i[28]&!i[27]\n', '    &!i[26]&!i[25]&!i[24]&!i[23]&!i[22]&!i[21]&!i[20]&!i[19]&!i[18]&!i[17]\n', '    &!i[16]&!i[15]&!i[14]&!i[13]&!i[11]&!i[10]&!i[9]&!i[8]&!i[7]&!i[6]\n', '    &!i[5]&!i[4]&i[3]&i[2]&i[1]&i[0]) | (!i[31]&!i[30]&!i[29]&!i[28]\n', '    &!i[19]&!i[18]&!i[17]&!i[16]&!i[15]&!i[14]&!i[13]&!i[12]&!i[11]&!i[10]\n', '    &!i[9]&!i[8]&!i[7]&!i[6]&!i[5]&!i[4]&i[3]&i[2]&i[1]&i[0]) | (i[13]\n', '    &i[6]&i[5]&i[4]&!i[3]&!i[2]&i[1]&i[0]) | (!i[13]&!i[6]&!i[5]&!i[4]\n', '    &!i[3]&!i[2]&i[1]&i[0]) | (i[6]&i[5]&!i[4]&i[3]&i[2]&i[1]&i[0]) | (\n', '    i[13]&!i[6]&!i[5]&i[4]&!i[3]&i[1]&i[0]) | (!i[14]&!i[12]&!i[6]&!i[4]\n', '    &!i[3]&!i[2]&i[1]&i[0]) | (!i[6]&i[4]&!i[3]&i[2]&i[1]&i[0]);\n', '\n', '\n', 'endmodule\n']"
"['// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '\n', 'module dec_gpr_ctl #(parameter GPR_BANKS      = 1,\n', '                               GPR_BANKS_LOG2 = 1)  (\n', '    input logic active_clk,\n', '\n', '    input logic [4:0] raddr0,  // logical read addresses\n', '    input logic [4:0] raddr1,\n', '    input logic [4:0] raddr2,\n', '    input logic [4:0] raddr3,\n', '\n', '    input logic       rden0,   // read enables\n', '    input logic       rden1,\n', '    input logic       rden2,\n', '    input logic       rden3,\n', '\n', '    input logic [4:0] waddr0,  // logical write addresses\n', '    input logic [4:0] waddr1,\n', '    input logic [4:0] waddr2,\n', '\n', '    input logic wen0,          // write enables\n', '    input logic wen1,\n', '    input logic wen2,\n', '\n', '    input logic [31:0] wd0,    // write data\n', '    input logic [31:0] wd1,\n', '    input logic [31:0] wd2,\n', '\n', '    input logic                      wen_bank_id,  // write enable for banks\n', '    input logic [GPR_BANKS_LOG2-1:0] wr_bank_id,   // read enable for banks\n', '\n', '    input logic       clk,\n', '    input logic       rst_l,\n', '\n', '    output logic [31:0] rd0,  // read data\n', '    output logic [31:0] rd1,\n', '    output logic [31:0] rd2,\n', '    output logic [31:0] rd3,\n', '\n', '    input  logic        scan_mode\n', ');\n', '\n', '   logic [GPR_BANKS-1:0][31:1] [31:0] gpr_out;     // 31 x 32 bit GPRs\n', '   logic [31:1] [31:0] gpr_in;\n', '   logic [31:1] w0v,w1v,w2v;\n', '   logic [31:1] gpr_wr_en;\n', '   logic [GPR_BANKS-1:0][31:1] gpr_bank_wr_en;\n', '   logic [GPR_BANKS_LOG2-1:0] gpr_bank_id;\n', '\n', ""   //assign gpr_bank_id[GPR_BANKS_LOG2-1:0] = '0;\n"", '   rvdffs #(GPR_BANKS_LOG2) bankid_ff (.*, .clk(active_clk), .en(wen_bank_id), .din(wr_bank_id[GPR_BANKS_LOG2-1:0]), .dout(gpr_bank_id[GPR_BANKS_LOG2-1:0]));\n', '\n', '   // GPR Write Enables for power savings\n', '   assign gpr_wr_en[31:1] = (w0v[31:1] | w1v[31:1] | w2v[31:1]);\n', '   for (genvar i=0; i<GPR_BANKS; i++) begin: gpr_banks\n', '      assign gpr_bank_wr_en[i][31:1] = gpr_wr_en[31:1] & {31{gpr_bank_id[GPR_BANKS_LOG2-1:0] == i}};\n', '      for ( genvar j=1; j<32; j++ )  begin : gpr\n', '         rvdffe #(32) gprff (.*, .en(gpr_bank_wr_en[i][j]), .din(gpr_in[j][31:0]), .dout(gpr_out[i][j][31:0]));\n', '      end : gpr\n', '   end: gpr_banks\n', '\n', '// the read out\n', '   always_comb begin\n', ""      rd0[31:0] = 32'b0;\n"", ""      rd1[31:0] = 32'b0;\n"", ""      rd2[31:0] = 32'b0;\n"", ""      rd3[31:0] = 32'b0;\n"", ""      w0v[31:1] = 31'b0;\n"", ""      w1v[31:1] = 31'b0;\n"", ""      w2v[31:1] = 31'b0;\n"", ""      gpr_in[31:1] = '0;\n"", '\n', '      // GPR Read logic\n', '      for (int i=0; i<GPR_BANKS; i++) begin\n', '         for (int j=1; j<32; j++ )  begin\n', ""            rd0[31:0] |= ({32{rden0 & (raddr0[4:0]== 5'(j)) & (gpr_bank_id[GPR_BANKS_LOG2-1:0] == 1'(i))}} & gpr_out[i][j][31:0]);\n"", ""            rd1[31:0] |= ({32{rden1 & (raddr1[4:0]== 5'(j)) & (gpr_bank_id[GPR_BANKS_LOG2-1:0] == 1'(i))}} & gpr_out[i][j][31:0]);\n"", ""            rd2[31:0] |= ({32{rden2 & (raddr2[4:0]== 5'(j)) & (gpr_bank_id[GPR_BANKS_LOG2-1:0] == 1'(i))}} & gpr_out[i][j][31:0]);\n"", ""            rd3[31:0] |= ({32{rden3 & (raddr3[4:0]== 5'(j)) & (gpr_bank_id[GPR_BANKS_LOG2-1:0] == 1'(i))}} & gpr_out[i][j][31:0]);\n"", '        end\n', '     end\n', '\n', '     // GPR Write logic\n', '     for (int j=1; j<32; j++ )  begin\n', ""         w0v[j]     = wen0  & (waddr0[4:0]== 5'(j) );\n"", ""         w1v[j]     = wen1  & (waddr1[4:0]== 5'(j) );\n"", ""         w2v[j]     = wen2  & (waddr2[4:0]== 5'(j) );\n"", '         gpr_in[j]  =    ({32{w0v[j]}} & wd0[31:0]) |\n', '                         ({32{w1v[j]}} & wd1[31:0]) |\n', '                         ({32{w2v[j]}} & wd2[31:0]);\n', '     end\n', '   end // always_comb begin\n', '\n', '`ifdef ASSERT_ON\n', '   // asserting that no 2 ports will write to the same gpr simultaneously\n', '   assert_multiple_wen_to_same_gpr: assert #0 (~( ((w0v[31:1] == w1v[31:1]) & wen0 & wen1) | ((w0v[31:1] == w2v[31:1]) & wen0 & wen2) | ((w1v[31:1] == w2v[31:1]) & wen1 & wen2) ) );\n', '\n', '`endif\n', '\n', 'endmodule\n']"
"['// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '\n', 'module dec_ib_ctl\n', '   import veer_types::*;\n', '(\n', '   input logic   free_clk,                    // free clk\n', '   input logic   active_clk,                  // active clk if not halt / pause\n', '\n', '   input logic                 dbg_cmd_valid,  // valid dbg cmd\n', '\n', '   input logic                 dbg_cmd_write,  // dbg cmd is write\n', '   input logic [1:0]           dbg_cmd_type,   // dbg type\n', '   input logic [1:0]           dbg_cmd_size,   // 00 - 1B, 01 - 2B, 10 - 4B, 11 - reserved\n', '   input logic [31:0]          dbg_cmd_addr,   // expand to 31:0\n', '\n', ""   input logic exu_flush_final,                // all flush sources: primary/secondary alu's, trap\n"", '\n', '   input logic          dec_ib0_valid_eff_d,   // effective valid taking decode into account\n', '   input logic          dec_ib1_valid_eff_d,\n', '\n', '   input br_pkt_t i0_brp,                      // i0 branch packet from aligner\n', '   input br_pkt_t i1_brp,\n', '\n', '   input logic   ifu_i0_pc4,                   // i0 is 4B inst else 2B\n', '   input logic   ifu_i1_pc4,\n', '\n', '   input logic   ifu_i0_valid,                 // i0 valid from ifu\n', '   input logic   ifu_i1_valid,\n', '\n', '   input logic   ifu_i0_icaf,                  // i0 instruction access fault\n', '   input logic   ifu_i1_icaf,\n', '   input logic   ifu_i0_icaf_second,               // i0 has access fault on second 2B of 4B inst\n', '   input logic   ifu_i1_icaf_second,\n', '   input logic   ifu_i0_perr,                  // i0 instruction parity error\n', '   input logic   ifu_i1_perr,\n', '   input logic   ifu_i0_sbecc,                 // i0 single-bit error\n', '   input logic   ifu_i1_sbecc,\n', '   input logic   ifu_i0_dbecc,                 // i0 double-bit error\n', '   input logic   ifu_i1_dbecc,\n', '\n', '   input logic [31:0]  ifu_i0_instr,           // i0 instruction from the aligner\n', '   input logic [31:0]  ifu_i1_instr,\n', '\n', '   input logic [31:1]  ifu_i0_pc,              // i0 pc from the aligner\n', '   input logic [31:1] ifu_i1_pc,\n', '\n', '   input logic   dec_i0_decode_d,              // i0 decode\n', '   input logic   dec_i1_decode_d,\n', '\n', '\n', '   input logic   rst_l,                        // test stuff\n', '   input logic   clk,\n', '\n', '\n', '   output logic dec_ib3_valid_d,               // ib3 valid\n', '   output logic dec_ib2_valid_d,               // ib2 valid\n', '   output logic dec_ib1_valid_d,               // ib1 valid\n', '   output logic dec_ib0_valid_d,               // ib0 valid\n', '\n', '\n', '   output logic [31:0] dec_i0_instr_d,         // i0 inst at decode\n', '   output logic [31:0] dec_i1_instr_d,         // i1 inst at decode\n', '\n', '   output logic [31:1] dec_i0_pc_d,            // i0 pc at decode\n', '   output logic [31:1] dec_i1_pc_d,\n', '\n', '   output logic dec_i0_pc4_d,                  // i0 is 4B inst else 2B\n', '   output logic dec_i1_pc4_d,\n', '\n', '   output br_pkt_t dec_i0_brp,                 // i0 branch packet at decode\n', '   output br_pkt_t dec_i1_brp,\n', '\n', '   output logic dec_i0_icaf_d,                 // i0 instruction access fault at decode\n', '   output logic dec_i1_icaf_d,\n', '   output logic dec_i0_icaf_second_d,              // i0 instruction access fault on second 2B of 4B inst\n', '   output logic dec_i0_perr_d,                 // i0 instruction parity error at decode\n', '   output logic dec_i1_perr_d,\n', '   output logic dec_i0_sbecc_d,                // i0 single-bit error at decode\n', '   output logic dec_i1_sbecc_d,\n', '   output logic dec_i0_dbecc_d,                // i0 double-bit error at decode\n', '   output logic dec_i1_dbecc_d,\n', '   output logic dec_debug_wdata_rs1_d,         // put debug write data onto rs1 source: machine is halted\n', '\n', '   output logic dec_debug_fence_d,             // debug fence inst\n', '\n', '   input logic [15:0] ifu_i0_cinst,            // 16b compressed inst from aligner\n', '   input logic [15:0] ifu_i1_cinst,\n', '\n', '   output logic [15:0] dec_i0_cinst_d,         // 16b compress inst at decode\n', '   output logic [15:0] dec_i1_cinst_d,\n', '\n', '   input  logic scan_mode\n', '\n', '   );\n', '\n', '`include ""global.h""\n', '\n', '   logic         flush_final;\n', '\n', '   logic [3:0]   ibval_in, ibval;\n', '\n', '   logic [31:0]  ib3_in, ib2_in, ib1_in, ib0_in;\n', '   logic [31:0]  ib3, ib2, ib1, ib0;\n', '\n', '   logic [36:0]  pc3_in, pc2_in, pc1_in, pc0_in;\n', '   logic [36:0]  pc3, pc2, pc1, pc0;\n', '\n', '   logic [15:0]  cinst3_in, cinst2_in, cinst1_in, cinst0_in;\n', '   logic [15:0]  cinst3, cinst2, cinst1, cinst0;\n', '\n', '   logic         write_i1_ib3, write_i0_ib3;\n', '   logic         write_i1_ib2, write_i0_ib2;\n', '   logic         write_i1_ib1, write_i0_ib1;\n', '   logic         write_i0_ib0;\n', '\n', '   logic         shift2, shift1, shift0;\n', '\n', '   logic         shift_ib1_ib0, shift_ib2_ib1, shift_ib3_ib2;\n', '   logic         shift_ib2_ib0;\n', '   logic         shift_ib3_ib1;\n', '\n', '\n', '   logic         ifu_i0_val, ifu_i1_val;\n', '   logic         debug_valid;\n', '   logic [4:0]   dreg;\n', '   logic [11:0]  dcsr;\n', '   logic [31:0]  ib0_debug_in;\n', '\n', '//   logic                     debug_read_mem;\n', '//   logic                     debug_write_mem;\n', '   logic         debug_read;\n', '   logic         debug_write;\n', '   logic         debug_read_gpr;\n', '   logic         debug_write_gpr;\n', '   logic         debug_read_csr;\n', '   logic         debug_write_csr;\n', '\n', '\n', '\n', '   rvdff #(1) flush_upperff (.*, .clk(free_clk), .din(exu_flush_final), .dout(flush_final));\n', '\n', '   logic [3:0]   ibvalid;\n', '\n', '   logic [3:0]   i0_wen;\n', '   logic [3:1]   i1_wen;\n', '   logic [3:0]   shift_ibval;\n', '   logic [3:0]   ibwrite;\n', '\n', ""   assign ibvalid[3:0] = ibval[3:0] | i0_wen[3:0] | {i1_wen[3:1],1'b0};\n"", '\n', '   assign ibval_in[3:0] = (({4{shift0}} & ibvalid[3:0]) |\n', ""                           ({4{shift1}} & {1'b0, ibvalid[3:1]}) |\n"", ""                           ({4{shift2}} & {2'b0, ibvalid[3:2]})) & ~{4{flush_final}};\n"", '\n', '   rvdff #(4) ibvalff (.*, .clk(active_clk), .din(ibval_in[3:0]), .dout(ibval[3:0]));\n', '\n', '// only valid if there is room\n', '   if (DEC_INSTBUF_DEPTH==4) begin\n', '      assign ifu_i0_val = ifu_i0_valid & ~ibval[3] & ~flush_final;\n', '      assign ifu_i1_val = ifu_i1_valid & ~ibval[2] & ~flush_final;\n', '   end\n', '   else begin\n', '      assign ifu_i0_val = ifu_i0_valid & (~dec_ib0_valid_eff_d | ~dec_ib1_valid_eff_d) & ~flush_final;\n', '      assign ifu_i1_val = ifu_i1_valid & (~dec_ib0_valid_eff_d & ~dec_ib1_valid_eff_d) & ~flush_final;\n', '   end\n', '\n', '\n', '   assign i0_wen[0] = ~ibval[0]             & (ifu_i0_val | debug_valid);\n', '   assign i0_wen[1] =  ibval[0] & ~ibval[1] & ifu_i0_val;\n', '   assign i0_wen[2] =  ibval[1] & ~ibval[2] & ifu_i0_val;\n', '   assign i0_wen[3] =  ibval[2] & ~ibval[3] & ifu_i0_val;\n', '\n', '   assign i1_wen[1] = ~ibval[0]             & ifu_i1_val;\n', '   assign i1_wen[2] =  ibval[0] & ~ibval[1] & ifu_i1_val;\n', '   assign i1_wen[3] =  ibval[1] & ~ibval[2] & ifu_i1_val;\n', '\n', '\n', '   // start trace\n', '\n', '   if (DEC_INSTBUF_DEPTH==4) begin\n', '      assign cinst3_in[15:0] = ({16{write_i0_ib3}} & ifu_i0_cinst[15:0]) |\n', '                               ({16{write_i1_ib3}} & ifu_i1_cinst[15:0]);\n', '\n', '      rvdffe #(16) cinst3ff (.*, .en(ibwrite[3]), .din(cinst3_in[15:0]), .dout(cinst3[15:0]));\n', '\n', '      assign cinst2_in[15:0] = ({16{write_i0_ib2}} & ifu_i0_cinst[15:0]) |\n', '                               ({16{write_i1_ib2}} & ifu_i1_cinst[15:0]) |\n', '                               ({16{shift_ib3_ib2}} & cinst3[15:0]);\n', '\n', '      rvdffe #(16) cinst2ff (.*, .en(ibwrite[2]), .din(cinst2_in[15:0]), .dout(cinst2[15:0]));\n', '   end // if (DEC_INSTBUF_DEPTH==4)\n', '   else begin\n', ""      assign cinst3 = '0;\n"", ""      assign cinst2 = '0;\n"", '   end\n', '\n', '   assign cinst1_in[15:0] = ({16{write_i0_ib1}} & ifu_i0_cinst[15:0]) |\n', '                            ({16{write_i1_ib1}} & ifu_i1_cinst[15:0]) |\n', '                            ({16{shift_ib2_ib1}} & cinst2[15:0]) |\n', '                            ({16{shift_ib3_ib1}} & cinst3[15:0]);\n', '\n', '   rvdffe #(16) cinst1ff (.*, .en(ibwrite[1]), .din(cinst1_in[15:0]), .dout(cinst1[15:0]));\n', '\n', '\n', '   assign cinst0_in[15:0] = ({16{write_i0_ib0}} & ifu_i0_cinst[15:0]) |\n', '                            ({16{shift_ib1_ib0}} & cinst1[15:0]) |\n', '                            ({16{shift_ib2_ib0}} & cinst2[15:0]);\n', '\n', '   rvdffe #(16) cinst0ff (.*, .en(ibwrite[0]), .din(cinst0_in[15:0]), .dout(cinst0[15:0]));\n', '\n', '   assign dec_i0_cinst_d[15:0] = cinst0[15:0];\n', '\n', '   assign dec_i1_cinst_d[15:0] = cinst1[15:0];\n', '\n', '   // end trace\n', '\n', '\n', '   // pc tracking\n', '\n', '\n', '   assign ibwrite[3:0] = {  write_i0_ib3 | write_i1_ib3,\n', '                            write_i0_ib2 | write_i1_ib2 | shift_ib3_ib2,\n', '                            write_i0_ib1 | write_i1_ib1 | shift_ib2_ib1 | shift_ib3_ib1,\n', '                            write_i0_ib0 | shift_ib1_ib0 | shift_ib2_ib0\n', '                            };\n', '\n', '   logic [36:0]  ifu_i1_pcdata, ifu_i0_pcdata;\n', '\n', '   assign ifu_i1_pcdata[36:0] = { ifu_i1_icaf_second, ifu_i1_dbecc, ifu_i1_sbecc, ifu_i1_perr, ifu_i1_icaf,\n', '                                  ifu_i1_pc[31:1], ifu_i1_pc4 };\n', '   assign ifu_i0_pcdata[36:0] = { ifu_i0_icaf_second, ifu_i0_dbecc, ifu_i0_sbecc, ifu_i0_perr, ifu_i0_icaf,\n', '                                  ifu_i0_pc[31:1], ifu_i0_pc4 };\n', '\n', '   if (DEC_INSTBUF_DEPTH==4) begin\n', '      assign pc3_in[36:0] = ({37{write_i0_ib3}} & ifu_i0_pcdata[36:0]) |\n', '                            ({37{write_i1_ib3}} & ifu_i1_pcdata[36:0]);\n', '\n', '      rvdffe #(37) pc3ff (.*, .en(ibwrite[3]), .din(pc3_in[36:0]), .dout(pc3[36:0]));\n', '\n', '      assign pc2_in[36:0] = ({37{write_i0_ib2}} & ifu_i0_pcdata[36:0]) |\n', '                            ({37{write_i1_ib2}} & ifu_i1_pcdata[36:0]) |\n', '                            ({37{shift_ib3_ib2}} & pc3[36:0]);\n', '\n', '      rvdffe #(37) pc2ff (.*, .en(ibwrite[2]), .din(pc2_in[36:0]), .dout(pc2[36:0]));\n', '   end // if (DEC_INSTBUF_DEPTH==4)\n', '   else begin\n', ""      assign pc3 = '0;\n"", ""      assign pc2 = '0;\n"", '   end\n', '\n', '   assign pc1_in[36:0] = ({37{write_i0_ib1}} & ifu_i0_pcdata[36:0]) |\n', '                         ({37{write_i1_ib1}} & ifu_i1_pcdata[36:0]) |\n', '                         ({37{shift_ib2_ib1}} & pc2[36:0]) |\n', '                         ({37{shift_ib3_ib1}} & pc3[36:0]);\n', '\n', '   rvdffe #(37) pc1ff (.*, .en(ibwrite[1]), .din(pc1_in[36:0]), .dout(pc1[36:0]));\n', '\n', '\n', '   assign pc0_in[36:0] = ({37{write_i0_ib0}} & ifu_i0_pcdata[36:0]) |\n', '                         ({37{shift_ib1_ib0}} & pc1[36:0]) |\n', '                         ({37{shift_ib2_ib0}} & pc2[36:0]);\n', '\n', '   rvdffe #(37) pc0ff (.*, .en(ibwrite[0]), .din(pc0_in[36:0]), .dout(pc0[36:0]));\n', '\n', ""   assign dec_i0_icaf_second_d = pc0[36];   // icaf's can only decode as i0\n"", '\n', '   assign dec_i1_dbecc_d = pc1[35];\n', '   assign dec_i0_dbecc_d = pc0[35];\n', '\n', '   assign dec_i1_sbecc_d = pc1[34];\n', '   assign dec_i0_sbecc_d = pc0[34];\n', '\n', '   assign dec_i1_perr_d = pc1[33];\n', '   assign dec_i0_perr_d = pc0[33];\n', '\n', '   assign dec_i1_icaf_d = pc1[32];\n', '   assign dec_i0_icaf_d = pc0[32];\n', '\n', '   assign dec_i1_pc_d[31:1] = pc1[31:1];\n', '   assign dec_i0_pc_d[31:1] = pc0[31:1];\n', '\n', '   assign dec_i1_pc4_d = pc1[0];\n', '   assign dec_i0_pc4_d = pc0[0];\n', '\n', '   // branch prediction\n', '\n', '   logic [$bits(br_pkt_t)-1:0] bp3_in,bp3,bp2_in,bp2,bp1_in,bp1,bp0_in,bp0;\n', '\n', '   if (DEC_INSTBUF_DEPTH==4) begin\n', '      assign bp3_in = ({$bits(br_pkt_t){write_i0_ib3}} & i0_brp) |\n', '                      ({$bits(br_pkt_t){write_i1_ib3}} & i1_brp);\n', '\n', '      rvdffe #($bits(br_pkt_t)) bp3ff (.*, .en(ibwrite[3]), .din(bp3_in), .dout(bp3));\n', '\n', '      assign bp2_in = ({$bits(br_pkt_t){write_i0_ib2}} & i0_brp) |\n', '                      ({$bits(br_pkt_t){write_i1_ib2}} & i1_brp) |\n', '                      ({$bits(br_pkt_t){shift_ib3_ib2}} & bp3);\n', '\n', '      rvdffe #($bits(br_pkt_t)) bp2ff (.*, .en(ibwrite[2]), .din(bp2_in), .dout(bp2));\n', '   end // if (DEC_INSTBUF_DEPTH==4)\n', '   else begin\n', ""      assign bp3 = '0;\n"", ""      assign bp2 = '0;\n"", '   end\n', '\n', '   assign bp1_in = ({$bits(br_pkt_t){write_i0_ib1}} & i0_brp) |\n', '                   ({$bits(br_pkt_t){write_i1_ib1}} & i1_brp) |\n', '                   ({$bits(br_pkt_t){shift_ib2_ib1}} & bp2) |\n', '                   ({$bits(br_pkt_t){shift_ib3_ib1}} & bp3);\n', '\n', '   rvdffe #($bits(br_pkt_t)) bp1ff (.*, .en(ibwrite[1]), .din(bp1_in), .dout(bp1));\n', '\n', '\n', '\n', '   assign bp0_in = ({$bits(br_pkt_t){write_i0_ib0}} & i0_brp) |\n', '                   ({$bits(br_pkt_t){shift_ib1_ib0}} & bp1) |\n', '                   ({$bits(br_pkt_t){shift_ib2_ib0}} & bp2);\n', '\n', '   rvdffe #($bits(br_pkt_t)) bp0ff (.*, .en(ibwrite[0]), .din(bp0_in), .dout(bp0));\n', '\n', '   // instruction buffers\n', '\n', '   if (DEC_INSTBUF_DEPTH==4) begin\n', '      assign ib3_in[31:0] = ({32{write_i0_ib3}} & ifu_i0_instr[31:0]) |\n', '                            ({32{write_i1_ib3}} & ifu_i1_instr[31:0]);\n', '\n', '      rvdffe #(32) ib3ff (.*, .en(ibwrite[3]), .din(ib3_in[31:0]), .dout(ib3[31:0]));\n', '\n', '      assign ib2_in[31:0] = ({32{write_i0_ib2}} & ifu_i0_instr[31:0]) |\n', '                            ({32{write_i1_ib2}} & ifu_i1_instr[31:0]) |\n', '                            ({32{shift_ib3_ib2}} & ib3[31:0]);\n', '\n', '      rvdffe #(32) ib2ff (.*, .en(ibwrite[2]), .din(ib2_in[31:0]), .dout(ib2[31:0]));\n', '   end // if (DEC_INSTBUF_DEPTH==4)\n', '   else begin\n', ""      assign ib3 = '0;\n"", ""      assign ib2 = '0;\n"", '   end\n', '\n', '   assign ib1_in[31:0] = ({32{write_i0_ib1}} & ifu_i0_instr[31:0]) |\n', '                         ({32{write_i1_ib1}} & ifu_i1_instr[31:0]) |\n', '                         ({32{shift_ib2_ib1}} & ib2[31:0]) |\n', '                         ({32{shift_ib3_ib1}} & ib3[31:0]);\n', '\n', '   rvdffe #(32) ib1ff (.*, .en(ibwrite[1]), .din(ib1_in[31:0]), .dout(ib1[31:0]));\n', '\n', '\n', '// GPR accesses\n', '\n', '// put reg to read on rs1\n', '// read ->   or %x0,  %reg,%x0      {000000000000,reg[4:0],110000000110011}\n', '\n', '// put write date on rs1\n', '// write ->  or %reg, %x0, %x0      {00000000000000000110,reg[4:0],0110011}\n', '\n', '\n', '// CSR accesses\n', '// csr is of form rd, csr, rs1\n', '\n', '// read  -> csrrs %x0, %csr, %x0     {csr[11:0],00000010000001110011}\n', '\n', '// put write data on rs1\n', '// write -> csrrw %x0, %csr, %x0     {csr[11:0],00000001000001110011}\n', '\n', '// abstract memory command not done here\n', ""   assign debug_valid = dbg_cmd_valid & (dbg_cmd_type[1:0] != 2'h2);\n"", '\n', '\n', '   assign debug_read  = debug_valid & ~dbg_cmd_write;\n', '   assign debug_write = debug_valid &  dbg_cmd_write;\n', '\n', ""   assign debug_read_gpr  = debug_read  & (dbg_cmd_type[1:0]==2'h0);\n"", ""   assign debug_write_gpr = debug_write & (dbg_cmd_type[1:0]==2'h0);\n"", ""   assign debug_read_csr  = debug_read  & (dbg_cmd_type[1:0]==2'h1);\n"", ""   assign debug_write_csr = debug_write & (dbg_cmd_type[1:0]==2'h1);\n"", '\n', '   assign dreg[4:0]  = dbg_cmd_addr[4:0];\n', '   assign dcsr[11:0] = dbg_cmd_addr[11:0];\n', '\n', '\n', ""   assign ib0_debug_in[31:0] = ({32{debug_read_gpr}}  & {12'b000000000000,dreg[4:0],15'b110000000110011}) |\n"", ""                               ({32{debug_write_gpr}} & {20'b00000000000000000110,dreg[4:0],7'b0110011}) |\n"", ""                               ({32{debug_read_csr}}  & {dcsr[11:0],20'b00000010000001110011}) |\n"", ""                               ({32{debug_write_csr}} & {dcsr[11:0],20'b00000001000001110011});\n"", '\n', '\n', '   // machine is in halted state, pipe empty, write will always happen next cycle\n', '   rvdff #(1) debug_wdata_rs1ff (.*, .clk(free_clk), .din(debug_write_gpr | debug_write_csr), .dout(dec_debug_wdata_rs1_d));\n', '\n', '\n', '   // special fence csr for use only in debug mode\n', '\n', '   logic                       debug_fence_in;\n', '\n', ""   assign debug_fence_in = debug_write_csr & (dcsr[11:0] == 12'h7c4);\n"", '\n', '   rvdff #(1) debug_fence_ff (.*,  .clk(free_clk), .din(debug_fence_in),  .dout(dec_debug_fence_d));\n', '\n', '\n', '   assign ib0_in[31:0] = ({32{write_i0_ib0}} & ((debug_valid) ? ib0_debug_in[31:0] : ifu_i0_instr[31:0])) |\n', '                         ({32{shift_ib1_ib0}} & ib1[31:0]) |\n', '                         ({32{shift_ib2_ib0}} & ib2[31:0]);\n', '\n', '   rvdffe #(32) ib0ff (.*, .en(ibwrite[0]), .din(ib0_in[31:0]), .dout(ib0[31:0]));\n', '\n', '   assign dec_ib3_valid_d = ibval[3];\n', '   assign dec_ib2_valid_d = ibval[2];\n', '   assign dec_ib1_valid_d = ibval[1];\n', '   assign dec_ib0_valid_d = ibval[0];\n', '\n', '   assign dec_i0_instr_d[31:0] = ib0[31:0];\n', '\n', '   assign dec_i1_instr_d[31:0] = ib1[31:0];\n', '\n', '   assign dec_i0_brp = bp0;\n', '   assign dec_i1_brp = bp1;\n', '\n', '\n', '   assign shift1 = dec_i0_decode_d & ~dec_i1_decode_d;\n', '\n', '   assign shift2 = dec_i0_decode_d & dec_i1_decode_d;\n', '\n', '   assign shift0 = ~dec_i0_decode_d;\n', '\n', '\n', '   // compute shifted ib valids to determine where to write\n', ""   assign shift_ibval[3:0] = ({4{shift1}} & {1'b0, ibval[3:1] }) |\n"", ""                             ({4{shift2}} & {2'b0, ibval[3:2]}) |\n"", '                             ({4{shift0}} & ibval[3:0]);\n', '\n', '   assign write_i0_ib0 = ~shift_ibval[0]                & (ifu_i0_val | debug_valid);\n', '   assign write_i0_ib1 =  shift_ibval[0] & ~shift_ibval[1] & ifu_i0_val;\n', '   assign write_i0_ib2 =  shift_ibval[1] & ~shift_ibval[2] & ifu_i0_val;\n', '   assign write_i0_ib3 =  shift_ibval[2] & ~shift_ibval[3] & ifu_i0_val;\n', '\n', '   assign write_i1_ib1 = ~shift_ibval[0]                & ifu_i1_val;\n', '   assign write_i1_ib2 =  shift_ibval[0] & ~shift_ibval[1] & ifu_i1_val;\n', '   assign write_i1_ib3 =  shift_ibval[1] & ~shift_ibval[2] & ifu_i1_val;\n', '\n', '\n', '   assign shift_ib1_ib0 = shift1 & ibval[1];\n', '   assign shift_ib2_ib1 = shift1 & ibval[2];\n', '   assign shift_ib3_ib2 = shift1 & ibval[3];\n', '\n', '   assign shift_ib2_ib0 = shift2 & ibval[2];\n', '   assign shift_ib3_ib1 = shift2 & ibval[3];\n', '\n', '\n', '\n', 'endmodule\n']"
"['// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '\n', '\n', '//********************************************************************************\n', '// dec_tlu_ctl.sv\n', '//\n', '//\n', '// Function: CSRs, Commit/WB, flushing, exceptions, interrupts\n', '// Comments:\n', '//\n', '//********************************************************************************\n', '\n', 'module dec_tlu_ctl\n', '   import veer_types::*;\n', '(\n', '   input logic clk,\n', '   input logic active_clk,\n', '   input logic free_clk,\n', '   input logic rst_l,\n', '   input logic scan_mode,\n', '\n', '   input logic [31:1] rst_vec, // reset vector, from core pins\n', '   input logic        nmi_int, // nmi pin\n', '   input logic [31:1] nmi_vec, // nmi vector\n', '   input logic  i_cpu_halt_req,    // Asynchronous Halt request to CPU\n', '   input logic  i_cpu_run_req,     // Asynchronous Restart request to CPU\n', '\n', '   input logic mpc_debug_halt_req, // Async halt request\n', '   input logic mpc_debug_run_req, // Async run request\n', '   input logic mpc_reset_run_req, // Run/halt after reset\n', '\n', '   // perf counter inputs\n', '   input logic [1:0] ifu_pmu_instr_aligned,   // aligned instructions\n', '   input logic       ifu_pmu_align_stall,  // aligner stalled\n', '   input logic       ifu_pmu_fetch_stall, // fetch unit stalled\n', '   input logic       ifu_pmu_ic_miss, // icache miss\n', '   input logic       ifu_pmu_ic_hit, // icache hit\n', '   input logic       ifu_pmu_bus_error, // Instruction side bus error\n', '   input logic       ifu_pmu_bus_busy, // Instruction side bus busy\n', '   input logic       ifu_pmu_bus_trxn, // Instruction side bus transaction\n', '   input logic [1:0] dec_pmu_instr_decoded, // decoded instructions\n', '   input logic       dec_pmu_decode_stall, // decode stall\n', ""   input logic       dec_pmu_presync_stall, // decode stall due to presync'd inst\n"", ""   input logic       dec_pmu_postsync_stall,// decode stall due to postsync'd inst\n"", '   input logic       lsu_freeze_dc3,         // lsu freeze stall\n', '   input logic       lsu_store_stall_any,    // SB or WB is full, stall decode\n', '   input logic       dma_dccm_stall_any,     // DMA stall of lsu\n', '   input logic       dma_iccm_stall_any,     // DMA stall of ifu\n', '   input logic       exu_pmu_i0_br_misp,     // pipe 0 branch misp\n', '   input logic       exu_pmu_i0_br_ataken,   // pipe 0 branch actual taken\n', '   input logic       exu_pmu_i0_pc4,         // pipe 0 4 byte branch\n', '   input logic       exu_pmu_i1_br_misp,     // pipe 1 branch misp\n', '   input logic       exu_pmu_i1_br_ataken,   // pipe 1 branch actual taken\n', '   input logic       exu_pmu_i1_pc4,         // pipe 1 4 byte branch\n', '   input logic       lsu_pmu_bus_trxn,       // D side bus transaction\n', '   input logic       lsu_pmu_bus_misaligned, // D side bus misaligned\n', '   input logic       lsu_pmu_bus_error,      // D side bus error\n', '   input logic       lsu_pmu_bus_busy,       // D side bus busy\n', '\n', '   input logic        dma_mem_dccm_req,\n', '\n', '   input logic       iccm_dma_sb_error,      // I side dma single bit error\n', '\n', '   input    lsu_error_pkt_t lsu_error_pkt_dc3, // lsu precise exception/error packet\n', '   input logic         lsu_single_ecc_error_incr,    // Increment the counter for Single ECC error\n', '\n', ""   input logic lsu_load_ecc_stbuf_full_dc3,    // STBUF full, ecc errors should be rfpc'd\n"", '\n', '   input logic dec_pause_state, // Pause counter not zero\n', '   input logic         lsu_imprecise_error_store_any,      // store bus error\n', '   input logic         lsu_imprecise_error_load_any,      // store bus error\n', '   input logic [31:0]  lsu_imprecise_error_addr_any, // store bus error address\n', '   input logic         lsu_freeze_external_ints_dc3, // load to side effect region\n', '\n', '   input logic        dec_csr_wen_unq_d,       // valid csr with write - for csr legal\n', '   input logic        dec_csr_any_unq_d,       // valid csr - for csr legal\n', '   input logic        dec_csr_wen_wb,      // csr write enable at wb\n', '   input logic [11:0] dec_csr_rdaddr_d,      // read address for csr\n', '   input logic [11:0] dec_csr_wraddr_wb,      // write address for csr\n', '   input logic [31:0] dec_csr_wrdata_wb,   // csr write data at wb\n', '   input logic        dec_csr_stall_int_ff, // csr is mie/mstatus\n', '\n', '   input logic dec_tlu_i0_valid_e4, // pipe 0 op at e4 is valid\n', '   input logic dec_tlu_i1_valid_e4, // pipe 1 op at e4 is valid\n', '\n', '   input logic dec_i0_load_e4, // during cycle after freeze asserts, load is in i0\n', '\n', '   input logic dec_fence_pending, // tell TLU to stall DMA\n', '\n', '   input logic [31:1] exu_npc_e4, // for NPC tracking\n', '   input logic exu_i0_flush_lower_e4,       // pipe 0 branch mp flush\n', '   input logic exu_i1_flush_lower_e4,       // pipe 1 branch mp flush\n', '   input logic [31:1] exu_i0_flush_path_e4, // pipe 0 correct path for mp, merge with lower path\n', '   input logic [31:1] exu_i1_flush_path_e4, // pipe 1 correct path for mp, merge with lower path\n', '\n', '   input logic [31:1] dec_tlu_i0_pc_e4, // for PC/NPC tracking\n', '   input logic [31:1] dec_tlu_i1_pc_e4, // for PC/NPC tracking\n', '\n', '   input trap_pkt_t dec_tlu_packet_e4, // exceptions known at decode\n', '\n', '   input logic [31:0] dec_illegal_inst, // For mtval\n', '   input logic        dec_i0_decode_d,  // decode valid, used for clean icache diagnostics\n', '\n', '   // branch info from pipe0 for errors or counter updates\n', '   input logic [`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] exu_i0_br_index_e4, // index\n', '   input logic [1:0]  exu_i0_br_hist_e4, // history\n', '   input logic [1:0]  exu_i0_br_bank_e4, // bank\n', '   input logic        exu_i0_br_error_e4, // error\n', '   input logic        exu_i0_br_start_error_e4, // start error\n', '   input logic        exu_i0_br_valid_e4, // valid\n', '   input logic        exu_i0_br_mp_e4, // mispredict\n', '   input logic        exu_i0_br_middle_e4, // middle of bank\n', '   input logic [`RV_BHT_GHR_RANGE]  exu_i0_br_fghr_e4, // FGHR when predicted\n', '\n', '   // branch info from pipe1 for errors or counter updates\n', '   input logic [`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] exu_i1_br_index_e4, // index\n', '   input logic [1:0]  exu_i1_br_hist_e4, // history\n', '   input logic [1:0]  exu_i1_br_bank_e4, // bank\n', '   input logic        exu_i1_br_error_e4, // error\n', '   input logic        exu_i1_br_start_error_e4, // start error\n', '   input logic        exu_i1_br_valid_e4, // valid\n', '   input logic        exu_i1_br_mp_e4, // mispredict\n', '   input logic        exu_i1_br_middle_e4, // middle of bank\n', '   input logic [`RV_BHT_GHR_RANGE]  exu_i1_br_fghr_e4, // FGHR when predicted\n', '\n', '`ifdef RV_BTB_48\n', '   input logic [1:0]       exu_i1_br_way_e4, // way hit or repl\n', '   input logic [1:0]       exu_i0_br_way_e4, // way hit or repl\n', '`else\n', '   input logic        exu_i1_br_way_e4, // way hit or repl\n', '   input logic        exu_i0_br_way_e4, // way hit or repl\n', '`endif\n', '\n', '   // Debug start\n', '   output logic dec_dbg_cmd_done, // abstract command done\n', '   output logic dec_dbg_cmd_fail, // abstract command failed\n', '   output logic dec_tlu_flush_noredir_wb , // Tell fetch to idle on this flush\n', '   output logic dec_tlu_mpc_halted_only, // Core is halted only due to MPC\n', '   output logic dec_tlu_dbg_halted, // Core is halted and ready for debug command\n', '   output logic dec_tlu_pmu_fw_halted, // Core is halted due to Power management unit or firmware halt\n', '   output logic dec_tlu_debug_mode, // Core is in debug mode\n', '   output logic dec_tlu_resume_ack, // Resume acknowledge\n', '   output logic dec_tlu_debug_stall, // stall decode while waiting on core to empty\n', '   output logic dec_tlu_flush_leak_one_wb, // single step\n', '   output logic dec_tlu_flush_err_wb, // iside perr/ecc rfpc\n', ""   output logic dec_tlu_stall_dma, // stall dma access when there's a halt request\n"", '   input  logic dbg_halt_req, // DM requests a halt\n', '   input  logic dbg_resume_req, // DM requests a resume\n', '   input  logic ifu_miss_state_idle, // I-side miss buffer empty\n', '   input  logic lsu_halt_idle_any, // lsu is idle\n', '   output trigger_pkt_t  [3:0] trigger_pkt_any, // trigger info for trigger blocks\n', '\n', '`ifdef RV_ICACHE_ECC\n', '   input logic [41:0] ifu_ic_debug_rd_data, // diagnostic icache read data\n', '`else\n', '   input logic [33:0] ifu_ic_debug_rd_data, // diagnostic icache read data\n', '`endif\n', '   input logic ifu_ic_debug_rd_data_valid, // diagnostic icache read data valid\n', '   output cache_debug_pkt_t dec_tlu_ic_diag_pkt, // packet of DICAWICS, DICAD0/1, DICAGO info for icache diagnostics\n', '   // Debug end\n', '\n', '   input logic [7:0] pic_claimid, // pic claimid for csr\n', '   input logic [3:0] pic_pl, // pic priv level for csr\n', '   input logic       mhwakeup, // high priority external int, wakeup if halted\n', '\n', '   input logic mexintpend, // external interrupt pending\n', '   input logic timer_int, // timer interrupt pending\n', '\n', '   output logic o_cpu_halt_status, // PMU interface, halted\n', '   output logic o_cpu_halt_ack, // halt req ack\n', '   output logic o_cpu_run_ack, // run req ack\n', '   output logic o_debug_mode_status, // Core to the PMU that core is in debug mode. When core is in debug mode, the PMU should refrain from sendng a halt or run request\n', '\n', '   output logic mpc_debug_halt_ack, // Halt ack\n', '   output logic mpc_debug_run_ack, // Run ack\n', '   output logic debug_brkpt_status, // debug breakpoint\n', '\n', '   output logic [3:0] dec_tlu_meicurpl, // to PIC\n', '   output logic [3:0] dec_tlu_meipt, // to PIC\n', '\n', '   output br_tlu_pkt_t dec_tlu_br0_wb_pkt, // branch pkt to bp\n', '   output br_tlu_pkt_t dec_tlu_br1_wb_pkt, // branch pkt to bp\n', '\n', '   output logic [31:0] dec_csr_rddata_d,      // csr read data at wb\n', '   output logic dec_csr_legal_d,              // csr indicates legal operation\n', '\n', ""   output logic dec_tlu_i0_kill_writeb_wb,    // I0 is flushed, don't writeback any results to arch state\n"", ""   output logic dec_tlu_i1_kill_writeb_wb,    // I1 is flushed, don't writeback any results to arch state\n"", '\n', '   output logic dec_tlu_flush_lower_wb,       // commit has a flush (exception, int, mispredict at e4)\n', '   output logic [31:1] dec_tlu_flush_path_wb, // flush pc\n', '   output logic dec_tlu_fence_i_wb,           // flush is a fence_i rfnpc, flush icache\n', '\n', ""   output logic dec_tlu_presync_d,            // CSR read needs to be presync'd\n"", ""   output logic dec_tlu_postsync_d,           // CSR needs to be presync'd\n"", '\n', '   output logic [31:0] dec_tlu_mrac_ff,        // CSR for memory region control\n', '\n', '   output logic dec_tlu_cancel_e4,             // Cancel lsu op at DC4 due to future trigger hit\n', '\n', '   output logic dec_tlu_wr_pause_wb,           // CSR write to pause reg is at WB.\n', '   output logic dec_tlu_flush_pause_wb,        // Flush is due to pause\n', '\n', '   output logic [1:0] dec_tlu_perfcnt0, // toggles when pipe0 perf counter 0 has an event inc\n', '   output logic [1:0] dec_tlu_perfcnt1, // toggles when pipe0 perf counter 1 has an event inc\n', '   output logic [1:0] dec_tlu_perfcnt2, // toggles when pipe0 perf counter 2 has an event inc\n', '   output logic [1:0] dec_tlu_perfcnt3, // toggles when pipe0 perf counter 3 has an event inc\n', '\n', '\n', '   output logic dec_tlu_i0_valid_wb1,  // pipe 0 valid\n', '   output logic dec_tlu_i1_valid_wb1,  // pipe 1 valid\n', '   output logic dec_tlu_i0_exc_valid_wb1, // pipe 0 exception valid\n', '   output logic dec_tlu_i1_exc_valid_wb1, // pipe 1 exception valid\n', '   output logic dec_tlu_int_valid_wb1, // pipe 2 int valid\n', '   output logic [4:0] dec_tlu_exc_cause_wb1, // exception or int cause\n', '   output logic [31:0] dec_tlu_mtval_wb1, // MTVAL value\n', '\n', '   // feature disable from mfdc\n', '   output logic  dec_tlu_sideeffect_posted_disable,    // disable posted writes to side-effect address\n', '   output logic  dec_tlu_dual_issue_disable, // disable dual issue\n', '   output logic  dec_tlu_core_ecc_disable, // disable core ECC\n', '   output logic  dec_tlu_sec_alu_disable, // disable secondary ALU\n', '   output logic  dec_tlu_dccm_nonblock_dma_disable, // disable dma nonblock\n', '   output logic  dec_tlu_non_blocking_disable,    // disable non blocking loads\n', '   output logic  dec_tlu_fast_div_disable,        // disable fast divider\n', '   output logic  dec_tlu_bpred_disable,           // disable branch prediction\n', '   output logic  dec_tlu_wb_coalescing_disable,   // disable writebuffer coalescing\n', '   output logic  dec_tlu_ld_miss_byp_wb_disable,  // disable loads miss bypass write buffer\n', '   output logic  dec_tlu_pipelining_disable,      // disable pipelining\n', '   output logic [2:0]  dec_tlu_dma_qos_prty,    // DMA QoS priority coming from MFDC [18:16]\n', '\n', '   // clock gating overrides from mcgc\n', '   output logic  dec_tlu_misc_clk_override, // override misc clock domain gating\n', '   output logic  dec_tlu_dec_clk_override,  // override decode clock domain gating\n', '   output logic  dec_tlu_exu_clk_override,  // override exu clock domain gating\n', '   output logic  dec_tlu_ifu_clk_override,  // override fetch clock domain gating\n', '   output logic  dec_tlu_lsu_clk_override,  // override load/store clock domain gating\n', '   output logic  dec_tlu_bus_clk_override,  // override bus clock domain gating\n', '   output logic  dec_tlu_pic_clk_override,  // override PIC clock domain gating\n', '   output logic  dec_tlu_dccm_clk_override, // override DCCM clock domain gating\n', '   output logic  dec_tlu_icm_clk_override   // override ICCM clock domain gating\n', '\n', '   );\n', '\n', '   logic         dec_csr_wen_wb_mod, clk_override, e4e5_int_clk, nmi_lsu_load_type, nmi_lsu_store_type, nmi_int_detected_f, nmi_lsu_load_type_f,\n', '                 nmi_lsu_store_type_f, allow_dbg_halt_csr_write, dbg_cmd_done_ns, i_cpu_run_req_d1_raw, debug_mode_status, lsu_single_ecc_error_wb,\n', '                 i0_mp_e4, i1_mp_e4, sel_npc_e4, sel_npc_wb, ce_int, mtval_capture_lsu_wb, wr_mdeau_wb, micect_cout_nc, miccmect_cout_nc,\n', '                 mdccmect_cout_nc, nmi_in_debug_mode, dpc_capture_npc, dpc_capture_pc, tdata_load, tdata_opcode, tdata_action, perfcnt_halted, tdata_chain,\n', '                 tdata_kill_write;\n', '\n', '\n', '   logic reset_delayed, reset_detect, reset_detected;\n', '   logic wr_mstatus_wb, wr_mtvec_wb, wr_mie_wb, wr_mcyclel_wb, wr_mcycleh_wb,\n', '         wr_minstretl_wb, wr_minstreth_wb, wr_mscratch_wb, wr_mepc_wb, wr_mcause_wb, wr_mtval_wb,\n', '         wr_mrac_wb, wr_meihap_wb, wr_meicurpl_wb, wr_meipt_wb, wr_dcsr_wb,\n', '         wr_dpc_wb, wr_meicidpl_wb, wr_meivt_wb, wr_meicpct_wb, wr_micect_wb, wr_miccmect_wb,\n', '         wr_mdccmect_wb,wr_mhpme3_wb, wr_mhpme4_wb, wr_mhpme5_wb, wr_mhpme6_wb;\n', '   logic wr_mgpmc_wb, mgpmc_b, mgpmc;\n', '   logic wr_mtsel_wb, wr_mtdata1_t0_wb, wr_mtdata1_t1_wb, wr_mtdata1_t2_wb, wr_mtdata1_t3_wb, wr_mtdata2_t0_wb, wr_mtdata2_t1_wb, wr_mtdata2_t2_wb, wr_mtdata2_t3_wb;\n', '   logic [31:0] mtdata2_t0, mtdata2_t1, mtdata2_t2, mtdata2_t3, mtdata2_tsel_out, mtdata1_tsel_out;\n', '   logic [9:0]  mtdata1_t0_ns, mtdata1_t0, mtdata1_t1_ns, mtdata1_t1, mtdata1_t2_ns, mtdata1_t2, mtdata1_t3_ns, mtdata1_t3;\n', '   logic [27:0] tdata_wrdata_wb;\n', '   logic [1:0] mtsel_ns, mtsel;\n', '   logic tlu_i0_kill_writeb_e4, tlu_i1_kill_writeb_e4;\n', '   logic [1:0]  mstatus_ns, mstatus;\n', '   logic mstatus_mie_ns;\n', '   logic [30:0] mtvec_ns, mtvec;\n', '   logic [15:2] dcsr_ns, dcsr;\n', '   logic [5:0] mip_ns, mip;\n', '   logic [5:0] mie_ns, mie;\n', '   logic [31:0] mcyclel_ns, mcyclel;\n', '   logic [31:0] mcycleh_ns, mcycleh;\n', '   logic [31:0] minstretl_ns, minstretl;\n', '   logic [31:0] minstreth_ns, minstreth;\n', '   logic [31:0] micect_ns, micect, miccmect_ns, miccmect, mdccmect_ns, mdccmect;\n', '   logic [26:0] micect_inc, miccmect_inc, mdccmect_inc;\n', '   logic [31:0] mscratch;\n', '   logic [31:0] mhpmc3, mhpmc3_ns, mhpmc4, mhpmc4_ns, mhpmc5, mhpmc5_ns, mhpmc6, mhpmc6_ns;\n', '   logic [31:0] mhpmc3h, mhpmc3h_ns, mhpmc4h, mhpmc4h_ns, mhpmc5h, mhpmc5h_ns, mhpmc6h, mhpmc6h_ns;\n', '   logic [5:0]  mhpme3, mhpme4, mhpme5, mhpme6;\n', '   logic [31:0] mrac;\n', '   logic [9:2] meihap;\n', '   logic [31:10] meivt;\n', '   logic [3:0] meicurpl_ns, meicurpl;\n', '   logic [3:0] meicidpl_ns, meicidpl;\n', '   logic [3:0] meipt_ns, meipt;\n', '   logic [31:0] mdseac;\n', '   logic mdseac_locked_ns, mdseac_locked_f, mdseac_en, nmi_lsu_detected;\n', '   logic [31:1] mepc_ns, mepc;\n', '   logic [31:1] dpc_ns, dpc;\n', '   logic [31:0] mcause_ns, mcause;\n', '   logic [31:0] mtval_ns, mtval;\n', '   logic       mret_wb;\n', '   logic dec_pause_state_f, dec_tlu_wr_pause_wb_f, pause_expired_e4, pause_expired_wb;\n', '   logic       tlu_flush_lower_e4, tlu_flush_lower_wb;\n', '   logic [31:1] tlu_flush_path_e4, tlu_flush_path_wb;\n', '   logic i0_valid_wb, i1_valid_wb;\n', '   logic [5:0] vectored_cause;\n', '   logic       vpath_overflow_nc;\n', '   logic [31:1] vectored_path, interrupt_path;\n', '   logic [18:2] dicawics_ns, dicawics;\n', '   logic        wr_dicawics_wb, wr_dicad0_wb, wr_dicad1_wb;\n', '   logic [31:0] dicad0_ns, dicad0;\n', '`ifdef RV_ICACHE_ECC\n', '   logic [9:0]  dicad1_ns, dicad1;\n', ' `else\n', '   logic [1:0]  dicad1_ns, dicad1;\n', ' `endif\n', '   logic        ebreak_e4, ebreak_to_debug_mode_e4, ecall_e4, illegal_e4, illegal_e4_qual, mret_e4, inst_acc_e4, fence_i_e4,\n', '                ic_perr_e4, iccm_sbecc_e4, ebreak_to_debug_mode_wb, kill_ebreak_count_wb, inst_acc_second_e4;\n', '   logic        ebreak_wb, ecall_wb, illegal_wb,  illegal_raw_wb, inst_acc_wb, inst_acc_second_wb, fence_i_wb, ic_perr_wb, iccm_sbecc_wb;\n', '   logic ce_int_ready, ext_int_ready, timer_int_ready, int_timer0_int_ready, int_timer1_int_ready, mhwakeup_ready,\n', '         take_ext_int, take_ce_int, take_timer_int, take_int_timer0_int, take_int_timer1_int, take_nmi, take_nmi_wb, int_timer0_int_possible, int_timer1_int_possible;\n', '   logic i0_exception_valid_e4, interrupt_valid, i0_exception_valid_wb, interrupt_valid_wb, exc_or_int_valid, exc_or_int_valid_wb, mdccme_ce_req, miccme_ce_req, mice_ce_req;\n', '   logic synchronous_flush_e4;\n', '   logic [4:0] exc_cause_e4, exc_cause_wb;\n', '   logic        mcyclel_cout, mcyclel_cout_f;\n', '   logic [31:0] mcyclel_inc;\n', '   logic        mcycleh_cout_nc;\n', '   logic [31:0] mcycleh_inc;\n', '   logic        minstretl_cout, minstretl_cout_f, minstret_enable;\n', '   logic [31:0] minstretl_inc, minstretl_read;\n', '   logic        minstreth_cout_nc;\n', '   logic [31:0] minstreth_inc, minstreth_read;\n', '   logic [31:1] pc_e4, pc_wb, npc_e4, npc_wb;\n', '   logic        mtval_capture_pc_wb, mtval_capture_inst_wb, mtval_clear_wb, mtval_capture_pc_plus2_wb;\n', '   logic valid_csr;\n', '   logic [`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] dec_tlu_br0_addr_e4, dec_tlu_br1_addr_e4;\n', '   logic [1:0]  dec_tlu_br0_bank_e4, dec_tlu_br1_bank_e4;\n', '   logic rfpc_i0_e4, rfpc_i1_e4;\n', '   logic lsu_i0_rfnpc_dc4, lsu_i1_rfnpc_dc4;\n', '   logic lsu_i0_rfpc_dc4, lsu_i1_rfpc_dc4;\n', '   logic dec_tlu_br0_error_e4, dec_tlu_br0_start_error_e4, dec_tlu_br0_v_e4;\n', '   logic dec_tlu_br1_error_e4, dec_tlu_br1_start_error_e4, dec_tlu_br1_v_e4;\n', '   logic lsu_i0_exc_dc4, lsu_i1_exc_dc4, lsu_i0_exc_dc4_raw, lsu_i1_exc_dc4_raw, lsu_exc_ma_dc4, lsu_exc_acc_dc4, lsu_exc_st_dc4,\n', '         lsu_exc_valid_e4, lsu_exc_valid_e4_raw, lsu_exc_valid_wb, lsu_i0_exc_wb,\n', '         block_interrupts, lsu_block_interrupts_dc3, lsu_block_interrupts_e4, lsu_load_ecc_stbuf_full_dc4;\n', '   logic tlu_i0_commit_cmt, tlu_i1_commit_cmt;\n', '   logic i0_trigger_eval_e4, i1_trigger_eval_e4, lsu_freeze_e4, lsu_freeze_pulse_e3, lsu_freeze_pulse_e4;\n', '\n', '   logic request_debug_mode_e4, request_debug_mode_wb, request_debug_mode_done, request_debug_mode_done_f;\n', '   logic take_halt, take_halt_f, halt_taken, halt_taken_f, internal_dbg_halt_mode, dbg_tlu_halted_f, take_reset,\n', '         dbg_tlu_halted, core_empty, lsu_halt_idle_any_f, ifu_miss_state_idle_f, resume_ack_ns,\n', '          debug_halt_req_f, debug_resume_req_f_raw, debug_resume_req_f, enter_debug_halt_req, dcsr_single_step_done, dcsr_single_step_done_f,\n', '          debug_halt_req_d1, debug_halt_req_ns, dcsr_single_step_running, dcsr_single_step_running_f, internal_dbg_halt_timers;\n', '\n', '   logic [3:0] i0_trigger_e4, i1_trigger_e4, trigger_action, trigger_enabled,\n', '               i0_trigger_chain_masked_e4, i1_trigger_chain_masked_e4;\n', '   logic [2:0] trigger_chain;\n', '   logic       i0_trigger_hit_e4, i0_trigger_hit_raw_e4, i0_trigger_action_e4,\n', '               trigger_hit_e4, trigger_hit_wb, i0_trigger_hit_wb,\n', '               mepc_trigger_hit_sel_pc_e4, i0_trigger_set_hit_e4, i1_trigger_set_hit_e4,\n', '               mepc_trigger_hit_sel_pc_wb;\n', '   logic       i1_trigger_hit_e4, i1_trigger_hit_raw_e4, i1_trigger_action_e4;\n', '   logic [3:0] update_hit_bit_e4, update_hit_bit_wb, i0_iside_trigger_has_pri_e4, i1_iside_trigger_has_pri_e4,\n', '               i0_lsu_trigger_has_pri_e4, i1_lsu_trigger_has_pri_e4;\n', '   logic cpu_halt_status, cpu_halt_ack, cpu_run_ack, ext_halt_pulse, i_cpu_halt_req_d1, i_cpu_run_req_d1;\n', '\n', '   logic inst_acc_e4_raw, trigger_hit_dmode_e4, trigger_hit_dmode_wb, trigger_hit_for_dscr_cause_wb;\n', '   logic wr_mcgc_wb, wr_mfdc_wb;\n', '   logic [8:0] mcgc;\n', '   logic [18:0] mfdc;\n', '   logic [14:0] mfdc_int, mfdc_ns;\n', '   logic i_cpu_halt_req_sync_qual, i_cpu_run_req_sync_qual, pmu_fw_halt_req_ns, pmu_fw_halt_req_f, int_timer_stalled,\n', '         fw_halt_req, enter_pmu_fw_halt_req, pmu_fw_tlu_halted, pmu_fw_tlu_halted_f, internal_pmu_fw_halt_mode,\n', '         internal_pmu_fw_halt_mode_f, int_timer0_int_hold, int_timer1_int_hold, int_timer0_int_hold_f, int_timer1_int_hold_f;\n', '   logic dcsr_single_step_running_ff;\n', '   logic nmi_int_delayed, nmi_int_detected;\n', '   logic [3:0] trigger_execute, trigger_data, trigger_store;\n', '   logic mpc_run_state_ns, debug_brkpt_status_ns, mpc_debug_halt_ack_ns, mpc_debug_run_ack_ns, dbg_halt_state_ns, dbg_run_state_ns,\n', '         dbg_halt_state_f, mpc_debug_halt_req_sync_f, mpc_debug_run_req_sync_f, mpc_halt_state_f, mpc_halt_state_ns, mpc_run_state_f, debug_brkpt_status_f,\n', '         mpc_debug_halt_ack_f, mpc_debug_run_ack_f, dbg_run_state_f, dbg_halt_state_ff, mpc_debug_halt_req_sync_pulse,\n', '         mpc_debug_run_req_sync_pulse, debug_brkpt_valid, debug_halt_req, debug_resume_req, dec_tlu_mpc_halted_only_ns;\n', '\n', '   logic wr_mpmc_wb, set_mie_pmu_fw_halt;\n', '   logic [1:1] mpmc_b_ns, mpmc, mpmc_b;\n', '\n', '   // internal timer, isolated for size reasons\n', '   logic [31:0] dec_timer_rddata_d;\n', '   logic dec_timer_read_d, dec_timer_t0_pulse, dec_timer_t1_pulse;\n', '\n', '   dec_timer_ctl int_timers(.*);\n', '   // end of internal timers\n', '\n', '   assign clk_override = dec_tlu_dec_clk_override;\n', '\n', ""   // Async inputs to the core have to be sync'd to the core clock.\n"", '   logic nmi_int_sync, timer_int_sync, i_cpu_halt_req_sync, i_cpu_run_req_sync, mpc_debug_halt_req_sync, mpc_debug_run_req_sync;\n', '   rvsyncss #(6) syncro_ff(.*,\n', '                           .clk(free_clk),\n', '                           .din ({nmi_int,      timer_int,      i_cpu_halt_req,      i_cpu_run_req,      mpc_debug_halt_req,      mpc_debug_run_req}),\n', '                           .dout({nmi_int_sync, timer_int_sync, i_cpu_halt_req_sync, i_cpu_run_req_sync, mpc_debug_halt_req_sync, mpc_debug_run_req_sync}));\n', '\n', '   // for CSRs that have inpipe writes only\n', '\n', '   logic csr_wr_clk;\n', '   rvoclkhdr csrwr_wb_cgc ( .en(dec_csr_wen_wb_mod | clk_override), .l1clk(csr_wr_clk), .* );\n', '   logic lsu_e3_e4_clk, lsu_e4_e5_clk;\n', '\n', '   // LSU exceptions (LSU responsible for prioritizing simultaneous cases)\n', '   lsu_error_pkt_t lsu_error_pkt_dc4;\n', '\n', '   rvoclkhdr lsu_e3_e4_cgc ( .en(lsu_error_pkt_dc3.exc_valid | lsu_error_pkt_dc4.exc_valid | lsu_error_pkt_dc3.single_ecc_error | lsu_error_pkt_dc4.single_ecc_error | clk_override), .l1clk(lsu_e3_e4_clk), .* );\n', '   rvoclkhdr lsu_e4_e5_cgc ( .en(lsu_error_pkt_dc4.exc_valid | lsu_exc_valid_wb | clk_override), .l1clk(lsu_e4_e5_clk), .* );\n', '\n', '   logic freeze_rfpc_e4, rfpc_postsync_in, rfpc_postsync, dma_mem_dccm_req_f;\n', '\n', '   logic e4e5_clk, e4_valid, e5_valid, e4e5_valid, internal_dbg_halt_mode_f, internal_dbg_halt_mode_f2, internal_dbg_halt_mode_f3;\n', '   assign e4_valid = dec_tlu_i0_valid_e4 | dec_tlu_i1_valid_e4;\n', '   assign e4e5_valid = e4_valid | e5_valid | freeze_rfpc_e4;\n', '   rvoclkhdr e4e5_cgc ( .en(e4e5_valid | clk_override), .l1clk(e4e5_clk), .* );\n', '   rvoclkhdr e4e5_int_cgc ( .en(e4e5_valid | internal_dbg_halt_mode_f | i_cpu_run_req_d1 | interrupt_valid | interrupt_valid_wb | reset_delayed | pause_expired_e4 | pause_expired_wb | clk_override), .l1clk(e4e5_int_clk), .* );\n', '\n', '\n', '   assign lsu_freeze_pulse_e3 = lsu_freeze_dc3 & ~lsu_freeze_e4;\n', '   rvdff #(10)  freeff (.*,   .clk(free_clk),\n', '                        .din({internal_dbg_halt_mode_f2,internal_dbg_halt_mode_f, lsu_freeze_dc3, lsu_freeze_pulse_e3,\n', '                              e4_valid, lsu_block_interrupts_dc3, internal_dbg_halt_mode, tlu_flush_lower_e4, tlu_i0_kill_writeb_e4, tlu_i1_kill_writeb_e4 }),\n', '                        .dout({internal_dbg_halt_mode_f3, internal_dbg_halt_mode_f2, lsu_freeze_e4, lsu_freeze_pulse_e4,\n', '                               e5_valid, lsu_block_interrupts_e4, internal_dbg_halt_mode_f, tlu_flush_lower_wb, dec_tlu_i0_kill_writeb_wb, dec_tlu_i1_kill_writeb_wb}));\n', '\n', '\n', ""   rvdff #(2) reset_ff (.*, .clk(free_clk), .din({1'b1, reset_detect}), .dout({reset_detect, reset_detected}));\n"", '   assign reset_delayed = reset_detect ^ reset_detected;\n', '\n', '   rvdff #(4) nmi_ff (.*, .clk(free_clk), .din({nmi_int_sync, nmi_int_detected, nmi_lsu_load_type, nmi_lsu_store_type}), .dout({nmi_int_delayed, nmi_int_detected_f, nmi_lsu_load_type_f, nmi_lsu_store_type_f}));\n', '\n', '   // Filter subsequent bus errors after the first, until the lock on MDSEAC is cleared\n', '   assign nmi_lsu_detected = ~mdseac_locked_f & (lsu_imprecise_error_load_any | lsu_imprecise_error_store_any);\n', '\n', '   assign nmi_int_detected = (nmi_int_sync & ~nmi_int_delayed) | nmi_lsu_detected | (nmi_int_detected_f & ~take_nmi_wb);\n', ""   // if the first nmi is a lsu type, note it. If there's already an nmi pending, ignore\n"", '   assign nmi_lsu_load_type = (nmi_lsu_detected & lsu_imprecise_error_load_any & ~(nmi_int_detected_f & ~take_nmi_wb)) | (nmi_lsu_load_type_f & ~take_nmi_wb);\n', '   assign nmi_lsu_store_type = (nmi_lsu_detected & lsu_imprecise_error_store_any & ~(nmi_int_detected_f & ~take_nmi_wb)) | (nmi_lsu_store_type_f & ~take_nmi_wb);\n', '\n', '`define MSTATUS_MIE 0\n', '`define MIP_MCEIP 5\n', '`define MIP_MITIP0 4\n', '`define MIP_MITIP1 3\n', '`define MIP_MEIP 2\n', '`define MIP_MTIP 1\n', '`define MIP_MSIP 0\n', '\n', '`define MIE_MCEIE 5\n', '`define MIE_MITIE0 4\n', '`define MIE_MITIE1 3\n', '`define MIE_MEIE 2\n', '`define MIE_MTIE 1\n', '`define MIE_MSIE 0\n', '\n', '`define DCSR_EBREAKM 15\n', '`define DCSR_STEPIE 11\n', '`define DCSR_STOPC 10\n', '//`define DCSR_STOPT 9\n', '`define DCSR_STEP 2\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MPC halt\n', '   // - can interact with debugger halt and v-v\n', '\n', '    rvdff #(11)  mpvhalt_ff (.*, .clk(free_clk),\n', '                                 .din({mpc_debug_halt_req_sync, mpc_debug_run_req_sync,\n', '                                       mpc_halt_state_ns, mpc_run_state_ns, debug_brkpt_status_ns,\n', '                                       mpc_debug_halt_ack_ns, mpc_debug_run_ack_ns,\n', '                                       dbg_halt_state_ns, dbg_run_state_ns, dbg_halt_state_f,\n', '                                       dec_tlu_mpc_halted_only_ns}),\n', '                                .dout({mpc_debug_halt_req_sync_f, mpc_debug_run_req_sync_f,\n', '                                       mpc_halt_state_f, mpc_run_state_f, debug_brkpt_status_f,\n', '                                       mpc_debug_halt_ack_f, mpc_debug_run_ack_f,\n', '                                       dbg_halt_state_f, dbg_run_state_f, dbg_halt_state_ff,\n', '                                       dec_tlu_mpc_halted_only}));\n', '\n', '   // turn level sensitive requests into pulses\n', '   assign mpc_debug_halt_req_sync_pulse = mpc_debug_halt_req_sync & ~mpc_debug_halt_req_sync_f;\n', '   assign mpc_debug_run_req_sync_pulse = mpc_debug_run_req_sync & ~mpc_debug_run_req_sync_f;\n', '\n', '   // states\n', '   assign mpc_halt_state_ns = (mpc_halt_state_f | mpc_debug_halt_req_sync_pulse | (reset_delayed & ~mpc_reset_run_req)) & ~mpc_debug_run_req_sync;\n', '   assign mpc_run_state_ns = (mpc_run_state_f | (mpc_debug_run_req_sync_pulse & ~mpc_debug_run_ack_f)) & (internal_dbg_halt_mode_f & ~dcsr_single_step_running_f);\n', '\n', '   // note, MPC halt can allow the jtag debugger to just start sending commands. When that happens, set the interal debugger halt state to prevent\n', '   // MPC run from starting the core.\n', '   assign dbg_halt_state_ns = (dbg_halt_state_f | (dbg_halt_req | dcsr_single_step_done_f | trigger_hit_dmode_wb | ebreak_to_debug_mode_wb)) & ~dbg_resume_req;\n', '   assign dbg_run_state_ns = (dbg_run_state_f | dbg_resume_req) & (internal_dbg_halt_mode_f & ~dcsr_single_step_running_f);\n', '\n', '   // tell dbg we are only MPC halted\n', '   assign dec_tlu_mpc_halted_only_ns = ~dbg_halt_state_f & mpc_halt_state_f;\n', '\n', '   // this asserts from detection of bkpt until after we leave debug mode\n', '   assign debug_brkpt_valid = ebreak_to_debug_mode_wb | trigger_hit_dmode_wb;\n', '   assign debug_brkpt_status_ns = (debug_brkpt_valid | debug_brkpt_status_f) & (internal_dbg_halt_mode & ~dcsr_single_step_running_f);\n', '\n', '   // acks back to interface\n', '   assign mpc_debug_halt_ack_ns = mpc_halt_state_f & internal_dbg_halt_mode_f & mpc_debug_halt_req_sync & core_empty;\n', '   assign mpc_debug_run_ack_ns = (mpc_debug_run_req_sync & ~internal_dbg_halt_mode & ~mpc_debug_halt_req_sync) | (mpc_debug_run_ack_f & mpc_debug_run_req_sync) ;\n', '\n', '   // Pins\n', '   assign mpc_debug_halt_ack = mpc_debug_halt_ack_f;\n', '   assign mpc_debug_run_ack = mpc_debug_run_ack_f;\n', '   assign debug_brkpt_status = debug_brkpt_status_f;\n', '\n', '\n', '   // combine MPC and DBG halt requests\n', '   assign debug_halt_req = (dbg_halt_req | mpc_debug_halt_req_sync | (reset_delayed & ~mpc_reset_run_req)) & ~internal_dbg_halt_mode_f;\n', '\n', '   assign debug_resume_req = ~debug_resume_req_f &  // squash back to back resumes\n', '                             ((mpc_run_state_ns & ~dbg_halt_state_ns) |  // MPC run req\n', '                              (dbg_run_state_ns & ~mpc_halt_state_ns)); // dbg request is a pulse\n', '\n', '   // HALT\n', '\n', '   // dbg/pmu/fw requests halt, service as soon as lsu is not blocking interrupts\n', '   assign take_halt = (debug_halt_req_f | pmu_fw_halt_req_f) & ~lsu_block_interrupts_e4 & ~synchronous_flush_e4 & ~mret_e4 & ~halt_taken_f & ~dec_tlu_flush_noredir_wb & ~take_reset;\n', '\n', ""   // hold after we take a halt, so we don't keep taking halts\n"", '   assign halt_taken = (dec_tlu_flush_noredir_wb & ~dec_tlu_flush_pause_wb) | (halt_taken_f & ~dbg_tlu_halted_f & ~pmu_fw_tlu_halted_f & ~interrupt_valid_wb);\n', '\n', '   // After doing halt flush (RFNPC) wait until core is idle before asserting a particular halt mode\n', '   // It takes a cycle for mb_empty to assert after a fetch, take_halt covers that cycle\n', '   assign core_empty = lsu_halt_idle_any & lsu_halt_idle_any_f & ifu_miss_state_idle & ifu_miss_state_idle_f & ~debug_halt_req & ~debug_halt_req_d1;\n', '\n', '//--------------------------------------------------------------------------------\n', '// Debug start\n', '//\n', '\n', '   assign enter_debug_halt_req = (~internal_dbg_halt_mode_f & debug_halt_req) | dcsr_single_step_done_f | trigger_hit_dmode_wb | ebreak_to_debug_mode_wb;\n', '\n', '   // dbg halt state active from request until non-step resume\n', '   assign internal_dbg_halt_mode = debug_halt_req_ns | (internal_dbg_halt_mode_f & ~(debug_resume_req_f & ~dcsr[`DCSR_STEP]));\n', '   // dbg halt can access csrs as long as we are not stepping\n', '   assign allow_dbg_halt_csr_write = internal_dbg_halt_mode_f & ~dcsr_single_step_running_f;\n', '\n', '\n', '   // hold debug_halt_req_ns high until we enter debug halt\n', '   assign debug_halt_req_ns = enter_debug_halt_req | (debug_halt_req_f & ~dbg_tlu_halted);\n', '\n', '   assign dbg_tlu_halted = (debug_halt_req_f & core_empty & halt_taken) | (dbg_tlu_halted_f & ~debug_resume_req_f);\n', '\n', '   assign resume_ack_ns = (debug_resume_req_f & dbg_tlu_halted_f & dbg_run_state_ns);\n', '\n', '   assign dcsr_single_step_done = dec_tlu_i0_valid_e4 & ~dec_tlu_dbg_halted & dcsr[`DCSR_STEP] & ~rfpc_i0_e4;\n', '\n', '   assign dcsr_single_step_running = (debug_resume_req_f & dcsr[`DCSR_STEP]) | (dcsr_single_step_running_f & ~dcsr_single_step_done_f);\n', '\n', '   assign dbg_cmd_done_ns = dec_tlu_i0_valid_e4 & dec_tlu_dbg_halted;\n', '\n', '   // used to hold off commits after an in-pipe debug mode request (triggers, DCSR)\n', '   assign request_debug_mode_e4 = (trigger_hit_dmode_e4 | ebreak_to_debug_mode_e4) | (request_debug_mode_wb & ~dec_tlu_flush_lower_wb);\n', '\n', '   assign request_debug_mode_done = (request_debug_mode_wb | request_debug_mode_done_f) & ~dbg_tlu_halted_f;\n', '\n', '    rvdff #(22)  halt_ff (.*, .clk(free_clk), .din({halt_taken, take_halt, lsu_halt_idle_any, ifu_miss_state_idle, dbg_tlu_halted,\n', '                                  resume_ack_ns, dbg_cmd_done_ns, debug_halt_req_ns, debug_resume_req, trigger_hit_dmode_e4,\n', '                                  dcsr_single_step_done, debug_halt_req,  update_hit_bit_e4[3:0], dec_tlu_wr_pause_wb, dec_pause_state,\n', '                                  request_debug_mode_e4, request_debug_mode_done, dcsr_single_step_running, dcsr_single_step_running_f}),\n', '                           .dout({halt_taken_f, take_halt_f, lsu_halt_idle_any_f, ifu_miss_state_idle_f, dbg_tlu_halted_f,\n', '                                  dec_tlu_resume_ack, dec_dbg_cmd_done, debug_halt_req_f, debug_resume_req_f_raw, trigger_hit_dmode_wb,\n', '                                  dcsr_single_step_done_f, debug_halt_req_d1, update_hit_bit_wb[3:0], dec_tlu_wr_pause_wb_f, dec_pause_state_f,\n', '                                  request_debug_mode_wb, request_debug_mode_done_f, dcsr_single_step_running_f, dcsr_single_step_running_ff}));\n', '\n', '   // MPC run collides with DBG halt, fix it here\n', '   assign debug_resume_req_f = debug_resume_req_f_raw & ~dbg_halt_req;\n', '\n', '   assign dec_tlu_debug_stall = debug_halt_req_f;\n', '   assign dec_tlu_dbg_halted = dbg_tlu_halted_f;\n', '   assign dec_tlu_debug_mode = internal_dbg_halt_mode_f;\n', '   assign dec_tlu_pmu_fw_halted = pmu_fw_tlu_halted_f;\n', '\n', ""   // kill fetch redirection on flush if going to halt, or if there's a fence during db-halt\n"", '   assign dec_tlu_flush_noredir_wb = take_halt_f | (fence_i_wb & internal_dbg_halt_mode_f) | dec_tlu_flush_pause_wb | (trigger_hit_wb & trigger_hit_dmode_wb);\n', '\n', '   // 1 cycle after writing the PAUSE counter, flush with noredir to idle F1-D.\n', '   assign dec_tlu_flush_pause_wb = dec_tlu_wr_pause_wb_f & ~interrupt_valid_wb;\n', '\n', '   // detect end of pause counter and rfpc\n', '   assign pause_expired_e4 = ~dec_pause_state & dec_pause_state_f & ~(ext_int_ready | ce_int_ready | timer_int_ready | int_timer0_int_hold_f | int_timer1_int_hold_f | nmi_int_detected) & ~interrupt_valid_wb & ~debug_halt_req_f & ~pmu_fw_halt_req_f & ~halt_taken_f;\n', '\n', '   // stall dma fifo if a fence is pending, decode is waiting for lsu to idle before decoding the fence inst.\n', '   assign dec_tlu_stall_dma = dec_fence_pending  & dec_tlu_dccm_nonblock_dma_disable; // Stall the DMA for fences when chicken bit is set;\n', '   assign dec_tlu_flush_leak_one_wb = dec_tlu_flush_lower_wb  & dcsr[`DCSR_STEP] & (dec_tlu_resume_ack | dcsr_single_step_running);\n', '   assign dec_tlu_flush_err_wb = dec_tlu_flush_lower_wb & (ic_perr_wb | iccm_sbecc_wb);\n', '\n', '   // If DM attempts to access an illegal CSR, send cmd_fail back\n', '   assign dec_dbg_cmd_fail = illegal_raw_wb & dec_dbg_cmd_done;\n', '\n', '\n', '   //--------------------------------------------------------------------------------\n', '   //--------------------------------------------------------------------------------\n', '   // Triggers\n', '   //\n', '`define MTDATA1_DMODE 9\n', '`define MTDATA1_SEL 7\n', '`define MTDATA1_ACTION 6\n', '`define MTDATA1_CHAIN 5\n', '`define MTDATA1_MATCH 4\n', '`define MTDATA1_M_ENABLED 3\n', '`define MTDATA1_EXE 2\n', '`define MTDATA1_ST 1\n', '`define MTDATA1_LD 0\n', '\n', '   // Prioritize trigger hits with other exceptions.\n', '   //\n', '   // Trigger should have highest priority except:\n', ""   // - trigger is an execute-data and there is an inst_access exception (lsu triggers won't fire, inst. is nop'd by decode)\n"", '   // - trigger is a store-data and there is a lsu_acc_exc or lsu_ma_exc.\n', '   assign trigger_execute[3:0] = {mtdata1_t3[`MTDATA1_EXE], mtdata1_t2[`MTDATA1_EXE], mtdata1_t1[`MTDATA1_EXE], mtdata1_t0[`MTDATA1_EXE]};\n', '   assign trigger_data[3:0] = {mtdata1_t3[`MTDATA1_SEL], mtdata1_t2[`MTDATA1_SEL], mtdata1_t1[`MTDATA1_SEL], mtdata1_t0[`MTDATA1_SEL]};\n', '   assign trigger_store[3:0] = {mtdata1_t3[`MTDATA1_ST], mtdata1_t2[`MTDATA1_ST], mtdata1_t1[`MTDATA1_ST], mtdata1_t0[`MTDATA1_ST]};\n', '\n', '\n', '   // MSTATUS[MIE] needs to be on to take triggers unless the action is trigger to debug mode.\n', '   assign trigger_enabled[3:0] = {(mtdata1_t3[`MTDATA1_ACTION] | mstatus[`MSTATUS_MIE]) & mtdata1_t3[`MTDATA1_M_ENABLED],\n', '                                  (mtdata1_t2[`MTDATA1_ACTION] | mstatus[`MSTATUS_MIE]) & mtdata1_t2[`MTDATA1_M_ENABLED],\n', '                                  (mtdata1_t1[`MTDATA1_ACTION] | mstatus[`MSTATUS_MIE]) & mtdata1_t1[`MTDATA1_M_ENABLED],\n', '                                  (mtdata1_t0[`MTDATA1_ACTION] | mstatus[`MSTATUS_MIE]) & mtdata1_t0[`MTDATA1_M_ENABLED]};\n', '\n', '   // iside exceptions are always in i0\n', '   assign i0_iside_trigger_has_pri_e4[3:0] = ~( (trigger_execute[3:0] & trigger_data[3:0] & {4{inst_acc_e4_raw}}) | // exe-data with inst_acc\n', '                                                ({4{exu_i0_br_error_e4 | exu_i0_br_start_error_e4}}));              // branch error in i0\n', '\n', '   assign i1_iside_trigger_has_pri_e4[3:0] = ~( ({4{exu_i1_br_error_e4 | exu_i1_br_start_error_e4}}) ); // branch error in i1\n', '\n', '   // lsu excs have to line up with their respective triggers since the lsu op can be in either i0 or i1 but not both\n', '   assign i0_lsu_trigger_has_pri_e4[3:0] = ~(trigger_store[3:0] & trigger_data[3:0] & {4{lsu_i0_exc_dc4_raw}});\n', '   assign i1_lsu_trigger_has_pri_e4[3:0] = ~(trigger_store[3:0] & trigger_data[3:0] & {4{lsu_i1_exc_dc4_raw}});\n', '\n', '   // Qual trigger hits\n', '   assign i0_trigger_eval_e4 = dec_tlu_i0_valid_e4 | ( dec_i0_load_e4 & lsu_freeze_pulse_e4);\n', '   assign i1_trigger_eval_e4 = dec_tlu_i1_valid_e4 | (~dec_i0_load_e4 & lsu_freeze_pulse_e4);\n', '\n', '   assign i0_trigger_e4[3:0] = {4{i0_trigger_eval_e4}} & dec_tlu_packet_e4.i0trigger[3:0] & i0_iside_trigger_has_pri_e4[3:0] & i0_lsu_trigger_has_pri_e4[3:0] & trigger_enabled[3:0];\n', '   assign i1_trigger_e4[3:0] = {4{i1_trigger_eval_e4}} & dec_tlu_packet_e4.i1trigger[3:0] & i1_iside_trigger_has_pri_e4[3:0] & i1_lsu_trigger_has_pri_e4[3:0] & trigger_enabled[3:0];\n', '\n', '   assign trigger_chain[2:0] = {mtdata1_t2[`MTDATA1_CHAIN], mtdata1_t1[`MTDATA1_CHAIN], mtdata1_t0[`MTDATA1_CHAIN]};\n', '\n', '   // chaining can mask raw trigger info\n', '   assign i0_trigger_chain_masked_e4[3:0] = {i0_trigger_e4[3] & (~trigger_chain[2] | i0_trigger_e4[2]),\n', '                                             i0_trigger_e4[2] & (~trigger_chain[2] | i0_trigger_e4[3]),\n', '                                             i0_trigger_e4[1] & (~trigger_chain[0] | i0_trigger_e4[0]),\n', '                                             i0_trigger_e4[0] & (~trigger_chain[0] | i0_trigger_e4[1])};\n', '\n', '   assign i1_trigger_chain_masked_e4[3:0] = {i1_trigger_e4[3] & (~trigger_chain[2] | i1_trigger_e4[2]),\n', '                                             i1_trigger_e4[2] & (~trigger_chain[2] | i1_trigger_e4[3]),\n', '                                             i1_trigger_e4[1] & (~trigger_chain[0] | i1_trigger_e4[0]),\n', '                                             i1_trigger_e4[0] & (~trigger_chain[0] | i1_trigger_e4[1])};\n', '\n', '   // This is the highest priority by this point.\n', '   assign i0_trigger_hit_raw_e4 = |i0_trigger_chain_masked_e4[3:0];\n', '   assign i1_trigger_hit_raw_e4 = |i1_trigger_chain_masked_e4[3:0];\n', '\n', '   // Qual trigger hits\n', '   assign i0_trigger_hit_e4 = ~(dec_tlu_flush_lower_wb | dec_tlu_dbg_halted | lsu_freeze_pulse_e4) & i0_trigger_hit_raw_e4;\n', '   assign i1_trigger_hit_e4 = ~(dec_tlu_flush_lower_wb | ~tlu_i0_commit_cmt | exu_i0_br_mp_e4 | dec_tlu_dbg_halted | lsu_freeze_pulse_e4 | lsu_i0_rfnpc_dc4) & i1_trigger_hit_raw_e4;\n', '\n', '   assign dec_tlu_cancel_e4 = (i0_trigger_hit_raw_e4 | i1_trigger_hit_raw_e4) & lsu_freeze_pulse_e4;\n', '\n', '   // Actions include breakpoint, or dmode. Dmode is only possible if the DMODE bit is set.\n', '   // Otherwise, take a breakpoint.\n', '   assign trigger_action[3:0] = {mtdata1_t3[`MTDATA1_ACTION] & mtdata1_t3[`MTDATA1_DMODE],\n', '                                 mtdata1_t2[`MTDATA1_ACTION] & mtdata1_t2[`MTDATA1_DMODE] & ~mtdata1_t2[`MTDATA1_CHAIN],\n', '                                 mtdata1_t1[`MTDATA1_ACTION] & mtdata1_t1[`MTDATA1_DMODE],\n', '                                 mtdata1_t0[`MTDATA1_ACTION] & mtdata1_t0[`MTDATA1_DMODE] & ~mtdata1_t0[`MTDATA1_CHAIN]};\n', '\n', '   // this is needed to set the HIT bit in the triggers\n', '   assign i0_trigger_set_hit_e4 = |i0_trigger_e4[3:0] & ~(dec_tlu_flush_lower_wb | dec_tlu_dbg_halted | rfpc_i0_e4);\n', '   assign i1_trigger_set_hit_e4 = |i1_trigger_e4[3:0] & ~(dec_tlu_flush_lower_wb | dec_tlu_dbg_halted |\n', '                                                          ~tlu_i0_commit_cmt | exu_i0_br_mp_e4 | dec_tlu_dbg_halted |\n', '                                                          lsu_freeze_pulse_e4 | lsu_i0_rfnpc_dc4 | rfpc_i1_e4);\n', '\n', '   assign update_hit_bit_e4[3:0] = ({4{i0_trigger_set_hit_e4}} & {i0_trigger_chain_masked_e4[3], i0_trigger_e4[2], i0_trigger_chain_masked_e4[1], i0_trigger_e4[0]} ) |\n', '                                   ({4{i1_trigger_set_hit_e4}} & {i1_trigger_chain_masked_e4[3], i1_trigger_e4[2], i1_trigger_chain_masked_e4[1], i1_trigger_e4[0]} );\n', '\n', '   // action, 1 means dmode. Simultaneous triggers with at least 1 set for dmode force entire action to dmode.\n', '   assign i0_trigger_action_e4 = |(i0_trigger_chain_masked_e4[3:0] & trigger_action[3:0]);\n', '   assign i1_trigger_action_e4 = |(i1_trigger_chain_masked_e4[3:0] & trigger_action[3:0]);\n', '\n', '   assign trigger_hit_e4 = i0_trigger_hit_e4 | i1_trigger_hit_e4;\n', '   assign trigger_hit_dmode_e4 = (i0_trigger_hit_e4 & i0_trigger_action_e4) | (i1_trigger_hit_e4 & ~i0_trigger_hit_e4 & i1_trigger_action_e4);\n', '\n', '   assign mepc_trigger_hit_sel_pc_e4 = trigger_hit_e4 & ~trigger_hit_dmode_e4;\n', '\n', '\n', '//\n', '// Debug end\n', '//--------------------------------------------------------------------------------\n', '\n', '   //----------------------------------------------------------------------\n', '   //\n', '   // Commit\n', '   //\n', '   //----------------------------------------------------------------------\n', '\n', '\n', '\n', '   //--------------------------------------------------------------------------------\n', '   // External halt (not debug halt)\n', '   // - Fully interlocked handshake\n', '   // i_cpu_halt_req  ____|--------------|_______________\n', '   // core_empty      ---------------|___________\n', '   // o_cpu_halt_ack  _________________|----|__________\n', '   // o_cpu_halt_status _______________|---------------------|_________\n', '   // i_cpu_run_req                              ______|----------|____\n', '   // o_cpu_run_ack                              ____________|------|________\n', '   //\n', '\n', '\n', '   // debug mode has priority, ignore PMU/FW halt/run while in debug mode\n', '   assign i_cpu_halt_req_sync_qual = i_cpu_halt_req_sync & ~dec_tlu_debug_mode;\n', '   assign i_cpu_run_req_sync_qual = i_cpu_run_req_sync & ~dec_tlu_debug_mode & pmu_fw_tlu_halted_f;\n', '\n', '   rvdff #(10) exthaltff (.*, .clk(free_clk), .din({i_cpu_halt_req_sync_qual, i_cpu_run_req_sync_qual,   cpu_halt_status,\n', '                                                   cpu_halt_ack,   cpu_run_ack, internal_pmu_fw_halt_mode,\n', '                                                   pmu_fw_halt_req_ns, pmu_fw_tlu_halted,\n', '                                                   int_timer0_int_hold, int_timer1_int_hold}),\n', '                                            .dout({i_cpu_halt_req_d1,        i_cpu_run_req_d1_raw,      o_cpu_halt_status,\n', '                                                   o_cpu_halt_ack, o_cpu_run_ack, internal_pmu_fw_halt_mode_f,\n', '                                                   pmu_fw_halt_req_f, pmu_fw_tlu_halted_f,\n', '                                                   int_timer0_int_hold_f, int_timer1_int_hold_f}));\n', '\n', ""   // only happens if we aren't in dgb_halt\n"", '   assign ext_halt_pulse = i_cpu_halt_req_sync_qual & ~i_cpu_halt_req_d1;\n', '\n', '   assign enter_pmu_fw_halt_req =  ext_halt_pulse | fw_halt_req;\n', '\n', '   assign pmu_fw_halt_req_ns = (enter_pmu_fw_halt_req | (pmu_fw_halt_req_f & ~pmu_fw_tlu_halted)) & ~debug_halt_req_f;\n', '\n', '   assign internal_pmu_fw_halt_mode = pmu_fw_halt_req_ns | (internal_pmu_fw_halt_mode_f & ~i_cpu_run_req_d1 & ~debug_halt_req_f);\n', '\n', '   // debug halt has priority\n', '   assign pmu_fw_tlu_halted = ((pmu_fw_halt_req_f & core_empty & halt_taken & ~enter_debug_halt_req) | (pmu_fw_tlu_halted_f & ~i_cpu_run_req_d1)) & ~debug_halt_req_f;\n', '\n', '   assign cpu_halt_ack = i_cpu_halt_req_d1 & pmu_fw_tlu_halted_f;\n', '   assign cpu_halt_status = (pmu_fw_tlu_halted_f & ~i_cpu_run_req_d1) | (o_cpu_halt_status & ~i_cpu_run_req_d1 & ~internal_dbg_halt_mode_f);\n', '   assign cpu_run_ack = (o_cpu_halt_status & i_cpu_run_req_d1_raw) | (o_cpu_run_ack & i_cpu_run_req_sync);\n', '   assign debug_mode_status = internal_dbg_halt_mode_f;\n', '   assign o_debug_mode_status = debug_mode_status;// & ~mpc_debug_run_ack_f;\n', '\n', '`ifdef ASSERT_ON\n', '  assert_commit_while_halted: assert #0 (~((tlu_i0_commit_cmt | tlu_i1_commit_cmt) & o_cpu_halt_status)) else $display(""ERROR: Commiting while cpu_halt_status asserted!"");\n', '`endif\n', '\n', '   // high priority interrupts can wakeup from external halt, so can unmasked timer interrupts\n', '   assign i_cpu_run_req_d1 = i_cpu_run_req_d1_raw | ((nmi_int_detected | timer_int_ready | int_timer0_int_hold_f | int_timer1_int_hold_f | (mhwakeup & mhwakeup_ready)) & o_cpu_halt_status);\n', '\n', '   //--------------------------------------------------------------------------------\n', '   //--------------------------------------------------------------------------------\n', '\n', '   rvdff #( $bits(lsu_error_pkt_t)+1 ) lsu_error_dc4ff (.*, .clk(lsu_e3_e4_clk), .din({lsu_error_pkt_dc3, lsu_load_ecc_stbuf_full_dc3}),  .dout({lsu_error_pkt_dc4, lsu_load_ecc_stbuf_full_dc4}));\n', '\n', '   logic lsu_single_ecc_error_wb_ns;\n', '   assign lsu_single_ecc_error_wb_ns = lsu_single_ecc_error_incr;\n', '   rvdff #(2) lsu_dccm_errorff (.*, .clk(free_clk), .din({mdseac_locked_ns, lsu_single_ecc_error_wb_ns}), .dout({mdseac_locked_f, lsu_single_ecc_error_wb}));\n', '\n', '   logic [31:0] lsu_error_pkt_addr_dc4, lsu_error_pkt_addr_wb;\n', '   assign lsu_error_pkt_addr_dc4[31:0] = lsu_error_pkt_dc4.addr[31:0];\n', '   rvdff #(34) lsu_error_wbff (.*, .clk(lsu_e4_e5_clk), .din({lsu_error_pkt_addr_dc4[31:0], lsu_exc_valid_e4, lsu_i0_exc_dc4}),  .dout({lsu_error_pkt_addr_wb[31:0], lsu_exc_valid_wb, lsu_i0_exc_wb}));\n', '\n', '\n', ""   // lsu exception is valid unless it's in pipe1 and there was a rfpc_i0_e4, brmp, or an iside exception in pipe0.\n"", '   assign lsu_exc_valid_e4_raw = lsu_error_pkt_dc4.exc_valid & ~(lsu_error_pkt_dc4.inst_pipe & (rfpc_i0_e4 | i0_exception_valid_e4 | exu_i0_br_mp_e4)) & ~dec_tlu_flush_lower_wb;\n', '\n', '   assign lsu_i0_exc_dc4_raw =  lsu_error_pkt_dc4.exc_valid & ~lsu_error_pkt_dc4.inst_pipe;\n', '   assign lsu_i1_exc_dc4_raw = lsu_error_pkt_dc4.exc_valid &  lsu_error_pkt_dc4.inst_pipe;\n', '   assign lsu_i0_exc_dc4 = lsu_i0_exc_dc4_raw & lsu_exc_valid_e4_raw & ~i0_trigger_hit_e4;\n', '   assign lsu_i1_exc_dc4 = lsu_i1_exc_dc4_raw & lsu_exc_valid_e4_raw & ~trigger_hit_e4;\n', '   assign lsu_exc_valid_e4 = lsu_i0_exc_dc4 | lsu_i1_exc_dc4;\n', '\n', '   assign lsu_exc_ma_dc4 = (lsu_i0_exc_dc4 | lsu_i1_exc_dc4) & ~lsu_error_pkt_dc4.exc_type;\n', '   assign lsu_exc_acc_dc4 = (lsu_i0_exc_dc4 | lsu_i1_exc_dc4) & lsu_error_pkt_dc4.exc_type;\n', '   assign lsu_exc_st_dc4 = (lsu_i0_exc_dc4 | lsu_i1_exc_dc4) & lsu_error_pkt_dc4.inst_type;\n', '\n', '   // If the stbuf is not full, then\n', '   // Single bit ECC errors on loads are RFNPC corrected, with the corrected data written to the GPR.\n', '   // LSU turns the load into a store and patches the data in the DCCM\n', '   assign lsu_i0_rfnpc_dc4 = dec_tlu_i0_valid_e4 & ~lsu_error_pkt_dc4.inst_pipe & ~lsu_error_pkt_dc4.inst_type &\n', '                             lsu_error_pkt_dc4.single_ecc_error & ~lsu_error_pkt_dc4.dma_valid & ~i0_trigger_hit_e4 & ~lsu_load_ecc_stbuf_full_dc4;\n', '   assign lsu_i1_rfnpc_dc4 = dec_tlu_i1_valid_e4 &  lsu_error_pkt_dc4.inst_pipe & ~lsu_error_pkt_dc4.inst_type &\n', '                             lsu_error_pkt_dc4.single_ecc_error & ~lsu_error_pkt_dc4.dma_valid & ~i0_trigger_hit_e4 & ~i1_trigger_hit_e4 & ~lsu_load_ecc_stbuf_full_dc4;\n', '   // otherwise, they are rfpcs\n', '   assign lsu_i0_rfpc_dc4 = dec_tlu_i0_valid_e4 & ~lsu_error_pkt_dc4.inst_pipe & ~lsu_error_pkt_dc4.inst_type &\n', '                            lsu_error_pkt_dc4.single_ecc_error & ~lsu_error_pkt_dc4.dma_valid & lsu_load_ecc_stbuf_full_dc4;\n', '   assign lsu_i1_rfpc_dc4 = dec_tlu_i1_valid_e4 &  lsu_error_pkt_dc4.inst_pipe & ~lsu_error_pkt_dc4.inst_type &\n', '                             lsu_error_pkt_dc4.single_ecc_error & ~lsu_error_pkt_dc4.dma_valid & lsu_load_ecc_stbuf_full_dc4;\n', '\n', '   // Branch prediction updating\n', '   assign dec_tlu_br0_addr_e4[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] = exu_i0_br_index_e4[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO];\n', '   assign dec_tlu_br0_bank_e4[1:0] = exu_i0_br_bank_e4[1:0];\n', '   assign dec_tlu_br1_addr_e4[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] = exu_i1_br_index_e4[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO];\n', '   assign dec_tlu_br1_bank_e4[1:0] = exu_i1_br_bank_e4[1:0];\n', '\n', '\n', '   //  Final commit valids\n', '   assign tlu_i0_commit_cmt = dec_tlu_i0_valid_e4 &\n', '                              ~rfpc_i0_e4 &\n', '                              ~lsu_i0_exc_dc4 &\n', '                              ~inst_acc_e4 &\n', '                              ~dec_tlu_dbg_halted &\n', '                              ~request_debug_mode_wb &\n', '                              ~i0_trigger_hit_e4;\n', '\n', '   assign tlu_i1_commit_cmt = dec_tlu_i1_valid_e4 &\n', '                              ~rfpc_i0_e4 & ~rfpc_i1_e4 &\n', '                              ~exu_i0_br_mp_e4 &\n', '                              ~lsu_i0_exc_dc4 & ~lsu_i1_exc_dc4 &\n', '                              ~lsu_i0_rfnpc_dc4 &\n', '                              ~inst_acc_e4 &\n', '                              ~request_debug_mode_wb &\n', '                              ~trigger_hit_e4;\n', '\n', '   // unified place to manage the killing of arch state writebacks\n', '   assign tlu_i0_kill_writeb_e4 = rfpc_i0_e4 | lsu_i0_exc_dc4 | inst_acc_e4 | (illegal_e4 & dec_tlu_dbg_halted) | i0_trigger_hit_e4 ;\n', '   assign tlu_i1_kill_writeb_e4 = rfpc_i0_e4 | rfpc_i1_e4 | lsu_exc_valid_e4 | exu_i0_br_mp_e4 | inst_acc_e4 | (illegal_e4 & dec_tlu_dbg_halted) | trigger_hit_e4 | lsu_i0_rfnpc_dc4;\n', '\n', '   // Auto postsync loads that freeze when DMA requests are stalled, if not disabled with MFDC[13].\n', '   assign freeze_rfpc_e4 = (lsu_block_interrupts_e4 | (dma_mem_dccm_req_f & lsu_freeze_e4)) & ~dec_tlu_flush_lower_wb & mfdc[13];\n', '   assign rfpc_postsync_in = (freeze_rfpc_e4 | rfpc_postsync) & ~tlu_i0_commit_cmt;\n', '   assign dec_tlu_dccm_nonblock_dma_disable = ~mfdc[13];\n', '\n', '   rvdff #(2)  freezerfpc_ff (.*,   .clk(free_clk),\n', '                              .din({rfpc_postsync_in, dma_mem_dccm_req}),\n', '                              .dout({rfpc_postsync, dma_mem_dccm_req_f}));\n', '\n', '\n', '   // refetch PC, microarch flush\n', '   // ic errors only in pipe0\n', '   assign rfpc_i0_e4 = freeze_rfpc_e4 | (\n', '                       dec_tlu_i0_valid_e4 & ~tlu_flush_lower_wb & (exu_i0_br_error_e4 | exu_i0_br_start_error_e4 | ic_perr_e4 | iccm_sbecc_e4 | lsu_i0_rfpc_dc4) & ~i0_trigger_hit_e4);\n', '    assign rfpc_i1_e4 = dec_tlu_i1_valid_e4 & ~tlu_flush_lower_wb & ~i0_exception_valid_e4 & ~exu_i0_br_mp_e4 & ~lsu_i0_exc_dc4 & ~lsu_i0_rfnpc_dc4 &\n', '                       ~(exu_i0_br_error_e4 | exu_i0_br_start_error_e4 | ic_perr_e4 | iccm_sbecc_e4 | lsu_i0_rfpc_dc4) &\n', '                       (exu_i1_br_error_e4 | exu_i1_br_start_error_e4 | lsu_i1_rfpc_dc4) &\n', '                       ~trigger_hit_e4;\n', '\n', ""   // go ahead and repair the branch error on other flushes, doesn't have to be the rfpc flush\n"", '   assign dec_tlu_br0_error_e4 = exu_i0_br_error_e4 & dec_tlu_i0_valid_e4 & ~tlu_flush_lower_wb;\n', '   assign dec_tlu_br0_start_error_e4 = exu_i0_br_start_error_e4 & dec_tlu_i0_valid_e4 & ~tlu_flush_lower_wb;\n', '   assign dec_tlu_br0_v_e4 = exu_i0_br_valid_e4 & dec_tlu_i0_valid_e4 & ~tlu_flush_lower_wb & ~exu_i0_br_mp_e4;\n', '\n', '   assign dec_tlu_br1_error_e4 = exu_i1_br_error_e4 & dec_tlu_i1_valid_e4 & ~tlu_flush_lower_wb & ~exu_i0_br_mp_e4;\n', '   assign dec_tlu_br1_start_error_e4 = exu_i1_br_start_error_e4 & dec_tlu_i1_valid_e4 & ~tlu_flush_lower_wb & ~exu_i0_br_mp_e4;\n', '   assign dec_tlu_br1_v_e4 = exu_i1_br_valid_e4 & ~tlu_flush_lower_wb & dec_tlu_i1_valid_e4 & ~exu_i0_br_mp_e4 & ~exu_i1_br_mp_e4;\n', '\n', '`ifdef RV_BTB_48\n', '   rvdff #(20)\n', '`else\n', '   rvdff #(18)\n', '`endif\n', '   bp_wb_ff (.*, .clk(e4e5_clk),\n', '                            .din({exu_i0_br_hist_e4[1:0],\n', '                                  dec_tlu_br0_error_e4,\n', '                                  dec_tlu_br0_start_error_e4,\n', '                                  dec_tlu_br0_v_e4,\n', '                                  exu_i1_br_hist_e4[1:0],\n', '                                  dec_tlu_br1_error_e4,\n', '                                  dec_tlu_br1_start_error_e4,\n', '                                  dec_tlu_br1_v_e4,\n', '                                  dec_tlu_br0_bank_e4[1:0],\n', '                                  dec_tlu_br1_bank_e4[1:0],\n', '                                  exu_i0_br_way_e4,\n', '                                  exu_i1_br_way_e4,\n', '                                  exu_i0_br_middle_e4,\n', '                                  exu_i1_br_middle_e4\n', '                                  }),\n', '                           .dout({dec_tlu_br0_wb_pkt.hist[1:0],\n', '                                  dec_tlu_br0_wb_pkt.br_error,\n', '                                  dec_tlu_br0_wb_pkt.br_start_error,\n', '                                  dec_tlu_br0_wb_pkt.valid,\n', '                                  dec_tlu_br1_wb_pkt.hist[1:0],\n', '                                  dec_tlu_br1_wb_pkt.br_error,\n', '                                  dec_tlu_br1_wb_pkt.br_start_error,\n', '                                  dec_tlu_br1_wb_pkt.valid,\n', '                                  dec_tlu_br0_wb_pkt.bank[1:0],\n', '                                  dec_tlu_br1_wb_pkt.bank[1:0],\n', '                                  dec_tlu_br0_wb_pkt.way,\n', '                                  dec_tlu_br1_wb_pkt.way,\n', '                                  dec_tlu_br0_wb_pkt.middle,\n', '                                  dec_tlu_br1_wb_pkt.middle\n', '                                  }));\n', '\n', '   rvdff #(`RV_BHT_GHR_SIZE*2)  bp_wb_ghrff (.*,  .clk(e4e5_clk),\n', '                                               .din({exu_i0_br_fghr_e4[`RV_BHT_GHR_RANGE],\n', '                                                     exu_i1_br_fghr_e4[`RV_BHT_GHR_RANGE]\n', '                                                     }),\n', '                                              .dout({dec_tlu_br0_wb_pkt.fghr[`RV_BHT_GHR_RANGE],\n', '                                                     dec_tlu_br1_wb_pkt.fghr[`RV_BHT_GHR_RANGE]\n', '                                                     }));\n', '\n', '   rvdff #(2*$bits(dec_tlu_br0_addr_e4[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO]))\n', '        bp_wb_index_ff (.*,  .clk(e4e5_clk),\n', '                            .din({dec_tlu_br0_addr_e4[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO],\n', '                                  dec_tlu_br1_addr_e4[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO]}),\n', '                           .dout({dec_tlu_br0_wb_pkt.index[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO],\n', '                                  dec_tlu_br1_wb_pkt.index[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO]}));\n', '\n', '   // only expect these in pipe 0\n', '   assign       ebreak_e4    =  (dec_tlu_packet_e4.pmu_i0_itype == EBREAK)  & dec_tlu_i0_valid_e4 & ~i0_trigger_hit_e4 & ~dcsr[`DCSR_EBREAKM];\n', '   assign       ecall_e4     =  (dec_tlu_packet_e4.pmu_i0_itype == ECALL)   & dec_tlu_i0_valid_e4 & ~i0_trigger_hit_e4;\n', '   assign       illegal_e4   =  ~dec_tlu_packet_e4.legal   & dec_tlu_i0_valid_e4 & ~i0_trigger_hit_e4;\n', '   assign       mret_e4      =  (dec_tlu_packet_e4.pmu_i0_itype == MRET)    & dec_tlu_i0_valid_e4 & ~i0_trigger_hit_e4;\n', ""   // fence_i includes debug only fence_i's\n"", '   assign       fence_i_e4   =  (dec_tlu_packet_e4.fence_i & dec_tlu_i0_valid_e4 & ~i0_trigger_hit_e4); //| csr_fence_i_wb;\n', '   assign       ic_perr_e4    =  dec_tlu_packet_e4.perr    & dec_tlu_i0_valid_e4 & ~i0_trigger_hit_e4;\n', '   assign       iccm_sbecc_e4 =  dec_tlu_packet_e4.sbecc   & dec_tlu_i0_valid_e4 & ~i0_trigger_hit_e4;\n', '   assign       inst_acc_e4_raw  =  dec_tlu_packet_e4.icaf & dec_tlu_i0_valid_e4;\n', '   assign       inst_acc_e4 = inst_acc_e4_raw & ~rfpc_i0_e4 & ~i0_trigger_hit_e4;\n', '   assign       inst_acc_second_e4 = dec_tlu_packet_e4.icaf_second;\n', '\n', '   assign       ebreak_to_debug_mode_e4 = (dec_tlu_packet_e4.pmu_i0_itype == EBREAK)  & dec_tlu_i0_valid_e4 & ~i0_trigger_hit_e4 & dcsr[`DCSR_EBREAKM];\n', '\n', '   assign illegal_e4_qual = illegal_e4 & ~dec_tlu_dbg_halted;\n', '\n', '   rvdff #(11)  exctype_wb_ff (.*, .clk(e4e5_clk),\n', '                                .din({ic_perr_e4, iccm_sbecc_e4, ebreak_e4, ebreak_to_debug_mode_e4, ecall_e4, illegal_e4,\n', '                                      illegal_e4_qual,  inst_acc_e4, inst_acc_second_e4, fence_i_e4, mret_e4}),\n', '                               .dout({ic_perr_wb, iccm_sbecc_wb, ebreak_wb, ebreak_to_debug_mode_wb, ecall_wb, illegal_raw_wb,\n', '                                      illegal_wb,       inst_acc_wb, inst_acc_second_wb, fence_i_wb, mret_wb}));\n', '\n', '   assign dec_tlu_fence_i_wb = fence_i_wb;\n', '   //\n', '   // Exceptions\n', '   //\n', '   // - MEPC <- PC\n', '   // - PC <- MTVEC, assert flush_lower\n', '   // - MCAUSE <- cause\n', '   // - MTVAL <-\n', '   // - MPIE <- MIE\n', '   // - MIE <- 0\n', '   //\n', '   assign i0_exception_valid_e4 = (ebreak_e4 | ecall_e4 | illegal_e4 | inst_acc_e4) & ~rfpc_i0_e4 & ~dec_tlu_dbg_halted;\n', '\n', '   // Cause:\n', '   //\n', '   // 0x2 : illegal\n', '   // 0x3 : breakpoint\n', '   // 0xb : Environment call M-mode\n', '\n', '\n', ""   assign exc_cause_e4[4:0] = ( ({5{take_ext_int}}        & 5'h0b) |\n"", ""                                ({5{take_timer_int}}      & 5'h07) |\n"", ""                                ({5{take_int_timer0_int}} & 5'h1d) |\n"", ""                                ({5{take_int_timer1_int}} & 5'h1c) |\n"", ""                                ({5{take_ce_int}}         & 5'h1e) |\n"", ""                                ({5{illegal_e4}}          & 5'h02) |\n"", ""                                ({5{ecall_e4}}            & 5'h0b) |\n"", ""                                ({5{inst_acc_e4}}         & 5'h01) |\n"", ""                                ({5{ebreak_e4 | trigger_hit_e4}}        & 5'h03) |\n"", ""                                ({5{lsu_exc_ma_dc4 & ~lsu_exc_st_dc4}}  & 5'h04) |\n"", ""                                ({5{lsu_exc_acc_dc4 & ~lsu_exc_st_dc4}} & 5'h05) |\n"", ""                                ({5{lsu_exc_ma_dc4 & lsu_exc_st_dc4}}   & 5'h06) |\n"", ""                                ({5{lsu_exc_acc_dc4 & lsu_exc_st_dc4}}  & 5'h07)\n"", '                                ) & ~{5{take_nmi}};\n', '\n', '   //\n', '   // Interrupts\n', '   //\n', '   // Priv spec 1.10, 3.1.14\n', '   // ""Multiple simultaneous interrupts and traps at the same privilege level are handled in the following\n', '   // decreasing priority order: external interrupts, software interrupts, timer interrupts, then finally any\n', '   // synchronous traps.""\n', '   //\n', '   // For above purposes, exceptions that are committed have already happened and will cause an int at E4 to wait a cycle\n', '   // or more if MSTATUS[MIE] is cleared.\n', '   //\n', '   // -in priority order, highest to lowest\n', '   // -single cycle window where a csr write to MIE/MSTATUS is at E4 when the other conditions for externals are met.\n', '   //  Hold off externals for a cycle to make sure we are consistent with what was just written\n', '   assign mhwakeup_ready =  ~dec_csr_stall_int_ff & mstatus_mie_ns & mip[`MIP_MEIP]   & mie_ns[`MIE_MEIE];\n', '   assign ext_int_ready   = ~dec_csr_stall_int_ff & mstatus_mie_ns & mip[`MIP_MEIP]   & mie_ns[`MIE_MEIE];\n', '   assign ce_int_ready    = ~dec_csr_stall_int_ff & mstatus_mie_ns & mip[`MIP_MCEIP]  & mie_ns[`MIE_MCEIE];\n', '   assign timer_int_ready = ~dec_csr_stall_int_ff & mstatus_mie_ns & mip[`MIP_MTIP]   & mie_ns[`MIE_MTIE];\n', '\n', ""   // MIP for internal timers pulses for 1 clock, resets the timer counter. Mip won't hold past the various stall conditions.\n"", '   assign int_timer0_int_possible = mstatus_mie_ns & mie_ns[`MIE_MITIE0];\n', '   assign int_timer0_int_ready = mip[`MIP_MITIP0] & int_timer0_int_possible;\n', '   assign int_timer1_int_possible = mstatus_mie_ns & mie_ns[`MIE_MITIE1];\n', '   assign int_timer1_int_ready = mip[`MIP_MITIP1] & int_timer1_int_possible;\n', '\n', ""   // Internal timers pulse and reset. If core is PMU/FW halted, the pulse will cause an exit from halt, but won't stick around\n"", '   // Make it sticky, also for 1 cycle stall conditions.\n', '   assign int_timer_stalled = dec_csr_stall_int_ff | synchronous_flush_e4 | exc_or_int_valid_wb | mret_wb | mret_e4;\n', '\n', '   assign int_timer0_int_hold = (int_timer0_int_ready & (pmu_fw_tlu_halted_f | int_timer_stalled)) | (int_timer0_int_possible & int_timer0_int_hold_f & ~interrupt_valid & ~internal_dbg_halt_mode_f);\n', '   assign int_timer1_int_hold = (int_timer1_int_ready & (pmu_fw_tlu_halted_f | int_timer_stalled)) | (int_timer1_int_possible & int_timer1_int_hold_f & ~interrupt_valid & ~internal_dbg_halt_mode_f);\n', '\n', '   // mispredicts\n', '   assign i0_mp_e4 = exu_i0_flush_lower_e4 & ~i0_trigger_hit_e4;\n', '   assign i1_mp_e4 = exu_i1_flush_lower_e4 & ~trigger_hit_e4 & ~lsu_i0_rfnpc_dc4;\n', '\n', '   assign internal_dbg_halt_timers = internal_dbg_halt_mode_f & ~dcsr_single_step_running;\n', '\n', '   // Prioritize externals\n', '   assign block_interrupts = ( (lsu_block_interrupts_e4 & ~dec_tlu_flush_lower_wb) | // I/O transaction on the bus pending\n', '                               (internal_dbg_halt_mode & (~dcsr_single_step_running | dec_tlu_i0_valid_e4)) | // No ints in db-halt unless we are single stepping\n', '                               internal_pmu_fw_halt_mode | i_cpu_halt_req_d1 |// No ints in PMU/FW halt. First we exit halt\n', '                               take_nmi | // NMI is top priority\n', '                               ebreak_to_debug_mode_e4 | // Heading to debug mode, hold off ints\n', '                               synchronous_flush_e4 | // exception flush this cycle\n', '                               exc_or_int_valid_wb | // ext/int past cycle (need time for MIE to update)\n', '                               mret_wb | // mret (need time for MIE to update)\n', '                               mret_e4  // mret in progress, for cases were ISR enables ints before mret\n', '                               );\n', '\n', '   assign take_ext_int = ext_int_ready & ~block_interrupts;\n', '   assign take_ce_int  = ce_int_ready & ~ext_int_ready & ~block_interrupts;\n', '   assign take_timer_int = timer_int_ready & ~ext_int_ready & ~ce_int_ready & ~block_interrupts;\n', '   assign take_int_timer0_int = (int_timer0_int_ready | int_timer0_int_hold_f) & int_timer0_int_possible & ~dec_csr_stall_int_ff & ~timer_int_ready & ~ext_int_ready & ~ce_int_ready & ~block_interrupts;\n', '   assign take_int_timer1_int = (int_timer1_int_ready | int_timer1_int_hold_f) & int_timer1_int_possible & ~dec_csr_stall_int_ff & ~(int_timer0_int_ready | int_timer0_int_hold_f) & ~timer_int_ready & ~ext_int_ready & ~ce_int_ready & ~block_interrupts;\n', '\n', '   assign take_reset = reset_delayed & mpc_reset_run_req;\n', '   assign take_nmi = nmi_int_detected & ~internal_pmu_fw_halt_mode & (~internal_dbg_halt_mode | (dcsr_single_step_running_f & dcsr[`DCSR_STEPIE] & ~dec_tlu_i0_valid_e4 & ~dcsr_single_step_done_f)) & ~synchronous_flush_e4 & ~mret_e4 & ~take_reset & ~ebreak_to_debug_mode_e4;\n', '\n', '   assign interrupt_valid = take_ext_int | take_timer_int | take_nmi | take_ce_int | take_int_timer0_int | take_int_timer1_int;\n', '\n', '\n', '   // Compute interrupt path:\n', '   // If vectored async is set in mtvec, flush path for interrupts is MTVEC + (4 * CAUSE);\n', ""   assign vectored_cause[5:0] = ({1'b0, exc_cause_e4[4:0]} << 1);\n"", ""   assign {vpath_overflow_nc, vectored_path[31:1]} = {mtvec[30:1], 1'b0} + {25'b0, vectored_cause[5:0]};\n"", ""   assign interrupt_path[31:1] = take_nmi ? nmi_vec[31:1] : ((mtvec[0] == 1'b1) ? vectored_path[31:1] : {mtvec[30:1], 1'b0});\n"", '\n', '   assign sel_npc_e4 = lsu_i0_rfnpc_dc4 | (lsu_i1_rfnpc_dc4 & tlu_i1_commit_cmt) | fence_i_e4 | (i_cpu_run_req_d1 & ~interrupt_valid);\n', '   assign sel_npc_wb = (i_cpu_run_req_d1 & pmu_fw_tlu_halted_f) | pause_expired_e4;\n', '\n', '\n', '   assign synchronous_flush_e4 = i0_exception_valid_e4 | // exception\n', '                                 i0_mp_e4 | i1_mp_e4 |  // mispredict\n', '                                 rfpc_i0_e4 | rfpc_i1_e4 | // rfpc\n', '                                 lsu_exc_valid_e4 |  // lsu exception in either pipe 0 or pipe 1\n', '                                 fence_i_e4 |  // fence, a rfnpc\n', '                                 lsu_i0_rfnpc_dc4 | lsu_i1_rfnpc_dc4 |\n', '                                 debug_resume_req_f | // resume from debug halt, fetch the dpc\n', '                                 sel_npc_wb |  // resume from pmu/fw halt, or from pause and fetch the NPC\n', '                                 dec_tlu_wr_pause_wb | // flush at start of pause\n', '                                 trigger_hit_e4; // trigger hit, ebreak or goto debug mode\n', '\n', '   assign tlu_flush_lower_e4 = interrupt_valid | mret_e4 | synchronous_flush_e4 | take_halt | take_reset;\n', '\n', '   assign tlu_flush_path_e4[31:1] = take_reset ? rst_vec[31:1] :\n', '\n', '                                     ( ({31{~take_nmi & i0_mp_e4}} & exu_i0_flush_path_e4[31:1]) |\n', '                                      ({31{~take_nmi & ~i0_mp_e4 & i1_mp_e4 & ~rfpc_i0_e4 & ~lsu_i0_exc_dc4}} & exu_i1_flush_path_e4[31:1]) |\n', '                                      ({31{~take_nmi & sel_npc_e4}} & npc_e4[31:1]) |\n', '                                      ({31{~take_nmi & rfpc_i0_e4}} & dec_tlu_i0_pc_e4[31:1]) |\n', '                                      ({31{~take_nmi & rfpc_i1_e4}} & dec_tlu_i1_pc_e4[31:1]) |\n', '                                      ({31{interrupt_valid}} & interrupt_path[31:1]) |\n', ""                                      ({31{(i0_exception_valid_e4 | lsu_exc_valid_e4 | (trigger_hit_e4 & ~trigger_hit_dmode_e4)) & ~interrupt_valid}} & {mtvec[30:1],1'b0}) |\n"", '                                      ({31{~take_nmi & mret_e4 & ~wr_mepc_wb}} & mepc[31:1]) |\n', '                                      ({31{~take_nmi & debug_resume_req_f}} & dpc[31:1]) |\n', '                                      ({31{~take_nmi & sel_npc_wb}} & npc_wb[31:1]) |\n', '                                      ({31{~take_nmi & mret_e4 & wr_mepc_wb}} & dec_csr_wrdata_wb[31:1]) );\n', '\n', '   rvdff #(31)  flush_lower_ff (.*, .clk(e4e5_int_clk),\n', '                                  .din({tlu_flush_path_e4[31:1]}),\n', '                                 .dout({tlu_flush_path_wb[31:1]}));\n', '\n', '   assign dec_tlu_flush_lower_wb = tlu_flush_lower_wb;\n', '   assign dec_tlu_flush_path_wb[31:1] = tlu_flush_path_wb[31:1];\n', '\n', '\n', '   // this is used to capture mepc, etc.\n', '   assign exc_or_int_valid = lsu_exc_valid_e4 | i0_exception_valid_e4 | interrupt_valid | (trigger_hit_e4 & ~trigger_hit_dmode_e4);\n', '\n', '   assign lsu_block_interrupts_dc3 = lsu_freeze_external_ints_dc3 & ~dec_tlu_flush_lower_wb;\n', '\n', '   rvdff #(15)  excinfo_wb_ff (.*, .clk(e4e5_int_clk),\n', '                                .din({interrupt_valid, i0_exception_valid_e4, exc_or_int_valid,\n', '                                      exc_cause_e4[4:0], tlu_i0_commit_cmt & ~illegal_e4, tlu_i1_commit_cmt,\n', '                                       mepc_trigger_hit_sel_pc_e4, trigger_hit_e4, i0_trigger_hit_e4,\n', '                                      take_nmi, pause_expired_e4 }),\n', '                               .dout({interrupt_valid_wb, i0_exception_valid_wb, exc_or_int_valid_wb,\n', '                                      exc_cause_wb[4:0], i0_valid_wb, i1_valid_wb,\n', '                                       mepc_trigger_hit_sel_pc_wb, trigger_hit_wb, i0_trigger_hit_wb,\n', '                                      take_nmi_wb, pause_expired_wb}));\n', '\n', '   //----------------------------------------------------------------------\n', '   //\n', '   // CSRs\n', '   //\n', '   //----------------------------------------------------------------------\n', '\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MISA (RO)\n', ""   //  [31:30] XLEN - implementation width, 2'b01 - 32 bits\n"", '   //  [12]    M    - integer mul/div\n', '   //  [8]     I    - RV32I\n', '   //  [2]     C    - Compressed extension\n', ""   `define MISA 12'h301\n"", '\n', '   // MVENDORID, MARCHID, MIMPID, MHARTID\n', ""   `define MVENDORID 12'hf11\n"", ""   `define MARCHID 12'hf12\n"", ""   `define MIMPID 12'hf13\n"", ""   `define MHARTID 12'hf14\n"", '\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MSTATUS (RW)\n', ""   // [12:11] MPP  : Prior priv level, always 2'b11, not flopped\n"", '   // [7]     MPIE : Int enable previous [1]\n', '   // [3]     MIE  : Int enable          [0]\n', ""   `define MSTATUS 12'h300\n"", '\n', '\n', '   //When executing a MRET instruction, supposing MPP holds the value 3, MIE\n', '   //is set to MPIE; the privilege mode is changed to 3; MPIE is set to 1; and MPP is set to 3\n', '\n', '   assign dec_csr_wen_wb_mod = dec_csr_wen_wb & ~trigger_hit_wb;\n', '   assign wr_mstatus_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MSTATUS);\n', '\n', ""   // set this even if we don't go to fwhalt due to debug halt. We committed the inst, so ...\n"", '   assign set_mie_pmu_fw_halt = ~mpmc_b_ns[1] & wr_mpmc_wb & dec_csr_wrdata_wb[0] & ~internal_dbg_halt_mode_f3;\n', '\n', ""   assign mstatus_ns[1:0] = ( ({2{~wr_mstatus_wb & exc_or_int_valid_wb}} & {(mstatus[`MSTATUS_MIE] | set_mie_pmu_fw_halt), 1'b0}) |\n"", ""                              ({2{ wr_mstatus_wb & exc_or_int_valid_wb}} & {dec_csr_wrdata_wb[3], 1'b0}) |\n"", ""                              ({2{mret_wb & ~exc_or_int_valid_wb}} & {1'b1, mstatus[1]}) |\n"", ""                              ({2{set_mie_pmu_fw_halt & ~exc_or_int_valid_wb}} & {mstatus[1], 1'b1}) |\n"", '                              ({2{wr_mstatus_wb & ~exc_or_int_valid_wb}} & {dec_csr_wrdata_wb[7], dec_csr_wrdata_wb[3]}) |\n', '                              ({2{~wr_mstatus_wb & ~exc_or_int_valid_wb & ~mret_wb & ~set_mie_pmu_fw_halt}} & mstatus[1:0]) );\n', '\n', '   // gate MIE if we are single stepping and DCSR[STEPIE] is off\n', '   assign mstatus_mie_ns = mstatus_ns[`MSTATUS_MIE] & (~dcsr_single_step_running_f | dcsr[`DCSR_STEPIE]);\n', '   rvdff #(2)  mstatus_ff (.*, .clk(free_clk), .din(mstatus_ns[1:0]), .dout(mstatus[1:0]));\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MTVEC (RW)\n', '   // [31:2] BASE : Trap vector base address\n', '   // [1] - Reserved, not implemented, reads zero\n', '   // [0]  MODE : 0 = Direct, 1 = Asyncs are vectored to BASE + (4 * CAUSE)\n', ""   `define MTVEC 12'h305\n"", '\n', '   assign wr_mtvec_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MTVEC);\n', '   assign mtvec_ns[30:0] = {dec_csr_wrdata_wb[31:2], dec_csr_wrdata_wb[0]} ;\n', '   rvdffe #(31)  mtvec_ff (.*, .en(wr_mtvec_wb), .din(mtvec_ns[30:0]), .dout(mtvec[30:0]));\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MIP (RW)\n', '   //\n', '   // [30] MCEIP  : (RO) M-Mode Correctable Error interrupt pending\n', '   // [29] MITIP0 : (RO) M-Mode Internal Timer0 interrupt pending\n', '   // [28] MITIP1 : (RO) M-Mode Internal Timer1 interrupt pending\n', '   // [11] MEIP   : (RO) M-Mode external interrupt pending\n', '   // [7]  MTIP   : (RO) M-Mode timer interrupt pending\n', '   // [3]  MSIP   : (RO) M-Mode software interrupt pending\n', ""   `define MIP 12'h344\n"", '\n', '   assign ce_int = (mdccme_ce_req | miccme_ce_req | mice_ce_req);\n', '\n', '   assign mip_ns[5:0] = {ce_int, dec_timer_t0_pulse, dec_timer_t1_pulse, mexintpend, timer_int_sync, mip[0]};\n', '   rvdff #(6)  mip_ff (.*, .clk(free_clk), .din(mip_ns[5:0]), .dout(mip[5:0]));\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MIE (RW)\n', '   // [30] MCEIE  : (RO) M-Mode Correctable Error interrupt enable\n', '   // [29] MITIE0 : (RO) M-Mode Internal Timer0 interrupt enable\n', '   // [28] MITIE1 : (RO) M-Mode Internal Timer1 interrupt enable\n', '   // [11] MEIE   : (RW) M-Mode external interrupt enable\n', '   // [7]  MTIE   : (RW) M-Mode timer interrupt enable\n', '   // [3]  MSIE   : (RW) M-Mode software interrupt enable\n', ""   `define MIE 12'h304\n"", '\n', '   assign wr_mie_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MIE);\n', '   assign mie_ns[5:0] = wr_mie_wb ? {dec_csr_wrdata_wb[30:28], dec_csr_wrdata_wb[11], dec_csr_wrdata_wb[7], dec_csr_wrdata_wb[3]} : mie[5:0];\n', '   rvdff #(6)  mie_ff (.*, .clk(csr_wr_clk), .din(mie_ns[5:0]), .dout(mie[5:0]));\n', '\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MCYCLEL (RW)\n', '   // [31:0] : Lower Cycle count\n', '\n', ""   `define MCYCLEL 12'hb00\n"", '\n', '\n', '   assign wr_mcyclel_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MCYCLEL);\n', '\n', '   logic mcyclel_cout_in;\n', '\n', '   assign kill_ebreak_count_wb = ebreak_to_debug_mode_wb & dcsr[`DCSR_STOPC];\n', '\n', '   assign mcyclel_cout_in = ~(kill_ebreak_count_wb | (dec_tlu_dbg_halted & dcsr[`DCSR_STOPC]) | dec_tlu_pmu_fw_halted);\n', '\n', ""   assign {mcyclel_cout, mcyclel_inc[31:0]} = mcyclel[31:0] + {31'b0, mcyclel_cout_in};\n"", '   assign mcyclel_ns[31:0] = wr_mcyclel_wb ? dec_csr_wrdata_wb[31:0] : mcyclel_inc[31:0];\n', '\n', '   rvdffe #(32) mcyclel_ff      (.*, .en(wr_mcyclel_wb | mcyclel_cout_in), .din(mcyclel_ns[31:0]), .dout(mcyclel[31:0]));\n', '   rvdff   #(1) mcyclef_cout_ff (.*, .clk(free_clk), .din(mcyclel_cout & ~wr_mcycleh_wb), .dout(mcyclel_cout_f));\n', '   // ----------------------------------------------------------------------\n', '   // MCYCLEH (RW)\n', '   // [63:32] : Higher Cycle count\n', '   // Chained with mcyclel. Note: mcyclel overflow due to a mcycleh write gets ignored.\n', '\n', ""   `define MCYCLEH 12'hb80\n"", '\n', '   assign wr_mcycleh_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MCYCLEH);\n', '\n', ""   assign {mcycleh_cout_nc, mcycleh_inc[31:0]} = mcycleh[31:0] + {31'b0, mcyclel_cout_f};\n"", '   assign mcycleh_ns[31:0] = wr_mcycleh_wb ? dec_csr_wrdata_wb[31:0] : mcycleh_inc[31:0];\n', '\n', '   rvdffe #(32)  mcycleh_ff (.*, .en(wr_mcycleh_wb | mcyclel_cout_f), .din(mcycleh_ns[31:0]), .dout(mcycleh[31:0]));\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MINSTRETL (RW)\n', '   // [31:0] : Lower Instruction retired count\n', '   // From the spec ""Some CSRs, such as the instructions retired counter, instret, may be modified as side effects\n', '   // of instruction execution. In these cases, if a CSR access instruction reads a CSR, it reads the\n', '   // value prior to the execution of the instruction. If a CSR access instruction writes a CSR, the\n', '   // update occurs after the execution of the instruction. In particular, a value written to instret by\n', '   // one instruction will be the value read by the following instruction (i.e., the increment of instret\n', '   // caused by the first instruction retiring happens before the write of the new value).""\n', ""   `define MINSTRETL 12'hb02\n"", '   logic i0_valid_no_ebreak_ecall_wb;\n', '   assign i0_valid_no_ebreak_ecall_wb = i0_valid_wb & ~(ebreak_wb | ecall_wb | ebreak_to_debug_mode_wb);\n', '\n', '   assign wr_minstretl_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MINSTRETL);\n', '\n', ""   assign {minstretl_cout, minstretl_inc[31:0]} = minstretl[31:0] + {31'b0,i0_valid_no_ebreak_ecall_wb} + {31'b0,i1_valid_wb};\n"", '\n', '   assign minstret_enable = i0_valid_no_ebreak_ecall_wb | i1_valid_wb;\n', '\n', '   assign minstretl_ns[31:0] = wr_minstretl_wb ? dec_csr_wrdata_wb[31:0] : minstretl_inc[31:0];\n', '   rvdffe #(32)  minstretl_ff (.*, .en(minstret_enable | wr_minstretl_wb), .din(minstretl_ns[31:0]), .dout(minstretl[31:0]));\n', '   logic minstret_enable_f;\n', '   rvdff #(2) minstretf_cout_ff (.*, .clk(free_clk), .din({minstret_enable, minstretl_cout & ~wr_minstreth_wb}), .dout({minstret_enable_f, minstretl_cout_f}));\n', '\n', '   assign minstretl_read[31:0] = minstretl[31:0];\n', '   // ----------------------------------------------------------------------\n', '   // MINSTRETH (RW)\n', '   // [63:32] : Higher Instret count\n', '   // Chained with minstretl. Note: minstretl overflow due to a minstreth write gets ignored.\n', '\n', ""   `define MINSTRETH 12'hb82\n"", '\n', '   assign wr_minstreth_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MINSTRETH);\n', '\n', ""   assign {minstreth_cout_nc, minstreth_inc[31:0]} = minstreth[31:0] + {31'b0, minstretl_cout_f};\n"", '   assign minstreth_ns[31:0] = wr_minstreth_wb ? dec_csr_wrdata_wb[31:0] : minstreth_inc[31:0];\n', '   rvdffe #(32)  minstreth_ff (.*, .en(minstret_enable_f | wr_minstreth_wb), .din(minstreth_ns[31:0]), .dout(minstreth[31:0]));\n', '\n', '   assign minstreth_read[31:0] = minstreth_inc[31:0];\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MSCRATCH (RW)\n', '   // [31:0] : Scratch register\n', ""   `define MSCRATCH 12'h340\n"", '\n', '   assign wr_mscratch_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MSCRATCH);\n', '\n', '   rvdffe #(32)  mscratch_ff (.*, .en(wr_mscratch_wb), .din(dec_csr_wrdata_wb[31:0]), .dout(mscratch[31:0]));\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MEPC (RW)\n', '   // [31:1] : Exception PC\n', ""   `define MEPC 12'h341\n"", '\n', '   // NPC\n', '   logic sel_exu_npc_e4, sel_flush_npc_e4, sel_i0_npc_e4, sel_hold_npc_e4;\n', '\n', '   // commit all ops\n', '   assign sel_exu_npc_e4 = ~dec_tlu_dbg_halted & ~tlu_flush_lower_wb & (dec_tlu_i0_valid_e4 | dec_tlu_i1_valid_e4) & ~(dec_tlu_i1_valid_e4 & lsu_i0_rfnpc_dc4);\n', ""   // commit just i0 when there's a valid i1 that should be flushed\n"", '   assign sel_i0_npc_e4 = ~dec_tlu_dbg_halted & ~tlu_flush_lower_wb & dec_tlu_i0_valid_e4 & lsu_i0_rfnpc_dc4 & dec_tlu_i1_valid_e4;\n', '   // flush, update npc\n', '   assign sel_flush_npc_e4 = ~dec_tlu_dbg_halted & tlu_flush_lower_wb & ~dec_tlu_flush_noredir_wb;\n', '   // hold prior npc\n', '   assign sel_hold_npc_e4 = ~sel_exu_npc_e4 & ~sel_flush_npc_e4 & ~sel_i0_npc_e4;\n', '\n', '   assign npc_e4[31:1] = ( ({31{sel_exu_npc_e4}} & exu_npc_e4[31:1]) |\n', '                           ({31{sel_i0_npc_e4}} & dec_tlu_i1_pc_e4[31:1]) |\n', '                           ({31{~mpc_reset_run_req & reset_delayed}} & rst_vec[31:1]) | // init to reset vector for mpc halt on reset case\n', '                           ({31{(sel_flush_npc_e4)}} & tlu_flush_path_wb[31:1]) |\n', '                           ({31{(sel_hold_npc_e4)}} & npc_wb[31:1]) );\n', '\n', '   rvdffe #(31)  npwbc_ff (.*, .en(sel_i0_npc_e4 | sel_exu_npc_e4 | sel_flush_npc_e4 | reset_delayed), .din(npc_e4[31:1]), .dout(npc_wb[31:1]));\n', '\n', '   // PC has to be captured for exceptions and interrupts. For MRET, we could execute it and then take an\n', '   // interrupt before the next instruction.\n', '   logic pc0_valid_e4, pc1_valid_e4;\n', '   assign pc0_valid_e4 = ~dec_tlu_dbg_halted & dec_tlu_i0_valid_e4;\n', '   assign pc1_valid_e4 = ~dec_tlu_dbg_halted & dec_tlu_i0_valid_e4 & dec_tlu_i1_valid_e4 & ~lsu_i0_exc_dc4 & ~rfpc_i0_e4 & ~inst_acc_e4 & ~i0_trigger_hit_e4;\n', '\n', '   assign pc_e4[31:1] = ( ({31{ pc0_valid_e4 & ~pc1_valid_e4}} & dec_tlu_i0_pc_e4[31:1]) |\n', '                          ({31{ pc1_valid_e4}} & dec_tlu_i1_pc_e4[31:1]) |\n', '                          ({31{~pc0_valid_e4 & ~pc1_valid_e4}} & pc_wb[31:1])\n', '                          );\n', '\n', '   rvdffe #(31)  pwbc_ff (.*, .en(pc0_valid_e4 | pc1_valid_e4), .din(pc_e4[31:1]), .dout(pc_wb[31:1]));\n', '\n', '   assign wr_mepc_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MEPC);\n', '\n', '   assign mepc_ns[31:1] = ( ({31{i0_exception_valid_wb | lsu_exc_valid_wb | mepc_trigger_hit_sel_pc_wb}} & pc_wb[31:1]) |\n', '                            ({31{interrupt_valid_wb}} & npc_wb[31:1]) |\n', '                            ({31{wr_mepc_wb & ~exc_or_int_valid_wb}} & dec_csr_wrdata_wb[31:1]) |\n', '                            ({31{~wr_mepc_wb & ~exc_or_int_valid_wb}} & mepc[31:1]) );\n', '\n', '\n', '   rvdff #(31)  mepc_ff (.*, .clk(e4e5_int_clk), .din(mepc_ns[31:1]), .dout(mepc[31:1]));\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MCAUSE (RW)\n', '   // [31:0] : Exception Cause\n', ""   `define MCAUSE 12'h342\n"", '\n', '   assign wr_mcause_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MCAUSE);\n', '\n', ""   assign mcause_ns[31:0] = ( ({32{exc_or_int_valid_wb & take_nmi_wb & nmi_lsu_store_type_f}} & {32'hf000_0000}) |\n"", ""                              ({32{exc_or_int_valid_wb & take_nmi_wb & nmi_lsu_load_type_f}} & {32'hf000_0001}) |\n"", ""                              ({32{exc_or_int_valid_wb & ~take_nmi_wb}} & {interrupt_valid_wb, 26'b0, exc_cause_wb[4:0]}) |\n"", '                              ({32{wr_mcause_wb & ~exc_or_int_valid_wb}} & dec_csr_wrdata_wb[31:0]) |\n', '                              ({32{~wr_mcause_wb & ~exc_or_int_valid_wb}} & mcause[31:0]) );\n', '\n', '   rvdff #(32)  mcause_ff (.*, .clk(e4e5_int_clk), .din(mcause_ns[31:0]), .dout(mcause[31:0]));\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MTVAL (RW)\n', '   // [31:0] : Exception address if relevant\n', ""   `define MTVAL 12'h343\n"", '\n', '   assign wr_mtval_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MTVAL);\n', '   assign mtval_capture_pc_wb = exc_or_int_valid_wb & (ebreak_wb | (inst_acc_wb & ~inst_acc_second_wb) | mepc_trigger_hit_sel_pc_wb) & ~take_nmi_wb;\n', '   assign mtval_capture_pc_plus2_wb = exc_or_int_valid_wb & (inst_acc_wb & inst_acc_second_wb) & ~take_nmi_wb;\n', '   assign mtval_capture_inst_wb = exc_or_int_valid_wb & illegal_wb & ~take_nmi_wb;\n', '   assign mtval_capture_lsu_wb = exc_or_int_valid_wb & lsu_exc_valid_wb & ~take_nmi_wb;\n', '   assign mtval_clear_wb = exc_or_int_valid_wb & ~mtval_capture_pc_wb & ~mtval_capture_inst_wb & ~mtval_capture_lsu_wb & ~mepc_trigger_hit_sel_pc_wb;\n', '\n', '\n', ""   assign mtval_ns[31:0] = (({32{mtval_capture_pc_wb}} & {pc_wb[31:1], 1'b0}) |\n"", ""                            ({32{mtval_capture_pc_plus2_wb}} & {pc_wb[31:1] + 31'b1, 1'b0}) |\n"", '                            ({32{mtval_capture_inst_wb}} & dec_illegal_inst[31:0]) |\n', '                            ({32{mtval_capture_lsu_wb}} & lsu_error_pkt_addr_wb[31:0]) |\n', '                            ({32{wr_mtval_wb & ~interrupt_valid_wb}} & dec_csr_wrdata_wb[31:0]) |\n', '                            ({32{~take_nmi_wb & ~wr_mtval_wb & ~mtval_capture_pc_wb & ~mtval_capture_inst_wb & ~mtval_clear_wb & ~mtval_capture_lsu_wb}} & mtval[31:0]) );\n', '\n', '\n', '   rvdff #(32)  mtval_ff (.*, .clk(e4e5_int_clk), .din(mtval_ns[31:0]), .dout(mtval[31:0]));\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MCGC (RW) Clock gating control\n', '   // [31:9] : Reserved, reads 0x0\n', '   // [8]    : misc_clk_override\n', '   // [7]    : dec_clk_override\n', '   // [6]    : exu_clk_override\n', '   // [5]    : ifu_clk_override\n', '   // [4]    : lsu_clk_override\n', '   // [3]    : bus_clk_override\n', '   // [2]    : pic_clk_override\n', '   // [1]    : dccm_clk_override\n', '   // [0]    : icm_clk_override\n', '   //\n', ""   `define MCGC 12'h7f8\n"", '   assign wr_mcgc_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MCGC);\n', '\n', '   rvdffe #(9)  mcgc_ff (.*, .en(wr_mcgc_wb), .din(dec_csr_wrdata_wb[8:0]), .dout(mcgc[8:0]));\n', '\n', '   assign dec_tlu_misc_clk_override = mcgc[8];\n', '   assign dec_tlu_dec_clk_override  = mcgc[7];\n', '   assign dec_tlu_exu_clk_override  = mcgc[6];\n', '   assign dec_tlu_ifu_clk_override  = mcgc[5];\n', '   assign dec_tlu_lsu_clk_override  = mcgc[4];\n', '   assign dec_tlu_bus_clk_override  = mcgc[3];\n', '   assign dec_tlu_pic_clk_override  = mcgc[2];\n', '   assign dec_tlu_dccm_clk_override = mcgc[1];\n', '   assign dec_tlu_icm_clk_override  = mcgc[0];\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MFDC (RW) Feature Disable Control\n', '   // [31:19] : Reserved, reads 0x0\n', '   // [18:16] : DMA QoS Prty\n', '   // [15:14] : Reserved, reads 0x0\n', '   // [13]    : Disable blocking DMA\n', '   // [12:11] : Reserved, reads 0x0\n', '   // [10]   : Disable dual issue\n', '   // [9]    : Disable pic multiple ints\n', '   // [8]    : Disable core ecc\n', '   // [7]    : Disable secondary alu?s\n', '   // [6]    : Disable multiple outstanding sideeffect accesses to bus\n', '   // [5]    : Disable non-blocking divides\n', '   // [4]    : Disable fast divide\n', '   // [3]    : Disable branch prediction and return stack\n', '   // [2]    : Disable write buffer coalescing\n', '   // [1]    : Disable load misses that bypass the write buffer\n', '   // [0]    : Disable pipelining - Enable single instruction execution\n', '   //\n', ""   `define MFDC 12'h7f9\n"", '\n', '   assign wr_mfdc_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MFDC);\n', '\n', '   rvdffe #(15)  mfdc_ff (.*, .en(wr_mfdc_wb), .din(mfdc_ns[14:0]), .dout(mfdc_int[14:0]));\n', '\n', '   `ifdef RV_BUILD_AXI4\n', '   // flip poweron value of bit 6 for AXI build\n', '   assign mfdc_ns[14:0] = {~dec_csr_wrdata_wb[18:16],dec_csr_wrdata_wb[13], dec_csr_wrdata_wb[10:7], ~dec_csr_wrdata_wb[6], dec_csr_wrdata_wb[5:0]};\n', ""   assign mfdc[18:0] = {~mfdc_int[14:12], 2'b0, mfdc_int[11], 2'b0, mfdc_int[10:7], ~mfdc_int[6], mfdc_int[5:0]};\n"", '   `else\n', '   assign mfdc_ns[14:0] = {~dec_csr_wrdata_wb[18:16],dec_csr_wrdata_wb[13],dec_csr_wrdata_wb[10:0]};\n', ""   assign mfdc[18:0] = {~mfdc_int[14:12], 2'b0, mfdc_int[11], 2'b0, mfdc_int[10:0]};\n"", '   `endif\n', '\n', '   assign dec_tlu_dma_qos_prty[2:0] = mfdc[18:16];\n', '   assign dec_tlu_dual_issue_disable = mfdc[10];\n', '   assign dec_tlu_core_ecc_disable = mfdc[8];\n', '   assign dec_tlu_sec_alu_disable = mfdc[7];\n', '   assign dec_tlu_sideeffect_posted_disable = mfdc[6];\n', '   assign dec_tlu_non_blocking_disable = mfdc[5];\n', '   assign dec_tlu_fast_div_disable = mfdc[4];\n', '   assign dec_tlu_bpred_disable = mfdc[3];\n', '   assign dec_tlu_wb_coalescing_disable = mfdc[2];\n', '   assign dec_tlu_ld_miss_byp_wb_disable = mfdc[1];\n', '   assign dec_tlu_pipelining_disable = mfdc[0];\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MCPC (RW) Pause counter\n', '   // [31:0] : Reads 0x0, decs in the wb register in decode_ctl\n', '\n', ""   `define MCPC 12'h7c2\n"", '   assign dec_tlu_wr_pause_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MCPC) & ~interrupt_valid_wb;\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MRAC (RW)\n', '   // [31:0] : Region Access Control Register, 16 regions, {side_effect, cachable} pairs\n', ""   `define MRAC 12'h7c0\n"", '\n', '   assign wr_mrac_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MRAC);\n', '\n', '   // prevent pairs of 0x11, side_effect and cacheable\n', '   logic [31:0] mrac_in;\n', '   assign mrac_in[31:0] = {dec_csr_wrdata_wb[31], dec_csr_wrdata_wb[30] & ~dec_csr_wrdata_wb[31],\n', '                           dec_csr_wrdata_wb[29], dec_csr_wrdata_wb[28] & ~dec_csr_wrdata_wb[29],\n', '                           dec_csr_wrdata_wb[27], dec_csr_wrdata_wb[26] & ~dec_csr_wrdata_wb[27],\n', '                           dec_csr_wrdata_wb[25], dec_csr_wrdata_wb[24] & ~dec_csr_wrdata_wb[25],\n', '                           dec_csr_wrdata_wb[23], dec_csr_wrdata_wb[22] & ~dec_csr_wrdata_wb[23],\n', '                           dec_csr_wrdata_wb[21], dec_csr_wrdata_wb[20] & ~dec_csr_wrdata_wb[21],\n', '                           dec_csr_wrdata_wb[19], dec_csr_wrdata_wb[18] & ~dec_csr_wrdata_wb[19],\n', '                           dec_csr_wrdata_wb[17], dec_csr_wrdata_wb[16] & ~dec_csr_wrdata_wb[17],\n', '                           dec_csr_wrdata_wb[15], dec_csr_wrdata_wb[14] & ~dec_csr_wrdata_wb[15],\n', '                           dec_csr_wrdata_wb[13], dec_csr_wrdata_wb[12] & ~dec_csr_wrdata_wb[13],\n', '                           dec_csr_wrdata_wb[11], dec_csr_wrdata_wb[10] & ~dec_csr_wrdata_wb[11],\n', '                           dec_csr_wrdata_wb[9], dec_csr_wrdata_wb[8] & ~dec_csr_wrdata_wb[9],\n', '                           dec_csr_wrdata_wb[7], dec_csr_wrdata_wb[6] & ~dec_csr_wrdata_wb[7],\n', '                           dec_csr_wrdata_wb[5], dec_csr_wrdata_wb[4] & ~dec_csr_wrdata_wb[5],\n', '                           dec_csr_wrdata_wb[3], dec_csr_wrdata_wb[2] & ~dec_csr_wrdata_wb[3],\n', '                           dec_csr_wrdata_wb[1], dec_csr_wrdata_wb[0] & ~dec_csr_wrdata_wb[1]};\n', '\n', '   rvdffe #(32)  mrac_ff (.*, .en(wr_mrac_wb), .din(mrac_in[31:0]), .dout(mrac[31:0]));\n', '\n', '   // drive to LSU/IFU\n', '   assign dec_tlu_mrac_ff[31:0] = mrac[31:0];\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MDEAU (WAR0)\n', '   // [31:0] : Dbus Error Address Unlock register\n', '   //\n', ""   `define MDEAU 12'hbc0\n"", '\n', '   assign wr_mdeau_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MDEAU);\n', '\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MDSEAC (R)\n', '   // [31:0] : Dbus Store Error Address Capture register\n', '   //\n', ""   `define MDSEAC 12'hfc0\n"", '\n', '   // only capture error bus if the MDSEAC reg is not locked\n', '   assign mdseac_locked_ns = mdseac_en | (mdseac_locked_f & ~wr_mdeau_wb);\n', '\n', '   assign mdseac_en = (lsu_imprecise_error_store_any | lsu_imprecise_error_load_any) & ~nmi_int_detected_f & ~mdseac_locked_f;\n', '\n', '   rvdffe #(32)  mdseac_ff (.*, .en(mdseac_en), .din(lsu_imprecise_error_addr_any[31:0]), .dout(mdseac[31:0]));\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MPMC (R0W1)\n', '   // [0] : FW halt\n', '   // [1] : HALTIE\n', '   //\n', ""   `define MPMC 12'h7c6\n"", '\n', '   assign wr_mpmc_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MPMC);\n', '\n', '   // allow the cycle of the dbg halt flush that contains the wr_mpmc_wb to\n', '   // set the mstatus bit potentially, use delayed version of internal dbg halt.\n', '   // Kill the req when we commit the fwhalt csr write and take an int\n', '   assign fw_halt_req = wr_mpmc_wb & dec_csr_wrdata_wb[0] & ~internal_dbg_halt_mode_f3 & ~interrupt_valid_wb;\n', '\n', '   assign mpmc_b_ns[1] = wr_mpmc_wb ? ~dec_csr_wrdata_wb[1] : ~mpmc[1];\n', '   rvdff #(1)  mpmc_ff (.*, .clk(csr_wr_clk), .din(mpmc_b_ns[1]), .dout(mpmc_b[1]));\n', '   assign mpmc[1] = ~mpmc_b[1];\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MICECT (I-Cache error counter/threshold)\n', '   // [31:27] : Icache parity error threshold\n', '   // [26:0]  : Icache parity error count\n', ""   `define MICECT 12'h7f0\n"", '\n', '   logic [31:27] csr_sat;\n', ""   assign csr_sat[31:27] = (dec_csr_wrdata_wb[31:27] > 5'd26) ? 5'd26 : dec_csr_wrdata_wb[31:27];\n"", '\n', '   assign wr_micect_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MICECT);\n', ""   assign {micect_cout_nc, micect_inc[26:0]} = micect[26:0] + {26'b0, ic_perr_wb};\n"", '   assign micect_ns =  wr_micect_wb ? {csr_sat[31:27], dec_csr_wrdata_wb[26:0]} : {micect[31:27], micect_inc[26:0]};\n', '\n', '   rvdffe #(32)  micect_ff (.*, .en(wr_micect_wb | ic_perr_wb), .din(micect_ns[31:0]), .dout(micect[31:0]));\n', '\n', ""   assign mice_ce_req = |({32'b1 << micect[31:27]} & {5'b0, micect[26:0]});\n"", '\n', '   // ----------------------------------------------------------------------\n', '   // MICCMECT (ICCM error counter/threshold)\n', '   // [31:27] : ICCM parity error threshold\n', '   // [26:0]  : ICCM parity error count\n', ""   `define MICCMECT 12'h7f1\n"", '\n', '   assign wr_miccmect_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MICCMECT);\n', ""   assign {miccmect_cout_nc, miccmect_inc[26:0]} = miccmect[26:0] + {26'b0, iccm_sbecc_wb | iccm_dma_sb_error};\n"", '   assign miccmect_ns =  wr_miccmect_wb ? {csr_sat[31:27], dec_csr_wrdata_wb[26:0]} : {miccmect[31:27], miccmect_inc[26:0]};\n', '\n', '   rvdffe #(32)  miccmect_ff (.*, .en(wr_miccmect_wb | iccm_sbecc_wb | iccm_dma_sb_error), .din(miccmect_ns[31:0]), .dout(miccmect[31:0]));\n', '\n', ""   assign miccme_ce_req = |({32'b1 << miccmect[31:27]} & {5'b0, miccmect[26:0]});\n"", '\n', '   // ----------------------------------------------------------------------\n', '   // MDCCMECT (DCCM error counter/threshold)\n', '   // [31:27] : DCCM parity error threshold\n', '   // [26:0]  : DCCM parity error count\n', ""   `define MDCCMECT 12'h7f2\n"", '\n', '   assign wr_mdccmect_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MDCCMECT);\n', ""   assign {mdccmect_cout_nc, mdccmect_inc[26:0]} = mdccmect[26:0] + {26'b0, lsu_single_ecc_error_wb};\n"", '   assign mdccmect_ns =  wr_mdccmect_wb ? {csr_sat[31:27], dec_csr_wrdata_wb[26:0]} : {mdccmect[31:27], mdccmect_inc[26:0]};\n', '\n', '   rvdffe #(32)  mdccmect_ff (.*, .en(wr_mdccmect_wb | lsu_single_ecc_error_wb), .din(mdccmect_ns[31:0]), .dout(mdccmect[31:0]));\n', '\n', ""   assign mdccme_ce_req = |({32'b1 << mdccmect[31:27]} & {5'b0, mdccmect[26:0]});\n"", '\n', '   // ----------------------------------------------------------------------\n', '   // MEIVT (External Interrupt Vector Table (R/W))\n', '   // [31:10]: Base address (R/W)\n', '   // [9:0]  : Reserved, reads 0x0\n', ""   `define MEIVT 12'hbc8\n"", '\n', '   assign wr_meivt_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MEIVT);\n', '\n', '   rvdffe #(22)  meivt_ff (.*, .en(wr_meivt_wb), .din(dec_csr_wrdata_wb[31:10]), .dout(meivt[31:10]));\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MEIHAP (External Interrupt Handler Access Pointer (R))\n', '   // [31:10]: Base address (R/W)\n', '   // [9:2]  : ClaimID (R)\n', '   // [1:0]  : Reserved, 0x0\n', ""   `define MEIHAP 12'hfc8\n"", '\n', '   assign wr_meihap_wb = wr_meicpct_wb;\n', '\n', '   rvdffe #(8)  meihap_ff (.*, .en(wr_meihap_wb), .din(pic_claimid[7:0]), .dout(meihap[9:2]));\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MEICURPL (R/W)\n', '   // [31:4] : Reserved (read 0x0)\n', '   // [3:0]  : CURRPRI - Priority level of current interrupt service routine (R/W)\n', ""   `define MEICURPL 12'hbcc\n"", '\n', '   assign wr_meicurpl_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MEICURPL);\n', '   assign meicurpl_ns[3:0] = wr_meicurpl_wb ? dec_csr_wrdata_wb[3:0] : meicurpl[3:0];\n', '\n', '   rvdff #(4)  meicurpl_ff (.*, .clk(csr_wr_clk), .din(meicurpl_ns[3:0]), .dout(meicurpl[3:0]));\n', '\n', '   // PIC needs this reg\n', '   assign dec_tlu_meicurpl[3:0] = meicurpl[3:0];\n', '\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MEICIDPL (R/W)\n', '   // [31:4] : Reserved (read 0x0)\n', ""   // [3:0]  : External Interrupt Claim ID's Priority Level Register\n"", ""   `define MEICIDPL 12'hbcb\n"", '\n', '   assign wr_meicidpl_wb = (dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MEICIDPL));\n', '\n', '   assign meicidpl_ns[3:0] = wr_meicpct_wb ? pic_pl[3:0] : (wr_meicidpl_wb ? dec_csr_wrdata_wb[3:0] : meicidpl[3:0]);\n', '\n', '   rvdff #(4)  meicidpl_ff (.*, .clk(csr_wr_clk), .din(meicidpl_ns[3:0]), .dout(meicidpl[3:0]));\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MEICPCT (Capture CLAIMID in MEIHAP and PL in MEICIDPL\n', '   // [31:1] : Reserved (read 0x0)\n', '   // [0]    : Capture (W1, Read 0)\n', ""   `define MEICPCT 12'hbca\n"", '\n', '   assign wr_meicpct_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MEICPCT);\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MEIPT (External Interrupt Priority Threshold)\n', '   // [31:4] : Reserved (read 0x0)\n', '   // [3:0]  : PRITHRESH\n', ""   `define MEIPT 12'hbc9\n"", '\n', '   assign wr_meipt_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MEIPT);\n', '   assign meipt_ns[3:0] = wr_meipt_wb ? dec_csr_wrdata_wb[3:0] : meipt[3:0];\n', '\n', '   rvdff #(4)  meipt_ff (.*, .clk(active_clk), .din(meipt_ns[3:0]), .dout(meipt[3:0]));\n', '\n', '   // to PIC\n', '   assign dec_tlu_meipt[3:0] = meipt[3:0];\n', '   // ----------------------------------------------------------------------\n', '   // DCSR (R/W) (Only accessible in debug mode)\n', '   // [31:28] : xdebugver (hard coded to 0x4) RO\n', '   // [27:16] : 0x0, reserved\n', '   // [15]    : ebreakm\n', '   // [14]    : 0x0, reserved\n', '   // [13]    : ebreaks (0x0 for this core)\n', '   // [12]    : ebreaku (0x0 for this core)\n', '   // [11]    : stepie\n', '   // [10]    : stopcount\n', '   // [9]     : 0x0 //stoptime\n', '   // [8:6]   : cause (RO)\n', '   // [5:4]   : 0x0, reserved\n', '   // [3]     : nmip\n', '   // [2]     : step\n', '   // [1:0]   : prv (0x3 for this core)\n', '   //\n', ""   `define DCSR 12'h7b0\n"", '   logic [8:6] dcsr_cause;\n', '\n', ""   // RV has clarified that 'priority 4' in the spec means top priority.\n"", '   // 4. single step. 3. Debugger request. 2. Ebreak. 1. Trigger.\n', '\n', '   // RV debug spec indicates a cause priority change for trigger hits during single step.\n', '   assign trigger_hit_for_dscr_cause_wb = trigger_hit_dmode_wb | (trigger_hit_wb & dcsr_single_step_done_f);\n', '\n', ""   assign dcsr_cause[8:6] = ( ({3{dcsr_single_step_done_f & ~ebreak_to_debug_mode_wb & ~trigger_hit_for_dscr_cause_wb & ~debug_halt_req}} & 3'b100) |\n"", ""                              ({3{debug_halt_req & ~ebreak_to_debug_mode_wb & ~trigger_hit_for_dscr_cause_wb}} &  3'b011) |\n"", ""                              ({3{ebreak_to_debug_mode_wb & ~trigger_hit_for_dscr_cause_wb}} &  3'b001) |\n"", ""                              ({3{trigger_hit_for_dscr_cause_wb}} & 3'b010));\n"", '\n', '   assign wr_dcsr_wb = allow_dbg_halt_csr_write & dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `DCSR);\n', '\n', '\n', '\n', '  // Multiple halt enter requests can happen before we are halted.\n', ""  // We have to continue to upgrade based on dcsr_cause priority but we can't downgrade.\n"", '   logic enter_debug_halt_req_le, dcsr_cause_upgradeable;\n', ""   assign dcsr_cause_upgradeable = internal_dbg_halt_mode_f & (dcsr[8:6] == 3'b011);\n"", '   assign enter_debug_halt_req_le = enter_debug_halt_req & (~dbg_tlu_halted | dcsr_cause_upgradeable);\n', '\n', '   assign nmi_in_debug_mode = nmi_int_detected_f & internal_dbg_halt_mode_f;\n', '   assign dcsr_ns[15:2] = enter_debug_halt_req_le ? {dcsr[15:9], dcsr_cause[8:6], dcsr[5:2]} :\n', ""                          (wr_dcsr_wb ? {dec_csr_wrdata_wb[15], 3'b0, dec_csr_wrdata_wb[11:10], 1'b0, dcsr[8:6], 2'b00, nmi_in_debug_mode | dcsr[3], dec_csr_wrdata_wb[2]} :\n"", '                           {dcsr[15:4], nmi_in_debug_mode, dcsr[2]});\n', '\n', '   rvdffe #(14)  dcsr_ff (.*, .en(enter_debug_halt_req_le | wr_dcsr_wb | internal_dbg_halt_mode | take_nmi_wb), .din(dcsr_ns[15:2]), .dout(dcsr[15:2]));\n', '\n', '   // ----------------------------------------------------------------------\n', '   // DPC (R/W) (Only accessible in debug mode)\n', '   // [31:0] : Debug PC\n', ""   `define DPC 12'h7b1\n"", '\n', '   assign wr_dpc_wb = allow_dbg_halt_csr_write & dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `DPC);\n', '   assign dpc_capture_npc = dbg_tlu_halted & ~dbg_tlu_halted_f & ~request_debug_mode_done_f;\n', '   assign dpc_capture_pc = request_debug_mode_wb;\n', '\n', '   assign dpc_ns[31:1] = ( ({31{~dpc_capture_pc & ~dpc_capture_npc & wr_dpc_wb}} & dec_csr_wrdata_wb[31:1]) |\n', '                           ({31{dpc_capture_pc}} & pc_wb[31:1]) |\n', '                           ({31{~dpc_capture_pc & dpc_capture_npc}} & npc_wb[31:1]) );\n', '\n', '   rvdffe #(31)  dpc_ff (.*, .en(wr_dpc_wb | dpc_capture_pc | dpc_capture_npc), .din(dpc_ns[31:1]), .dout(dpc[31:1]));\n', '\n', '   // ----------------------------------------------------------------------\n', '   // DICAWICS (R/W) (Only accessible in debug mode)\n', '   // [31:25] : Reserved\n', '   // [24]    : Array select, 0 is data, 1 is tag\n', '   // [23:22] : Reserved\n', '   // [21:20] : Way select\n', '   // [19:16] : Reserved\n', '   // [15:2]  : Index\n', '   // [1:0]   : Reserved\n', ""   `define DICAWICS 12'h7c8\n"", '\n', '   assign dicawics_ns[18:2] = {dec_csr_wrdata_wb[24], dec_csr_wrdata_wb[21:20], dec_csr_wrdata_wb[15:2]};\n', '   assign wr_dicawics_wb = allow_dbg_halt_csr_write & dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `DICAWICS);\n', '\n', '   rvdffe #(17)  dicawics_ff (.*, .en(wr_dicawics_wb), .din(dicawics_ns[18:2]), .dout(dicawics[18:2]));\n', '\n', '   // ----------------------------------------------------------------------\n', '   // DICAD0 (R/W) (Only accessible in debug mode)\n', '   //\n', '   // If dicawics[array] is 0\n', '   // [31:0]  : inst data\n', '   //\n', '   // If dicawics[array] is 1\n', '   // [31:16] : Tag\n', '   // [15:7]  : Reserved\n', '   // [6:4]   : LRU\n', '   // [3:1]   : Reserved\n', '   // [0]     : Valid\n', ""   `define DICAD0 12'h7c9\n"", '\n', '   assign dicad0_ns[31:0] = wr_dicad0_wb ? dec_csr_wrdata_wb[31:0] : ifu_ic_debug_rd_data[31:0];\n', '\n', '   assign wr_dicad0_wb = allow_dbg_halt_csr_write & dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `DICAD0);\n', '\n', '   rvdffe #(32)  dicad0_ff (.*, .en(wr_dicad0_wb | ifu_ic_debug_rd_data_valid), .din(dicad0_ns[31:0]), .dout(dicad0[31:0]));\n', '\n', '\n', '`ifdef RV_ICACHE_ECC\n', '   // ----------------------------------------------------------------------\n', '   // DICAD1 (R/W) (Only accessible in debug mode)\n', '   // [9:0]     : ECC\n', ""   `define DICAD1 12'h7ca\n"", '\n', '   assign dicad1_ns[9:0] = wr_dicad1_wb ? dec_csr_wrdata_wb[9:0] : ifu_ic_debug_rd_data[41:32];\n', '\n', '   assign wr_dicad1_wb = allow_dbg_halt_csr_write & dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `DICAD1);\n', '\n', '   rvdffs #(10)  dicad1_ff (.*, .clk(active_clk), .en(wr_dicad1_wb | ifu_ic_debug_rd_data_valid), .din(dicad1_ns[9:0]), .dout(dicad1[9:0]));\n', '\n', '`else\n', '   // ----------------------------------------------------------------------\n', '   // DICAD1 (R/W) (Only accessible in debug mode)\n', '   // [1:0]     : Parity\n', ""   `define DICAD1 12'h7ca\n"", '\n', '   assign dicad1_ns[1:0] = wr_dicad1_wb ? dec_csr_wrdata_wb[1:0] : ifu_ic_debug_rd_data[33:32];\n', '\n', '   assign wr_dicad1_wb = allow_dbg_halt_csr_write & dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `DICAD1);\n', '\n', '   rvdffs #(2)  dicad1_ff (.*, .clk(active_clk), .en(wr_dicad1_wb | ifu_ic_debug_rd_data_valid), .din(dicad1_ns[1:0]), .dout(dicad1[1:0]));\n', '`endif\n', '   // ----------------------------------------------------------------------\n', '   // DICAGO (R/W) (Only accessible in debug mode)\n', '   // [0]     : Go\n', ""   `define DICAGO 12'h7cb\n"", '\n', '`ifdef RV_ICACHE_ECC\n', '   assign dec_tlu_ic_diag_pkt.icache_wrdata[41:0] = {dicad1[9:0], dicad0[31:0]};\n', '`else\n', '   assign dec_tlu_ic_diag_pkt.icache_wrdata[33:0] = {dicad1[1:0], dicad0[31:0]};\n', '`endif\n', '   assign dec_tlu_ic_diag_pkt.icache_dicawics[18:2] = dicawics[18:2];\n', '\n', '   logic icache_rd_valid, icache_wr_valid, icache_rd_valid_f, icache_wr_valid_f;\n', '   assign icache_rd_valid = allow_dbg_halt_csr_write & dec_csr_any_unq_d & dec_i0_decode_d & ~dec_csr_wen_unq_d & (dec_csr_rdaddr_d[11:0] == `DICAGO);\n', '   assign icache_wr_valid = allow_dbg_halt_csr_write & dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `DICAGO);\n', '\n', '   rvdff #(2)  dicgo_ff (.*, .clk(active_clk), .din({icache_rd_valid, icache_wr_valid}), .dout({icache_rd_valid_f, icache_wr_valid_f}));\n', '\n', '   assign dec_tlu_ic_diag_pkt.icache_rd_valid = icache_rd_valid_f;\n', '   assign dec_tlu_ic_diag_pkt.icache_wr_valid = icache_wr_valid_f;\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MTSEL (R/W)\n', '   // [1:0] : Trigger select : 00, 01, 10 are data/address triggers. 11 is inst count\n', ""   `define MTSEL 12'h7a0\n"", '\n', '   assign wr_mtsel_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MTSEL);\n', '   assign mtsel_ns[1:0] = wr_mtsel_wb ? {dec_csr_wrdata_wb[1:0]} : mtsel[1:0];\n', '\n', '   rvdff #(2)  mtsel_ff (.*, .clk(csr_wr_clk), .din(mtsel_ns[1:0]), .dout(mtsel[1:0]));\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MTDATA1 (R/W)\n', '   // [31:0] : Trigger Data 1\n', ""   `define MTDATA1 12'h7a1\n"", '\n', '   // for triggers 0, 1, 2 and 3 aka Match Control\n', '   // [31:28] : type, hard coded to 0x2\n', '   // [27]    : dmode\n', '   // [26:21] : hard coded to 0x1f\n', '   // [20]    : hit\n', '   // [19]    : select (0 - address, 1 - data)\n', ""   // [18]    : timing, always 'before', reads 0x0\n"", '   // [17:12] : action, bits  [17:13] not implemented and reads 0x0\n', '   // [11]    : chain\n', '   // [10:7]  : match, bits [10:8] not implemented and reads 0x0\n', '   // [6]     : M\n', '   // [5:3]   : not implemented, reads 0x0\n', '   // [2]     : execute\n', '   // [1]     : store\n', '   // [0]     : load\n', '   //\n', '   // decoder ring\n', '   // [27]    : => 9\n', '   // [20]    : => 8\n', '   // [19]    : => 7\n', '   // [12]    : => 6\n', '   // [11]    : => 5\n', '   // [7]     : => 4\n', '   // [6]     : => 3\n', '   // [2]     : => 2\n', '   // [1]     : => 1\n', '   // [0]     : => 0\n', '\n', '\n', ""   // don't allow setting load-data.\n"", '   assign tdata_load = dec_csr_wrdata_wb[0] & ~dec_csr_wrdata_wb[19];\n', ""   // don't allow setting execute-data.\n"", '   assign tdata_opcode = dec_csr_wrdata_wb[2] & ~dec_csr_wrdata_wb[19];\n', ""   // don't allow clearing DMODE and action=1\n"", '   assign tdata_action = (dec_csr_wrdata_wb[27] & dbg_tlu_halted_f) & dec_csr_wrdata_wb[12];\n', '\n', '   // Chain bit has conditions: WARL for triggers without chains. Force to zero if dmode is 0 but next trigger dmode is 1.\n', ""   assign tdata_chain = mtsel[0] ? 1'b0 : // triggers 1 and 3 chain bit is always zero\n"", '                        mtsel[1] ?  dec_csr_wrdata_wb[11] & ~(mtdata1_t3[`MTDATA1_DMODE] & ~dec_csr_wrdata_wb[27]) : // trigger 2\n', '                                    dec_csr_wrdata_wb[11] & ~(mtdata1_t1[`MTDATA1_DMODE] & ~dec_csr_wrdata_wb[27]);  // trigger 0\n', '\n', '   // Kill mtdata1 write if dmode=1 but prior trigger has dmode=0/chain=1. Only applies to T1 and T3\n', '   assign tdata_kill_write = mtsel[1] ? dec_csr_wrdata_wb[27] & (~mtdata1_t2[`MTDATA1_DMODE] & mtdata1_t2[`MTDATA1_CHAIN]) : // trigger 3\n', '                                        dec_csr_wrdata_wb[27] & (~mtdata1_t0[`MTDATA1_DMODE] & mtdata1_t0[`MTDATA1_CHAIN]) ; // trigger 1\n', '\n', '   assign tdata_wrdata_wb[9:0]  = {dec_csr_wrdata_wb[27] & dbg_tlu_halted_f,\n', '                                   dec_csr_wrdata_wb[20:19],\n', '                                   tdata_action,\n', '                                   tdata_chain,\n', '                                   dec_csr_wrdata_wb[7:6],\n', '                                   tdata_opcode,\n', '                                   dec_csr_wrdata_wb[1],\n', '                                   tdata_load};\n', '\n', '   // If the DMODE bit is set, tdata1 can only be updated in debug_mode\n', ""   assign wr_mtdata1_t0_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MTDATA1) & (mtsel[1:0] == 2'b0) & (~mtdata1_t0[`MTDATA1_DMODE] | dbg_tlu_halted_f);\n"", '   assign mtdata1_t0_ns[9:0] = wr_mtdata1_t0_wb ? tdata_wrdata_wb[9:0] :\n', '                                {mtdata1_t0[9], update_hit_bit_wb[0] | mtdata1_t0[8], mtdata1_t0[7:0]};\n', '\n', ""   assign wr_mtdata1_t1_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MTDATA1) & (mtsel[1:0] == 2'b01) & (~mtdata1_t1[`MTDATA1_DMODE] | dbg_tlu_halted_f) & ~tdata_kill_write;\n"", '   assign mtdata1_t1_ns[9:0] = wr_mtdata1_t1_wb ? tdata_wrdata_wb[9:0] :\n', '                                {mtdata1_t1[9], update_hit_bit_wb[1] | mtdata1_t1[8], mtdata1_t1[7:0]};\n', '\n', ""   assign wr_mtdata1_t2_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MTDATA1) & (mtsel[1:0] == 2'b10) & (~mtdata1_t2[`MTDATA1_DMODE] | dbg_tlu_halted_f);\n"", '   assign mtdata1_t2_ns[9:0] = wr_mtdata1_t2_wb ? tdata_wrdata_wb[9:0] :\n', '                                {mtdata1_t2[9], update_hit_bit_wb[2] | mtdata1_t2[8], mtdata1_t2[7:0]};\n', '\n', ""   assign wr_mtdata1_t3_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MTDATA1) & (mtsel[1:0] == 2'b11) & (~mtdata1_t3[`MTDATA1_DMODE] | dbg_tlu_halted_f) & ~tdata_kill_write;\n"", '   assign mtdata1_t3_ns[9:0] = wr_mtdata1_t3_wb ? tdata_wrdata_wb[9:0] :\n', '                                {mtdata1_t3[9], update_hit_bit_wb[3] | mtdata1_t3[8], mtdata1_t3[7:0]};\n', '\n', '\n', '   rvdff #(10)  mtdata1_t0_ff (.*, .clk(active_clk), .din(mtdata1_t0_ns[9:0]), .dout(mtdata1_t0[9:0]));\n', '   rvdff #(10)  mtdata1_t1_ff (.*, .clk(active_clk), .din(mtdata1_t1_ns[9:0]), .dout(mtdata1_t1[9:0]));\n', '   rvdff #(10)  mtdata1_t2_ff (.*, .clk(active_clk), .din(mtdata1_t2_ns[9:0]), .dout(mtdata1_t2[9:0]));\n', '   rvdff #(10)  mtdata1_t3_ff (.*, .clk(active_clk), .din(mtdata1_t3_ns[9:0]), .dout(mtdata1_t3[9:0]));\n', '\n', ""   assign mtdata1_tsel_out[31:0] = ( ({32{(mtsel[1:0] == 2'b00)}} & {4'h2, mtdata1_t0[9], 6'b011111, mtdata1_t0[8:7], 6'b0, mtdata1_t0[6:5], 3'b0, mtdata1_t0[4:3], 3'b0, mtdata1_t0[2:0]}) |\n"", ""                                     ({32{(mtsel[1:0] == 2'b01)}} & {4'h2, mtdata1_t1[9], 6'b011111, mtdata1_t1[8:7], 6'b0, mtdata1_t1[6:5], 3'b0, mtdata1_t1[4:3], 3'b0, mtdata1_t1[2:0]}) |\n"", ""                                     ({32{(mtsel[1:0] == 2'b10)}} & {4'h2, mtdata1_t2[9], 6'b011111, mtdata1_t2[8:7], 6'b0, mtdata1_t2[6:5], 3'b0, mtdata1_t2[4:3], 3'b0, mtdata1_t2[2:0]}) |\n"", ""                                     ({32{(mtsel[1:0] == 2'b11)}} & {4'h2, mtdata1_t3[9], 6'b011111, mtdata1_t3[8:7], 6'b0, mtdata1_t3[6:5], 3'b0, mtdata1_t3[4:3], 3'b0, mtdata1_t3[2:0]}));\n"", '\n', '   assign trigger_pkt_any[0].select = mtdata1_t0[`MTDATA1_SEL];\n', '   assign trigger_pkt_any[0].match = mtdata1_t0[`MTDATA1_MATCH];\n', '   assign trigger_pkt_any[0].store = mtdata1_t0[`MTDATA1_ST];\n', '   assign trigger_pkt_any[0].load = mtdata1_t0[`MTDATA1_LD];\n', '   assign trigger_pkt_any[0].execute = mtdata1_t0[`MTDATA1_EXE];\n', '   assign trigger_pkt_any[0].m = mtdata1_t0[`MTDATA1_M_ENABLED];\n', '\n', '   assign trigger_pkt_any[1].select = mtdata1_t1[`MTDATA1_SEL];\n', '   assign trigger_pkt_any[1].match = mtdata1_t1[`MTDATA1_MATCH];\n', '   assign trigger_pkt_any[1].store = mtdata1_t1[`MTDATA1_ST];\n', '   assign trigger_pkt_any[1].load = mtdata1_t1[`MTDATA1_LD];\n', '   assign trigger_pkt_any[1].execute = mtdata1_t1[`MTDATA1_EXE];\n', '   assign trigger_pkt_any[1].m = mtdata1_t1[`MTDATA1_M_ENABLED];\n', '\n', '   assign trigger_pkt_any[2].select = mtdata1_t2[`MTDATA1_SEL];\n', '   assign trigger_pkt_any[2].match = mtdata1_t2[`MTDATA1_MATCH];\n', '   assign trigger_pkt_any[2].store = mtdata1_t2[`MTDATA1_ST];\n', '   assign trigger_pkt_any[2].load = mtdata1_t2[`MTDATA1_LD];\n', '   assign trigger_pkt_any[2].execute = mtdata1_t2[`MTDATA1_EXE];\n', '   assign trigger_pkt_any[2].m = mtdata1_t2[`MTDATA1_M_ENABLED];\n', '\n', '   assign trigger_pkt_any[3].select = mtdata1_t3[`MTDATA1_SEL];\n', '   assign trigger_pkt_any[3].match = mtdata1_t3[`MTDATA1_MATCH];\n', '   assign trigger_pkt_any[3].store = mtdata1_t3[`MTDATA1_ST];\n', '   assign trigger_pkt_any[3].load = mtdata1_t3[`MTDATA1_LD];\n', '   assign trigger_pkt_any[3].execute = mtdata1_t3[`MTDATA1_EXE];\n', '   assign trigger_pkt_any[3].m = mtdata1_t3[`MTDATA1_M_ENABLED];\n', '\n', '\n', '\n', '\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MTDATA2 (R/W)\n', '   // [31:0] : Trigger Data 2\n', ""   `define MTDATA2 12'h7a2\n"", '\n', '   // If the DMODE bit is set, tdata2 can only be updated in debug_mode\n', ""   assign wr_mtdata2_t0_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MTDATA2) & (mtsel[1:0] == 2'b0)  & (~mtdata1_t0[`MTDATA1_DMODE] | dbg_tlu_halted_f);\n"", ""   assign wr_mtdata2_t1_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MTDATA2) & (mtsel[1:0] == 2'b01) & (~mtdata1_t1[`MTDATA1_DMODE] | dbg_tlu_halted_f);\n"", ""   assign wr_mtdata2_t2_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MTDATA2) & (mtsel[1:0] == 2'b10) & (~mtdata1_t2[`MTDATA1_DMODE] | dbg_tlu_halted_f);\n"", ""   assign wr_mtdata2_t3_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MTDATA2) & (mtsel[1:0] == 2'b11) & (~mtdata1_t3[`MTDATA1_DMODE] | dbg_tlu_halted_f);\n"", '\n', '   rvdffe #(32)  mtdata2_t0_ff (.*, .en(wr_mtdata2_t0_wb), .din(dec_csr_wrdata_wb[31:0]), .dout(mtdata2_t0[31:0]));\n', '   rvdffe #(32)  mtdata2_t1_ff (.*, .en(wr_mtdata2_t1_wb), .din(dec_csr_wrdata_wb[31:0]), .dout(mtdata2_t1[31:0]));\n', '   rvdffe #(32)  mtdata2_t2_ff (.*, .en(wr_mtdata2_t2_wb), .din(dec_csr_wrdata_wb[31:0]), .dout(mtdata2_t2[31:0]));\n', '   rvdffe #(32)  mtdata2_t3_ff (.*, .en(wr_mtdata2_t3_wb), .din(dec_csr_wrdata_wb[31:0]), .dout(mtdata2_t3[31:0]));\n', '\n', ""   assign mtdata2_tsel_out[31:0] = ( ({32{(mtsel[1:0] == 2'b00)}} & mtdata2_t0[31:0]) |\n"", ""                                     ({32{(mtsel[1:0] == 2'b01)}} & mtdata2_t1[31:0]) |\n"", ""                                     ({32{(mtsel[1:0] == 2'b10)}} & mtdata2_t2[31:0]) |\n"", ""                                     ({32{(mtsel[1:0] == 2'b11)}} & mtdata2_t3[31:0]));\n"", '\n', '   assign trigger_pkt_any[0].tdata2[31:0] = mtdata2_t0[31:0];\n', '   assign trigger_pkt_any[1].tdata2[31:0] = mtdata2_t1[31:0];\n', '   assign trigger_pkt_any[2].tdata2[31:0] = mtdata2_t2[31:0];\n', '   assign trigger_pkt_any[3].tdata2[31:0] = mtdata2_t3[31:0];\n', '\n', '\n', '   //----------------------------------------------------------------------\n', '   // Performance Monitor Counters section starts\n', '   //----------------------------------------------------------------------\n', ""   `define MHPME_NOEVENT         6'd0\n"", ""   `define MHPME_CLK_ACTIVE      6'd1 // OOP - out of pipe\n"", ""   `define MHPME_ICACHE_HIT      6'd2 // OOP\n"", ""   `define MHPME_ICACHE_MISS     6'd3 // OOP\n"", ""   `define MHPME_INST_COMMIT     6'd4\n"", ""   `define MHPME_INST_COMMIT_16B 6'd5\n"", ""   `define MHPME_INST_COMMIT_32B 6'd6\n"", ""   `define MHPME_INST_ALIGNED    6'd7 // OOP\n"", ""   `define MHPME_INST_DECODED    6'd8 // OOP\n"", ""   `define MHPME_INST_MUL        6'd9\n"", ""   `define MHPME_INST_DIV        6'd10\n"", ""   `define MHPME_INST_LOAD       6'd11\n"", ""   `define MHPME_INST_STORE      6'd12\n"", ""   `define MHPME_INST_MALOAD     6'd13\n"", ""   `define MHPME_INST_MASTORE    6'd14\n"", ""   `define MHPME_INST_ALU        6'd15\n"", ""   `define MHPME_INST_CSRREAD    6'd16\n"", ""   `define MHPME_INST_CSRRW      6'd17\n"", ""   `define MHPME_INST_CSRWRITE   6'd18\n"", ""   `define MHPME_INST_EBREAK     6'd19\n"", ""   `define MHPME_INST_ECALL      6'd20\n"", ""   `define MHPME_INST_FENCE      6'd21\n"", ""   `define MHPME_INST_FENCEI     6'd22\n"", ""   `define MHPME_INST_MRET       6'd23\n"", ""   `define MHPME_INST_BRANCH     6'd24\n"", ""   `define MHPME_BRANCH_MP       6'd25\n"", ""   `define MHPME_BRANCH_TAKEN    6'd26\n"", ""   `define MHPME_BRANCH_NOTP     6'd27\n"", ""   `define MHPME_FETCH_STALL     6'd28 // OOP\n"", ""   `define MHPME_ALGNR_STALL     6'd29 // OOP\n"", ""   `define MHPME_DECODE_STALL    6'd30 // OOP\n"", ""   `define MHPME_POSTSYNC_STALL  6'd31 // OOP\n"", ""   `define MHPME_PRESYNC_STALL   6'd32 // OOP\n"", ""   `define MHPME_LSU_FREEZE      6'd33 // OOP\n"", ""   `define MHPME_LSU_SB_WB_STALL 6'd34 // OOP\n"", ""   `define MHPME_DMA_DCCM_STALL  6'd35 // OOP\n"", ""   `define MHPME_DMA_ICCM_STALL  6'd36 // OOP\n"", ""   `define MHPME_EXC_TAKEN       6'd37\n"", ""   `define MHPME_TIMER_INT_TAKEN 6'd38\n"", ""   `define MHPME_EXT_INT_TAKEN   6'd39\n"", ""   `define MHPME_FLUSH_LOWER     6'd40\n"", ""   `define MHPME_BR_ERROR        6'd41\n"", ""   `define MHPME_IBUS_TRANS      6'd42 // OOP\n"", ""   `define MHPME_DBUS_TRANS      6'd43 // OOP\n"", ""   `define MHPME_DBUS_MA_TRANS   6'd44 // OOP\n"", ""   `define MHPME_IBUS_ERROR      6'd45 // OOP\n"", ""   `define MHPME_DBUS_ERROR      6'd46 // OOP\n"", ""   `define MHPME_IBUS_STALL      6'd47 // OOP\n"", ""   `define MHPME_DBUS_STALL      6'd48 // OOP\n"", ""   `define MHPME_INT_DISABLED    6'd49 // OOP\n"", ""   `define MHPME_INT_STALLED     6'd50 // OOP\n"", '\n', '\n', '   logic [3:0][1:0] mhpmc_inc_e4, mhpmc_inc_wb;\n', '   logic [3:0][5:0] mhpme_vec;\n', '   logic            mhpmc3_wr_en0, mhpmc3_wr_en1, mhpmc3_wr_en;\n', '   logic            mhpmc4_wr_en0, mhpmc4_wr_en1, mhpmc4_wr_en;\n', '   logic            mhpmc5_wr_en0, mhpmc5_wr_en1, mhpmc5_wr_en;\n', '   logic            mhpmc6_wr_en0, mhpmc6_wr_en1, mhpmc6_wr_en;\n', '   logic            mhpmc3h_wr_en0, mhpmc3h_wr_en;\n', '   logic            mhpmc4h_wr_en0, mhpmc4h_wr_en;\n', '   logic            mhpmc5h_wr_en0, mhpmc5h_wr_en;\n', '   logic            mhpmc6h_wr_en0, mhpmc6h_wr_en;\n', '   logic [63:0]     mhpmc3_incr, mhpmc4_incr, mhpmc5_incr, mhpmc6_incr;\n', '\n', '   // Pack the event selects into a vector for genvar\n', '   assign mhpme_vec[0][5:0] = mhpme3[5:0];\n', '   assign mhpme_vec[1][5:0] = mhpme4[5:0];\n', '   assign mhpme_vec[2][5:0] = mhpme5[5:0];\n', '   assign mhpme_vec[3][5:0] = mhpme6[5:0];\n', '\n', '   // only consider committed itypes\n', '   logic [3:0] pmu_i0_itype_qual, pmu_i1_itype_qual;\n', '   assign pmu_i0_itype_qual[3:0] = dec_tlu_packet_e4.pmu_i0_itype[3:0] & {4{tlu_i0_commit_cmt}};\n', '   assign pmu_i1_itype_qual[3:0] = dec_tlu_packet_e4.pmu_i1_itype[3:0] & {4{tlu_i1_commit_cmt}};\n', '\n', '   // Generate the muxed incs for all counters based on event type\n', '   for (genvar i=0 ; i < 4; i++) begin\n', '      assign mhpmc_inc_e4[i][1:0] =  {2{mgpmc}} &\n', '           (\n', ""             ({2{(mhpme_vec[i][5:0] == `MHPME_CLK_ACTIVE      )}} & 2'b01) |\n"", ""             ({2{(mhpme_vec[i][5:0] == `MHPME_ICACHE_HIT      )}} & {1'b0, ifu_pmu_ic_hit}) |\n"", ""             ({2{(mhpme_vec[i][5:0] == `MHPME_ICACHE_MISS     )}} & {1'b0, ifu_pmu_ic_miss}) |\n"", '             ({2{(mhpme_vec[i][5:0] == `MHPME_INST_COMMIT     )}} & {tlu_i1_commit_cmt, tlu_i0_commit_cmt & ~illegal_e4}) |\n', '             ({2{(mhpme_vec[i][5:0] == `MHPME_INST_COMMIT_16B )}} & {tlu_i1_commit_cmt & ~exu_pmu_i1_pc4, tlu_i0_commit_cmt & ~exu_pmu_i0_pc4 & ~illegal_e4}) |\n', '             ({2{(mhpme_vec[i][5:0] == `MHPME_INST_COMMIT_32B )}} & {tlu_i1_commit_cmt &  exu_pmu_i1_pc4, tlu_i0_commit_cmt &  exu_pmu_i0_pc4 & ~illegal_e4}) |\n', '             ({2{(mhpme_vec[i][5:0] == `MHPME_INST_ALIGNED    )}} & ifu_pmu_instr_aligned[1:0])  |\n', '             ({2{(mhpme_vec[i][5:0] == `MHPME_INST_DECODED    )}} & dec_pmu_instr_decoded[1:0])  |\n', ""             ({2{(mhpme_vec[i][5:0] == `MHPME_ALGNR_STALL     )}} & {1'b0,ifu_pmu_align_stall})  |\n"", ""             ({2{(mhpme_vec[i][5:0] == `MHPME_DECODE_STALL    )}} & {1'b0,dec_pmu_decode_stall}) |\n"", '             ({2{(mhpme_vec[i][5:0] == `MHPME_INST_MUL        )}} & {(pmu_i1_itype_qual[3:0] == MUL),     (pmu_i0_itype_qual[3:0] == MUL)})     |\n', ""             ({2{(mhpme_vec[i][5:0] == `MHPME_INST_DIV        )}} & {1'b0, dec_tlu_packet_e4.pmu_divide & tlu_i0_commit_cmt})     |\n"", '             ({2{(mhpme_vec[i][5:0] == `MHPME_INST_LOAD       )}} & {(pmu_i1_itype_qual[3:0] == LOAD),    (pmu_i0_itype_qual[3:0] == LOAD)})    |\n', '             ({2{(mhpme_vec[i][5:0] == `MHPME_INST_STORE      )}} & {(pmu_i1_itype_qual[3:0] == STORE),   (pmu_i0_itype_qual[3:0] == STORE)})   |\n', '             ({2{(mhpme_vec[i][5:0] == `MHPME_INST_MALOAD     )}} & {(pmu_i1_itype_qual[3:0] == LOAD),    (pmu_i0_itype_qual[3:0] == LOAD)} &\n', '                                                                      {2{dec_tlu_packet_e4.pmu_lsu_misaligned}})    |\n', '             ({2{(mhpme_vec[i][5:0] == `MHPME_INST_MASTORE    )}} & {(pmu_i1_itype_qual[3:0] == STORE),   (pmu_i0_itype_qual[3:0] == STORE)} &\n', '                                                                      {2{dec_tlu_packet_e4.pmu_lsu_misaligned}})    |\n', '             ({2{(mhpme_vec[i][5:0] == `MHPME_INST_ALU        )}} & {(pmu_i1_itype_qual[3:0] == ALU),     (pmu_i0_itype_qual[3:0] == ALU)})     |\n', ""             ({2{(mhpme_vec[i][5:0] == `MHPME_INST_CSRREAD    )}} & {1'b0, (pmu_i0_itype_qual[3:0] == CSRREAD)}) |\n"", ""             ({2{(mhpme_vec[i][5:0] == `MHPME_INST_CSRWRITE   )}} & {1'b0, (pmu_i0_itype_qual[3:0] == CSRWRITE)})|\n"", ""             ({2{(mhpme_vec[i][5:0] == `MHPME_INST_CSRRW      )}} & {1'b0, (pmu_i0_itype_qual[3:0] == CSRRW)})   |\n"", ""             ({2{(mhpme_vec[i][5:0] == `MHPME_INST_EBREAK     )}} & {1'b0, (pmu_i0_itype_qual[3:0] == EBREAK)})  |\n"", ""             ({2{(mhpme_vec[i][5:0] == `MHPME_INST_ECALL      )}} & {1'b0, (pmu_i0_itype_qual[3:0] == ECALL)})   |\n"", ""             ({2{(mhpme_vec[i][5:0] == `MHPME_INST_FENCE      )}} & {1'b0, (pmu_i0_itype_qual[3:0] == FENCE)})   |\n"", ""             ({2{(mhpme_vec[i][5:0] == `MHPME_INST_FENCEI     )}} & {1'b0, (pmu_i0_itype_qual[3:0] == FENCEI)})  |\n"", ""             ({2{(mhpme_vec[i][5:0] == `MHPME_INST_MRET       )}} & {1'b0, (pmu_i0_itype_qual[3:0] == MRET)})    |\n"", '             ({2{(mhpme_vec[i][5:0] == `MHPME_INST_BRANCH     )}} & {((pmu_i1_itype_qual[3:0] == CONDBR) | (pmu_i1_itype_qual[3:0] == JAL)),\n', '                                                                     ((pmu_i0_itype_qual[3:0] == CONDBR) | (pmu_i0_itype_qual[3:0] == JAL))})   |\n', '             ({2{(mhpme_vec[i][5:0] == `MHPME_BRANCH_MP       )}} & {exu_pmu_i1_br_misp & tlu_i1_commit_cmt, exu_pmu_i0_br_misp & tlu_i0_commit_cmt}) |\n', '             ({2{(mhpme_vec[i][5:0] == `MHPME_BRANCH_TAKEN    )}} & {exu_pmu_i1_br_ataken & tlu_i1_commit_cmt, exu_pmu_i0_br_ataken & tlu_i0_commit_cmt}) |\n', '             ({2{(mhpme_vec[i][5:0] == `MHPME_BRANCH_NOTP     )}} & {dec_tlu_packet_e4.pmu_i1_br_unpred & tlu_i1_commit_cmt, dec_tlu_packet_e4.pmu_i0_br_unpred & tlu_i0_commit_cmt}) |\n', ""             ({2{(mhpme_vec[i][5:0] == `MHPME_FETCH_STALL     )}} & {1'b0, ifu_pmu_fetch_stall}) |\n"", ""             ({2{(mhpme_vec[i][5:0] == `MHPME_ALGNR_STALL     )}} & {1'b0, ifu_pmu_align_stall}) |\n"", ""             ({2{(mhpme_vec[i][5:0] == `MHPME_DECODE_STALL    )}} & {1'b0, dec_pmu_decode_stall}) |\n"", ""             ({2{(mhpme_vec[i][5:0] == `MHPME_POSTSYNC_STALL  )}} & {1'b0,dec_pmu_postsync_stall}) |\n"", ""             ({2{(mhpme_vec[i][5:0] == `MHPME_PRESYNC_STALL   )}} & {1'b0,dec_pmu_presync_stall}) |\n"", ""             ({2{(mhpme_vec[i][5:0] == `MHPME_LSU_FREEZE      )}} & {1'b0, lsu_freeze_dc3}) |\n"", ""             ({2{(mhpme_vec[i][5:0] == `MHPME_LSU_SB_WB_STALL )}} & {1'b0, lsu_store_stall_any}) |\n"", ""             ({2{(mhpme_vec[i][5:0] == `MHPME_DMA_DCCM_STALL  )}} & {1'b0, dma_dccm_stall_any}) |\n"", ""             ({2{(mhpme_vec[i][5:0] == `MHPME_DMA_ICCM_STALL  )}} & {1'b0, dma_iccm_stall_any}) |\n"", ""             ({2{(mhpme_vec[i][5:0] == `MHPME_EXC_TAKEN       )}} & {1'b0, (i0_exception_valid_e4 | trigger_hit_e4 | lsu_exc_valid_e4)}) |\n"", ""             ({2{(mhpme_vec[i][5:0] == `MHPME_TIMER_INT_TAKEN )}} & {1'b0, take_timer_int | take_int_timer0_int | take_int_timer1_int}) |\n"", ""             ({2{(mhpme_vec[i][5:0] == `MHPME_EXT_INT_TAKEN   )}} & {1'b0, take_ext_int}) |\n"", ""             ({2{(mhpme_vec[i][5:0] == `MHPME_FLUSH_LOWER     )}} & {1'b0, tlu_flush_lower_e4}) |\n"", '             ({2{(mhpme_vec[i][5:0] == `MHPME_BR_ERROR        )}} & {(dec_tlu_br1_error_e4 | dec_tlu_br1_start_error_e4) & rfpc_i1_e4, (dec_tlu_br0_error_e4 | dec_tlu_br0_start_error_e4) & rfpc_i0_e4}) |\n', ""             ({2{(mhpme_vec[i][5:0] == `MHPME_IBUS_TRANS      )}} & {1'b0, ifu_pmu_bus_trxn}) |\n"", ""             ({2{(mhpme_vec[i][5:0] == `MHPME_DBUS_TRANS      )}} & {1'b0, lsu_pmu_bus_trxn}) |\n"", ""             ({2{(mhpme_vec[i][5:0] == `MHPME_DBUS_MA_TRANS   )}} & {1'b0, lsu_pmu_bus_misaligned}) |\n"", ""             ({2{(mhpme_vec[i][5:0] == `MHPME_IBUS_ERROR      )}} & {1'b0, ifu_pmu_bus_error}) |\n"", ""             ({2{(mhpme_vec[i][5:0] == `MHPME_DBUS_ERROR      )}} & {1'b0, lsu_pmu_bus_error}) |\n"", ""             ({2{(mhpme_vec[i][5:0] == `MHPME_IBUS_STALL      )}} & {1'b0, ifu_pmu_bus_busy}) |\n"", ""             ({2{(mhpme_vec[i][5:0] == `MHPME_DBUS_STALL      )}} & {1'b0, lsu_pmu_bus_busy}) |\n"", ""             ({2{(mhpme_vec[i][5:0] == `MHPME_INT_DISABLED    )}} & {1'b0, ~mstatus[`MSTATUS_MIE]}) |\n"", ""             ({2{(mhpme_vec[i][5:0] == `MHPME_INT_STALLED     )}} & {1'b0, ~mstatus[`MSTATUS_MIE] & |(mip[5:0] & mie[5:0])})\n"", '             );\n', '   end\n', '\n', '   rvdff #(2) pmu0inc_ff (.*, .clk(free_clk), .din(mhpmc_inc_e4[0][1:0]), .dout(mhpmc_inc_wb[0][1:0]));\n', '   rvdff #(2) pmu1inc_ff (.*, .clk(free_clk), .din(mhpmc_inc_e4[1][1:0]), .dout(mhpmc_inc_wb[1][1:0]));\n', '   rvdff #(2) pmu2inc_ff (.*, .clk(free_clk), .din(mhpmc_inc_e4[2][1:0]), .dout(mhpmc_inc_wb[2][1:0]));\n', '   rvdff #(2) pmu3inc_ff (.*, .clk(free_clk), .din(mhpmc_inc_e4[3][1:0]), .dout(mhpmc_inc_wb[3][1:0]));\n', '\n', '   assign perfcnt_halted = ((dec_tlu_dbg_halted & dcsr[`DCSR_STOPC]) | dec_tlu_pmu_fw_halted);\n', '\n', '   assign dec_tlu_perfcnt0[1:0] = mhpmc_inc_wb[0][1:0] & ~{2{perfcnt_halted}};\n', '   assign dec_tlu_perfcnt1[1:0] = mhpmc_inc_wb[1][1:0] & ~{2{perfcnt_halted}};\n', '   assign dec_tlu_perfcnt2[1:0] = mhpmc_inc_wb[2][1:0] & ~{2{perfcnt_halted}};\n', '   assign dec_tlu_perfcnt3[1:0] = mhpmc_inc_wb[3][1:0] & ~{2{perfcnt_halted}};\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MHPMC3H(RW), MHPMC3(RW)\n', '   // [63:32][31:0] : Hardware Performance Monitor Counter 3\n', ""   `define MHPMC3 12'hB03\n"", ""   `define MHPMC3H 12'hB83\n"", '\n', '   assign mhpmc3_wr_en0 = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MHPMC3);\n', '   assign mhpmc3_wr_en1 = ~perfcnt_halted & (|(mhpmc_inc_wb[0][1:0]));\n', '   assign mhpmc3_wr_en  = mhpmc3_wr_en0 | mhpmc3_wr_en1;\n', ""   assign mhpmc3_incr[63:0] = {mhpmc3h[31:0],mhpmc3[31:0]} + {63'b0,mhpmc_inc_wb[0][1]} + {63'b0,mhpmc_inc_wb[0][0]};\n"", '   assign mhpmc3_ns[31:0] = mhpmc3_wr_en0 ? dec_csr_wrdata_wb[31:0] : mhpmc3_incr[31:0];\n', '   rvdffe #(32)  mhpmc3_ff (.*, .en(mhpmc3_wr_en), .din(mhpmc3_ns[31:0]), .dout(mhpmc3[31:0]));\n', '\n', '   assign mhpmc3h_wr_en0 = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MHPMC3H);\n', '   assign mhpmc3h_wr_en  = mhpmc3h_wr_en0 | mhpmc3_wr_en1;\n', '   assign mhpmc3h_ns[31:0] = mhpmc3h_wr_en0 ? dec_csr_wrdata_wb[31:0] : mhpmc3_incr[63:32];\n', '   rvdffe #(32)  mhpmc3h_ff (.*, .en(mhpmc3h_wr_en), .din(mhpmc3h_ns[31:0]), .dout(mhpmc3h[31:0]));\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MHPMC4H(RW), MHPMC4(RW)\n', '   // [63:32][31:0] : Hardware Performance Monitor Counter 4\n', ""   `define MHPMC4 12'hB04\n"", ""   `define MHPMC4H 12'hB84\n"", '\n', '   assign mhpmc4_wr_en0 = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MHPMC4);\n', '   assign mhpmc4_wr_en1 = ~perfcnt_halted & (|(mhpmc_inc_wb[1][1:0]));\n', '   assign mhpmc4_wr_en  = mhpmc4_wr_en0 | mhpmc4_wr_en1;\n', ""   assign mhpmc4_incr[63:0] = {mhpmc4h[31:0],mhpmc4[31:0]} + {63'b0,mhpmc_inc_wb[1][1]} + {63'b0,mhpmc_inc_wb[1][0]};\n"", '   assign mhpmc4_ns[31:0] = mhpmc4_wr_en0 ? dec_csr_wrdata_wb[31:0] : mhpmc4_incr[31:0];\n', '   rvdffe #(32)  mhpmc4_ff (.*, .en(mhpmc4_wr_en), .din(mhpmc4_ns[31:0]), .dout(mhpmc4[31:0]));\n', '\n', '   assign mhpmc4h_wr_en0 = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MHPMC4H);\n', '   assign mhpmc4h_wr_en  = mhpmc4h_wr_en0 | mhpmc4_wr_en1;\n', '   assign mhpmc4h_ns[31:0] = mhpmc4h_wr_en0 ? dec_csr_wrdata_wb[31:0] : mhpmc4_incr[63:32];\n', '   rvdffe #(32)  mhpmc4h_ff (.*, .en(mhpmc4h_wr_en), .din(mhpmc4h_ns[31:0]), .dout(mhpmc4h[31:0]));\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MHPMC5H(RW), MHPMC5(RW)\n', '   // [63:32][31:0] : Hardware Performance Monitor Counter 5\n', ""   `define MHPMC5 12'hB05\n"", ""   `define MHPMC5H 12'hB85\n"", '\n', '   assign mhpmc5_wr_en0 = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MHPMC5);\n', '   assign mhpmc5_wr_en1 = ~perfcnt_halted & (|(mhpmc_inc_wb[2][1:0]));\n', '   assign mhpmc5_wr_en  = mhpmc5_wr_en0 | mhpmc5_wr_en1;\n', ""   assign mhpmc5_incr[63:0] = {mhpmc5h[31:0],mhpmc5[31:0]} + {63'b0,mhpmc_inc_wb[2][1]} + {63'b0,mhpmc_inc_wb[2][0]};\n"", '   assign mhpmc5_ns[31:0] = mhpmc5_wr_en0 ? dec_csr_wrdata_wb[31:0] : mhpmc5_incr[31:0];\n', '   rvdffe #(32)  mhpmc5_ff (.*, .en(mhpmc5_wr_en), .din(mhpmc5_ns[31:0]), .dout(mhpmc5[31:0]));\n', '\n', '   assign mhpmc5h_wr_en0 = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MHPMC5H);\n', '   assign mhpmc5h_wr_en  = mhpmc5h_wr_en0 | mhpmc5_wr_en1;\n', '   assign mhpmc5h_ns[31:0] = mhpmc5h_wr_en0 ? dec_csr_wrdata_wb[31:0] : mhpmc5_incr[63:32];\n', '   rvdffe #(32)  mhpmc5h_ff (.*, .en(mhpmc5h_wr_en), .din(mhpmc5h_ns[31:0]), .dout(mhpmc5h[31:0]));\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MHPMC6H(RW), MHPMC6(RW)\n', '   // [63:32][31:0] : Hardware Performance Monitor Counter 6\n', ""   `define MHPMC6 12'hB06\n"", ""   `define MHPMC6H 12'hB86\n"", '\n', '   assign mhpmc6_wr_en0 = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MHPMC6);\n', '   assign mhpmc6_wr_en1 = ~perfcnt_halted & (|(mhpmc_inc_wb[3][1:0]));\n', '   assign mhpmc6_wr_en  = mhpmc6_wr_en0 | mhpmc6_wr_en1;\n', ""   assign mhpmc6_incr[63:0] = {mhpmc6h[31:0],mhpmc6[31:0]} + {63'b0,mhpmc_inc_wb[3][1]} + {63'b0,mhpmc_inc_wb[3][0]};\n"", '   assign mhpmc6_ns[31:0] = mhpmc6_wr_en0 ? dec_csr_wrdata_wb[31:0] : mhpmc6_incr[31:0];\n', '   rvdffe #(32)  mhpmc6_ff (.*, .en(mhpmc6_wr_en), .din(mhpmc6_ns[31:0]), .dout(mhpmc6[31:0]));\n', '\n', '   assign mhpmc6h_wr_en0 = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MHPMC6H);\n', '   assign mhpmc6h_wr_en  = mhpmc6h_wr_en0 | mhpmc6_wr_en1;\n', '   assign mhpmc6h_ns[31:0] = mhpmc6h_wr_en0 ? dec_csr_wrdata_wb[31:0] : mhpmc6_incr[63:32];\n', '   rvdffe #(32)  mhpmc6h_ff (.*, .en(mhpmc6h_wr_en), .din(mhpmc6h_ns[31:0]), .dout(mhpmc6h[31:0]));\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MHPME3(RW)\n', '   // [5:0] : Hardware Performance Monitor Event 3\n', ""   `define MHPME3 12'h323\n"", '\n', '   // we only have 50 events, HPME* are WARL so saturate at 50\n', '   logic [5:0] event_saturate_wb;\n', ""   assign event_saturate_wb[5:0] = ((dec_csr_wrdata_wb[5:0] > 6'd50) | (|dec_csr_wrdata_wb[31:6])) ? 6'd50 : dec_csr_wrdata_wb[5:0];\n"", '\n', '   assign wr_mhpme3_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MHPME3);\n', '   rvdffs #(6)  mhpme3_ff (.*, .clk(active_clk), .en(wr_mhpme3_wb), .din(event_saturate_wb[5:0]), .dout(mhpme3[5:0]));\n', '   // ----------------------------------------------------------------------\n', '   // MHPME4(RW)\n', '   // [5:0] : Hardware Performance Monitor Event 4\n', ""   `define MHPME4 12'h324\n"", '\n', '   assign wr_mhpme4_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MHPME4);\n', '   rvdffs #(6)  mhpme4_ff (.*, .clk(active_clk), .en(wr_mhpme4_wb), .din(event_saturate_wb[5:0]), .dout(mhpme4[5:0]));\n', '   // ----------------------------------------------------------------------\n', '   // MHPME5(RW)\n', '   // [5:0] : Hardware Performance Monitor Event 5\n', ""   `define MHPME5 12'h325\n"", '\n', '   assign wr_mhpme5_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MHPME5);\n', '   rvdffs #(6)  mhpme5_ff (.*, .clk(active_clk), .en(wr_mhpme5_wb), .din(event_saturate_wb[5:0]), .dout(mhpme5[5:0]));\n', '   // ----------------------------------------------------------------------\n', '   // MHPME6(RW)\n', '   // [5:0] : Hardware Performance Monitor Event 6\n', ""   `define MHPME6 12'h326\n"", '\n', '   assign wr_mhpme6_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MHPME6);\n', '   rvdffs #(6)  mhpme6_ff (.*, .clk(active_clk), .en(wr_mhpme6_wb), .din(event_saturate_wb[5:0]), .dout(mhpme6[5:0]));\n', '\n', '   //----------------------------------------------------------------------\n', '   // Performance Monitor Counters section ends\n', '   //----------------------------------------------------------------------\n', '   // ----------------------------------------------------------------------\n', '\n', '   // MGPMC(RW)\n', '   // [31:1] : Reserved, read 0x0\n', '   // [0]    : Perfmon controls 0: disable perf counters 1: enable.\n', '   //\n', ""   // Resets to 1'b1, counters enabled\n"", ""   `define MGPMC 12'h7d0\n"", '\n', '   assign wr_mgpmc_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MGPMC);\n', '   rvdffs #(1)  mgpmc_ff (.*, .clk(active_clk), .en(wr_mgpmc_wb), .din(~dec_csr_wrdata_wb[0]), .dout(mgpmc_b));\n', '   assign mgpmc = ~mgpmc_b;\n', '\n', '\n', '   //--------------------------------------------------------------------------------\n', '   // trace\n', '   //--------------------------------------------------------------------------------\n', '   logic usoc_tclk;\n', '\n', '   rvoclkhdr usoctrace_cgc ( .en(i0_valid_wb | exc_or_int_valid_wb | interrupt_valid_wb | dec_tlu_i0_valid_wb1 |\n', '                                dec_tlu_i0_exc_valid_wb1 | dec_tlu_i1_exc_valid_wb1 | dec_tlu_int_valid_wb1 | clk_override), .l1clk(usoc_tclk), .* );\n', '   rvdff #(10)  traceff (.*,   .clk(usoc_tclk),\n', '                        .din ({i0_valid_wb, i1_valid_wb,\n', '                               i0_exception_valid_wb | lsu_i0_exc_wb | (i0_trigger_hit_wb & ~trigger_hit_dmode_wb),\n', '                               ~(i0_exception_valid_wb | lsu_i0_exc_wb | i0_trigger_hit_wb) & exc_or_int_valid_wb & ~interrupt_valid_wb,\n', '                               exc_cause_wb[4:0],\n', '                               interrupt_valid_wb}),\n', '                        .dout({dec_tlu_i0_valid_wb1, dec_tlu_i1_valid_wb1,\n', '                               dec_tlu_i0_exc_valid_wb1, dec_tlu_i1_exc_valid_wb1,\n', '                               dec_tlu_exc_cause_wb1[4:0],\n', '                               dec_tlu_int_valid_wb1}));\n', '\n', '   assign dec_tlu_mtval_wb1  = mtval[31:0];\n', '\n', '   // end trace\n', '   //--------------------------------------------------------------------------------\n', '\n', '\n', '   // ----------------------------------------------------------------------\n', '   // CSR read mux\n', '   // ----------------------------------------------------------------------\n', '\n', '// file ""csrdecode"" is human readable file that has all of the CSR decodes defined and is part of git repo\n', '// modify this file as needed\n', '\n', '// to generate all the equations below from ""csrdecode"" except legal equation:\n', '\n', '// 1) coredecode -in csrdecode > corecsrdecode.e\n', '\n', '// 2) espresso -Dso -oeqntott corecsrdecode.e | addassign -pre out.  > csrequations\n', '\n', '// to generate the legal CSR equation below:\n', '\n', '// 1) coredecode -in csrdecode -legal > csrlegal.e\n', '\n', '// 2) espresso -Dso -oeqntott csrlegal.e | addassign -pre out. > csrlegal_equation\n', '\n', '\n', 'logic csr_misa;\n', 'logic csr_mvendorid;\n', 'logic csr_marchid;\n', 'logic csr_mimpid;\n', 'logic csr_mhartid;\n', 'logic csr_mstatus;\n', 'logic csr_mtvec;\n', 'logic csr_mip;\n', 'logic csr_mie;\n', 'logic csr_mcyclel;\n', 'logic csr_mcycleh;\n', 'logic csr_minstretl;\n', 'logic csr_minstreth;\n', 'logic csr_mscratch;\n', 'logic csr_mepc;\n', 'logic csr_mcause;\n', 'logic csr_mtval;\n', 'logic csr_mrac;\n', 'logic csr_dmst;\n', 'logic csr_mdseac;\n', 'logic csr_meihap;\n', 'logic csr_meivt;\n', 'logic csr_meipt;\n', 'logic csr_meicurpl;\n', 'logic csr_meicidpl;\n', 'logic csr_dcsr;\n', 'logic csr_mpmc;\n', 'logic csr_mcgc;\n', 'logic csr_mcpc;\n', 'logic csr_mfdc;\n', 'logic csr_dpc;\n', 'logic csr_mtsel;\n', 'logic csr_mtdata1;\n', 'logic csr_mtdata2;\n', 'logic csr_mhpmc3;\n', 'logic csr_mhpmc4;\n', 'logic csr_mhpmc5;\n', 'logic csr_mhpmc6;\n', 'logic csr_mhpmc3h;\n', 'logic csr_mhpmc4h;\n', 'logic csr_mhpmc5h;\n', 'logic csr_mhpmc6h;\n', 'logic csr_mhpme3;\n', 'logic csr_mhpme4;\n', 'logic csr_mhpme5;\n', 'logic csr_mhpme6;\n', 'logic csr_mgpmc;\n', 'logic csr_micect;\n', 'logic csr_miccmect;\n', 'logic csr_mdccmect;\n', 'logic csr_dicawics;\n', 'logic csr_dicad0;\n', 'logic csr_dicad1;\n', 'logic csr_dicago;\n', 'logic presync;\n', 'logic postsync;\n', '\n', 'assign csr_misa = (!dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[6]\n', '    &!dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_mvendorid = (dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[7]\n', '    &!dec_csr_rdaddr_d[1]&dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_marchid = (dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[7]\n', '    &dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_mimpid = (dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[6]\n', '    &dec_csr_rdaddr_d[1]&dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_mhartid = (dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[7]\n', '    &dec_csr_rdaddr_d[2]);\n', '\n', 'assign csr_mstatus = (!dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[6]\n', '    &!dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_mtvec = (!dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[5]\n', '    &!dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_mip = (!dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[2]);\n', '\n', 'assign csr_mie = (!dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]\n', '    &dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_mcyclel = (dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[7]\n', '    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]\n', '    &!dec_csr_rdaddr_d[1]);\n', '\n', 'assign csr_mcycleh = (dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[6]\n', '    &!dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]\n', '    &!dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[1]);\n', '\n', 'assign csr_minstretl = (!dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[6]\n', '    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]\n', '    &dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_minstreth = (!dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[7]\n', '    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]\n', '    &dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_mscratch = (!dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]\n', '    &!dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_mepc = (!dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[1]\n', '    &dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_mcause = (!dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]\n', '    &dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_mtval = (!dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[1]\n', '    &dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_mrac = (!dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]\n', '    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]\n', '    &!dec_csr_rdaddr_d[1]);\n', '\n', 'assign csr_dmst = (dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[2]\n', '    &!dec_csr_rdaddr_d[1]);\n', '\n', 'assign csr_mdseac = (dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[10]\n', '    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]);\n', '\n', 'assign csr_meihap = (dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[10]\n', '    &dec_csr_rdaddr_d[3]);\n', '\n', 'assign csr_meivt = (!dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[6]\n', '    &dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[1]\n', '    &!dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_meipt = (dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[1]\n', '    &dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_meicurpl = (dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[3]\n', '    &dec_csr_rdaddr_d[2]);\n', '\n', 'assign csr_meicidpl = (dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[6]\n', '    &dec_csr_rdaddr_d[1]&dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_dcsr = (dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]\n', '    &dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_mpmc = (dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[2]\n', '    &dec_csr_rdaddr_d[1]);\n', '\n', 'assign csr_mcgc = (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[3]\n', '    &!dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_mcpc = (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[4]\n', '    &!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[1]);\n', '\n', 'assign csr_mfdc = (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[3]\n', '    &dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_dpc = (dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]\n', '    &dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_mtsel = (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]\n', '    &!dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_mtdata1 = (dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[4]\n', '    &!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_mtdata2 = (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[5]\n', '    &!dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[1]);\n', '\n', 'assign csr_mhpmc3 = (dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[7]\n', '    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]\n', '    &dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_mhpmc4 = (dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[7]\n', '    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[2]\n', '    &!dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_mhpmc5 = (dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[7]\n', '    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[1]\n', '    &dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_mhpmc6 = (!dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[5]\n', '    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[2]\n', '    &dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_mhpmc3h = (dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[4]\n', '    &!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[1]\n', '    &dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_mhpmc4h = (dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[6]\n', '    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[2]\n', '    &!dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_mhpmc5h = (dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[4]\n', '    &!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[1]\n', '    &dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_mhpmc6h = (dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[6]\n', '    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[2]\n', '    &dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_mhpme3 = (!dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[5]\n', '    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]);\n', '\n', 'assign csr_mhpme4 = (dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]\n', '    &!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[1]\n', '    &!dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_mhpme5 = (dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]\n', '    &!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[1]\n', '    &dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_mhpme6 = (dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]\n', '    &!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[1]\n', '    &!dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_mgpmc = (dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[4]\n', '    &!dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[1]);\n', '\n', 'assign csr_micect = (dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[3]\n', '    &!dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_miccmect = (dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]\n', '    &!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_mdccmect = (dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]\n', '    &dec_csr_rdaddr_d[1]);\n', '\n', 'assign csr_dicawics = (!dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[5]\n', '    &dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_dicad0 = (dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[4]\n', '    &dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[1]&dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_dicad1 = (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[3]\n', '    &dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_dicago = (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[3]\n', '    &dec_csr_rdaddr_d[1]&dec_csr_rdaddr_d[0]);\n', '\n', 'assign presync = (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[3]\n', '    &dec_csr_rdaddr_d[0]) | (dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]\n', '    &dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[1]) | (\n', '    !dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]\n', '    &!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[1]) | (\n', '    dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]\n', '    &dec_csr_rdaddr_d[0]) | (dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[4]\n', '    &!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]) | (\n', '    dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]\n', '    &dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[1]) | (dec_csr_rdaddr_d[7]\n', '    &!dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]\n', '    &!dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[1]);\n', '\n', 'assign postsync = (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[3]\n', '    &dec_csr_rdaddr_d[0]) | (!dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[5]\n', '    &!dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[0]) | (\n', '    !dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]\n', '    &!dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[0]) | (!dec_csr_rdaddr_d[7]\n', '    &dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[1]&dec_csr_rdaddr_d[0]) | (\n', '    dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]\n', '    &dec_csr_rdaddr_d[0]) | (dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[4]\n', '    &dec_csr_rdaddr_d[2]) | (!dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[7]\n', '    &!dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]\n', '    &!dec_csr_rdaddr_d[1]) | (dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[4]\n', '    &!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[1]);\n', '\n', 'logic legal_csr;\n', 'assign legal_csr = (!dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]\n', '    &dec_csr_rdaddr_d[8]&!dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[6]\n', '    &!dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]\n', '    &!dec_csr_rdaddr_d[1]) | (dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[9]\n', '    &dec_csr_rdaddr_d[8]&dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]\n', '    &!dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[2]\n', '    &!dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]) | (dec_csr_rdaddr_d[11]\n', '    &!dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]\n', '    &!dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[0]) | (\n', '    !dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]\n', '    &dec_csr_rdaddr_d[8]&dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]\n', '    &dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[2]\n', '    &!dec_csr_rdaddr_d[1]) | (!dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[10]\n', '    &dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]&!dec_csr_rdaddr_d[7]\n', '    &!dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[2]) | (\n', '    !dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]\n', '    &dec_csr_rdaddr_d[8]&dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]\n', '    &dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]\n', '    &!dec_csr_rdaddr_d[0]) | (!dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[10]\n', '    &dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]&dec_csr_rdaddr_d[7]\n', '    &!dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[3]\n', '    &!dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[1]) | (dec_csr_rdaddr_d[11]\n', '    &dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]&!dec_csr_rdaddr_d[7]\n', '    &!dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[4]\n', '    &!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[0]) | (\n', '    !dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]\n', '    &dec_csr_rdaddr_d[8]&dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]\n', '    &!dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]\n', '    &dec_csr_rdaddr_d[2]) | (dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[9]\n', '    &dec_csr_rdaddr_d[8]&!dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[6]\n', '    &!dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]\n', '    &dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]) | (\n', '    dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]\n', '    &dec_csr_rdaddr_d[8]&dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[5]\n', '    &!dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]) | (\n', '    !dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]\n', '    &dec_csr_rdaddr_d[8]&dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]\n', '    &!dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[3]\n', '    &!dec_csr_rdaddr_d[2]) | (!dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[10]\n', '    &dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]&!dec_csr_rdaddr_d[7]\n', '    &!dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[1]\n', '    &dec_csr_rdaddr_d[0]) | (dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[10]\n', '    &dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]&dec_csr_rdaddr_d[7]\n', '    &!dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[3]\n', '    &!dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]) | (dec_csr_rdaddr_d[11]\n', '    &dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]&!dec_csr_rdaddr_d[7]\n', '    &!dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[4]\n', '    &!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[1]) | (\n', '    !dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]\n', '    &dec_csr_rdaddr_d[8]&dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]\n', '    &!dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]\n', '    &dec_csr_rdaddr_d[1]) | (dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[10]\n', '    &dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]&!dec_csr_rdaddr_d[6]\n', '    &!dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[2]) | (!dec_csr_rdaddr_d[11]\n', '    &dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]\n', '    &dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]\n', '    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]\n', '    &!dec_csr_rdaddr_d[0]) | (dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[10]\n', '    &dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]&!dec_csr_rdaddr_d[6]\n', '    &!dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[1]) | (!dec_csr_rdaddr_d[11]\n', '    &dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]\n', '    &dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]\n', '    &!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[0]) | (!dec_csr_rdaddr_d[11]\n', '    &!dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]\n', '    &!dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]\n', '    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]) | (\n', '    !dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]\n', '    &dec_csr_rdaddr_d[8]&!dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[5]\n', '    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[1]\n', '    &!dec_csr_rdaddr_d[0]) | (!dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[10]\n', '    &dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]&!dec_csr_rdaddr_d[7]\n', '    &!dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[3]) | (\n', '    dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]\n', '    &dec_csr_rdaddr_d[8]&!dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]\n', '    &dec_csr_rdaddr_d[3]) | (!dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[10]\n', '    &dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]&!dec_csr_rdaddr_d[7]\n', '    &!dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[4]) | (\n', '    dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]\n', '    &dec_csr_rdaddr_d[8]&!dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]\n', '    &dec_csr_rdaddr_d[4]);\n', '\n', '\n', 'assign dec_tlu_presync_d = presync & dec_csr_any_unq_d & ~dec_csr_wen_unq_d;\n', 'assign dec_tlu_postsync_d = (postsync & dec_csr_any_unq_d) | rfpc_postsync;\n', 'assign valid_csr = ( legal_csr & (~(csr_dcsr | csr_dpc | csr_dmst | csr_dicawics | csr_dicad0 | csr_dicad1 | csr_dicago) | dbg_tlu_halted_f));\n', '\n', 'assign dec_csr_legal_d = ( dec_csr_any_unq_d &\n', '                           valid_csr &          // of a valid CSR\n', ""                           ~(dec_csr_wen_unq_d & (csr_mvendorid | csr_marchid | csr_mimpid | csr_mhartid | csr_mdseac | csr_meihap)) // that's not a write to a RO CSR\n"", '                           );\n', '   // CSR read mux\n', ""assign dec_csr_rddata_d[31:0] = ( ({32{csr_misa}}      & 32'h40001104) |\n"", ""                                  ({32{csr_mvendorid}} & 32'h00000045) |\n"", ""                                  ({32{csr_marchid}}   & 32'h0000000b) |\n"", ""                                  ({32{csr_mimpid}}    & 32'h6) |\n"", ""                                  ({32{csr_mstatus}}   & {19'b0, 2'b11, 3'b0, mstatus[1], 3'b0, mstatus[0], 3'b0}) |\n"", ""                                  ({32{csr_mtvec}}     & {mtvec[30:1], 1'b0, mtvec[0]}) |\n"", ""                                  ({32{csr_mip}}       & {1'b0, mip[5:3], 16'b0, mip[2], 3'b0, mip[1], 3'b0, mip[0], 3'b0}) |\n"", ""                                  ({32{csr_mie}}       & {1'b0, mie[5:3], 16'b0, mie[2], 3'b0, mie[1], 3'b0, mie[0], 3'b0}) |\n"", '                                  ({32{csr_mcyclel}}   & mcyclel[31:0]) |\n', '                                  ({32{csr_mcycleh}}   & mcycleh_inc[31:0]) |\n', '                                  ({32{csr_minstretl}} & minstretl_read[31:0]) |\n', '                                  ({32{csr_minstreth}} & minstreth_read[31:0]) |\n', '                                  ({32{csr_mscratch}}  & mscratch[31:0]) |\n', ""                                  ({32{csr_mepc}}      & {mepc[31:1], 1'b0}) |\n"", '                                  ({32{csr_mcause}}    & mcause[31:0]) |\n', '                                  ({32{csr_mtval}}     & mtval[31:0]) |\n', '                                  ({32{csr_mrac}}      & mrac[31:0]) |\n', '                                  ({32{csr_mdseac}}    & mdseac[31:0]) |\n', ""                                  ({32{csr_meivt}}     & {meivt[31:10], 10'b0}) |\n"", ""                                  ({32{csr_meihap}}    & {meivt[31:10], meihap[9:2], 2'b0}) |\n"", ""                                  ({32{csr_meicurpl}}  & {28'b0, meicurpl[3:0]}) |\n"", ""                                  ({32{csr_meicidpl}}  & {28'b0, meicidpl[3:0]}) |\n"", ""                                  ({32{csr_meipt}}     & {28'b0, meipt[3:0]}) |\n"", ""                                  ({32{csr_mcgc}}      & {23'b0, mcgc[8:0]}) |\n"", ""                                  ({32{csr_mfdc}}      & {13'b0, mfdc[18:0]}) |\n"", ""                                  ({32{csr_dcsr}}      & {16'h4000, dcsr[15:2], 2'b11}) |\n"", ""                                  ({32{csr_dpc}}       & {dpc[31:1], 1'b0}) |\n"", '                                  ({32{csr_dicad0}}    & dicad0[31:0]) |\n', '`ifdef RV_ICACHE_ECC\n', ""                                  ({32{csr_dicad1}}    & {22'b0, dicad1[9:0]}) |\n"", '`else\n', ""                                  ({32{csr_dicad1}}    & {30'b0, dicad1[1:0]}) |\n"", '`endif\n', ""                                  ({32{csr_dicawics}}  & {7'b0, dicawics[18], 2'b0, dicawics[17:16], 4'b0, dicawics[15:2], 2'b0}) |\n"", ""                                  ({32{csr_mtsel}}     & {30'b0, mtsel[1:0]}) |\n"", '                                  ({32{csr_mtdata1}}   & {mtdata1_tsel_out[31:0]}) |\n', '                                  ({32{csr_mtdata2}}   & {mtdata2_tsel_out[31:0]}) |\n', '                                  ({32{csr_micect}}    & {micect[31:0]}) |\n', '                                  ({32{csr_miccmect}}  & {miccmect[31:0]}) |\n', '                                  ({32{csr_mdccmect}}  & {mdccmect[31:0]}) |\n', '                                  ({32{csr_mhpmc3}}    & mhpmc3[31:0]) |\n', '                                  ({32{csr_mhpmc4}}    & mhpmc4[31:0]) |\n', '                                  ({32{csr_mhpmc5}}    & mhpmc5[31:0]) |\n', '                                  ({32{csr_mhpmc6}}    & mhpmc6[31:0]) |\n', '                                  ({32{csr_mhpmc3h}}   & mhpmc3h[31:0]) |\n', '                                  ({32{csr_mhpmc4h}}   & mhpmc4h[31:0]) |\n', '                                  ({32{csr_mhpmc5h}}   & mhpmc5h[31:0]) |\n', '                                  ({32{csr_mhpmc6h}}   & mhpmc6h[31:0]) |\n', ""                                  ({32{csr_mhpme3}}    & {26'b0,mhpme3[5:0]}) |\n"", ""                                  ({32{csr_mhpme4}}    & {26'b0,mhpme4[5:0]}) |\n"", ""                                  ({32{csr_mhpme5}}    & {26'b0,mhpme5[5:0]}) |\n"", ""                                  ({32{csr_mhpme6}}    & {26'b0,mhpme6[5:0]}) |\n"", ""                                  ({32{csr_mpmc}}      & {30'b0, mpmc[1], 1'b0}) |\n"", ""                                  ({32{csr_mgpmc}}     & {31'b0, mgpmc}) |\n"", '                                  ({32{dec_timer_read_d}} & dec_timer_rddata_d[31:0])\n', '                                  );\n', '\n', '\n', '\n', '`undef MSTATUS_MIE\n', '`undef MISA\n', '`undef MVENDORID\n', '`undef MARCHID\n', '`undef MIMPID\n', '`undef MHARTID\n', '`undef MSTATUS\n', '`undef MTVEC\n', '`undef MIP\n', '`undef MIP_MEIP\n', '`undef MIP_MTIP\n', '`undef MIP_MSIP\n', '`undef MIE\n', '`undef MIE_MEIE\n', '`undef MIE_MTIE\n', '`undef MCYCLEL\n', '`undef MCYCLEH\n', '`undef MINSTRETL\n', '`undef MINSTRETH\n', '`undef MSCRATCH\n', '`undef MEPC\n', '`undef MCAUSE\n', '`undef MTVAL\n', '`undef MRAC\n', '`undef MDSEAC\n', '`undef MEIHAP\n', '`undef MEIPT\n', '`undef MEICURPL\n', '\n', '\n', 'endmodule // dec_tlu_ctl\n', '\n', 'module dec_timer_ctl\n', '  (\n', '   input logic clk,\n', '   input logic free_clk,\n', '   input logic rst_l,\n', '   input logic        dec_csr_wen_wb_mod,      // csr write enable at wb\n', '   input logic [11:0] dec_csr_rdaddr_d,      // read address for csr\n', '   input logic [11:0] dec_csr_wraddr_wb,      // write address for csr\n', '   input logic [31:0] dec_csr_wrdata_wb,   // csr write data at wb\n', '\n', '   input logic dec_pause_state, // Paused\n', '   input logic dec_tlu_pmu_fw_halted, // pmu/fw halted\n', '   input logic internal_dbg_halt_timers, // debug halted\n', '\n', '   output logic [31:0] dec_timer_rddata_d, // timer CSR read data\n', '   output logic        dec_timer_read_d, // timer CSR address match\n', '   output logic        dec_timer_t0_pulse, // timer0 int\n', '   output logic        dec_timer_t1_pulse, // timer1 int\n', '\n', '   input  logic        scan_mode\n', '   );\n', '   `define MITCTL_ENABLE 0\n', '   `define MITCTL_ENABLE_HALTED 1\n', '   `define MITCTL_ENABLE_PAUSED 2\n', '\n', '   logic [31:0] mitcnt0_ns, mitcnt0, mitcnt1_ns, mitcnt1, mitb0, mitb1, mitb0_b, mitb1_b, mitcnt0_inc, mitcnt1_inc;\n', '   logic [2:0] mitctl0_ns, mitctl0, mitctl1_ns, mitctl1;\n', '   logic wr_mitcnt0_wb, wr_mitcnt1_wb, wr_mitb0_wb, wr_mitb1_wb, wr_mitctl0_wb, wr_mitctl1_wb;\n', '   logic mitcnt0_inc_ok, mitcnt1_inc_ok, mitcnt0_cout_nc, mitcnt1_cout_nc;\n', '\n', ' logic mit0_match_ns;\n', ' logic mit1_match_ns;\n', ' logic mitctl0_0_b_ns;\n', ' logic mitctl0_0_b;\n', ' logic mitctl1_0_b_ns;\n', ' logic mitctl1_0_b;\n', '\n', '   assign mit0_match_ns = (mitcnt0[31:0] >= mitb0[31:0]);\n', '   assign mit1_match_ns = (mitcnt1[31:0] >= mitb1[31:0]);\n', '\n', '   assign dec_timer_t0_pulse = mit0_match_ns;\n', '   assign dec_timer_t1_pulse = mit1_match_ns;\n', '   // ----------------------------------------------------------------------\n', '   // MITCNT0 (RW)\n', '   // [31:0] : Internal Timer Counter 0\n', '\n', ""   `define MITCNT0 12'h7d2\n"", '\n', '   assign wr_mitcnt0_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MITCNT0);\n', '\n', '   assign mitcnt0_inc_ok = mitctl0[`MITCTL_ENABLE] & (~dec_pause_state | mitctl0[`MITCTL_ENABLE_PAUSED]) & (~dec_tlu_pmu_fw_halted | mitctl0[`MITCTL_ENABLE_HALTED]) & ~internal_dbg_halt_timers;\n', '\n', ""   assign {mitcnt0_cout_nc, mitcnt0_inc[31:0]} = mitcnt0[31:0] + {31'b0, 1'b1};\n"", ""   assign mitcnt0_ns[31:0] = mit0_match_ns ? 'b0 : wr_mitcnt0_wb ? dec_csr_wrdata_wb[31:0] : mitcnt0_inc[31:0];\n"", '\n', '   rvdffe #(32) mitcnt0_ff      (.*, .en(wr_mitcnt0_wb | mitcnt0_inc_ok | mit0_match_ns), .din(mitcnt0_ns[31:0]), .dout(mitcnt0[31:0]));\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MITCNT1 (RW)\n', '   // [31:0] : Internal Timer Counter 0\n', '\n', ""   `define MITCNT1 12'h7d5\n"", '\n', '   assign wr_mitcnt1_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MITCNT1);\n', '\n', '   assign mitcnt1_inc_ok = mitctl1[`MITCTL_ENABLE] & (~dec_pause_state | mitctl1[`MITCTL_ENABLE_PAUSED]) & (~dec_tlu_pmu_fw_halted | mitctl1[`MITCTL_ENABLE_HALTED]) & ~internal_dbg_halt_timers;\n', '\n', ""   assign {mitcnt1_cout_nc, mitcnt1_inc[31:0]} = mitcnt1[31:0] + {31'b0, 1'b1};\n"", ""   assign mitcnt1_ns[31:0] = mit1_match_ns ? 'b0 :  wr_mitcnt1_wb ? dec_csr_wrdata_wb[31:0] : mitcnt1_inc[31:0];\n"", '\n', '   rvdffe #(32) mitcnt1_ff      (.*, .en(wr_mitcnt1_wb | mitcnt1_inc_ok | mit1_match_ns), .din(mitcnt1_ns[31:0]), .dout(mitcnt1[31:0]));\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MITB0 (RW)\n', '   // [31:0] : Internal Timer Bound 0\n', '\n', ""   `define MITB0 12'h7d3\n"", '\n', '   assign wr_mitb0_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MITB0);\n', '\n', '   rvdffe #(32) mitb0_ff      (.*, .en(wr_mitb0_wb), .din(~dec_csr_wrdata_wb[31:0]), .dout(mitb0_b[31:0]));\n', '   assign mitb0[31:0] = ~mitb0_b[31:0];\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MITB1 (RW)\n', '   // [31:0] : Internal Timer Bound 1\n', '\n', ""   `define MITB1 12'h7d6\n"", '\n', '   assign wr_mitb1_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MITB1);\n', '\n', '   rvdffe #(32) mitb1_ff      (.*, .en(wr_mitb1_wb), .din(~dec_csr_wrdata_wb[31:0]), .dout(mitb1_b[31:0]));\n', '   assign mitb1[31:0] = ~mitb1_b[31:0];\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MITCTL0 (RW) Internal Timer Ctl 0\n', '   // [31:3] : Reserved, reads 0x0\n', '   // [2]    : Enable while PAUSEd\n', '   // [1]    : Enable while HALTed\n', '   // [0]    : Enable (resets to 0x1)\n', '\n', ""   `define MITCTL0 12'h7d4\n"", '\n', '   assign wr_mitctl0_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MITCTL0);\n', '   assign mitctl0_ns[2:0] = wr_mitctl0_wb ? {dec_csr_wrdata_wb[2:0]} : {mitctl0[2:0]};\n', '\n', '   assign mitctl0_0_b_ns = ~mitctl0_ns[0];\n', '   rvdff #(3) mitctl0_ff      (.*, .clk(free_clk), .din({mitctl0_ns[2:1], mitctl0_0_b_ns}), .dout({mitctl0[2:1], mitctl0_0_b}));\n', '   assign mitctl0[0] = ~mitctl0_0_b;\n', '\n', '   // ----------------------------------------------------------------------\n', '   // MITCTL1 (RW) Internal Timer Ctl 1\n', '   // [31:3] : Reserved, reads 0x0\n', '   // [2]    : Enable while PAUSEd\n', '   // [1]    : Enable while HALTed\n', '   // [0]    : Enable (resets to 0x1)\n', '\n', ""   `define MITCTL1 12'h7d7\n"", '\n', '   assign wr_mitctl1_wb = dec_csr_wen_wb_mod & (dec_csr_wraddr_wb[11:0] == `MITCTL1);\n', '   assign mitctl1_ns[2:0] = wr_mitctl1_wb ? {dec_csr_wrdata_wb[2:0]} : {mitctl1[2:0]};\n', '\n', '   assign mitctl1_0_b_ns = ~mitctl1_ns[0];\n', '   rvdff #(3) mitctl1_ff      (.*, .clk(free_clk), .din({mitctl1_ns[2:1], mitctl1_0_b_ns}), .dout({mitctl1[2:1], mitctl1_0_b}));\n', '   assign mitctl1[0] = ~mitctl1_0_b;\n', '\n', '\n', '\n', 'logic csr_mitctl0;\n', 'logic csr_mitctl1;\n', 'logic csr_mitb0;\n', 'logic csr_mitb1;\n', 'logic csr_mitcnt0;\n', 'logic csr_mitcnt1;\n', 'assign csr_mitctl0 = (dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[4]\n', '    &dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_mitctl1 = (dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[2]\n', '    &dec_csr_rdaddr_d[1]&dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_mitb0 = (dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[4]\n', '    &!dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_mitb1 = (dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[2]\n', '    &dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_mitcnt0 = (dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]\n', '    &dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[1]\n', '    &!dec_csr_rdaddr_d[0]);\n', '\n', 'assign csr_mitcnt1 = (dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[2]\n', '    &!dec_csr_rdaddr_d[1]&dec_csr_rdaddr_d[0]);\n', '\n', '\n', '\n', '   assign dec_timer_read_d = csr_mitcnt1 | csr_mitcnt0 | csr_mitb1 | csr_mitb0 | csr_mitctl0 | csr_mitctl1;\n', '   assign dec_timer_rddata_d[31:0] = ( ({32{csr_mitcnt0}}      & mitcnt0[31:0]) |\n', '                                       ({32{csr_mitcnt1}}      & mitcnt1[31:0]) |\n', '                                       ({32{csr_mitb0}}        & mitb0[31:0]) |\n', '                                       ({32{csr_mitb1}}        & mitb1[31:0]) |\n', ""                                       ({32{csr_mitctl0}}      & {29'b0, mitctl0[2:0]}) |\n"", ""                                       ({32{csr_mitctl1}}      & {29'b0, mitctl1[2:0]})\n"", '                                       );\n', '\n', '\n', 'endmodule // dec_timer_ctl\n']"
"['// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '\n', '//********************************************************************************\n', '// $Id$\n', '//\n', '//\n', '// Owner:\n', '// Function: DEC Trigger Logic\n', '// Comments:\n', '//\n', '//********************************************************************************\n', 'module dec_trigger\n', '   import veer_types::*;\n', '(\n', '   input logic         clk,\n', '   input logic         rst_l,\n', '\n', ""   input trigger_pkt_t [3:0] trigger_pkt_any,           // Packet from tlu. 'select':0-pc,1-Opcode  'Execute' needs to be set for dec triggers to fire. 'match'-1 do mask, 0: full match\n"", '   input logic [31:1]  dec_i0_pc_d,                     // i0 pc\n', '   input logic [31:1]  dec_i1_pc_d,                     // i1 pc\n', '\n', '   output logic [3:0] dec_i0_trigger_match_d,\n', '   output logic [3:0] dec_i1_trigger_match_d\n', ');\n', '\n', '   logic [3:0][31:0]  dec_i0_match_data;\n', '   logic [3:0]        dec_i0_trigger_data_match;\n', '   logic [3:0][31:0]  dec_i1_match_data;\n', '   logic [3:0]        dec_i1_trigger_data_match;\n', '\n', '   for (genvar i=0; i<4; i++) begin\n', '      assign dec_i0_match_data[i][31:0] = ({32{~trigger_pkt_any[i].select & trigger_pkt_any[i].execute}} & {dec_i0_pc_d[31:1], trigger_pkt_any[i].tdata2[0]});      // select=0; do a PC match\n', '\n', '      assign dec_i1_match_data[i][31:0] = ({32{~trigger_pkt_any[i].select & trigger_pkt_any[i].execute}} & {dec_i1_pc_d[31:1], trigger_pkt_any[i].tdata2[0]} );     // select=0; do a PC match\n', '\n', '      rvmaskandmatch trigger_i0_match (.mask(trigger_pkt_any[i].tdata2[31:0]), .data(dec_i0_match_data[i][31:0]), .masken(trigger_pkt_any[i].match), .match(dec_i0_trigger_data_match[i]));\n', '      rvmaskandmatch trigger_i1_match (.mask(trigger_pkt_any[i].tdata2[31:0]), .data(dec_i1_match_data[i][31:0]), .masken(trigger_pkt_any[i].match), .match(dec_i1_trigger_data_match[i]));\n', '\n', '      assign dec_i0_trigger_match_d[i] = trigger_pkt_any[i].execute & trigger_pkt_any[i].m & dec_i0_trigger_data_match[i];\n', '      assign dec_i1_trigger_match_d[i] = trigger_pkt_any[i].execute & trigger_pkt_any[i].m & dec_i1_trigger_data_match[i];\n', '   end\n', '\n', 'endmodule // dec_trigger\n', '\n']"
"['// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '\n', '//********************************************************************************\n', '// $Id$\n', '//\n', '// Function: Top level VEER core file\n', '// Comments:\n', '//\n', '//********************************************************************************\n', '\n', 'module dma_ctrl (\n', '   input logic         clk,\n', '   input logic         free_clk,\n', '   input logic         rst_l,\n', '   input logic         dma_bus_clk_en, // slave bus clock enable\n', '   input logic         clk_override,\n', '\n', '   // AXI signals\n', '   // AXI Write Channels\n', '   input  logic                         dma_axi_awvalid,\n', '   output logic                         dma_axi_awready,\n', '   input  logic [`RV_DMA_BUS_TAG-1:0]   dma_axi_awid,\n', '   input  logic [31:0]                  dma_axi_awaddr,\n', '   input  logic [2:0]                   dma_axi_awsize,\n', '   input  logic [2:0]                   dma_axi_awprot,\n', '   input  logic [7:0]                   dma_axi_awlen,\n', '   input  logic [1:0]                   dma_axi_awburst,\n', '\n', '   input  logic                         dma_axi_wvalid,\n', '   output logic                         dma_axi_wready,\n', '   input  logic [63:0]                  dma_axi_wdata,\n', '   input  logic [7:0]                   dma_axi_wstrb,\n', '   input  logic                         dma_axi_wlast,\n', '\n', '   output logic                         dma_axi_bvalid,\n', '   input  logic                         dma_axi_bready,\n', '   output logic [1:0]                   dma_axi_bresp,\n', '   output logic [`RV_DMA_BUS_TAG-1:0]   dma_axi_bid,\n', '\n', '   // AXI Read Channels\n', '   input  logic                         dma_axi_arvalid,\n', '   output logic                         dma_axi_arready,\n', '   input  logic [`RV_DMA_BUS_TAG-1:0]   dma_axi_arid,\n', '   input  logic [31:0]                  dma_axi_araddr,\n', '   input  logic [2:0]                   dma_axi_arsize,\n', '   input  logic [2:0]                   dma_axi_arprot,\n', '   input  logic [7:0]                   dma_axi_arlen,\n', '   input  logic [1:0]                   dma_axi_arburst,\n', '\n', '   output logic                         dma_axi_rvalid,\n', '   input  logic                         dma_axi_rready,\n', '   output logic [`RV_DMA_BUS_TAG-1:0]   dma_axi_rid,\n', '   output logic [63:0]                  dma_axi_rdata,\n', '   output logic [1:0]                   dma_axi_rresp,\n', '   output logic                         dma_axi_rlast,\n', '\n', '   output logic                        dma_slv_algn_err,\n', '   // Debug signals\n', '   input logic [31:0]  dbg_cmd_addr,\n', '   input logic [31:0]  dbg_cmd_wrdata,\n', '   input logic         dbg_cmd_valid,\n', '   input logic         dbg_cmd_write, // 1: write command, 0: read_command\n', '   input logic [1:0]   dbg_cmd_type, // 0:gpr 1:csr 2: memory\n', '   input logic [1:0]   dbg_cmd_size, // size of the abstract mem access debug command\n', '\n', '   input  logic        dbg_dma_bubble,   // Debug needs a bubble to send a valid\n', '   output logic        dma_dbg_ready,    // DMA is ready to accept debug request\n', '\n', '   output logic        dma_dbg_cmd_done,\n', '   output logic        dma_dbg_cmd_fail,\n', '   output logic [31:0] dma_dbg_rddata,\n', '\n', '   // Core side signals\n', '   output logic        dma_dccm_req, // DMA dccm request (only one of dccm/iccm will be set)\n', '   output logic        dma_iccm_req, // DMA iccm request\n', '   output logic [31:0] dma_mem_addr, // DMA request address\n', '   output logic [2:0]  dma_mem_sz, // DMA request size\n', '   output logic        dma_mem_write, // DMA write to dccm/iccm\n', '   output logic [63:0] dma_mem_wdata, // DMA write data\n', '\n', '   input logic         dccm_dma_rvalid,    // dccm data valid for DMA read\n', '   input logic         dccm_dma_ecc_error, // ECC error on DMA read\n', '   input logic [63:0]  dccm_dma_rdata,     // dccm data for DMA read\n', '   input logic         iccm_dma_rvalid,    // iccm data valid for DMA read\n', '   input logic         iccm_dma_ecc_error, // ECC error on DMA read\n', '   input logic [63:0]  iccm_dma_rdata,     // iccm data for DMA read\n', '\n', '   output logic        dma_dccm_stall_any, // stall dccm pipe (bubble) so that DMA can proceed\n', '   output logic        dma_iccm_stall_any, // stall iccm pipe (bubble) so that DMA can proceed\n', '   input logic         dccm_ready, // dccm ready to accept DMA request\n', '   input logic         iccm_ready, // iccm ready to accept DMA request\n', '   input logic         dec_tlu_stall_dma, // stall dma accesses, tlu is attempting to enter halt/debug mode\n', '   input logic [2:0]   dec_tlu_dma_qos_prty,    // DMA QoS priority coming from MFDC [18:15]\n', '\n', '   output logic        dma_mem_dccm_req,        // Used by TLU to do rfpc in case of freeze\n', '\n', '   input logic         scan_mode\n', ');\n', '\n', '`include ""global.h""\n', '\n', '   localparam DEPTH = DMA_BUF_DEPTH;\n', '   localparam DEPTH_PTR = $clog2(DEPTH);\n', '   localparam NACK_COUNT = 7;\n', '\n', '   logic [DEPTH-1:0]        fifo_valid;\n', '   logic [DEPTH-1:0][1:0]   fifo_error;\n', '   logic [DEPTH-1:0]        fifo_dccm_valid;\n', '   logic [DEPTH-1:0]        fifo_iccm_valid;\n', '   logic [DEPTH-1:0]        fifo_data_valid;\n', '   logic [DEPTH-1:0]        fifo_data_bus_valid;\n', '   logic [DEPTH-1:0]        fifo_error_bus;\n', '   logic [DEPTH-1:0]        fifo_rpend;\n', '   logic [DEPTH-1:0]        fifo_done;      // DMA trxn is done in core\n', '   logic [DEPTH-1:0]        fifo_done_bus;  // DMA trxn is done in core synced to bus\n', '   logic [DEPTH-1:0]        fifo_rsp_done;  // DMA response sent to bus\n', '   logic [DEPTH-1:0][31:0]  fifo_addr;\n', '   logic [DEPTH-1:0][2:0]   fifo_sz;\n', '   logic [DEPTH-1:0]        fifo_write;\n', '   logic [DEPTH-1:0]        fifo_posted_write;\n', '   logic [DEPTH-1:0]        fifo_dbg;\n', '   logic [DEPTH-1:0][63:0]  fifo_data;\n', '   logic [DEPTH-1:0][DMA_BUS_TAG-1:0]  fifo_tag;\n', '\n', '   logic [DEPTH-1:0]        fifo_cmd_en;\n', '   logic [DEPTH-1:0]        fifo_valid_en;\n', '   logic [DEPTH-1:0]        fifo_data_en;\n', '   logic [DEPTH-1:0]        fifo_data_bus_en;\n', '   logic [DEPTH-1:0]        fifo_pend_en;\n', '   logic [DEPTH-1:0]        fifo_done_en;\n', '   logic [DEPTH-1:0]        fifo_done_bus_en;\n', '   logic [DEPTH-1:0]        fifo_error_en;\n', '   logic [DEPTH-1:0]        fifo_error_bus_en;\n', '   //logic [DEPTH-1:0]      fifo_rsp_done_en;\n', '   logic [DEPTH-1:0]        fifo_reset;\n', '   logic [DEPTH-1:0][1:0]   fifo_error_in;\n', '   logic [DEPTH-1:0][63:0]  fifo_data_in;\n', '\n', '   logic                    fifo_write_in;\n', '   logic                    fifo_posted_write_in;\n', '   logic                    fifo_dbg_in;\n', '   logic [31:0]             fifo_addr_in;\n', '   logic [2:0]              fifo_sz_in;\n', '\n', '   logic [DEPTH_PTR-1:0]    RspPtr, PrevRspPtr, NxtRspPtr;\n', '   logic [DEPTH_PTR-1:0]    WrPtr, NxtWrPtr;\n', '   logic [DEPTH_PTR-1:0]    RdPtr, NxtRdPtr;\n', '   logic [DEPTH_PTR-1:0]    RdPtr_Q1, RdPtr_Q2, RdPtr_Q3;\n', '   logic                    WrPtrEn, RdPtrEn, RspPtrEn;\n', '\n', '   logic [1:0]              dma_dbg_sz;\n', '   logic [1:0]              dma_dbg_addr;\n', '   logic [31:0]             dma_dbg_mem_rddata;\n', '   logic [31:0]             dma_dbg_mem_wrdata;\n', '   logic                    dma_dbg_cmd_error_in;\n', '   logic                    dma_dbg_cmd_done_q;\n', '\n', '   logic                    fifo_full, fifo_full_spec, fifo_empty;\n', '   logic                    dma_address_error, dma_alignment_error;\n', '   logic [3:0]              num_fifo_vld;\n', '   logic                    dma_mem_req;\n', '   logic                    dma_addr_in_dccm;\n', '   logic                    dma_addr_in_iccm;\n', '   logic                    dma_addr_in_pic;\n', '   logic                    dma_addr_in_pic_region_nc;\n', '   logic                    dma_addr_in_dccm_region_nc;\n', '   logic                    dma_addr_in_iccm_region_nc;\n', '\n', '   logic [2:0]              dma_nack_count_csr;\n', '   logic [2:0]              dma_nack_count, dma_nack_count_d;\n', '\n', '   logic                    dma_buffer_c1_clken;\n', '   logic                    dma_free_clken;\n', '   logic                    dma_buffer_c1_clk;\n', '   logic                    dma_free_clk;\n', '   logic                    dma_bus_clk;\n', '\n', '\n', '   logic                    wrbuf_en, wrbuf_data_en;\n', '   logic                    wrbuf_cmd_sent, wrbuf_rst, wrbuf_data_rst;\n', '   logic                    wrbuf_vld;\n', '   logic                    wrbuf_data_vld;\n', '   logic                    wrbuf_posted;\n', '   logic [DMA_BUS_TAG-1:0]  wrbuf_tag;\n', '   logic [2:0]              wrbuf_size;\n', '   logic [31:0]             wrbuf_addr;\n', '   logic [63:0]             wrbuf_data;\n', '   logic [7:0]              wrbuf_byteen;\n', '\n', '   logic                    rdbuf_en;\n', '   logic                    rdbuf_cmd_sent, rdbuf_rst;\n', '   logic                    rdbuf_vld;\n', '   logic [DMA_BUS_TAG-1:0]  rdbuf_tag;\n', '   logic [2:0]              rdbuf_size;\n', '   logic [31:0]             rdbuf_addr;\n', '\n', '\n', '   logic                    axi_mstr_valid, axi_mstr_valid_q;\n', '   logic                    axi_mstr_write;\n', '   logic                    axi_mstr_posted_write;\n', '   logic [DMA_BUS_TAG-1:0]  axi_mstr_tag;\n', '   logic [31:0]             axi_mstr_addr;\n', '   logic [2:0]              axi_mstr_size;\n', '   logic [63:0]             axi_mstr_wdata;\n', '   logic [7:0]              axi_mstr_wstrb;\n', '\n', '   logic                    axi_mstr_prty_in, axi_mstr_prty_en;\n', '   logic                    axi_mstr_priority;\n', '   logic                    axi_mstr_sel;\n', '\n', '   logic                    axi_slv_valid;\n', '   logic                    axi_slv_sent, axi_slv_sent_q;\n', '   logic                    axi_slv_write;\n', '   logic                    axi_slv_posted_write;\n', '   logic [DMA_BUS_TAG-1:0]  axi_slv_tag;\n', '   logic [1:0]              axi_slv_error;\n', '   logic [63:0]             axi_slv_rdata;\n', '\n', '   logic                    dma_bus_clk_en_q;\n', '   logic                    fifo_full_spec_bus;\n', '   logic                    dbg_dma_bubble_bus;\n', '   logic                    dec_tlu_stall_dma_bus;\n', '   logic                    dma_fifo_ready;\n', '\n', '   //------------------------LOGIC STARTS HERE---------------------------------\n', '\n', '   // FIFO inputs\n', ""   assign fifo_addr_in[31:0]    = dbg_cmd_valid ? dbg_cmd_addr[31:0] : (axi_mstr_write & (axi_mstr_wstrb[7:0] == 8'hf0)) ? {axi_mstr_addr[31:3],1'b1,axi_mstr_addr[1:0]} : axi_mstr_addr[31:0];\n"", ""   assign fifo_sz_in[2:0]       = dbg_cmd_valid ? {1'b0,dbg_cmd_size[1:0]} : (axi_mstr_write & ((axi_mstr_wstrb[7:0] == 8'h0f) | (axi_mstr_wstrb[7:0] == 8'hf0))) ? 3'h2 : axi_mstr_size[2:0];\n"", '   assign fifo_write_in         = dbg_cmd_valid ? dbg_cmd_write : axi_mstr_write;\n', '   assign fifo_posted_write_in  = axi_mstr_valid & axi_mstr_posted_write;\n', '   assign fifo_dbg_in           = dbg_cmd_valid;\n', '\n', '   for (genvar i=0 ;i<DEPTH; i++) begin: GenFifo\n', '      assign fifo_valid_en[i] = axi_mstr_valid & (i == WrPtr[DEPTH_PTR-1:0]);\n', '      assign fifo_cmd_en[i]   = ((axi_mstr_valid & dma_bus_clk_en) | (dbg_cmd_valid & dbg_cmd_type[1])) &\n', '                                (i == WrPtr[DEPTH_PTR-1:0]);\n', '      assign fifo_data_en[i] = (((axi_mstr_valid & (axi_mstr_write | dma_address_error | dma_alignment_error) & dma_bus_clk_en) |\n', '                                 (dbg_cmd_valid & dbg_cmd_type[1] & dbg_cmd_write))  & (i == WrPtr[DEPTH_PTR-1:0])) |\n', '                               ((dccm_dma_rvalid & (i == RdPtr_Q3[DEPTH_PTR-1:0]))| (iccm_dma_rvalid & (i == RdPtr_Q2[DEPTH_PTR-1:0])));\n', '      assign fifo_data_bus_en[i] = (fifo_data_en[i] | fifo_data_valid[i]) & dma_bus_clk_en;\n', '      assign fifo_pend_en[i] = (dma_dccm_req | dma_iccm_req) & ~dma_mem_write & (i == RdPtr[DEPTH_PTR-1:0]);\n', '      assign fifo_error_en[i] = fifo_cmd_en[i] | (((dccm_dma_rvalid & dccm_dma_ecc_error & (i == RdPtr_Q3[DEPTH_PTR-1:0])) | (iccm_dma_rvalid & iccm_dma_ecc_error & (i == RdPtr_Q2[DEPTH_PTR-1:0]))));\n', '      assign fifo_error_bus_en[i] = (((|fifo_error_in[i][1:0]) & fifo_error_en[i]) | (|fifo_error[i])) & dma_bus_clk_en;\n', '      assign fifo_done_en[i] = (((|fifo_error[i]) | ((dma_dccm_req | dma_iccm_req) & dma_mem_write)) & (i == RdPtr[DEPTH_PTR-1:0])) |\n', '                               ((dccm_dma_rvalid & (i == RdPtr_Q3[DEPTH_PTR-1:0])) | (iccm_dma_rvalid & (i == RdPtr_Q2[DEPTH_PTR-1:0])));\n', '      assign fifo_done_bus_en[i] = (fifo_done_en[i] | fifo_done[i]) & dma_bus_clk_en;\n', '      assign fifo_reset[i]   = ((axi_slv_sent & dma_bus_clk_en) | dma_dbg_cmd_done) & (i == RspPtr[DEPTH_PTR-1:0]);\n', ""      assign fifo_error_in[i]  = (dccm_dma_rvalid & (i == RdPtr_Q3[DEPTH_PTR-1:0])) ? {1'b0,dccm_dma_ecc_error} : (iccm_dma_rvalid & (i == RdPtr_Q2[DEPTH_PTR-1:0])) ? {1'b0,iccm_dma_ecc_error}  :\n"", '                                                                                                                                                {(dma_address_error | dma_alignment_error | dma_dbg_cmd_error_in), dma_alignment_error};\n', ""      assign fifo_data_in[i]   = (fifo_error_en[i] & (|fifo_error_in[i])) ? (fifo_cmd_en[i] ? {32'b0,axi_mstr_addr[31:0]} : {32'b0,fifo_addr[i]}) :\n"", '                                                                            ((dccm_dma_rvalid & (i == RdPtr_Q3[DEPTH_PTR-1:0]))  ? dccm_dma_rdata[63:0] : (iccm_dma_rvalid & (i == RdPtr_Q2[DEPTH_PTR-1:0])) ? iccm_dma_rdata[63:0] :\n', '                                                                                                                                                       (dbg_cmd_valid ? {2{dma_dbg_mem_wrdata[31:0]}} : axi_mstr_wdata[63:0]));\n', '\n', ""      rvdffsc #(1) fifo_valid_dff (.din(1'b1), .dout(fifo_valid[i]), .en(fifo_cmd_en[i]), .clear(fifo_reset[i]), .clk(dma_free_clk), .*);\n"", '      rvdffsc #(2) fifo_error_dff (.din(fifo_error_in[i]), .dout(fifo_error[i]), .en(fifo_error_en[i]), .clear(fifo_reset[i]), .clk(dma_free_clk), .*);\n', ""      rvdffsc #(1) fifo_error_bus_dff (.din(1'b1), .dout(fifo_error_bus[i]), .en(fifo_error_bus_en[i]), .clear(fifo_reset[i]), .clk(dma_free_clk), .*);\n"", '      rvdffs  #(1) fifo_dccm_valid_dff (.din((dma_addr_in_dccm | dma_addr_in_pic)), .dout(fifo_dccm_valid[i]), .en(fifo_cmd_en[i]), .clk(dma_buffer_c1_clk), .*);\n', '      rvdffs  #(1) fifo_iccm_valid_dff (.din(dma_addr_in_iccm), .dout(fifo_iccm_valid[i]), .en(fifo_cmd_en[i]), .clk(dma_buffer_c1_clk), .*);\n', ""      rvdffsc #(1) fifo_data_valid_dff (.din(1'b1), .dout(fifo_data_valid[i]), .en(fifo_data_en[i]), .clear(fifo_reset[i]), .clk(dma_free_clk), .*);\n"", ""      rvdffsc #(1) fifo_data_bus_valid_dff (.din(1'b1), .dout(fifo_data_bus_valid[i]), .en(fifo_data_bus_en[i]), .clear(fifo_reset[i]), .clk(dma_free_clk), .*);\n"", ""      rvdffsc #(1) fifo_rpend_dff (.din(1'b1), .dout(fifo_rpend[i]), .en(fifo_pend_en[i]), .clear(fifo_reset[i]), .clk(dma_free_clk), .*);\n"", ""      rvdffsc #(1) fifo_done_dff (.din(1'b1), .dout(fifo_done[i]), .en(fifo_done_en[i]), .clear(fifo_reset[i]), .clk(dma_free_clk), .*);\n"", ""      rvdffsc #(1) fifo_done_bus_dff (.din(1'b1), .dout(fifo_done_bus[i]), .en(fifo_done_bus_en[i]), .clear(fifo_reset[i]), .clk(dma_free_clk), .*);\n"", '      rvdffe  #(32) fifo_addr_dff (.din(fifo_addr_in[31:0]), .dout(fifo_addr[i]), .en(fifo_cmd_en[i]), .*);\n', '      rvdffs  #(3) fifo_sz_dff (.din(fifo_sz_in[2:0]), .dout(fifo_sz[i]), .en(fifo_cmd_en[i]), .clk(dma_buffer_c1_clk), .*);\n', '      rvdffs  #(1) fifo_write_dff (.din(fifo_write_in), .dout(fifo_write[i]), .en(fifo_cmd_en[i]), .clk(dma_buffer_c1_clk), .*);\n', '      rvdffs  #(1) fifo_posted_write_dff (.din(fifo_posted_write_in), .dout(fifo_posted_write[i]), .en(fifo_cmd_en[i]), .clk(dma_buffer_c1_clk), .*);\n', '      rvdffs  #(1) fifo_dbg_dff (.din(fifo_dbg_in), .dout(fifo_dbg[i]), .en(fifo_cmd_en[i]), .clk(dma_buffer_c1_clk), .*);\n', '      rvdffe  #(64) fifo_data_dff (.din(fifo_data_in[i]), .dout(fifo_data[i]), .en(fifo_data_en[i]), .*);\n', '      rvdffs  #(DMA_BUS_TAG) fifo_tag_dff(.din(axi_mstr_tag[DMA_BUS_TAG-1:0]), .dout(fifo_tag[i][DMA_BUS_TAG-1:0]), .en(fifo_cmd_en[i]), .clk(dma_buffer_c1_clk), .*);\n', '   end\n', '\n', '   // Pointer logic\n', ""   assign NxtWrPtr[DEPTH_PTR-1:0] = WrPtr[DEPTH_PTR-1:0] + 1'b1;\n"", ""   assign NxtRdPtr[DEPTH_PTR-1:0] = RdPtr[DEPTH_PTR-1:0] + 1'b1;\n"", ""   assign NxtRspPtr[DEPTH_PTR-1:0] = RspPtr[DEPTH_PTR-1:0] + 1'b1;\n"", '\n', '   assign WrPtrEn = |fifo_cmd_en[DEPTH-1:0];\n', '   assign RdPtrEn = (dma_dccm_req | dma_iccm_req) | ((|fifo_error[RdPtr]) & ~fifo_done[RdPtr]);\n', '   assign RspPtrEn = (dma_dbg_cmd_done | (axi_slv_sent & dma_bus_clk_en));\n', '\n', '   rvdffs #(DEPTH_PTR) WrPtr_dff(.din(NxtWrPtr[DEPTH_PTR-1:0]), .dout(WrPtr[DEPTH_PTR-1:0]), .en(WrPtrEn), .clk(dma_free_clk), .*);\n', '   rvdffs #(DEPTH_PTR) RdPtr_dff(.din(NxtRdPtr[DEPTH_PTR-1:0]), .dout(RdPtr[DEPTH_PTR-1:0]), .en(RdPtrEn), .clk(dma_free_clk), .*);\n', '   rvdffs #(DEPTH_PTR) RspPtr_dff(.din(NxtRspPtr[DEPTH_PTR-1:0]), .dout(RspPtr[DEPTH_PTR-1:0]), .en(RspPtrEn), .clk(dma_free_clk), .*);\n', '\n', '   rvdff #(DEPTH_PTR) RdPtrQ1_dff(.din(RdPtr[DEPTH_PTR-1:0]),    .dout(RdPtr_Q1[DEPTH_PTR-1:0]), .clk(dma_free_clk), .*);\n', '   rvdff #(DEPTH_PTR) RdPtrQ2_dff(.din(RdPtr_Q1[DEPTH_PTR-1:0]), .dout(RdPtr_Q2[DEPTH_PTR-1:0]), .clk(dma_free_clk), .*);\n', '   rvdff #(DEPTH_PTR) RdPtrQ3_dff(.din(RdPtr_Q2[DEPTH_PTR-1:0]), .dout(RdPtr_Q3[DEPTH_PTR-1:0]), .clk(dma_free_clk), .*);\n', '\n', '   // Miscellaneous signals\n', '   assign fifo_full = fifo_full_spec_bus;\n', '\n', '   always_comb begin\n', ""      num_fifo_vld[3:0] = 4'b0;\n"", '      for (int i=0; i<DEPTH; i++) begin\n', ""         num_fifo_vld[3:0] += {3'b0,(fifo_valid_en[i] | fifo_valid[i])};\n"", '      end\n', '   end\n', '   assign fifo_full_spec = ((num_fifo_vld[3:0] == DEPTH) & ~(|fifo_reset[DEPTH-1:0]));\n', '\n', '   assign dma_fifo_ready = ~(fifo_full | dbg_dma_bubble_bus | dec_tlu_stall_dma_bus);\n', '\n', '   // Error logic\n', '   assign dma_address_error = axi_mstr_valid & (~(dma_addr_in_dccm | dma_addr_in_iccm));    // request not for ICCM or DCCM\n', '   assign dma_alignment_error = axi_mstr_valid & ~dma_address_error &\n', ""                                (((axi_mstr_size[2:0] == 3'h1) & axi_mstr_addr[0])                                                          |    // HW size but unaligned\n"", ""                                 ((axi_mstr_size[2:0] == 3'h2) & (|axi_mstr_addr[1:0]))                                                     |    // W size but unaligned\n"", ""                                 ((axi_mstr_size[2:0] == 3'h3) & (|axi_mstr_addr[2:0]))                                                     |    // DW size but unaligned\n"", ""                                 (dma_addr_in_iccm & ~((axi_mstr_size[1:0] == 2'b10) | (axi_mstr_size[1:0] == 2'b11)))                      |    // ICCM access not word size\n"", ""                                 (dma_addr_in_dccm & axi_mstr_write & ~((axi_mstr_size[1:0] == 2'b10) | (axi_mstr_size[1:0] == 2'b11)))     |    // DCCM write not word size\n"", ""                                 (axi_mstr_write & (axi_mstr_size[2:0] == 3'h2) & (axi_mstr_wstrb[axi_mstr_addr[2:0]+:4] != 4'hf))          |    // Write byte enables not aligned for word store\n"", ""                                 (axi_mstr_write & (axi_mstr_size[2:0] == 3'h3) & ~((axi_mstr_wstrb[7:0] == 8'h0f) | (axi_mstr_wstrb[7:0] == 8'hf0) | (axi_mstr_wstrb[7:0] == 8'hff)))); // Write byte enables not aligned for dword store\n"", '\n', '   //Dbg outputs\n', '   assign dma_dbg_ready    = fifo_empty & dbg_dma_bubble;\n', '   assign dma_dbg_cmd_done = (fifo_valid[RspPtr] & fifo_dbg[RspPtr] & (fifo_write[RspPtr] | fifo_data_valid[RspPtr] | (|fifo_error[RspPtr])));\n', '   assign dma_dbg_cmd_fail     = |fifo_error[RspPtr];\n', '\n', '   assign dma_dbg_sz[1:0]          = fifo_sz[RspPtr][1:0];\n', '   assign dma_dbg_addr[1:0]        = fifo_addr[RspPtr][1:0];\n', '   assign dma_dbg_mem_rddata[31:0] = fifo_addr[RspPtr][2] ? fifo_data[RspPtr][63:32] : fifo_data[RspPtr][31:0];\n', ""   assign dma_dbg_rddata[31:0]     = ({32{(dma_dbg_sz[1:0] == 2'h0)}} & ((dma_dbg_mem_rddata[31:0] >> 8*dma_dbg_addr[1:0]) & 32'hff)) |\n"", ""                                     ({32{(dma_dbg_sz[1:0] == 2'h1)}} & ((dma_dbg_mem_rddata[31:0] >> 16*dma_dbg_addr[1]) & 32'hffff)) |\n"", ""                                     ({32{(dma_dbg_sz[1:0] == 2'h2)}} & dma_dbg_mem_rddata[31:0]);\n"", '\n', ""   assign dma_dbg_cmd_error_in = dbg_cmd_valid & (dbg_cmd_type[1:0] == 2'b10) &\n"", '                                 ((~(dma_addr_in_dccm | dma_addr_in_iccm | dma_addr_in_pic)) |             // Address outside of ICCM/DCCM/PIC\n', ""                                  ((dma_addr_in_iccm | dma_addr_in_pic) & (dbg_cmd_size[1:0] != 2'b10)));  // Only word accesses allowed for ICCM/PIC\n"", '\n', ""   assign dma_dbg_mem_wrdata[31:0] = ({32{dbg_cmd_size[1:0] == 2'h0}} & {4{dbg_cmd_wrdata[7:0]}}) |\n"", ""                                     ({32{dbg_cmd_size[1:0] == 2'h1}} & {2{dbg_cmd_wrdata[15:0]}}) |\n"", ""                                     ({32{dbg_cmd_size[1:0] == 2'h2}} & dbg_cmd_wrdata[31:0]);\n"", '\n', '\n', '   // Block the decode if fifo full\n', '   assign dma_dccm_stall_any = dma_mem_req & fifo_dccm_valid[RdPtr] & (dma_nack_count >= dma_nack_count_csr);\n', '   assign dma_iccm_stall_any = dma_mem_req & fifo_iccm_valid[RdPtr] & (dma_nack_count >= dma_nack_count_csr);\n', '\n', '   // Used to indicate ready to debug\n', '   assign fifo_empty     = ~(|(fifo_valid_en[DEPTH-1:0] | fifo_valid[DEPTH-1:0]) | axi_mstr_valid | axi_slv_sent_q);  // We want RspPtr to settle before accepting debug command\n', '\n', '   // Nack counter, stall the lsu pipe if 7 nacks\n', '   assign dma_nack_count_csr[2:0] = dec_tlu_dma_qos_prty[2:0];\n', '   assign dma_nack_count_d[2:0] = (dma_nack_count[2:0] >= dma_nack_count_csr[2:0]) ? ({3{~(dma_dccm_req | dma_iccm_req)}} & dma_nack_count[2:0]) :\n', ""                                                                                    (dma_mem_req & ~(dma_dccm_req | dma_iccm_req)) ? (dma_nack_count[2:0] + 1'b1) : 3'b0;\n"", '\n', '   rvdffs #(3) nack_count_dff(.din(dma_nack_count_d[2:0]), .dout(dma_nack_count[2:0]), .en(dma_mem_req), .clk(dma_free_clk), .*);\n', '\n', '   // Core outputs\n', '   assign dma_mem_req  = fifo_valid[RdPtr] & ~fifo_rpend[RdPtr] & ~fifo_done[RdPtr] & ~(|fifo_error[RdPtr]) & (~fifo_write[RdPtr] | fifo_data_valid[RdPtr]);\n', '   assign dma_mem_dccm_req = dma_mem_req & fifo_dccm_valid[RdPtr];     // Only used by TLU for rfpc\n', '   assign dma_dccm_req = dma_mem_req & fifo_dccm_valid[RdPtr] & dccm_ready;\n', '   assign dma_iccm_req = dma_mem_req & fifo_iccm_valid[RdPtr] & iccm_ready;\n', '   assign dma_mem_addr[31:0]  = fifo_addr[RdPtr];\n', '   assign dma_mem_sz[2:0]     = fifo_sz[RdPtr];\n', '   assign dma_mem_write       = fifo_write[RdPtr];\n', '   assign dma_mem_wdata[63:0] = fifo_data[RdPtr];\n', '\n', '   // Address check  dccm\n', '   rvrangecheck #(.CCM_SADR(`RV_DCCM_SADR),\n', '                  .CCM_SIZE(`RV_DCCM_SIZE)) addr_dccm_rangecheck (\n', '      .addr(fifo_addr_in[31:0]),\n', '      .in_range(dma_addr_in_dccm),\n', '      .in_region(dma_addr_in_dccm_region_nc)\n', '   );\n', '\n', '   // Address check  iccm\n', '`ifdef RV_ICCM_ENABLE\n', '   rvrangecheck #(.CCM_SADR(`RV_ICCM_SADR),\n', '                  .CCM_SIZE(`RV_ICCM_SIZE)) addr_iccm_rangecheck (\n', '      .addr(fifo_addr_in[31:0]),\n', '      .in_range(dma_addr_in_iccm),\n', '      .in_region(dma_addr_in_iccm_region_nc)\n', '   );\n', '`else\n', ""   assign dma_addr_in_iccm = '0;\n"", ""   assign dma_addr_in_iccm_region_nc = '0;\n"", '`endif\n', '\n', '   // PIC memory address check\n', '   rvrangecheck #(.CCM_SADR(`RV_PIC_BASE_ADDR),\n', '                  .CCM_SIZE(`RV_PIC_SIZE)) addr_pic_rangecheck (\n', '      .addr(fifo_addr_in[31:0]),\n', '      .in_range(dma_addr_in_pic),\n', '      .in_region(dma_addr_in_pic_region_nc)\n', '    );\n', '\n', '   // Inputs\n', '   rvdff #(1)  ahbs_bus_clken_ff (.din(dma_bus_clk_en), .dout(dma_bus_clk_en_q), .clk(free_clk), .*);\n', '   rvdff #(1) dma_dbg_cmd_doneff (.din(dma_dbg_cmd_done), .dout(dma_dbg_cmd_done_q), .clk(free_clk), .*);\n', '\n', '   // Clock Gating logic\n', '   assign dma_buffer_c1_clken = (axi_mstr_valid & dma_bus_clk_en) | dbg_cmd_valid | dec_tlu_stall_dma | clk_override;\n', '   assign dma_free_clken = (axi_mstr_valid | axi_mstr_valid_q | axi_slv_valid | axi_slv_sent_q | dbg_cmd_valid | dma_dbg_cmd_done | dma_dbg_cmd_done_q | (|fifo_valid[DEPTH-1:0]) | wrbuf_vld | rdbuf_vld | dec_tlu_stall_dma | clk_override);\n', '\n', '   rvoclkhdr dma_buffer_c1cgc ( .en(dma_buffer_c1_clken), .l1clk(dma_buffer_c1_clk), .* );\n', '   rvoclkhdr dma_free_cgc (.en(dma_free_clken), .l1clk(dma_free_clk), .*);\n', '\n', '`ifndef RV_FPGA_OPTIMIZE\n', '   rvclkhdr dma_bus_cgc (.en(dma_bus_clk_en), .l1clk(dma_bus_clk), .*);  // ifndef FPGA_OPTIMIZE\n', '`endif\n', '\n', ""   rvdffsc_fpga  #(1)  wrbuf_vldff     (.din(1'b1), .clear(wrbuf_rst),      .dout(wrbuf_vld),      .en(wrbuf_en),      .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n"", ""   rvdffsc_fpga  #(1)  wrbuf_data_vldff(.din(1'b1), .clear(wrbuf_data_rst), .dout(wrbuf_data_vld), .en(wrbuf_data_en), .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n"", ""   rvdffsc_fpga  #(1)  rdbuf_vldff     (.din(1'b1), .clear(rdbuf_rst),      .dout(rdbuf_vld),      .en(rdbuf_en),      .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n"", '\n', '\n', '   rvdff_fpga  #(1)  fifo_full_bus_ff     (.din(fifo_full_spec),                .dout(fifo_full_spec_bus),                        .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n', '   rvdff_fpga  #(1)  dbg_dma_bubble_ff    (.din(dbg_dma_bubble),                .dout(dbg_dma_bubble_bus),                        .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n', '   rvdff_fpga  #(1)  dec_tlu_stall_dma_ff (.din(dec_tlu_stall_dma),             .dout(dec_tlu_stall_dma_bus),                     .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n', ""   rvdffs_fpga #(1) wrbuf_postedff        (.din(1'b0),                          .dout(wrbuf_posted),               .en(wrbuf_en), .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n"", '   rvdffs_fpga #(DMA_BUS_TAG) wrbuf_tagff (.din(dma_axi_awid[DMA_BUS_TAG-1:0]), .dout(wrbuf_tag[DMA_BUS_TAG-1:0]), .en(wrbuf_en), .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n', '   rvdffs_fpga #(3) wrbuf_sizeff          (.din(dma_axi_awsize[2:0]),           .dout(wrbuf_size[2:0]),            .en(wrbuf_en), .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n', '   rvdffs_fpga #(8) wrbuf_byteenff        (.din(dma_axi_wstrb[7:0]),            .dout(wrbuf_byteen[7:0]),     .en(wrbuf_data_en), .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n', '   rvdffs_fpga #(DMA_BUS_TAG) rdbuf_tagff (.din(dma_axi_arid[DMA_BUS_TAG-1:0]), .dout(rdbuf_tag[DMA_BUS_TAG-1:0]), .en(rdbuf_en), .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n', '   rvdffs_fpga #(3) rdbuf_sizeff          (.din(dma_axi_arsize[2:0]),           .dout(rdbuf_size[2:0]),            .en(rdbuf_en), .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n', '   rvdffs_fpga #(1) mstr_prtyff           (.din(axi_mstr_prty_in),              .dout(axi_mstr_priority),  .en(axi_mstr_prty_en), .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n', '\n', '   rvdff_fpga #(1) axi_mstr_validff       ( .din(axi_mstr_valid), .dout(axi_mstr_valid_q), .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n', '   rvdff_fpga #(1) axi_slv_sentff         ( .din(axi_slv_sent),   .dout(axi_slv_sent_q),   .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n', '\n', '\n', '   rvdffe   #(32) wrbuf_addrff(.din(dma_axi_awaddr[31:0]), .dout(wrbuf_addr[31:0]), .en(wrbuf_en & dma_bus_clk_en),      .*);\n', '   rvdffe   #(64) wrbuf_dataff(.din(dma_axi_wdata[63:0]),  .dout(wrbuf_data[63:0]), .en(wrbuf_data_en & dma_bus_clk_en), .*);\n', '   rvdffe   #(32) rdbuf_addrff(.din(dma_axi_araddr[31:0]), .dout(rdbuf_addr[31:0]), .en(rdbuf_en & dma_bus_clk_en),      .*);\n', '\n', '   // Write channel buffer\n', '   assign wrbuf_en       = dma_axi_awvalid & dma_axi_awready;\n', '   assign wrbuf_data_en  = dma_axi_wvalid & dma_axi_wready;\n', '   assign wrbuf_cmd_sent = axi_mstr_valid & axi_mstr_write;\n', '   assign wrbuf_rst      = wrbuf_cmd_sent & ~wrbuf_en;\n', '   assign wrbuf_data_rst = wrbuf_cmd_sent & ~wrbuf_data_en;\n', '\n', '   // Read channel buffer\n', '   assign rdbuf_en    = dma_axi_arvalid & dma_axi_arready;\n', '   assign rdbuf_cmd_sent = axi_mstr_valid & ~axi_mstr_write & dma_fifo_ready;\n', '   assign rdbuf_rst   = rdbuf_cmd_sent & ~rdbuf_en;\n', '\n', '\n', '   assign dma_axi_awready = ~(wrbuf_vld & ~wrbuf_cmd_sent);\n', '   assign dma_axi_wready  = ~(wrbuf_data_vld & ~wrbuf_cmd_sent);\n', '   assign dma_axi_arready = ~(rdbuf_vld & ~rdbuf_cmd_sent);\n', '\n', '   //Generate a single request from read/write channel\n', '   assign axi_mstr_valid                  = ((wrbuf_vld & wrbuf_data_vld) | rdbuf_vld) & dma_fifo_ready;\n', '   assign axi_mstr_tag[DMA_BUS_TAG-1:0]   = axi_mstr_sel ? wrbuf_tag[DMA_BUS_TAG-1:0] : rdbuf_tag[DMA_BUS_TAG-1:0];\n', '   assign axi_mstr_write                  = axi_mstr_sel;\n', '   assign axi_mstr_posted_write           = axi_mstr_sel & wrbuf_posted;\n', '   assign axi_mstr_addr[31:0]             = axi_mstr_sel ? wrbuf_addr[31:0] : rdbuf_addr[31:0];\n', '   assign axi_mstr_size[2:0]              = axi_mstr_sel ? wrbuf_size[2:0] : rdbuf_size[2:0];\n', '   assign axi_mstr_wdata[63:0]            = wrbuf_data[63:0];\n', '   assign axi_mstr_wstrb[7:0]             = wrbuf_byteen[7:0];\n', '\n', '   // Sel=1 -> write has higher priority\n', '   assign axi_mstr_sel     = (wrbuf_vld & wrbuf_data_vld & rdbuf_vld) ? axi_mstr_priority : (wrbuf_vld & wrbuf_data_vld);\n', '   assign axi_mstr_prty_in = ~axi_mstr_priority;\n', '   assign axi_mstr_prty_en = axi_mstr_valid;\n', '\n', '   assign axi_slv_valid                  = fifo_valid[RspPtr] & ~fifo_dbg[RspPtr] & fifo_done_bus[RspPtr];\n', '   assign axi_slv_tag[DMA_BUS_TAG-1:0]   = fifo_tag[RspPtr];\n', '   assign axi_slv_rdata[63:0]            = fifo_data[RspPtr];\n', '   assign axi_slv_write                  = fifo_write[RspPtr];\n', '   assign axi_slv_posted_write           = axi_slv_write & fifo_posted_write[RspPtr];\n', ""   assign axi_slv_error[1:0]             = fifo_error[RspPtr][0] ? 2'b10 : (fifo_error[RspPtr][1] ? 2'b11 : 2'b0);\n"", '\n', '\n', '   // AXI response channel signals\n', '   assign dma_axi_bvalid                  = axi_slv_valid & axi_slv_write;\n', '   assign dma_axi_bresp[1:0]              = axi_slv_error[1:0];\n', '   assign dma_axi_bid[DMA_BUS_TAG-1:0]    = axi_slv_tag[DMA_BUS_TAG-1:0];\n', '\n', '   assign dma_axi_rvalid                  = axi_slv_valid & ~axi_slv_write;\n', '   assign dma_axi_rresp[1:0]              = axi_slv_error;\n', '   assign dma_axi_rid[DMA_BUS_TAG-1:0]    = axi_slv_tag[DMA_BUS_TAG-1:0];\n', '   assign dma_axi_rdata[63:0]             = axi_slv_rdata[63:0];\n', ""   assign dma_axi_rlast                   = 1'b1;\n"", '\n', '   assign axi_slv_sent       = (dma_axi_bvalid & dma_axi_bready) | (dma_axi_rvalid & dma_axi_rready);\n', '   assign dma_slv_algn_err   = fifo_error[RspPtr][1];\n', '\n', '`ifdef ASSERT_ON\n', '\n', ""   //assert_nack_count:   assert #0 (dma_nack_count[2:0] < 3'h4);\n"", '\n', '   for (genvar i=0; i<DEPTH; i++) begin\n', '      //assert_picm_rspdone_and_novalid: assert #0 (~fifo_rsp_done[i] | fifo_valid[i]);\n', '      assert_done_and_novalid: assert #0 (~fifo_done[i] | fifo_valid[i]);\n', '   end\n', '\n', '   // Assertion to check AXI write address is aligned to size\n', '   property dma_axi_write_trxn_aligned;\n', ""     @(posedge dma_bus_clk) dma_axi_awvalid  |-> ((dma_axi_awsize[2:0] == 3'h0)                                  |\n"", ""                                                  ((dma_axi_awsize[2:0] == 3'h1) & (dma_axi_awaddr[0] == 1'b0))   |\n"", ""                                                  ((dma_axi_awsize[2:0] == 3'h2) & (dma_axi_awaddr[1:0] == 2'b0)) |\n"", ""                                                  ((dma_axi_awsize[2:0] == 3'h3) & (dma_axi_awaddr[2:0] == 3'b0)));\n"", '   endproperty\n', '  // assert_dma_write_trxn_aligned: assert property (dma_axi_write_trxn_aligned) else\n', '  //   $display(""Assertion dma_axi_write_trxn_aligned failed: dma_axi_awvalid=1\'b%b, dma_axi_awsize=3\'h%h, dma_axi_awaddr=32\'h%h"",dma_axi_awvalid, dma_axi_awsize[2:0], dma_axi_awaddr[31:0]);\n', '\n', '   // Assertion to check AXI read address is aligned to size\n', '   property dma_axi_read_trxn_aligned;\n', ""     @(posedge dma_bus_clk) dma_axi_arvalid  |-> ((dma_axi_arsize[2:0] == 3'h0)                                  |\n"", ""                                                  ((dma_axi_arsize[2:0] == 3'h1) & (dma_axi_araddr[0] == 1'b0))   |\n"", ""                                                  ((dma_axi_arsize[2:0] == 3'h2) & (dma_axi_araddr[1:0] == 2'b0)) |\n"", ""                                                  ((dma_axi_arsize[2:0] == 3'h3) & (dma_axi_araddr[2:0] == 3'b0)));\n"", '   endproperty\n', '  // assert_dma_read_trxn_aligned: assert property (dma_axi_read_trxn_aligned) else\n', '  //   $display(""Assertion dma_axi_read_trxn_aligned failed: dma_axi_arvalid=1\'b%b, dma_axi_arsize=3\'h%h, dma_axi_araddr=32\'h%h"",dma_axi_arvalid, dma_axi_arsize[2:0], dma_axi_araddr[31:0]);\n', '\n', '   // Assertion to check write size is 8 byte or less\n', '   property dma_axi_awsize_check;\n', ""     @(posedge dma_bus_clk) disable iff(~rst_l) (dma_axi_awvalid & dma_axi_awready) |-> (dma_axi_awsize[2] == 1'b0);\n"", '   endproperty\n', '   assert_dma_axi_awsize_check: assert property (dma_axi_awsize_check) else\n', '      $display(""DMA AXI awsize is illegal. Size greater than 8B not supported"");\n', '\n', '   // Assertion to check there are no burst commands\n', '   property dma_axi_awlen_check;\n', ""     @(posedge dma_bus_clk) disable iff(~rst_l) (dma_axi_awvalid & dma_axi_awready) |-> (dma_axi_awlen[7:0] == 8'b0);\n"", '   endproperty\n', '   assert_dma_axi_awlen_check: assert property (dma_axi_awlen_check) else\n', '      $display(""DMA AXI awlen is illegal. Length greater than 0 not supported"");\n', '\n', '   // Assertion to check write size is 8 byte or less\n', '   property dma_axi_arsize_check;\n', ""     @(posedge dma_bus_clk) disable iff(~rst_l) (dma_axi_arvalid & dma_axi_arready) |-> (dma_axi_arsize[2] == 1'b0);\n"", '   endproperty\n', '   assert_dma_axi_arsize_check: assert property (dma_axi_arsize_check) else\n', '      $display(""DMA AXI arsize is illegal, Size bigger than 8B not supported"");\n', '\n', '   // Assertion to check there are no burst commands\n', '   property dma_axi_arlen_check;\n', ""     @(posedge dma_bus_clk) disable iff(~rst_l) (dma_axi_arvalid & dma_axi_arready) |-> (dma_axi_arlen[7:0] == 8'b0);\n"", '   endproperty\n', '   assert_dma_axi_arlen_check: assert property (dma_axi_arlen_check) else\n', '      $display(""DMA AXI arlen greater than 0 not supported."");\n', '\n', '   // Assertion to check cmd valid stays stable during entire bus clock\n', '   property dma_axi_awvalid_stable;\n', '      @(posedge clk) disable iff(~rst_l) (dma_axi_awvalid != $past(dma_axi_awvalid)) |-> $past(dma_bus_clk_en);\n', '   endproperty\n', '   assert_dma_axi_awvalid_stable: assert property (dma_axi_awvalid_stable) else\n', '      $display(""DMA AXI  awvalid changed in middle of bus clock"");\n', '\n', '   // Assertion to check cmd ready stays stable during entire bus clock\n', '   property dma_axi_awready_stable;\n', '      @(posedge clk) disable iff(~rst_l) (dma_axi_awready != $past(dma_axi_awready)) |-> $past(dma_bus_clk_en);\n', '   endproperty\n', '   assert_dma_axi_awready_stable: assert property (dma_axi_awready_stable) else\n', '      $display(""DMA AXI  awready changed in middle of bus clock"");\n', '\n', '   // Assertion to check cmd tag stays stable during entire bus clock\n', '   property dma_axi_awid_stable;\n', '      @(posedge clk) disable iff(~rst_l) (dma_axi_awvalid & (dma_axi_awid[DMA_BUS_TAG-1:0] != $past(dma_axi_awid[DMA_BUS_TAG-1:0]))) |-> $past(dma_bus_clk_en);\n', '   endproperty\n', '   assert_dma_axi_awid_stable: assert property (dma_axi_awid_stable) else\n', '      $display(""DMA AXI awid changed in middle of bus clock"");\n', '\n', '   // Assertion to check cmd addr stays stable during entire bus clock\n', '   property dma_axi_awaddr_stable;\n', '      @(posedge clk) disable iff(~rst_l) (dma_axi_awvalid & (dma_axi_awaddr[31:0] != $past(dma_axi_awaddr[31:0]))) |-> $past(dma_bus_clk_en);\n', '   endproperty\n', '   assert_dma_axi_awaddr_stable: assert property (dma_axi_awaddr_stable) else\n', '      $display(""DMA AXI awaddr changed in middle of bus clock"");\n', '\n', '   // Assertion to check cmd length stays stable during entire bus clock\n', '   property dma_axi_awsize_stable;\n', '      @(posedge clk) disable iff(~rst_l) (dma_axi_awvalid & (dma_axi_awsize[2:0] != $past(dma_axi_awsize[2:0]))) |-> $past(dma_bus_clk_en);\n', '   endproperty\n', '   assert_dma_axi_awsize_stable: assert property (dma_axi_awsize_stable) else\n', '      $display(""DMA AXI awsize changed in middle of bus clock"");\n', '\n', '   // Assertion to check cmd valid stays stable during entire bus clock\n', '   property dma_axi_wvalid_stable;\n', '      @(posedge clk) disable iff(~rst_l) (dma_axi_wvalid != $past(dma_axi_wvalid)) |-> $past(dma_bus_clk_en);\n', '   endproperty\n', '   assert_dma_axi_wvalid_stable: assert property (dma_axi_wvalid_stable) else\n', '      $display(""DMA AXI  wvalid changed in middle of bus clock"");\n', '\n', '   // Assertion to check cmd ready stays stable during entire bus clock\n', '   property dma_axi_wready_stable;\n', '      @(posedge clk) disable iff(~rst_l) (dma_axi_wready != $past(dma_axi_wready)) |-> $past(dma_bus_clk_en);\n', '   endproperty\n', '   assert_dma_axi_wready_stable: assert property (dma_axi_wready_stable) else\n', '      $display(""DMA AXI  wready changed in middle of bus clock"");\n', '\n', '   // Assertion to check cmd wbe stays stable during entire bus clock\n', '   property dma_axi_wstrb_stable;\n', '      @(posedge clk) disable iff(~rst_l) (dma_axi_wvalid & (dma_axi_wstrb[7:0] != $past(dma_axi_wstrb[7:0]))) |-> $past(dma_bus_clk_en);\n', '   endproperty\n', '   assert_dma_axi_wstrb_stable: assert property (dma_axi_wstrb_stable) else\n', '      $display(""DMA AXI wstrb changed in middle of bus clock"");\n', '\n', '   // Assertion to check cmd wdata stays stable during entire bus clock\n', '   property dma_axi_wdata_stable;\n', '      @(posedge clk) disable iff(~rst_l) (dma_axi_wvalid & (dma_axi_wdata[63:0] != $past(dma_axi_wdata[63:0]))) |-> $past(dma_bus_clk_en);\n', '   endproperty\n', '   assert_dma_axi_wdata_stable: assert property (dma_axi_wdata_stable) else\n', '      $display(""DMA AXI wdata changed in middle of bus clock"");\n', '\n', '   // Assertion to check cmd valid stays stable during entire bus clock\n', '   property dma_axi_arvalid_stable;\n', '      @(posedge clk) disable iff(~rst_l) (dma_axi_arvalid != $past(dma_axi_arvalid)) |-> $past(dma_bus_clk_en);\n', '   endproperty\n', '   assert_dma_axi_arvalid_stable: assert property (dma_axi_arvalid_stable) else\n', '      $display(""DMA AXI  arvalid changed in middle of bus clock"");\n', '\n', '   // Assertion to check cmd ready stays stable during entire bus clock\n', '   property dma_axi_arready_stable;\n', '      @(posedge clk) disable iff(~rst_l) (dma_axi_arready != $past(dma_axi_arready)) |-> $past(dma_bus_clk_en);\n', '   endproperty\n', '   assert_dma_axi_arready_stable: assert property (dma_axi_arready_stable) else\n', '      $display(""DMA AXI  arready changed in middle of bus clock"");\n', '\n', '   // Assertion to check cmd tag stays stable during entire bus clock\n', '   property dma_axi_arid_stable;\n', '      @(posedge clk) disable iff(~rst_l) (dma_axi_arvalid & (dma_axi_arid[DMA_BUS_TAG-1:0] != $past(dma_axi_arid[DMA_BUS_TAG-1:0]))) |-> $past(dma_bus_clk_en);\n', '   endproperty\n', '   assert_dma_axi_arid_stable: assert property (dma_axi_arid_stable) else\n', '      $display(""DMA AXI arid changed in middle of bus clock"");\n', '\n', '   // Assertion to check cmd addr stays stable during entire bus clock\n', '   property dma_axi_araddr_stable;\n', '      @(posedge clk) disable iff(~rst_l) (dma_axi_arvalid & (dma_axi_araddr[31:0] != $past(dma_axi_araddr[31:0]))) |-> $past(dma_bus_clk_en);\n', '   endproperty\n', '   assert_dma_axi_araddr_stable: assert property (dma_axi_araddr_stable) else\n', '      $display(""DMA AXI araddr changed in middle of bus clock"");\n', '\n', '   // Assertion to check cmd length stays stable during entire bus clock\n', '   property dma_axi_arsize_stable;\n', '      @(posedge clk) disable iff(~rst_l) (dma_axi_arvalid & (dma_axi_arsize[2:0] != $past(dma_axi_arsize[2:0]))) |-> $past(dma_bus_clk_en);\n', '   endproperty\n', '   assert_dma_axi_arsize_stable: assert property (dma_axi_arsize_stable) else\n', '      $display(""DMA AXI arsize changed in middle of bus clock"");\n', '\n', '   //Assertion to check write rsp valid stays stable during entire bus clock\n', '   property dma_axi_bvalid_stable;\n', '      @(posedge clk) disable iff(~rst_l) (dma_axi_bvalid != $past(dma_axi_bvalid)) |-> $past(dma_bus_clk_en);\n', '   endproperty\n', '   assert_dma_axi_bvalid_stable: assert property (dma_axi_bvalid_stable) else\n', '      $display(""DMA AXI bvalid changed in middle of bus clock"");\n', '\n', '   // //Assertion to check write rsp ready stays stable during entire bus clock\n', '   // property dma_axi_bready_stable;\n', '   //    @(posedge clk) (dma_axi_bready != $past(dma_axi_bready)) |-> $past(dma_bus_clk_en);\n', '   // endproperty\n', '   // assert_dma_axi_bready_stable: assert property (dma_axi_bready_stable) else\n', '   //    $display(""DMA AXI bready changed in middle of bus clock"");\n', '\n', '   //Assertion to check write rsp stays stable during entire bus clock\n', '   property dma_axi_bresp_stable;\n', '      @(posedge clk) disable iff(~rst_l) (dma_axi_bvalid & (dma_axi_bresp[1:0] != $past(dma_axi_bresp[1:0]))) |-> $past(dma_bus_clk_en);\n', '   endproperty\n', '   assert_dma_axi_bresp_stable: assert property (dma_axi_bresp_stable) else\n', '      $display(""DMA AXI bvalid changed in middle of bus clock"");\n', '\n', '   // Assertion to check write rsp tag stays stable during entire bus clock\n', '   property dma_axi_bid_stable;\n', '      @(posedge clk) disable iff(~rst_l) (dma_axi_bvalid & (dma_axi_bid[DMA_BUS_TAG-1:0] != $past(dma_axi_bid[DMA_BUS_TAG-1:0]))) |-> $past(dma_bus_clk_en);\n', '   endproperty\n', '   assert_dma_axi_bid_stable: assert property (dma_axi_bid_stable) else\n', '      $display(""DMA AXI bid changed in middle of bus clock"");\n', '\n', '   //Assertion to check write rsp valid stays stable during entire bus clock\n', '   property dma_axi_rvalid_stable;\n', '      @(posedge clk) disable iff(~rst_l) (dma_axi_rvalid != $past(dma_axi_rvalid)) |-> $past(dma_bus_clk_en);\n', '   endproperty\n', '   assert_dma_axi_rvalid_stable: assert property (dma_axi_rvalid_stable) else\n', '      $display(""DMA AXI bvalid changed in middle of bus clock"");\n', '\n', '   // //Assertion to check write rsp ready stays stable during entire bus clock\n', '   // property dma_axi_rready_stable;\n', '   //    @(posedge clk) (dma_axi_rready != $past(dma_axi_rready)) |-> $past(dma_bus_clk_en);\n', '   // endproperty\n', '   // assert_dma_axi_rready_stable: assert property (dma_axi_rready_stable) else\n', '   //    $display(""DMA AXI bready changed in middle of bus clock"");\n', '\n', '   //Assertion to check write rsp stays stable during entire bus clock\n', '   property dma_axi_rresp_stable;\n', '      @(posedge clk) disable iff(~rst_l) (dma_axi_rvalid & (dma_axi_rresp[1:0] != $past(dma_axi_rresp[1:0]))) |-> $past(dma_bus_clk_en);\n', '   endproperty\n', '   assert_dma_axi_rresp_stable: assert property (dma_axi_rresp_stable) else\n', '      $display(""DMA AXI bvalid changed in middle of bus clock"");\n', '\n', '   // Assertion to check write rsp tag stays stable during entire bus clock\n', '   property dma_axi_rid_stable;\n', '      @(posedge clk) disable iff(~rst_l) (dma_axi_rvalid & (dma_axi_rid[DMA_BUS_TAG-1:0] != $past(dma_axi_rid[DMA_BUS_TAG-1:0]))) |-> $past(dma_bus_clk_en);\n', '   endproperty\n', '   assert_dma_axi_rid_stable: assert property (dma_axi_rid_stable) else\n', '      $display(""DMA AXI bid changed in middle of bus clock"");\n', '\n', '`endif\n', '\n', 'endmodule // dma_ctrl\n']"
"['// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '// \n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '// \n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '// \n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '//------------------------------------------------------------------------------------\n', '//                This module Synchronizes the signals between JTAG (TCK) and\n', '//                processor (clk)\n', '//\n', '//-------------------------------------------------------------------------------------\n', '\n', 'module dmi_jtag_to_core_sync (\n', '   // JTAG signals\n', '   input                       rd_en,       // 1 bit  Read Enable\n', '   input                       wr_en,       // 1 bit  Write enable\n', '\n', '\n', '   // Processor Signals\n', '   input                       rst_n,       // Core clock\n', '   input                       clk,         // Core reset\n', '\n', '   output                      reg_en,      // 1 bit  Write interface bit to Processor\n', '   output                      reg_wr_en    // 1 bit  Write enable to Processor\n', ');\n', '\n', '\n', '  \n', '  wire                         c_rd_en;\n', '  wire                         c_wr_en;\n', '   \n', '\n', '  //Assign statements\n', '\n', '  assign reg_en = c_wr_en | c_rd_en;\n', '  assign reg_wr_en = c_wr_en;\n', '\n', '  reg [2:0] rden, wren;\n', '\n', '// synchronizers  \n', 'always @ ( posedge clk or negedge rst_n) begin\n', '    if(!rst_n) begin\n', ""        rden <= 3'b0;\n"", ""        wren <= 3'b0;\n"", '    end\n', '    else begin\n', '        rden <= {rden[1:0], rd_en};\n', '        wren <= {wren[1:0], wr_en};\n', '    end\n', 'end\n', '\n', 'assign c_rd_en = rden[1] & ~rden[2];\n', 'assign c_wr_en = wren[1] & ~wren[2];\n', ' \n', '\n', '\n', 'endmodule\n']"
"['// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '// \n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '// \n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '// \n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '//------------------------------------------------------------------------------------\n', '//\n', '//  Copyright Western Digital, 2019\n', '//  Owner : Anusha Narayanamoorthy\n', '//  Description:  \n', '//                Wrapper module for JTAG_TAP and DMI synchronizer\n', '//\n', '//-------------------------------------------------------------------------------------\n', '\n', 'module dmi_wrapper(\n', '  // JTAG signals\n', '  input              trst_n,              // JTAG reset\n', '  input              tck,                 // JTAG clock\n', '  input              tms,                 // Test mode select   \n', '  input              tdi,                 // Test Data Input\n', '  output             tdo,                 // Test Data Output           \n', '  output             tdoEnable,           // Test Data Output enable             \n', '\n', '  // Processor Signals\n', '  input              core_rst_n,          // Core reset                  \n', '  input              core_clk,            // Core clock                  \n', '  input [31:1]       jtag_id,             // JTAG ID\n', '  input [31:0]       rd_data,             // 32 bit Read data from  Processor                       \n', '  output [31:0]      reg_wr_data,         // 32 bit Write data to Processor                      \n', '  output [6:0]       reg_wr_addr,         // 7 bit reg address to Processor                   \n', '  output             reg_en,              // 1 bit  Read enable to Processor                                    \n', '  output             reg_wr_en,           // 1 bit  Write enable to Processor \n', '  output             dmi_hard_reset  \n', ');\n', '\n', '\n', '  \n', '\n', '\n', '  //Wire Declaration\n', '  wire                     rd_en;\n', '  wire                     wr_en;\n', '  wire                     dmireset;\n', '\n', ' \n', '  //jtag_tap instantiation\n', ' rvjtag_tap i_jtag_tap(\n', '   .trst(trst_n),                      // dedicated JTAG TRST (active low) pad signal or asynchronous active low power on reset\n', '   .tck(tck),                          // dedicated JTAG TCK pad signal\n', '   .tms(tms),                          // dedicated JTAG TMS pad signal\n', '   .tdi(tdi),                          // dedicated JTAG TDI pad signal\n', '   .tdo(tdo),                          // dedicated JTAG TDO pad signal\n', '   .tdoEnable(tdoEnable),              // enable for TDO pad\n', '   .wr_data(reg_wr_data),              // 32 bit Write data\n', '   .wr_addr(reg_wr_addr),              // 7 bit Write address\n', '   .rd_en(rd_en),                      // 1 bit  read enable\n', '   .wr_en(wr_en),                      // 1 bit  Write enable\n', '   .rd_data(rd_data),                  // 32 bit Read data\n', ""   .rd_status(2'b0),\n"", ""   .idle(3'h0),                         // no need to wait to sample data\n"", ""   .dmi_stat(2'b0),                     // no need to wait or error possible\n"", ""   .version(4'h1),                      // debug spec 0.13 compliant\n"", '   .jtag_id(jtag_id),\n', '   .dmi_hard_reset(dmi_hard_reset),\n', '   .dmi_reset(dmireset)\n', ');\n', '\n', '\n', '  // dmi_jtag_to_core_sync instantiation\n', '  dmi_jtag_to_core_sync i_dmi_jtag_to_core_sync(\n', '    .wr_en(wr_en),                          // 1 bit  Write enable\n', '    .rd_en(rd_en),                          // 1 bit  Read enable\n', '\n', '    .rst_n(core_rst_n),\n', '    .clk(core_clk),\n', '    .reg_en(reg_en),                          // 1 bit  Write interface bit\n', '    .reg_wr_en(reg_wr_en)                          // 1 bit  Write enable\n', '  );\n', '\n', 'endmodule\n']"
"['// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '\n', '\n', 'module exu\n', '   import veer_types::*;\n', '(\n', '\n', '   input logic clk,                                                    // Top level clock\n', '   input logic active_clk,                                             // Level 1 active clock\n', '   input logic clk_override,                                           // Override multiply clock enables\n', '   input logic rst_l,                                                  // Reset\n', '   input logic scan_mode,                                              // Scan control\n', '   input logic lsu_freeze_dc3,                                         // Freeze pipe from D to DC3\n', '\n', '   input logic  dec_tlu_fast_div_disable,                              // Disable divide small number optimization\n', '\n', '   input logic [4:2] dec_i0_data_en,                                   // Slot I0 clock enable {e1, e2, e3    }, one cycle pulse\n', '   input logic [4:1] dec_i0_ctl_en,                                    // Slot I0 clock enable {e1, e2, e3, e4}, two cycle pulse\n', '   input logic [4:2] dec_i1_data_en,                                   // Slot I1 clock enable {e1, e2, e3    }, one cycle pulse\n', '   input logic [4:1] dec_i1_ctl_en,                                    // Slot I1 clock enable {e1, e2, e3, e4}, two cycle pulse\n', '\n', '   input logic dec_debug_wdata_rs1_d,                                  // Debug select to primary I0 RS1\n', '\n', '   input logic [31:0] dbg_cmd_wrdata,                                  // Debug data   to primary I0 RS1\n', '\n', '   input logic [31:0] lsu_result_dc3,                                  // Load result\n', '\n', '   input predict_pkt_t  i0_predict_p_d,                                // DEC branch predict packet\n', '   input predict_pkt_t  i1_predict_p_d,                                // DEC branch predict packet\n', '\n', '   input logic        dec_i0_rs1_bypass_en_e2,                         // DEC bypass bus select for E2 stage\n', '   input logic        dec_i0_rs2_bypass_en_e2,                         // DEC bypass bus select for E2 stage\n', '   input logic        dec_i1_rs1_bypass_en_e2,                         // DEC bypass bus select for E2 stage\n', '   input logic        dec_i1_rs2_bypass_en_e2,                         // DEC bypass bus select for E2 stage\n', '   input logic [31:0] i0_rs1_bypass_data_e2,                           // DEC bypass bus\n', '   input logic [31:0] i0_rs2_bypass_data_e2,                           // DEC bypass bus\n', '   input logic [31:0] i1_rs1_bypass_data_e2,                           // DEC bypass bus\n', '   input logic [31:0] i1_rs2_bypass_data_e2,                           // DEC bypass bus\n', '\n', '   input logic        dec_i0_rs1_bypass_en_e3,                         // DEC bypass bus select for E3 stage\n', '   input logic        dec_i0_rs2_bypass_en_e3,                         // DEC bypass bus select for E3 stage\n', '   input logic        dec_i1_rs1_bypass_en_e3,                         // DEC bypass bus select for E3 stage\n', '   input logic        dec_i1_rs2_bypass_en_e3,                         // DEC bypass bus select for E3 stage\n', '   input logic [31:0] i0_rs1_bypass_data_e3,                           // DEC bypass bus\n', '   input logic [31:0] i0_rs2_bypass_data_e3,                           // DEC bypass bus\n', '   input logic [31:0] i1_rs1_bypass_data_e3,                           // DEC bypass bus\n', '   input logic [31:0] i1_rs2_bypass_data_e3,                           // DEC bypass bus\n', '\n', '   input logic        dec_i0_sec_decode_e3,                            // Secondary ALU valid\n', '   input logic        dec_i1_sec_decode_e3,                            // Secondary ALU valid\n', '   input logic [31:1] dec_i0_pc_e3,                                    // Secondary ALU PC\n', '   input logic [31:1] dec_i1_pc_e3,                                    // Secondary ALU PC\n', '\n', '   input logic [31:1] pred_correct_npc_e2,                             // DEC NPC for correctly predicted branch\n', '\n', '   input logic        dec_i1_valid_e1,                                 // I1 valid E1\n', '\n', '   input logic        dec_i0_mul_d,                                    // Select for Multiply GPR value\n', '   input logic        dec_i1_mul_d,                                    // Select for Multiply GPR value\n', '\n', '   input logic        dec_i0_div_d,                                    // Select for Divide GPR value\n', '   input logic        dec_i1_div_d,                                    // Select for Divide GPR value\n', '\n', '   input logic [31:0] gpr_i0_rs1_d,                                    // DEC data gpr\n', '   input logic [31:0] gpr_i0_rs2_d,                                    // DEC data gpr\n', '   input logic [31:0] dec_i0_immed_d,                                  // DEC data immediate\n', '\n', '   input logic [31:0] gpr_i1_rs1_d,                                    // DEC data gpr\n', '   input logic [31:0] gpr_i1_rs2_d,                                    // DEC data gpr\n', '   input logic [31:0] dec_i1_immed_d,                                  // DEC data immediate\n', '\n', '   input logic [31:0] i0_rs1_bypass_data_d,                            // DEC bypass data\n', '   input logic [31:0] i0_rs2_bypass_data_d,                            // DEC bypass data\n', '   input logic [31:0] i1_rs1_bypass_data_d,                            // DEC bypass data\n', '   input logic [31:0] i1_rs2_bypass_data_d,                            // DEC bypass data\n', '\n', '   input logic [12:1] dec_i0_br_immed_d,                               // Branch immediate\n', '   input logic [12:1] dec_i1_br_immed_d,                               // Branch immediate\n', '\n', '   input         alu_pkt_t i0_ap,                                      // DEC alu {valid,predecodes}\n', '   input         alu_pkt_t i1_ap,                                      // DEC alu {valid,predecodes}\n', '\n', '   input logic   dec_i0_alu_decode_d,                                  // Valid to Primary ALU\n', '   input logic   dec_i1_alu_decode_d,                                  // Valid to Primary ALU\n', '\n', '   input logic   dec_i0_select_pc_d,                                   // PC select to RS1\n', '   input logic   dec_i1_select_pc_d,                                   // PC select to RS1\n', '\n', '   input logic [31:1] dec_i0_pc_d, dec_i1_pc_d,                        // Instruction PC\n', '\n', '   input logic  dec_i0_rs1_bypass_en_d,                                // DEC bypass select\n', '   input logic  dec_i0_rs2_bypass_en_d,                                // DEC bypass select\n', '   input logic  dec_i1_rs1_bypass_en_d,                                // DEC bypass select\n', '   input logic  dec_i1_rs2_bypass_en_d,                                // DEC bypass select\n', '\n', '   input logic        dec_tlu_flush_lower_wb,                          // Flush divide and secondary ALUs\n', '   input logic [31:1] dec_tlu_flush_path_wb,                           // Redirect target\n', '\n', '   input logic dec_tlu_i0_valid_e4,                                    // Valid for GHR\n', '   input logic dec_tlu_i1_valid_e4,                                    // Valid for GHR\n', '\n', '   output logic [31:0] exu_i0_result_e1,                               // Primary ALU result to DEC\n', '   output logic [31:0] exu_i1_result_e1,                               // Primary ALU result to DEC\n', '   output logic [31:1] exu_i0_pc_e1,                                   // Primary PC  result to DEC\n', '   output logic [31:1] exu_i1_pc_e1,                                   // Primary PC  result to DEC\n', '\n', '\n', '   output logic [31:0] exu_i0_result_e4,                               // Secondary ALU result\n', '   output logic [31:0] exu_i1_result_e4,                               // Secondary ALU result\n', '\n', '\n', '   output logic        exu_i0_flush_final,                             // I0 flush to DEC\n', '   output logic        exu_i1_flush_final,                             // I1 flush to DEC\n', '\n', '\n', '\n', '   input mul_pkt_t  mul_p,                                             // DEC {valid, operand signs, low, operand bypass}\n', '\n', '   input div_pkt_t  div_p,                                             // DEC {valid, unsigned, rem}\n', '\n', '   input logic   dec_i0_lsu_d,                                         // Bypass control for LSU operand bus\n', '   input logic   dec_i1_lsu_d,                                         // Bypass control for LSU operand bus\n', '\n', '   input logic   dec_csr_ren_d,                                        // Clear I0 RS1 primary\n', '\n', '   output logic [31:0] exu_lsu_rs1_d,                                  // LSU operand\n', '   output logic [31:0] exu_lsu_rs2_d,                                  // LSU operand\n', '\n', '   output logic [31:0] exu_csr_rs1_e1,                                 // RS1 source for a CSR instruction\n', '\n', '   output logic         exu_flush_final,                               // Pipe is being flushed this cycle\n', '   output logic [31:1]  exu_flush_path_final,                          // Target for the oldest flush source\n', '\n', '   output logic [31:0] exu_mul_result_e3,                              // Multiply result\n', '\n', '   output logic [31:0]  exu_div_result,                                // Divide result\n', '   output logic exu_div_finish,                                        // Divide is finished\n', '   output logic exu_div_stall,                                         // Divide is running\n', '   output logic [31:1] exu_npc_e4,                                     // Divide NPC\n', '\n', '   output logic exu_i0_flush_lower_e4,                                 // to TLU - lower branch flush\n', '   output logic exu_i1_flush_lower_e4,                                 // to TLU - lower branch flush\n', '   output logic [31:1] exu_i0_flush_path_e4,                           // to TLU - lower branch flush path\n', '   output logic [31:1] exu_i1_flush_path_e4,                           // to TLU - lower branch flush path\n', '\n', '   output predict_pkt_t exu_mp_pkt,                                    // Mispredict branch packet\n', '\n', '   output logic [`RV_BHT_GHR_RANGE]  exu_mp_eghr,                      // Mispredict global history\n', '\n', '   output logic [1:0]  exu_i0_br_hist_e4,                              // to DEC  I0 branch history\n', '   output logic [1:0]  exu_i0_br_bank_e4,                              // to DEC  I0 branch bank\n', '   output logic        exu_i0_br_error_e4,                             // to DEC  I0 branch error\n', '   output logic        exu_i0_br_start_error_e4,                       // to DEC  I0 branch start error\n', '   output logic [`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] exu_i0_br_index_e4,  // to DEC  I0 branch index\n', '   output logic        exu_i0_br_valid_e4,                             // to DEC  I0 branch valid\n', '   output logic        exu_i0_br_mp_e4,                                // to DEC  I0 branch mispredict\n', '`ifdef RV_BTB_48\n', '   output logic [1:0]  exu_i0_br_way_e4,                               // to DEC  I0 branch way\n', '`else\n', '   output logic        exu_i0_br_way_e4,                               // to DEC  I0 branch way\n', '`endif\n', '   output logic        exu_i0_br_middle_e4,                            // to DEC  I0 branch middle\n', '   output logic [`RV_BHT_GHR_RANGE]  exu_i0_br_fghr_e4,                // to DEC  I0 branch fghr\n', '   output logic        exu_i0_br_ret_e4,                               // to DEC  I0 branch return\n', '   output logic        exu_i0_br_call_e4,                              // to DEC  I0 branch call\n', '\n', '   output logic [1:0]  exu_i1_br_hist_e4,                              // to DEC  I1 branch history\n', '   output logic [1:0]  exu_i1_br_bank_e4,                              // to DEC  I1 branch bank\n', '   output logic        exu_i1_br_error_e4,                             // to DEC  I1 branch error\n', '   output logic        exu_i1_br_start_error_e4,                       // to DEC  I1 branch start error\n', '   output logic [`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] exu_i1_br_index_e4,  // to DEC  I1 branch index\n', '   output logic        exu_i1_br_valid_e4,                             // to DEC  I1 branch valid\n', '   output logic        exu_i1_br_mp_e4,                                // to DEC  I1 branch mispredict\n', '`ifdef RV_BTB_48\n', '   output logic [1:0]  exu_i1_br_way_e4,                               // to DEC  I1 branch way\n', '`else\n', '   output logic        exu_i1_br_way_e4,                               // to DEC  I1 branch way\n', '`endif\n', '   output logic        exu_i1_br_middle_e4,                            // to DEC  I1 branch middle\n', '   output logic [`RV_BHT_GHR_RANGE]  exu_i1_br_fghr_e4,                // to DEC  I1 branch fghr\n', '   output logic        exu_i1_br_ret_e4,                               // to DEC  I1 branch return\n', '   output logic        exu_i1_br_call_e4,                              // to DEC  I1 branch call\n', '   output logic        exu_flush_upper_e2,                             // flush upper, either i0 or i1\n', '\n', '   output rets_pkt_t exu_rets_e1_pkt,                                  // to IFU - I0+I1 {call, return, pc}\n', '   output rets_pkt_t exu_rets_e4_pkt,                                  // to IFU - I0+I1 {call, return, pc}\n', '\n', '   output logic exu_pmu_i0_br_misp,                                    // to PMU - I0 E4 branch mispredict\n', '   output logic exu_pmu_i0_br_ataken,                                  // to PMU - I0 E4 taken\n', '   output logic exu_pmu_i0_pc4,                                        // to PMU - I0 E4 PC\n', '   output logic exu_pmu_i1_br_misp,                                    // to PMU - I1 E4 branch mispredict\n', '   output logic exu_pmu_i1_br_ataken,                                  // to PMU - I1 E4 taken\n', '   output logic exu_pmu_i1_pc4                                         // to PMU - I1 E4 PC\n', '\n', '   );\n', '\n', '\n', '   logic [31:0] i0_rs1_d,i0_rs2_d,i1_rs1_d,i1_rs2_d;\n', '\n', '\n', '\n', '   logic        exu_i0_flush_upper_e1;\n', '   logic [31:1] exu_i0_flush_path_e1;\n', '\n', '   logic        exu_i1_flush_upper_e1;\n', '   logic [31:1] exu_i1_flush_path_e1;\n', '\n', '   logic [31:0] i0_rs1_final_d;\n', '\n', '   logic [31:1]  exu_flush_path_e2;\n', '   logic [31:0]  mul_rs1_d, mul_rs2_d;\n', '\n', '   logic [31:0]  div_rs1_d, div_rs2_d;\n', '\n', '   logic        i1_valid_e2;\n', '   logic [31:1] npc_e4;\n', '   logic [31:1] div_npc;\n', '\n', '   logic [31:0] i0_rs1_e1, i0_rs2_e1;\n', '   logic [31:0] i0_rs1_e2, i0_rs2_e2;\n', '   logic [31:0] i0_rs1_e3, i0_rs2_e3;\n', '   logic [12:1] i0_br_immed_e1, i0_br_immed_e2, i0_br_immed_e3;\n', '\n', '   logic [31:0] i1_rs1_e1, i1_rs2_e1;\n', '   logic [31:0] i1_rs1_e2, i1_rs2_e2;\n', '   logic [31:0] i1_rs1_e3, i1_rs2_e3;\n', '\n', '   logic [12:1] i1_br_immed_e1, i1_br_immed_e2, i1_br_immed_e3;\n', '\n', '   logic [31:0] i0_rs1_e2_final, i0_rs2_e2_final;\n', '   logic [31:0] i1_rs1_e2_final, i1_rs2_e2_final;\n', '   logic [31:0] i0_rs1_e3_final, i0_rs2_e3_final;\n', '   logic [31:0] i1_rs1_e3_final, i1_rs2_e3_final;\n', '   logic [31:1] i0_alu_pc_nc, i1_alu_pc_nc;\n', '   logic [31:1] exu_flush_path_e1;\n', '   logic        exu_i0_flush_upper_e2, exu_i1_flush_upper_e2;\n', '   logic        i1_valid_e3, i1_valid_e4;\n', '   logic [31:1] pred_correct_npc_e3, pred_correct_npc_e4;\n', '   logic                                  exu_i0_flush_upper_e3;\n', '   logic                                  exu_i0_flush_upper_e4;\n', '   logic        i1_pred_correct_upper_e1, i0_pred_correct_upper_e1;\n', '   logic        i1_pred_correct_upper_e2, i0_pred_correct_upper_e2;\n', '   logic        i1_pred_correct_upper_e3, i0_pred_correct_upper_e3;\n', '   logic        i1_pred_correct_upper_e4, i0_pred_correct_upper_e4;\n', '   logic        i1_pred_correct_lower_e4, i0_pred_correct_lower_e4;\n', '\n', '\n', '   logic        i1_valid_e4_eff;\n', '   logic        i1_sec_decode_e4, i0_sec_decode_e4;\n', '   logic        i1_pred_correct_e4_eff, i0_pred_correct_e4_eff;\n', '   logic [31:1] i1_flush_path_e4_eff, i0_flush_path_e4_eff;\n', '   logic [31:0] csr_rs1_in_d;\n', '   logic [31:1] i1_flush_path_upper_e2, i0_flush_path_upper_e2;\n', '   logic [31:1] i1_flush_path_upper_e3, i0_flush_path_upper_e3;\n', '   logic [31:1] i1_flush_path_upper_e4, i0_flush_path_upper_e4;\n', '\n', '   logic        div_valid_e1;\n', '   logic        div_finish_early;\n', '   logic        freeze;\n', '\n', '\n', '   alu_pkt_t i0_ap_e1, i0_ap_e2, i0_ap_e3, i0_ap_e4;\n', '   alu_pkt_t i1_ap_e1, i1_ap_e2, i1_ap_e3, i1_ap_e4;\n', '   assign freeze = lsu_freeze_dc3;\n', '\n', '   assign i0_rs1_d[31:0] = ({32{~dec_i0_rs1_bypass_en_d}} & ((dec_debug_wdata_rs1_d) ? dbg_cmd_wrdata[31:0] : gpr_i0_rs1_d[31:0])) |\n', ""                           ({32{~dec_i0_rs1_bypass_en_d   & dec_i0_select_pc_d}} & { dec_i0_pc_d[31:1], 1'b0}) |    // for jal's\n"", '                           ({32{ dec_i0_rs1_bypass_en_d}} & i0_rs1_bypass_data_d[31:0]);\n', '\n', '\n', '   assign i0_rs1_final_d[31:0] = ({32{~dec_csr_ren_d}} & i0_rs1_d[31:0]);\n', '\n', '   assign i0_rs2_d[31:0]       = ({32{~dec_i0_rs2_bypass_en_d}} & gpr_i0_rs2_d[31:0]) |\n', '                                 ({32{~dec_i0_rs2_bypass_en_d}} & dec_i0_immed_d[31:0]) |\n', '                                 ({32{ dec_i0_rs2_bypass_en_d}} & i0_rs2_bypass_data_d[31:0]);\n', '\n', '   assign i1_rs1_d[31:0]       = ({32{~dec_i1_rs1_bypass_en_d}} & gpr_i1_rs1_d[31:0]) |\n', ""                                 ({32{~dec_i1_rs1_bypass_en_d   & dec_i1_select_pc_d}} & { dec_i1_pc_d[31:1], 1'b0}) |  // pc orthogonal with rs1\n"", '                                 ({32{ dec_i1_rs1_bypass_en_d}} & i1_rs1_bypass_data_d[31:0]);\n', '\n', '   assign i1_rs2_d[31:0]       = ({32{~dec_i1_rs2_bypass_en_d}} & gpr_i1_rs2_d[31:0]) |\n', '                                 ({32{~dec_i1_rs2_bypass_en_d}} & dec_i1_immed_d[31:0]) |\n', '                                 ({32{ dec_i1_rs2_bypass_en_d}} & i1_rs2_bypass_data_d[31:0]);\n', '\n', '   assign exu_lsu_rs1_d[31:0]  = ({32{ ~dec_i0_rs1_bypass_en_d &  dec_i0_lsu_d               }} & gpr_i0_rs1_d[31:0]        ) |\n', '                                 ({32{ ~dec_i1_rs1_bypass_en_d & ~dec_i0_lsu_d & dec_i1_lsu_d}} & gpr_i1_rs1_d[31:0]        ) |\n', '                                 ({32{  dec_i0_rs1_bypass_en_d &  dec_i0_lsu_d               }} & i0_rs1_bypass_data_d[31:0]) |\n', '                                 ({32{  dec_i1_rs1_bypass_en_d & ~dec_i0_lsu_d & dec_i1_lsu_d}} & i1_rs1_bypass_data_d[31:0]);\n', '\n', '   assign exu_lsu_rs2_d[31:0]  = ({32{ ~dec_i0_rs2_bypass_en_d &  dec_i0_lsu_d               }} & gpr_i0_rs2_d[31:0]        ) |\n', '                                 ({32{ ~dec_i1_rs2_bypass_en_d & ~dec_i0_lsu_d & dec_i1_lsu_d}} & gpr_i1_rs2_d[31:0]        ) |\n', '                                 ({32{  dec_i0_rs2_bypass_en_d &  dec_i0_lsu_d               }} & i0_rs2_bypass_data_d[31:0]) |\n', '                                 ({32{  dec_i1_rs2_bypass_en_d & ~dec_i0_lsu_d & dec_i1_lsu_d}} & i1_rs2_bypass_data_d[31:0]);\n', '\n', '   assign mul_rs1_d[31:0]      = ({32{ ~dec_i0_rs1_bypass_en_d &  dec_i0_mul_d               }} & gpr_i0_rs1_d[31:0]        ) |\n', '                                 ({32{ ~dec_i1_rs1_bypass_en_d & ~dec_i0_mul_d & dec_i1_mul_d}} & gpr_i1_rs1_d[31:0]        ) |\n', '                                 ({32{  dec_i0_rs1_bypass_en_d &  dec_i0_mul_d               }} & i0_rs1_bypass_data_d[31:0]) |\n', '                                 ({32{  dec_i1_rs1_bypass_en_d & ~dec_i0_mul_d & dec_i1_mul_d}} & i1_rs1_bypass_data_d[31:0]);\n', '\n', '   assign mul_rs2_d[31:0]      = ({32{ ~dec_i0_rs2_bypass_en_d &  dec_i0_mul_d               }} & gpr_i0_rs2_d[31:0]        ) |\n', '                                 ({32{ ~dec_i1_rs2_bypass_en_d & ~dec_i0_mul_d & dec_i1_mul_d}} & gpr_i1_rs2_d[31:0]        ) |\n', '                                 ({32{  dec_i0_rs2_bypass_en_d &  dec_i0_mul_d               }} & i0_rs2_bypass_data_d[31:0]) |\n', '                                 ({32{  dec_i1_rs2_bypass_en_d & ~dec_i0_mul_d & dec_i1_mul_d}} & i1_rs2_bypass_data_d[31:0]);\n', '\n', '\n', '\n', '   assign div_rs1_d[31:0]      = ({32{ ~dec_i0_rs1_bypass_en_d &  dec_i0_div_d               }} & gpr_i0_rs1_d[31:0]) |\n', '                                 ({32{ ~dec_i1_rs1_bypass_en_d & ~dec_i0_div_d & dec_i1_div_d}} & gpr_i1_rs1_d[31:0]) |\n', '                                 ({32{  dec_i0_rs1_bypass_en_d &  dec_i0_div_d               }} & i0_rs1_bypass_data_d[31:0]) |\n', '                                 ({32{  dec_i1_rs1_bypass_en_d & ~dec_i0_div_d & dec_i1_div_d}} & i1_rs1_bypass_data_d[31:0]);\n', '\n', '   assign div_rs2_d[31:0]      = ({32{ ~dec_i0_rs2_bypass_en_d &  dec_i0_div_d               }} & gpr_i0_rs2_d[31:0]) |\n', '                                 ({32{ ~dec_i1_rs2_bypass_en_d & ~dec_i0_div_d & dec_i1_div_d}} & gpr_i1_rs2_d[31:0]) |\n', '                                 ({32{  dec_i0_rs2_bypass_en_d &  dec_i0_div_d               }} & i0_rs2_bypass_data_d[31:0]) |\n', '                                 ({32{  dec_i1_rs2_bypass_en_d & ~dec_i0_div_d & dec_i1_div_d}} & i1_rs2_bypass_data_d[31:0]);\n', '\n', '\n', '   assign csr_rs1_in_d[31:0] = (dec_csr_ren_d) ? i0_rs1_d[31:0] : exu_csr_rs1_e1[31:0];\n', '\n', '   logic       i0_e1_data_en, i0_e2_data_en, i0_e3_data_en;\n', '   logic       i0_e1_ctl_en,  i0_e2_ctl_en,  i0_e3_ctl_en,  i0_e4_ctl_en;\n', '\n', '   assign {i0_e1_data_en, i0_e2_data_en, i0_e3_data_en }                = dec_i0_data_en[4:2];\n', '   assign {i0_e1_ctl_en,  i0_e2_ctl_en,  i0_e3_ctl_en,  i0_e4_ctl_en }  = dec_i0_ctl_en[4:1];\n', '\n', '   logic       i1_e1_data_en, i1_e2_data_en, i1_e3_data_en;\n', '   logic       i1_e1_ctl_en,  i1_e2_ctl_en,  i1_e3_ctl_en,  i1_e4_ctl_en;\n', '\n', '   assign {i1_e1_data_en, i1_e2_data_en, i1_e3_data_en}                = dec_i1_data_en[4:2];\n', '   assign {i1_e1_ctl_en,  i1_e2_ctl_en,  i1_e3_ctl_en,  i1_e4_ctl_en}  = dec_i1_ctl_en[4:1];\n', '\n', '\n', '\n', '\n', '   rvdffe #(32) csr_rs1_ff (.*, .en(i0_e1_data_en), .din(csr_rs1_in_d[31:0]), .dout(exu_csr_rs1_e1[31:0]));\n', '\n', '\n', '   exu_mul_ctl mul_e1    (.*,\n', '                          .clk_override  ( clk_override                ),   // I\n', '                          .freeze        ( freeze                      ),   // I\n', '                          .mp            ( mul_p                       ),   // I\n', '                          .a             ( mul_rs1_d[31:0]             ),   // I\n', '                          .b             ( mul_rs2_d[31:0]             ),   // I\n', '                          .out           ( exu_mul_result_e3[31:0]     ));  // O\n', '\n', '\n', '   exu_div_ctl div_e1    (.*,\n', '                          .flush_lower   ( dec_tlu_flush_lower_wb      ),   // I\n', '                          .dp            ( div_p                       ),   // I\n', '                          .dividend      ( div_rs1_d[31:0]             ),   // I\n', '                          .divisor       ( div_rs2_d[31:0]             ),   // I\n', '                          .valid_ff_e1   ( div_valid_e1                ),   // O\n', '                          .div_stall     ( exu_div_stall               ),   // O\n', '                          .finish_early  ( div_finish_early            ),   // O\n', '                          .finish        ( exu_div_finish              ),   // O\n', '                          .out           ( exu_div_result[31:0]        ));  // O\n', '\n', '\n', '   predict_pkt_t i0_predict_newp_d, i1_predict_newp_d;\n', '\n', '   always_comb begin\n', '      i0_predict_newp_d = i0_predict_p_d;\n', '      i0_predict_newp_d.boffset = dec_i0_pc_d[1];  // from the start of inst\n', '\n', '      i0_predict_newp_d.index[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] = i0_predict_p_d.index[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO]; // from the end of inst\n', '      i0_predict_newp_d.bank[1:0] = i0_predict_p_d.bank[1:0];\n', '\n', '      i1_predict_newp_d = i1_predict_p_d;\n', '      i1_predict_newp_d.boffset = dec_i1_pc_d[1];\n', '\n', '      i1_predict_newp_d.index[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] = i1_predict_p_d.index[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO];\n', '      i1_predict_newp_d.bank[1:0] = i1_predict_p_d.bank[1:0];\n', '\n', '   end\n', '\n', '\n', '   predict_pkt_t i0_predict_p_e1, i0_predict_p_e4;\n', '   predict_pkt_t i1_predict_p_e1, i1_predict_p_e4;\n', '\n', '   assign exu_pmu_i0_br_misp   = i0_predict_p_e4.misp   & ~exu_div_finish;  // qual with divide\n', '   assign exu_pmu_i0_br_ataken = i0_predict_p_e4.ataken & ~exu_div_finish;  // qual with divide\n', '   assign exu_pmu_i0_pc4       = i0_predict_p_e4.pc4 | exu_div_finish;      // divides are always 4B\n', '   assign exu_pmu_i1_br_misp   = i1_predict_p_e4.misp;\n', '   assign exu_pmu_i1_br_ataken = i1_predict_p_e4.ataken;\n', '   assign exu_pmu_i1_pc4       = i1_predict_p_e4.pc4;\n', '\n', '\n', '   exu_alu_ctl i0_alu_e1 (.*,\n', '                          .freeze        ( freeze                      ),   // I\n', '                          .enable        ( i0_e1_ctl_en                ),   // I\n', '                          .predict_p     ( i0_predict_newp_d           ),   // I\n', '                          .valid         ( dec_i0_alu_decode_d         ),   // I\n', '                          .flush         ( exu_flush_final             ),   // I\n', '                          .a             ( i0_rs1_final_d[31:0]        ),   // I\n', '                          .b             ( i0_rs2_d[31:0]              ),   // I\n', '                          .pc            ( dec_i0_pc_d[31:1]           ),   // I\n', '                          .brimm         ( dec_i0_br_immed_d[12:1]     ),   // I\n', '                          .ap            ( i0_ap_e1                    ),   // I\n', '                          .out           ( exu_i0_result_e1[31:0]      ),   // O\n', '                          .flush_upper   ( exu_i0_flush_upper_e1       ),   // O : will be 0 if freeze this cycle\n', '                          .flush_path    ( exu_i0_flush_path_e1[31:1]  ),   // O\n', '                          .predict_p_ff  ( i0_predict_p_e1             ),   // O\n', '                          .pc_ff         ( exu_i0_pc_e1[31:1]          ),   // O\n', '                          .pred_correct  ( i0_pred_correct_upper_e1    )    // O\n', '                          );\n', '\n', '\n', '   exu_alu_ctl i1_alu_e1 (.*,\n', '                          .freeze        ( freeze                      ),   // I\n', '                          .enable        ( i1_e1_ctl_en                ),   // I\n', '                          .predict_p     ( i1_predict_newp_d           ),   // I\n', '                          .valid         ( dec_i1_alu_decode_d         ),   // I\n', '                          .flush         ( exu_flush_final             ),   // I\n', '                          .a             ( i1_rs1_d[31:0]              ),   // I\n', '                          .b             ( i1_rs2_d[31:0]              ),   // I\n', '                          .pc            ( dec_i1_pc_d[31:1]           ),   // I\n', '                          .brimm         ( dec_i1_br_immed_d[12:1]     ),   // I\n', '                          .ap            ( i1_ap_e1                    ),   // I\n', '                          .out           ( exu_i1_result_e1[31:0]      ),   // O\n', '                          .flush_upper   ( exu_i1_flush_upper_e1       ),   // O : will be 0 if freeze this cycle\n', '                          .flush_path    ( exu_i1_flush_path_e1[31:1]  ),   // O\n', '                          .predict_p_ff  ( i1_predict_p_e1             ),   // O\n', '                          .pc_ff         ( exu_i1_pc_e1[31:1]          ),   // O\n', '                          .pred_correct  ( i1_pred_correct_upper_e1    )    // O\n', '                          );\n', '\n', '   predict_pkt_t i0_pp_e2, i0_pp_e3, i0_pp_e4_in;\n', '\n', '   rvdffe #($bits(predict_pkt_t)) i0_pp_e2_ff (.*, .en(i0_e2_ctl_en), .din(i0_predict_p_e1),.dout(i0_pp_e2) );\n', '   rvdffe #($bits(predict_pkt_t)) i0_pp_e3_ff (.*, .en(i0_e3_ctl_en), .din(i0_pp_e2),.dout(i0_pp_e3) );\n', '\n', '   predict_pkt_t i1_pp_e2, i1_pp_e3, i1_pp_e4_in;\n', '\n', '   rvdffe #($bits(predict_pkt_t)) i1_pp_e2_ff (.*, .en(i1_e2_ctl_en), .din(i1_predict_p_e1),.dout(i1_pp_e2) );\n', '   rvdffe #($bits(predict_pkt_t)) i1_pp_e3_ff (.*, .en(i1_e3_ctl_en), .din(i1_pp_e2),.dout(i1_pp_e3) );\n', '\n', ""   // set the predict_pkt to 0's if freeze, goes to secondary alu's\n"", ""   assign i0_pp_e4_in = (freeze) ? '0 : i0_pp_e3;\n"", ""   assign i1_pp_e4_in = (freeze) ? '0 : i1_pp_e3;\n"", '\n', '   rvdffe #($bits(alu_pkt_t)) i0_ap_e1_ff (.*,  .en(i0_e1_ctl_en), .din(i0_ap),   .dout(i0_ap_e1) );\n', '   rvdffe #($bits(alu_pkt_t)) i0_ap_e2_ff (.*,  .en(i0_e2_ctl_en), .din(i0_ap_e1),.dout(i0_ap_e2) );\n', '   rvdffe #($bits(alu_pkt_t)) i0_ap_e3_ff (.*,  .en(i0_e3_ctl_en), .din(i0_ap_e2),.dout(i0_ap_e3) );\n', '   rvdffe #($bits(alu_pkt_t)) i0_ap_e4_ff (.*,  .en(i0_e4_ctl_en), .din(i0_ap_e3),.dout(i0_ap_e4) );\n', '\n', '\n', '   rvdffe #($bits(alu_pkt_t)) i1_ap_e1_ff (.*,  .en(i1_e1_ctl_en), .din(i1_ap),   .dout(i1_ap_e1) );\n', '   rvdffe #($bits(alu_pkt_t)) i1_ap_e2_ff (.*,  .en(i1_e2_ctl_en), .din(i1_ap_e1),.dout(i1_ap_e2) );\n', '   rvdffe #($bits(alu_pkt_t)) i1_ap_e3_ff (.*,  .en(i1_e3_ctl_en), .din(i1_ap_e2),.dout(i1_ap_e3) );\n', '   rvdffe #($bits(alu_pkt_t)) i1_ap_e4_ff (.*,  .en(i1_e4_ctl_en), .din(i1_ap_e3),.dout(i1_ap_e4) );\n', '\n', '   assign exu_rets_e1_pkt.pc0_call = i0_predict_p_e1.pcall & i0_predict_p_e1.valid & ~i0_predict_p_e1.br_error;\n', '   assign exu_rets_e1_pkt.pc1_call = i1_predict_p_e1.pcall & i1_predict_p_e1.valid & ~i1_predict_p_e1.br_error;\n', '   assign exu_rets_e1_pkt.pc0_ret  = i0_predict_p_e1.pret  & i0_predict_p_e1.valid & ~i0_predict_p_e1.br_error;\n', '   assign exu_rets_e1_pkt.pc1_ret  = i1_predict_p_e1.pret  & i1_predict_p_e1.valid & ~i1_predict_p_e1.br_error;\n', '   assign exu_rets_e1_pkt.pc0_pc4  = i0_predict_p_e1.pc4;\n', '   assign exu_rets_e1_pkt.pc1_pc4  = i1_predict_p_e1.pc4;\n', '\n', '\n', '\n', '   rvdffe #(76) i0_src_e1_ff (.*,\n', '                            .en(i0_e1_data_en),\n', '                            .din( {i0_rs1_d[31:0], i0_rs2_d[31:0], dec_i0_br_immed_d[12:1]}),\n', '                            .dout({i0_rs1_e1[31:0], i0_rs2_e1[31:0], i0_br_immed_e1[12:1]})\n', '                            );\n', '\n', '   rvdffe #(76) i0_src_e2_ff (.*,\n', '                            .en(i0_e2_data_en),\n', '                            .din( {i0_rs1_e1[31:0], i0_rs2_e1[31:0], i0_br_immed_e1[12:1]}),\n', '                            .dout({i0_rs1_e2[31:0], i0_rs2_e2[31:0], i0_br_immed_e2[12:1]})\n', '                            );\n', '\n', '   rvdffe #(76) i0_src_e3_ff (.*,\n', '                            .en(i0_e3_data_en),\n', '                            .din( {i0_rs1_e2_final[31:0], i0_rs2_e2_final[31:0], i0_br_immed_e2[12:1]}),\n', '                            .dout({i0_rs1_e3[31:0], i0_rs2_e3[31:0], i0_br_immed_e3[12:1]})\n', '                            );\n', '\n', '\n', '\n', '   rvdffe #(76) i1_src_e1_ff (.*,\n', '                            .en(i1_e1_data_en),\n', '                            .din( {i1_rs1_d[31:0], i1_rs2_d[31:0], dec_i1_br_immed_d[12:1]}),\n', '                            .dout({i1_rs1_e1[31:0], i1_rs2_e1[31:0], i1_br_immed_e1[12:1]})\n', '                            );\n', '\n', '   rvdffe #(76) i1_src_e2_ff (.*,\n', '                            .en(i1_e2_data_en),\n', '                            .din( {i1_rs1_e1[31:0], i1_rs2_e1[31:0], i1_br_immed_e1[12:1]}),\n', '                            .dout({i1_rs1_e2[31:0], i1_rs2_e2[31:0], i1_br_immed_e2[12:1]})\n', '                            );\n', '\n', '   rvdffe #(76) i1_src_e3_ff (.*,\n', '                            .en(i1_e3_data_en),\n', '                            .din( {i1_rs1_e2_final[31:0], i1_rs2_e2_final[31:0], i1_br_immed_e2[12:1]}),\n', '                            .dout({i1_rs1_e3[31:0], i1_rs2_e3[31:0], i1_br_immed_e3[12:1]})\n', '                            );\n', '\n', '\n', '\n', '\n', '   assign i0_rs1_e2_final[31:0] = (dec_i0_rs1_bypass_en_e2) ? i0_rs1_bypass_data_e2[31:0] : i0_rs1_e2[31:0];\n', '   assign i0_rs2_e2_final[31:0] = (dec_i0_rs2_bypass_en_e2) ? i0_rs2_bypass_data_e2[31:0] : i0_rs2_e2[31:0];\n', '   assign i1_rs1_e2_final[31:0] = (dec_i1_rs1_bypass_en_e2) ? i1_rs1_bypass_data_e2[31:0] : i1_rs1_e2[31:0];\n', '   assign i1_rs2_e2_final[31:0] = (dec_i1_rs2_bypass_en_e2) ? i1_rs2_bypass_data_e2[31:0] : i1_rs2_e2[31:0];\n', '\n', '\n', '   assign i0_rs1_e3_final[31:0] = (dec_i0_rs1_bypass_en_e3) ? i0_rs1_bypass_data_e3[31:0] : i0_rs1_e3[31:0];\n', '   assign i0_rs2_e3_final[31:0] = (dec_i0_rs2_bypass_en_e3) ? i0_rs2_bypass_data_e3[31:0] : i0_rs2_e3[31:0];\n', '   assign i1_rs1_e3_final[31:0] = (dec_i1_rs1_bypass_en_e3) ? i1_rs1_bypass_data_e3[31:0] : i1_rs1_e3[31:0];\n', '   assign i1_rs2_e3_final[31:0] = (dec_i1_rs2_bypass_en_e3) ? i1_rs2_bypass_data_e3[31:0] : i1_rs2_e3[31:0];\n', '\n', '   // E1 GHR\n', '   // fill in the ptaken for secondary branches.\n', '\n', '   logic [`RV_BHT_GHR_RANGE] ghr_e4_ns, ghr_e4;\n', '   logic [`RV_BHT_GHR_RANGE] ghr_e1_ns, ghr_e1;\n', '   logic i0_taken_e1, i1_taken_e1, dec_i0_alu_decode_e1, dec_i1_alu_decode_e1, i0_valid_e1, i1_valid_e1, i0_ataken_e1, i1_ataken_e1, exu_flush_final_f;\n', '   assign i0_valid_e1 = ~exu_flush_final & ~exu_flush_final_f & (i0_predict_p_e1.valid | i0_predict_p_e1.misp);\n', '   assign i1_valid_e1 = ~exu_flush_final & ~exu_flush_final_f & (i1_predict_p_e1.valid | i1_predict_p_e1.misp) & ~exu_i0_flush_upper_e1;\n', '   assign i0_ataken_e1 = i0_predict_p_e1.ataken;\n', '   assign i1_ataken_e1 = i1_predict_p_e1.ataken;\n', '\n', '   assign i0_taken_e1 = (i0_ataken_e1 & dec_i0_alu_decode_e1) | (i0_predict_p_e1.hist[1] & ~dec_i0_alu_decode_e1);\n', '   assign i1_taken_e1= (i1_ataken_e1 & dec_i1_alu_decode_e1) | (i1_predict_p_e1.hist[1] & ~dec_i1_alu_decode_e1);\n', '\n', '    assign ghr_e1_ns[`RV_BHT_GHR_RANGE] = ( ({`RV_BHT_GHR_SIZE{~dec_tlu_flush_lower_wb & i0_valid_e1 & (i0_predict_p_e1.misp | ~i1_valid_e1)}} & {ghr_e1[`RV_BHT_GHR_SIZE-2:0], i0_taken_e1}) |\n', '`ifdef RV_BHT_GHR_SIZE_2\n', '                                           ({`RV_BHT_GHR_SIZE{~dec_tlu_flush_lower_wb & i0_valid_e1 & ~i0_predict_p_e1.misp &  i1_valid_e1}} & {                              i0_taken_e1, i1_taken_e1}) |\n', '`else\n', '                                           ({`RV_BHT_GHR_SIZE{~dec_tlu_flush_lower_wb & i0_valid_e1 & ~i0_predict_p_e1.misp &  i1_valid_e1}} & {ghr_e1[`RV_BHT_GHR_SIZE-3:0], i0_taken_e1, i1_taken_e1}) |\n', '`endif\n', '                                           ({`RV_BHT_GHR_SIZE{~dec_tlu_flush_lower_wb & ~i0_valid_e1 & ~i0_predict_p_e1.br_error & i1_valid_e1}} & {ghr_e1[`RV_BHT_GHR_SIZE-2:0], i1_taken_e1}) |\n', '                                           ({`RV_BHT_GHR_SIZE{dec_tlu_flush_lower_wb}} & ghr_e4[`RV_BHT_GHR_RANGE]) |\n', '                                           ({`RV_BHT_GHR_SIZE{~dec_tlu_flush_lower_wb & ~i0_valid_e1 & ~i1_valid_e1}} & ghr_e1[`RV_BHT_GHR_RANGE]) );\n', '\n', '   rvdffs #(`RV_BHT_GHR_SIZE) e1ghrff (.*, .clk(active_clk), .en(~freeze), .din({ghr_e1_ns[`RV_BHT_GHR_RANGE]}), .dout({ghr_e1[`RV_BHT_GHR_RANGE]}));\n', '   rvdffs #(2)             e1ghrdecff (.*, .clk(active_clk), .en(~freeze), .din({dec_i0_alu_decode_d, dec_i1_alu_decode_d}), .dout({dec_i0_alu_decode_e1, dec_i1_alu_decode_e1}));\n', '\n', '   // E4 GHR\n', '   // the ataken is filled in by e1 stage if e1 stage executes the branch, otherwise by e4 stage.\n', '   logic i0_valid_e4, i1_pred_valid_e4;\n', '   assign i0_valid_e4 = dec_tlu_i0_valid_e4 & ((i0_predict_p_e4.valid) | i0_predict_p_e4.misp);\n', '   assign i1_pred_valid_e4 = dec_tlu_i1_valid_e4 & ((i1_predict_p_e4.valid) | i1_predict_p_e4.misp) & ~exu_i0_flush_upper_e4;\n', '   assign ghr_e4_ns[`RV_BHT_GHR_RANGE]  = ( ({`RV_BHT_GHR_SIZE{i0_valid_e4 & (i0_predict_p_e4.misp | ~i1_pred_valid_e4)}} & {ghr_e4[`RV_BHT_GHR_SIZE-2:0], i0_predict_p_e4.ataken}) |\n', '`ifdef RV_BHT_GHR_SIZE_2\n', '                                           ({`RV_BHT_GHR_SIZE{i0_valid_e4  & ~i0_predict_p_e4.misp &  i1_pred_valid_e4}} & {                              i0_predict_p_e4.ataken, i1_predict_p_e4.ataken}) |\n', '`else\n', '                                           ({`RV_BHT_GHR_SIZE{i0_valid_e4  & ~i0_predict_p_e4.misp &  i1_pred_valid_e4}} & {ghr_e4[`RV_BHT_GHR_SIZE-3:0], i0_predict_p_e4.ataken, i1_predict_p_e4.ataken}) |\n', '`endif\n', '                                           ({`RV_BHT_GHR_SIZE{~i0_valid_e4 & ~i0_predict_p_e4.br_error & i1_pred_valid_e4}} & {ghr_e4[`RV_BHT_GHR_SIZE-2:0], i1_predict_p_e4.ataken}) |\n', '                                           ({`RV_BHT_GHR_SIZE{~i0_valid_e4 & ~i1_pred_valid_e4}} & ghr_e4[`RV_BHT_GHR_RANGE]) );\n', '\n', '   rvdff #(`RV_BHT_GHR_SIZE) e4ghrff (.*, .clk(active_clk), .din({ghr_e4_ns[`RV_BHT_GHR_RANGE]}),\n', '                                                            .dout({ghr_e4[`RV_BHT_GHR_RANGE]}));\n', '   rvdff #(1)           e4ghrflushff (.*, .clk(active_clk), .din({exu_flush_final}),\n', '                                                            .dout({exu_flush_final_f}));\n', '\n', '// RV_NO_SECONDARY_ALU {{\n', '`ifdef RV_NO_SECONDARY_ALU\n', '\n', '   rvdffe #($bits(predict_pkt_t)) i0_pp_e4_ff (.*, .en(i0_e4_ctl_en), .din(i0_pp_e4_in),.dout(i0_predict_p_e4) );\n', '   rvdffe #($bits(predict_pkt_t)) i1_pp_e4_ff (.*, .en(i1_e4_ctl_en), .din(i1_pp_e4_in),.dout(i1_predict_p_e4) );\n', '\n', ""   assign exu_i0_result_e4[31:0]     = '0;\n"", ""   assign exu_i0_flush_lower_e4      = '0;\n"", ""   assign exu_i0_flush_path_e4[31:1] = '0;\n"", ""   assign i0_alu_pc_nc[31:1]         = '0;\n"", ""   assign i0_pred_correct_lower_e4   = '0;\n"", '\n', ""   assign exu_i1_result_e4[31:0]     = '0;\n"", ""   assign exu_i1_flush_lower_e4      = '0;\n"", ""   assign exu_i1_flush_path_e4[31:1] = '0;\n"", ""   assign i1_alu_pc_nc[31:1]         = '0;\n"", ""   assign i1_pred_correct_lower_e4   = '0;\n"", '\n', '`else\n', '\n', '   exu_alu_ctl i0_alu_e4 (.*,\n', ""                          .freeze        ( 1'b0                        ),   // I\n"", '                          .enable        ( i0_e4_ctl_en                ),   // I\n', '                          .predict_p     ( i0_pp_e4_in                 ),   // I\n', '                          .valid         ( dec_i0_sec_decode_e3        ),   // I\n', '                          .flush         ( dec_tlu_flush_lower_wb      ),   // I\n', '                          .a             ( i0_rs1_e3_final[31:0]       ),   // I\n', '                          .b             ( i0_rs2_e3_final[31:0]       ),   // I\n', '                          .pc            ( dec_i0_pc_e3[31:1]          ),   // I\n', '                          .brimm         ( i0_br_immed_e3[12:1]        ),   // I\n', '                          .ap            ( i0_ap_e4                    ),   // I\n', '                          .out           ( exu_i0_result_e4[31:0]      ),   // O\n', '                          .flush_upper   ( exu_i0_flush_lower_e4       ),   // O\n', '                          .flush_path    ( exu_i0_flush_path_e4[31:1]  ),   // O\n', '                          .predict_p_ff  ( i0_predict_p_e4             ),   // O\n', '                          .pc_ff         ( i0_alu_pc_nc[31:1]          ),   // O\n', '                          .pred_correct  ( i0_pred_correct_lower_e4    )    // O\n', '                          );\n', '\n', '\n', '   exu_alu_ctl i1_alu_e4 (.*,\n', ""                          .freeze        ( 1'b0                        ),   // I\n"", '                          .enable        ( i1_e4_ctl_en                ),   // I\n', '                          .predict_p     ( i1_pp_e4_in                 ),   // I\n', '                          .valid         ( dec_i1_sec_decode_e3        ),   // I\n', '                          .flush         ( dec_tlu_flush_lower_wb      ),   // I\n', '                          .a             ( i1_rs1_e3_final[31:0]       ),   // I\n', '                          .b             ( i1_rs2_e3_final[31:0]       ),   // I\n', '                          .pc            ( dec_i1_pc_e3[31:1]          ),   // I\n', '                          .brimm         ( i1_br_immed_e3[12:1]        ),   // I\n', '                          .ap            ( i1_ap_e4                    ),   // I\n', '                          .out           ( exu_i1_result_e4[31:0]      ),   // O\n', '                          .flush_upper   ( exu_i1_flush_lower_e4       ),   // O\n', '                          .flush_path    ( exu_i1_flush_path_e4[31:1]  ),   // O\n', '                          .predict_p_ff  ( i1_predict_p_e4             ),   // O\n', '                          .pc_ff         ( i1_alu_pc_nc[31:1]          ),   // O\n', '                          .pred_correct  ( i1_pred_correct_lower_e4    )    // O\n', '                          );\n', '\n', '`endif      // RV_NO_SECONDARY_ALU  }}\n', '\n', '\n', '   assign exu_i0_br_hist_e4[1:0]               = i0_predict_p_e4.hist[1:0];\n', '   assign exu_i0_br_bank_e4[1:0]               = i0_predict_p_e4.bank[1:0];\n', '   assign exu_i0_br_error_e4                   = i0_predict_p_e4.br_error;\n', '   assign exu_i0_br_fghr_e4[`RV_BHT_GHR_RANGE] = i0_predict_p_e4.fghr[`RV_BHT_GHR_RANGE];\n', '   assign exu_i0_br_middle_e4                  = i0_predict_p_e4.pc4 ^ i0_predict_p_e4.boffset;\n', '   assign exu_i0_br_start_error_e4     = i0_predict_p_e4.br_start_error;\n', '   assign exu_i0_br_index_e4[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO]     = i0_predict_p_e4.index[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO];\n', '\n', '   assign exu_i0_br_valid_e4           = i0_predict_p_e4.valid;\n', '   assign exu_i0_br_mp_e4              = i0_predict_p_e4.misp; // needed to squash i1 error\n', '   assign exu_i0_br_ret_e4             = i0_predict_p_e4.pret;\n', '   assign exu_i0_br_call_e4            = i0_predict_p_e4.pcall;\n', '   assign exu_i0_br_way_e4             = i0_predict_p_e4.way;\n', '\n', '   assign exu_i1_br_hist_e4[1:0]               = i1_predict_p_e4.hist[1:0];\n', '   assign exu_i1_br_bank_e4[1:0]               = i1_predict_p_e4.bank[1:0];\n', '   assign exu_i1_br_fghr_e4[`RV_BHT_GHR_RANGE] = i1_predict_p_e4.fghr[`RV_BHT_GHR_RANGE];\n', '   assign exu_i1_br_middle_e4                  = i1_predict_p_e4.pc4 ^ i1_predict_p_e4.boffset;\n', '   assign exu_i1_br_error_e4                   = i1_predict_p_e4.br_error;\n', '   assign exu_i1_br_index_e4[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO]     = i1_predict_p_e4.index[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO];\n', '\n', '   assign exu_i1_br_start_error_e4     = i1_predict_p_e4.br_start_error;\n', '   assign exu_i1_br_valid_e4           = i1_predict_p_e4.valid;\n', '   assign exu_i1_br_mp_e4              = i1_predict_p_e4.misp;\n', '   assign exu_i1_br_way_e4             = i1_predict_p_e4.way;\n', '\n', '   assign exu_i1_br_ret_e4             = i1_predict_p_e4.pret;\n', '   assign exu_i1_br_call_e4            = i1_predict_p_e4.pcall;\n', '\n', '   assign exu_rets_e4_pkt.pc0_call = i0_predict_p_e4.pcall & i0_predict_p_e4.valid & ~i0_predict_p_e4.br_error;\n', '   assign exu_rets_e4_pkt.pc1_call = i1_predict_p_e4.pcall & i1_predict_p_e4.valid & ~i1_predict_p_e4.br_error;\n', '   assign exu_rets_e4_pkt.pc0_ret = i0_predict_p_e4.pret & i0_predict_p_e4.valid & ~i0_predict_p_e4.br_error;\n', '   assign exu_rets_e4_pkt.pc1_ret = i1_predict_p_e4.pret & i1_predict_p_e4.valid & ~i1_predict_p_e4.br_error;\n', '   assign exu_rets_e4_pkt.pc0_pc4 = i0_predict_p_e4.pc4;\n', '   assign exu_rets_e4_pkt.pc1_pc4 = i1_predict_p_e4.pc4;\n', '\n', '   predict_pkt_t final_predict_mp, final_predict_mp_ff;\n', '\n', '   logic fp_enable, fp_enable_ff;\n', '\n', '   assign fp_enable = exu_i0_flush_lower_e4 | exu_i1_flush_lower_e4 |\n', '                      exu_i0_flush_upper_e1 | exu_i1_flush_upper_e1;\n', '\n', '   rvdff #(1) final_predict_ff (.*, .clk(active_clk), .din(fp_enable), .dout(fp_enable_ff));\n', '\n', '\n', ""   // flush_upper_e1's below take freeze into account\n"", '   assign final_predict_mp = (exu_i0_flush_lower_e4) ? i0_predict_p_e4 :\n', '                             (exu_i1_flush_lower_e4) ? i1_predict_p_e4 :\n', '                             (exu_i0_flush_upper_e1) ? i0_predict_p_e1 :\n', ""                             (exu_i1_flush_upper_e1) ? i1_predict_p_e1 : '0;\n"", '\n', '   rvdffe #($bits(predict_pkt_t)) predict_mp_ff (.*, .en(fp_enable | fp_enable_ff), .din(final_predict_mp), .dout(final_predict_mp_ff));\n', '\n', '   logic [`RV_BHT_GHR_RANGE] final_eghr, after_flush_eghr;\n', '   assign final_eghr[`RV_BHT_GHR_RANGE] = ((exu_i0_flush_upper_e1 | exu_i1_flush_upper_e1) & ~dec_tlu_flush_lower_wb & ~exu_i0_flush_lower_e4 & ~exu_i1_flush_lower_e4 ) ? ghr_e1[`RV_BHT_GHR_RANGE] : ghr_e4[`RV_BHT_GHR_RANGE];\n', '\n', '   assign after_flush_eghr[`RV_BHT_GHR_RANGE] = ((exu_i0_flush_upper_e2 | exu_i1_flush_upper_e2) & ~dec_tlu_flush_lower_wb) ? ghr_e1[`RV_BHT_GHR_RANGE] : ghr_e4[`RV_BHT_GHR_RANGE];\n', '\n', '\n', '   assign exu_mp_pkt.way                                    = final_predict_mp_ff.way;\n', '   assign exu_mp_pkt.misp                                   = final_predict_mp_ff.misp;\n', '   assign exu_mp_pkt.pcall                                  = final_predict_mp_ff.pcall;\n', '   assign exu_mp_pkt.pja                                    = final_predict_mp_ff.pja;\n', '   assign exu_mp_pkt.pret                                   = final_predict_mp_ff.pret;\n', '   assign exu_mp_pkt.ataken                                 = final_predict_mp_ff.ataken;\n', '   assign exu_mp_pkt.boffset                                = final_predict_mp_ff.boffset;\n', '   assign exu_mp_pkt.pc4                                    = final_predict_mp_ff.pc4;\n', '   assign exu_mp_pkt.hist[1:0]                              = final_predict_mp_ff.hist[1:0];\n', '   assign exu_mp_pkt.toffset[11:0]                          = final_predict_mp_ff.toffset[11:0];\n', '   assign exu_mp_pkt.index[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] = final_predict_mp_ff.index[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO];\n', '   assign exu_mp_pkt.bank[1:0]                              = final_predict_mp_ff.bank[1:0];\n', '   assign exu_mp_pkt.btag[`RV_BTB_BTAG_SIZE-1:0]            = final_predict_mp_ff.btag[`RV_BTB_BTAG_SIZE-1:0];\n', '   assign exu_mp_pkt.fghr[`RV_BHT_GHR_RANGE]                = after_flush_eghr[`RV_BHT_GHR_RANGE];     // fghr repair value\n', '\n', '   assign exu_mp_eghr[`RV_BHT_GHR_RANGE] = final_predict_mp_ff.fghr[`RV_BHT_GHR_RANGE]; // mp ghr for bht write\n', '\n', '\n', '\n', '   rvdffe #(32) i0_upper_flush_e2_ff (.*,\n', '                                    .en(i0_e2_ctl_en),\n', '                                    .din({\n', '                                          exu_i0_flush_path_e1[31:1],\n', '                                          exu_i0_flush_upper_e1}),\n', '\n', '                                    .dout({\n', '                                           i0_flush_path_upper_e2[31:1],\n', '                                           exu_i0_flush_upper_e2})\n', '                                    );\n', '\n', '   rvdffe #(33) i1_upper_flush_e2_ff (.*,\n', '                                    .en(i1_e2_ctl_en),\n', '                                    .din({dec_i1_valid_e1,\n', '                                          exu_i1_flush_path_e1[31:1],\n', '                                          exu_i1_flush_upper_e1}),\n', '                                    .dout({i1_valid_e2,\n', '                                           i1_flush_path_upper_e2[31:1],\n', '                                           exu_i1_flush_upper_e2})\n', '                                    );\n', '\n', '   assign exu_flush_path_e2[31:1] = (exu_i0_flush_upper_e2) ? i0_flush_path_upper_e2[31:1] : i1_flush_path_upper_e2[31:1];\n', '\n', '   assign exu_i0_flush_final = dec_tlu_flush_lower_wb | (exu_i0_flush_upper_e2 & ~freeze);\n', '\n', '   assign exu_i1_flush_final = dec_tlu_flush_lower_wb | (exu_i1_flush_upper_e2 & ~freeze);\n', '\n', '   assign exu_flush_upper_e2 = (exu_i0_flush_upper_e2 | exu_i1_flush_upper_e2) & ~freeze;\n', '\n', '   assign exu_flush_final = dec_tlu_flush_lower_wb | exu_flush_upper_e2;\n', '\n', '   assign exu_flush_path_final[31:1] = (dec_tlu_flush_lower_wb) ? dec_tlu_flush_path_wb[31:1] : exu_flush_path_e2[31:1];\n', '\n', '\n', '   rvdffe #(63) i0_upper_flush_e3_ff (.*,\n', '                                    .en(i0_e3_ctl_en),\n', '                                    .din({i0_flush_path_upper_e2[31:1],\n', '                                          pred_correct_npc_e2[31:1],\n', '                                          exu_i0_flush_upper_e2}),\n', '                                    .dout({\n', '                                           i0_flush_path_upper_e3[31:1],\n', '                                           pred_correct_npc_e3[31:1],\n', '                                           exu_i0_flush_upper_e3})\n', '                                    );\n', '\n', '   rvdffe #(32) i1_upper_flush_e3_ff (.*,\n', '                                    .en(i1_e3_ctl_en),\n', '                                    .din({i1_valid_e2,\n', '                                          i1_flush_path_upper_e2[31:1]\n', '                                          }),\n', '                                    .dout({i1_valid_e3,\n', '                                           i1_flush_path_upper_e3[31:1]})\n', '                                    );\n', '\n', '   rvdffe #(63) i0_upper_flush_e4_ff (.*,\n', '                                    .en(i0_e4_ctl_en),\n', '                                    .din({\n', '                                          i0_flush_path_upper_e3[31:1],\n', '                                          pred_correct_npc_e3[31:1],\n', '                                          exu_i0_flush_upper_e3 & ~freeze}),\n', '                                    .dout({\n', '                                           i0_flush_path_upper_e4[31:1],\n', '                                           pred_correct_npc_e4[31:1],\n', '                                           exu_i0_flush_upper_e4})\n', '                                    );\n', '\n', '   rvdffe #(32) i1_upper_flush_e4_ff (.*,\n', '                                    .en(i1_e4_ctl_en),\n', '                                    .din({i1_valid_e3 & ~freeze,\n', '                                          i1_flush_path_upper_e3[31:1]}),\n', '                                    .dout({i1_valid_e4,\n', '                                           i1_flush_path_upper_e4[31:1]})\n', '                                    );\n', '\n', '\n', '   // npc logic for commit\n', '\n', '   rvdffs #(2) pred_correct_upper_e2_ff  (.*,\n', '                                       .clk(active_clk),\n', '                                       .en(~freeze),\n', '                                       .din({i1_pred_correct_upper_e1,i0_pred_correct_upper_e1}),\n', '                                       .dout({i1_pred_correct_upper_e2,i0_pred_correct_upper_e2})\n', '                                       );\n', '\n', '   rvdffs #(2) pred_correct_upper_e3_ff  (.*,\n', '                                       .clk(active_clk),\n', '                                       .en(~freeze),\n', '                                       .din({i1_pred_correct_upper_e2,i0_pred_correct_upper_e2}),\n', '                                       .dout({i1_pred_correct_upper_e3,i0_pred_correct_upper_e3})\n', '                                       );\n', '\n', '   rvdff #(2) pred_correct_upper_e4_ff  (.*,\n', '                                       .clk(active_clk),\n', '                                       .din({i1_pred_correct_upper_e3,i0_pred_correct_upper_e3}),\n', '                                       .dout({i1_pred_correct_upper_e4,i0_pred_correct_upper_e4})\n', '                                       );\n', '\n', '   rvdff #(2) sec_decode_e4_ff  (.*,\n', '                                       .clk(active_clk),\n', '                                       .din({dec_i0_sec_decode_e3,dec_i1_sec_decode_e3}),\n', '                                       .dout({i0_sec_decode_e4,i1_sec_decode_e4})\n', '                               );\n', '\n', '\n', '\n', '   assign i1_valid_e4_eff = i1_valid_e4 & ~((i0_sec_decode_e4) ? exu_i0_flush_lower_e4 : exu_i0_flush_upper_e4);\n', '\n', '   assign i1_pred_correct_e4_eff = (i1_sec_decode_e4) ? i1_pred_correct_lower_e4 : i1_pred_correct_upper_e4;\n', '   assign i0_pred_correct_e4_eff = (i0_sec_decode_e4) ? i0_pred_correct_lower_e4 : i0_pred_correct_upper_e4;\n', '\n', '   assign i1_flush_path_e4_eff[31:1] = (i1_sec_decode_e4) ? exu_i1_flush_path_e4[31:1] : i1_flush_path_upper_e4[31:1];\n', '   assign i0_flush_path_e4_eff[31:1] = (i0_sec_decode_e4) ? exu_i0_flush_path_e4[31:1] : i0_flush_path_upper_e4[31:1];\n', '\n', '\n', '   assign npc_e4[31:1] = (i1_valid_e4_eff) ? ((i1_pred_correct_e4_eff) ? pred_correct_npc_e4[31:1] : i1_flush_path_e4_eff[31:1]) :\n', '                                             ((i0_pred_correct_e4_eff) ? pred_correct_npc_e4[31:1] : i0_flush_path_e4_eff[31:1]);\n', '\n', '\n', '   assign exu_npc_e4[31:1] = (div_finish_early) ? exu_i0_flush_path_e1[31:1] :\n', '                             (exu_div_finish)   ? div_npc[31:1]              :\n', '                                                  npc_e4[31:1];\n', '\n', '   // remember the npc of the divide\n', '   rvdffe #(31) npc_any_ff (.*, .en(div_valid_e1), .din(exu_i0_flush_path_e1[31:1]),    .dout(div_npc[31:1]));\n', '\n', '\n', 'endmodule // exu\n']"
"['// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '\n', '\n', 'module exu_alu_ctl\n', '   import veer_types::*;\n', '(\n', '   input logic  clk,                      // Top level clock\n', '   input logic  active_clk,               // Level 1 free clock\n', '   input logic  rst_l,                    // Reset\n', '   input logic  scan_mode,                // Scan control\n', '\n', '   input predict_pkt_t  predict_p,        // Predicted branch structure\n', '\n', '   input logic freeze,                    // Clock enable for valid\n', '\n', '   input logic [31:0] a,                  // A operand\n', '   input logic [31:0] b,                  // B operand\n', '   input logic [31:1] pc,                 // for pc=pc+2,4 calculations\n', '\n', '   input logic valid,                     // Valid\n', '   input logic flush,                     // Flush pipeline\n', '\n', '   input logic [12:1] brimm,              // Branch offset\n', '\n', '   input alu_pkt_t ap,                    // {valid,predecodes}\n', '\n', '   input logic  enable,                   // Clock enable\n', '\n', '\n', '   output logic [31:0] out,               // final result\n', '\n', '   output logic        flush_upper,       // Branch flush\n', '   output logic [31:1] flush_path,        // Branch flush PC\n', '\n', '   output logic [31:1] pc_ff,             // flopped PC\n', '\n', '   output logic pred_correct,             // NPC control\n', '   output predict_pkt_t predict_p_ff      // Predicted branch structure\n', '\n', '  );\n', '\n', '\n', '\n', '\n', '   logic        [31:0]  aout,bm;\n', '   logic                cout,ov,neg;\n', '\n', '   logic        [3:1]   logic_sel;\n', '\n', '   logic        [31:0]  lout;\n', '   logic        [31:0]  sout;\n', '   logic                sel_logic,sel_shift,sel_adder;\n', '\n', '   logic                slt_one;\n', '\n', '   logic                actual_taken;\n', '\n', '   logic signed [31:0]  a_ff;\n', '\n', '   logic [31:0]         b_ff;\n', '\n', '   logic [12:1]         brimm_ff;\n', '\n', '   logic [31:1]         pcout;\n', '\n', '   logic                valid_ff;\n', '\n', '   logic [31:0]         ashift;\n', '   logic                cond_mispredict;\n', '   logic                target_mispredict;\n', '\n', '   logic                eq, ne, lt, ge;\n', '\n', '\n', '   rvdffs #(1)  validff (.*, .clk(active_clk), .en(~freeze), .din(valid & ~flush), .dout(valid_ff));\n', '\n', '   rvdffe #(32) aff (.*, .en(enable & valid), .din(a[31:0]), .dout(a_ff[31:0]));\n', '\n', '   rvdffe #(32) bff (.*, .en(enable & valid), .din(b[31:0]), .dout(b_ff[31:0]));\n', '\n', ""   // any PC is run through here - doesn't have to be alu\n"", '   rvdffe #(31) pcff (.*, .en(enable), .din(pc[31:1]), .dout(pc_ff[31:1]));\n', '\n', '   rvdffe #(12) brimmff (.*, .en(enable), .din(brimm[12:1]), .dout(brimm_ff[12:1]));\n', '\n', '   predict_pkt_t pp_ff;\n', '\n', '   rvdffe #($bits(predict_pkt_t)) predictpacketff (.*,\n', '                           .en(enable),\n', '                           .din(predict_p),\n', '                           .dout(pp_ff)\n', '                           );\n', '\n', '\n', '   // immediates are just muxed into rs2\n', '\n', '   // add => add=1;\n', '   // sub => add=1; sub=1;\n', '\n', '   // and => lctl=3\n', '   // or  => lctl=2\n', '   // xor => lctl=1\n', '\n', '   // sll => sctl=3\n', '   // srl => sctl=2\n', '   // sra => sctl=1\n', '\n', '   // slt => slt\n', '\n', '   // lui   => lctl=2; or x0, imm20 previously << 12\n', '   // auipc => add;  add pc, imm20 previously << 12\n', '\n', '   // beq  => bctl=4; add; add x0, pc, sext(offset[12:1])\n', '   // bne  => bctl=3; add; add x0, pc, sext(offset[12:1])\n', '   // blt  => bctl=2; add; add x0, pc, sext(offset[12:1])\n', '   // bge  => bctl=1; add; add x0, pc, sext(offset[12:1])\n', '\n', ""   // jal  => rs1=pc {pc[31:1],1'b0},  rs2=sext(offset20:1]);    rd=pc+[2,4]\n"", '   // jalr => rs1=rs1, rs2=sext(offset20:1]);                    rd=pc+[2,4]\n', '\n', '\n', '   assign bm[31:0] = ( ap.sub ) ? ~b_ff[31:0] : b_ff[31:0];\n', '\n', '\n', ""   assign {cout, aout[31:0]} = {1'b0, a_ff[31:0]} + {1'b0, bm[31:0]} + {32'b0, ap.sub};\n"", '\n', '   assign ov = (~a_ff[31] & ~bm[31] &  aout[31]) |\n', '               ( a_ff[31] &  bm[31] & ~aout[31] );\n', '\n', '   assign neg = aout[31];\n', '\n', '   assign eq = a_ff[31:0] == b_ff[31:0];\n', '\n', '   assign ne = ~eq;\n', '\n', '   assign logic_sel[3] = ap.land | ap.lor;\n', '   assign logic_sel[2] = ap.lor | ap.lxor;\n', '   assign logic_sel[1] = ap.lor | ap.lxor;\n', '\n', '\n', '\n', '   assign lout[31:0] =  (  a_ff[31:0] &  b_ff[31:0] & {32{logic_sel[3]}} ) |\n', '                        (  a_ff[31:0] & ~b_ff[31:0] & {32{logic_sel[2]}} ) |\n', '                        ( ~a_ff[31:0] &  b_ff[31:0] & {32{logic_sel[1]}} );\n', '\n', '\n', '\n', '   assign ashift[31:0] = a_ff >>> b_ff[4:0];\n', '\n', '   assign sout[31:0] = ( {32{ap.sll}} & (a_ff[31:0] <<  b_ff[4:0]) ) |\n', '                       ( {32{ap.srl}} & (a_ff[31:0] >>  b_ff[4:0]) ) |\n', '                       ( {32{ap.sra}} &  ashift[31:0]              );\n', '\n', '\n', '   assign sel_logic = |{ap.land,ap.lor,ap.lxor};\n', '\n', '   assign sel_shift = |{ap.sll,ap.srl,ap.sra};\n', '\n', '   assign sel_adder = (ap.add | ap.sub) & ~ap.slt;\n', '\n', '\n', '\n', '\n', '   assign lt = (~ap.unsign & (neg ^ ov)) |\n', '               ( ap.unsign & ~cout);\n', '\n', '   assign ge = ~lt;\n', '\n', '\n', '   assign slt_one = (ap.slt & lt);\n', '\n', '   assign out[31:0] = ({32{sel_logic}} & lout[31:0]) |\n', '                      ({32{sel_shift}} & sout[31:0]) |\n', '                      ({32{sel_adder}} & aout[31:0]) |\n', ""                      ({32{ap.jal | pp_ff.pcall | pp_ff.pja | pp_ff.pret}} & {pcout[31:1],1'b0}) |\n"", '                      ({32{ap.csr_write}} & ((ap.csr_imm) ? b_ff[31:0] : a_ff[31:0])) |                // csr_write: if csr_imm rs2 else rs1\n', ""                      ({31'b0, slt_one});\n"", '\n', '   // branch handling\n', '\n', '   logic                any_jal;\n', '\n', '   assign any_jal =       ap.jal |\n', '                          pp_ff.pcall |\n', '                          pp_ff.pja   |\n', '                          pp_ff.pret;\n', '\n', '\n', '   assign actual_taken = (ap.beq & eq) |\n', '                         (ap.bne & ne) |\n', '                         (ap.blt & lt) |\n', '                         (ap.bge & ge) |\n', '                         (any_jal);\n', '\n', '   // for a conditional br pcout[] will be the opposite of the branch prediction\n', '   // for jal or pcall, it will be the link address pc+2 or pc+4\n', '\n', '   rvbradder ibradder (\n', '                     .pc(pc_ff[31:1]),\n', '                     .offset(brimm_ff[12:1]),\n', '                     .dout(pcout[31:1])\n', '                      );\n', '\n', '   // pred_correct is for the npc logic\n', '   // pred_correct indicates not to use the flush_path\n', '   // for any_jal pred_correct==0\n', '\n', '   assign pred_correct = ((ap.predict_nt & ~actual_taken) |\n', '                          (ap.predict_t  &  actual_taken)) & ~any_jal;\n', '\n', '\n', '   // for any_jal adder output is the flush path\n', '   assign flush_path[31:1] = (any_jal) ? aout[31:1] : pcout[31:1];\n', '\n', '\n', '   // pcall and pret are included here\n', '   assign cond_mispredict = (ap.predict_t & ~actual_taken) |\n', '                            (ap.predict_nt & actual_taken);\n', '\n', ""   // target mispredicts on ret's\n"", '\n', '   assign target_mispredict = pp_ff.pret & (pp_ff.prett[31:1] != aout[31:1]);\n', '\n', '   assign flush_upper = ( ap.jal | cond_mispredict | target_mispredict) & valid_ff & ~flush & ~freeze;\n', '\n', '\n', '   // .i 3\n', '   // .o 2\n', '   // .ilb hist[1] hist[0] taken\n', '   // .ob newhist[1] newhist[0]\n', '   // .type fd\n', '   //\n', '   // 00 0 01\n', '   // 01 0 01\n', '   // 10 0 00\n', '   // 11 0 10\n', '   // 00 1 10\n', '   // 01 1 00\n', '   // 10 1 11\n', '   // 11 1 11\n', '\n', '   logic [1:0]          newhist;\n', '\n', '   assign newhist[1] = (pp_ff.hist[1]&pp_ff.hist[0]) | (!pp_ff.hist[0]&actual_taken);\n', '\n', '   assign newhist[0] = (!pp_ff.hist[1]&!actual_taken) | (pp_ff.hist[1]&actual_taken);\n', '\n', '\n', '\n', '   always_comb begin\n', '      predict_p_ff = pp_ff;\n', '\n', '      predict_p_ff.misp    = (valid_ff) ? (cond_mispredict | target_mispredict) & ~flush : pp_ff.misp;\n', '      predict_p_ff.ataken  = (valid_ff) ? actual_taken : pp_ff.ataken;\n', '      predict_p_ff.hist[1] = (valid_ff) ? newhist[1] : pp_ff.hist[1];\n', '      predict_p_ff.hist[0] = (valid_ff) ? newhist[0] : pp_ff.hist[0];\n', '\n', '   end\n', '\n', '\n', '\n', 'endmodule // exu_alu_ctl\n']"
"['// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '\n', '\n', 'module exu_div_ctl\n', '   import veer_types::*;\n', '(\n', '   input logic         clk,                       // Top level clock\n', '   input logic         active_clk,                // Level 1 active clock\n', '   input logic         rst_l,                     // Reset\n', '   input logic         scan_mode,                 // Scan mode\n', '\n', '   input logic         dec_tlu_fast_div_disable,  // Disable small number optimization\n', '\n', '   input logic  [31:0] dividend,                  // Numerator\n', '   input logic  [31:0] divisor,                   // Denominator\n', '\n', '   input div_pkt_t     dp,                        // valid, sign, rem\n', '\n', '   input logic         flush_lower,               // Flush pipeline\n', '\n', '\n', '   output logic        valid_ff_e1,               // Valid E1 stage\n', '   output logic        finish_early,              // Finish smallnum\n', '   output logic        finish,                    // Finish smallnum or normal divide\n', '   output logic        div_stall,                 // Divide is running\n', '\n', '   output logic [31:0] out                        // Result\n', '  );\n', '\n', '\n', '   logic         run_in, run_state;\n', '   logic [5:0]   count_in, count;\n', '   logic [32:0]  m_ff;\n', '   logic         qff_enable;\n', '   logic         aff_enable;\n', '   logic [32:0]  q_in, q_ff;\n', '   logic [32:0]  a_in, a_ff;\n', '   logic [32:0]  m_eff;\n', '   logic [32:0]  a_shift;\n', '   logic         dividend_neg_ff, divisor_neg_ff;\n', '   logic [31:0]  dividend_comp;\n', '   logic [31:0]  dividend_eff;\n', '   logic [31:0]  q_ff_comp;\n', '   logic [31:0]  q_ff_eff;\n', '   logic [31:0]  a_ff_comp;\n', '   logic [31:0]  a_ff_eff;\n', '   logic         sign_ff, sign_eff;\n', '   logic         rem_ff;\n', '   logic         add;\n', '   logic [32:0]  a_eff;\n', '   logic [64:0]  a_eff_shift;\n', '   logic         rem_correct;\n', '   logic         flush_lower_ff;\n', '   logic         valid_e1;\n', '\n', '   logic         smallnum_case, smallnum_case_ff;\n', '   logic [3:0]   smallnum, smallnum_ff;\n', '   logic         m_already_comp;\n', '\n', '\n', '\n', '   rvdff  #(1)  flush_any_ff      (.*, .clk(active_clk), .din(flush_lower),                                .dout(flush_lower_ff));\n', '   rvdff  #(1)  e1val_ff          (.*, .clk(active_clk), .din(dp.valid & ~flush_lower_ff),                 .dout(valid_ff_e1));\n', '   rvdff  #(1)  runff             (.*, .clk(active_clk), .din(run_in),                                     .dout(run_state));\n', '   rvdff  #(6)  countff           (.*, .clk(active_clk), .din(count_in[5:0]),                              .dout(count[5:0]));\n', '   rvdffs #(4)  miscf             (.*, .clk(active_clk), .din({dividend[31],divisor[31],sign_eff,dp.rem}), .dout({dividend_neg_ff,divisor_neg_ff,sign_ff,rem_ff}), .en(dp.valid));\n', '   rvdff  #(5)  smallnumff        (.*, .clk(active_clk), .din({smallnum_case,smallnum[3:0]}),              .dout({smallnum_case_ff,smallnum_ff[3:0]}));\n', '   rvdffe #(33) mff               (.*, .en(dp.valid),    .din({ ~dp.unsign & divisor[31], divisor[31:0]}), .dout(m_ff[32:0]));\n', '   rvdffe #(33) qff               (.*, .en(qff_enable),  .din(q_in[32:0]),                                 .dout(q_ff[32:0]));\n', '   rvdffe #(33) aff               (.*, .en(aff_enable),  .din(a_in[32:0]),                                 .dout(a_ff[32:0]));\n', '\n', '   rvtwoscomp #(32) dividend_c    (.din(q_ff[31:0]), .dout(dividend_comp[31:0]));\n', '   rvtwoscomp #(32) q_ff_c        (.din(q_ff[31:0]), .dout(q_ff_comp[31:0]));\n', '   rvtwoscomp #(32) a_ff_c        (.din(a_ff[31:0]), .dout(a_ff_comp[31:0]));\n', '\n', '\n', '   assign valid_e1                = valid_ff_e1 & ~flush_lower_ff;\n', '\n', '\n', '   // START - short circuit logic for small numbers {{\n', '\n', '   // small number divides - any 4b / 4b is done in 1 cycle (divisor != 0)\n', '   // to generate espresso equations:\n', '   // 1)  smalldiv > smalldiv.e\n', '   // 2)  espresso -Dso -oeqntott smalldiv.e | addassign > smalldiv\n', '\n', '   // smallnum case does not cover divide by 0\n', ""   assign smallnum_case           = ((q_ff[31:4] == 28'b0) & (m_ff[31:4] == 28'b0) & (m_ff[31:0] != 32'b0) & ~rem_ff & valid_e1 & ~dec_tlu_fast_div_disable) |\n"", ""                                    ((q_ff[31:0] == 32'b0) &                         (m_ff[31:0] != 32'b0) & ~rem_ff & valid_e1 & ~dec_tlu_fast_div_disable);\n"", '\n', '\n', '   assign smallnum[3]             = ( q_ff[3] &                                  ~m_ff[3] & ~m_ff[2] & ~m_ff[1]           );\n', '\n', '\n', '   assign smallnum[2]             = ( q_ff[3] &                                  ~m_ff[3] & ~m_ff[2] &            ~m_ff[0]) |\n', '                                    ( q_ff[2] &                                  ~m_ff[3] & ~m_ff[2] & ~m_ff[1]           ) |\n', '                                    ( q_ff[3] &  q_ff[2] &                       ~m_ff[3] & ~m_ff[2]                      );\n', '\n', '\n', '   assign smallnum[1]             = ( q_ff[2] &                                  ~m_ff[3] & ~m_ff[2] &            ~m_ff[0]) |\n', '                                    (                       q_ff[1] &            ~m_ff[3] & ~m_ff[2] & ~m_ff[1]           ) |\n', '                                    ( q_ff[3] &                                  ~m_ff[3] &            ~m_ff[1] & ~m_ff[0]) |\n', '                                    ( q_ff[3] & ~q_ff[2] &                       ~m_ff[3] & ~m_ff[2] &  m_ff[1] &  m_ff[0]) |\n', '                                    (~q_ff[3] &  q_ff[2] &  q_ff[1] &            ~m_ff[3] & ~m_ff[2]                      ) |\n', '                                    ( q_ff[3] &  q_ff[2] &                       ~m_ff[3] &                       ~m_ff[0]) |\n', '                                    ( q_ff[3] &  q_ff[2] &                       ~m_ff[3] &  m_ff[2] & ~m_ff[1]           ) |\n', '                                    ( q_ff[3] &             q_ff[1] & ~m_ff[3] &                       ~m_ff[1]           ) |\n', '                                    ( q_ff[3] &  q_ff[2] &  q_ff[1] &            ~m_ff[3] &  m_ff[2]                      );\n', '\n', '\n', '   assign smallnum[0]             = (            q_ff[2] &  q_ff[1] &  q_ff[0] & ~m_ff[3] &            ~m_ff[1]           ) |\n', '                                    ( q_ff[3] & ~q_ff[2] &  q_ff[0] &            ~m_ff[3] &             m_ff[1] &  m_ff[0]) |\n', '                                    (            q_ff[2] &                       ~m_ff[3] &            ~m_ff[1] & ~m_ff[0]) |\n', '                                    (                       q_ff[1] &            ~m_ff[3] & ~m_ff[2] &            ~m_ff[0]) |\n', '                                    (                                  q_ff[0] & ~m_ff[3] & ~m_ff[2] & ~m_ff[1]           ) |\n', '                                    (~q_ff[3] &  q_ff[2] & ~q_ff[1] &            ~m_ff[3] & ~m_ff[2] &  m_ff[1] &  m_ff[0]) |\n', '                                    (~q_ff[3] &  q_ff[2] &  q_ff[1] &            ~m_ff[3] &                       ~m_ff[0]) |\n', '                                    ( q_ff[3] &                                             ~m_ff[2] & ~m_ff[1] & ~m_ff[0]) |\n', '                                    ( q_ff[3] & ~q_ff[2] &                       ~m_ff[3] &  m_ff[2] &  m_ff[1]           ) |\n', '                                    (~q_ff[3] &  q_ff[2] &  q_ff[1] &            ~m_ff[3] &  m_ff[2] & ~m_ff[1]           ) |\n', '                                    (~q_ff[3] &  q_ff[2] &             q_ff[0] & ~m_ff[3] &            ~m_ff[1]           ) |\n', '                                    ( q_ff[3] & ~q_ff[2] & ~q_ff[1] &            ~m_ff[3] &  m_ff[2] &             m_ff[0]) |\n', '                                    (           ~q_ff[2] &  q_ff[1] &  q_ff[0] & ~m_ff[3] & ~m_ff[2]                      ) |\n', '                                    ( q_ff[3] &  q_ff[2] &                                             ~m_ff[1] & ~m_ff[0]) |\n', '                                    ( q_ff[3] &             q_ff[1] &                       ~m_ff[2] &            ~m_ff[0]) |\n', '                                    (~q_ff[3] &  q_ff[2] &  q_ff[1] &  q_ff[0] & ~m_ff[3] &  m_ff[2]                      ) |\n', '                                    ( q_ff[3] &  q_ff[2] &                        m_ff[3] & ~m_ff[2]                      ) |\n', '                                    ( q_ff[3] &             q_ff[1] &             m_ff[3] & ~m_ff[2] & ~m_ff[1]           ) |\n', '                                    ( q_ff[3] &                        q_ff[0] &            ~m_ff[2] & ~m_ff[1]           ) |\n', '                                    ( q_ff[3] &            ~q_ff[1] &            ~m_ff[3] &  m_ff[2] &  m_ff[1] &  m_ff[0]) |\n', '                                    ( q_ff[3] &  q_ff[2] &  q_ff[1] &             m_ff[3] &                       ~m_ff[0]) |\n', '                                    ( q_ff[3] &  q_ff[2] &  q_ff[1] &             m_ff[3] &            ~m_ff[1]           ) |\n', '                                    ( q_ff[3] &  q_ff[2] &             q_ff[0] &  m_ff[3] &            ~m_ff[1]           ) |\n', '                                    ( q_ff[3] & ~q_ff[2] &  q_ff[1] &            ~m_ff[3] &             m_ff[1]           ) |\n', '                                    ( q_ff[3] &             q_ff[1] &  q_ff[0] &            ~m_ff[2]                      ) |\n', '                                    ( q_ff[3] &  q_ff[2] &  q_ff[1] &  q_ff[0] &  m_ff[3]                                 );\n', '\n', '\n', '\n', '   // END   - short circuit logic for small numbers }}\n', '\n', '\n', '   // *** Start Short Q *** {{\n', '\n', '   logic [4:0]   a_cls;\n', '   logic [4:0]   b_cls;\n', '   logic [5:0]   shortq;\n', '   logic [5:0]   shortq_shift;\n', '   logic [5:0]   shortq_shift_ff;\n', '   logic         shortq_enable;\n', '   logic         shortq_enable_ff;\n', '   logic [32:0]  short_dividend;\n', '\n', '   assign short_dividend[31:0]    =  q_ff[31:0];\n', '   assign short_dividend[32]      =  sign_ff & q_ff[31];\n', '\n', '\n', '   //    A       B\n', '   //   210     210    SH\n', '   //   ---     ---    --\n', '   //   1xx     000     0\n', '   //   1xx     001     8\n', '   //   1xx     01x    16\n', '   //   1xx     1xx    24\n', '   //   01x     000     8\n', '   //   01x     001    16\n', '   //   01x     01x    24\n', '   //   01x     1xx    32\n', '   //   001     000    16\n', '   //   001     001    24\n', '   //   001     01x    32\n', '   //   001     1xx    32\n', '   //   000     000    24\n', '   //   000     001    32\n', '   //   000     01x    32\n', '   //   000     1xx    32\n', '\n', '   logic [3:0]   shortq_raw;\n', '   logic [3:0]   shortq_shift_xx;\n', '\n', ""   assign a_cls[4:3]              =  2'b0;\n"", ""   assign a_cls[2]                =  (~short_dividend[32] & (short_dividend[31:24] != {8{1'b0}})) | ( short_dividend[32] & (short_dividend[31:23] != {9{1'b1}}));\n"", ""   assign a_cls[1]                =  (~short_dividend[32] & (short_dividend[23:16] != {8{1'b0}})) | ( short_dividend[32] & (short_dividend[22:15] != {8{1'b1}}));\n"", ""   assign a_cls[0]                =  (~short_dividend[32] & (short_dividend[15:08] != {8{1'b0}})) | ( short_dividend[32] & (short_dividend[14:07] != {8{1'b1}}));\n"", '\n', ""   assign b_cls[4:3]              =  2'b0;\n"", ""   assign b_cls[2]                =  (~m_ff[32]           & (          m_ff[31:24] != {8{1'b0}})) | ( m_ff[32]           & (          m_ff[31:24] != {8{1'b1}}));\n"", ""   assign b_cls[1]                =  (~m_ff[32]           & (          m_ff[23:16] != {8{1'b0}})) | ( m_ff[32]           & (          m_ff[23:16] != {8{1'b1}}));\n"", ""   assign b_cls[0]                =  (~m_ff[32]           & (          m_ff[15:08] != {8{1'b0}})) | ( m_ff[32]           & (          m_ff[15:08] != {8{1'b1}}));\n"", '\n', ""   assign shortq_raw[3]           = ( (a_cls[2:1] == 2'b01 ) & (b_cls[2]   == 1'b1  ) ) |   // Shift by 32\n"", ""                                    ( (a_cls[2:0] == 3'b001) & (b_cls[2]   == 1'b1  ) ) |\n"", ""                                    ( (a_cls[2:0] == 3'b000) & (b_cls[2]   == 1'b1  ) ) |\n"", ""                                    ( (a_cls[2:0] == 3'b001) & (b_cls[2:1] == 2'b01 ) ) |\n"", ""                                    ( (a_cls[2:0] == 3'b000) & (b_cls[2:1] == 2'b01 ) ) |\n"", ""                                    ( (a_cls[2:0] == 3'b000) & (b_cls[2:0] == 3'b001) );\n"", '\n', ""   assign shortq_raw[2]           = ( (a_cls[2]   == 1'b1  ) & (b_cls[2]   == 1'b1  ) ) |   // Shift by 24\n"", ""                                    ( (a_cls[2:1] == 2'b01 ) & (b_cls[2:1] == 2'b01 ) ) |\n"", ""                                    ( (a_cls[2:0] == 3'b001) & (b_cls[2:0] == 3'b001) ) |\n"", ""                                    ( (a_cls[2:0] == 3'b000) & (b_cls[2:0] == 3'b000) );\n"", '\n', ""   assign shortq_raw[1]           = ( (a_cls[2]   == 1'b1  ) & (b_cls[2:1] == 2'b01 ) ) |   // Shift by 16\n"", ""                                    ( (a_cls[2:1] == 2'b01 ) & (b_cls[2:0] == 3'b001) ) |\n"", ""                                    ( (a_cls[2:0] == 3'b001) & (b_cls[2:0] == 3'b000) );\n"", '\n', ""   assign shortq_raw[0]           = ( (a_cls[2]   == 1'b1  ) & (b_cls[2:0] == 3'b001) ) |   // Shift by  8\n"", ""                                    ( (a_cls[2:1] == 2'b01 ) & (b_cls[2:0] == 3'b000) );\n"", '\n', '\n', ""   assign shortq_enable           =  valid_ff_e1 & (m_ff[31:0] != 32'b0) & (shortq_raw[3:0] != 4'b0);\n"", '\n', '   assign shortq_shift[3:0]       = ({4{shortq_enable}} & shortq_raw[3:0]);\n', '\n', '   rvdff  #(5)  i_shortq_ff       (.*, .clk(active_clk), .din({shortq_enable,shortq_shift[3:0]}), .dout({shortq_enable_ff,shortq_shift_xx[3:0]}));\n', '\n', ""   assign shortq_shift_ff[5:0]    = ({6{shortq_shift_xx[3]}} & 6'b01_1111) |   // 31\n"", ""                                    ({6{shortq_shift_xx[2]}} & 6'b01_1000) |   // 24\n"", ""                                    ({6{shortq_shift_xx[1]}} & 6'b01_0000) |   // 16\n"", ""                                    ({6{shortq_shift_xx[0]}} & 6'b00_1000);    //  8\n"", '\n', '`ifdef ASSERT_ON\n', '\n', '   logic  div_assert_fail;\n', '\n', '   assign div_assert_fail         =  (shortq_shift_xx[3] & shortq_shift_xx[2]) |\n', '                                     (shortq_shift_xx[3] & shortq_shift_xx[1]) |\n', '                                     (shortq_shift_xx[3] & shortq_shift_xx[0]) |\n', '                                     (shortq_shift_xx[2] & shortq_shift_xx[1]) |\n', '                                     (shortq_shift_xx[2] & shortq_shift_xx[0]) |\n', '                                     (shortq_shift_xx[1] & shortq_shift_xx[0]);\n', '\n', '   assert_exu_div_shortq_shift_error: assert #0 (~div_assert_fail) else $display(""ERROR: SHORTQ_SHIFT_XX with multiple shifts ON!"");\n', '\n', '`endif\n', '\n', '   // *** End   Short Q *** }}\n', '\n', '\n', '\n', '\n', '\n', '   assign div_stall               =  run_state;\n', '\n', '   assign run_in                  = (dp.valid | run_state) & ~finish & ~flush_lower_ff;\n', '\n', ""   assign count_in[5:0]           = {6{run_state & ~finish & ~flush_lower_ff & ~shortq_enable}} & (count[5:0] + shortq_shift_ff[5:0] + 6'd1);\n"", '\n', '\n', '   assign finish_early            =  smallnum_case;\n', '\n', ""   assign finish                  = (smallnum_case | ((~rem_ff) ? (count[5:0] == 6'd32) : (count[5:0] == 6'd33))) & ~flush_lower & ~flush_lower_ff;\n"", '\n', ""   assign sign_eff                = ~dp.unsign & (divisor[31:0] != 32'b0);\n"", '\n', '\n', ""   assign q_in[32:0]              = ({33{~run_state                                   }} &  {1'b0,dividend[31:0]}) |\n"", '                                    ({33{ run_state &  (valid_ff_e1 | shortq_enable_ff)}} &  ({dividend_eff[31:0], ~a_in[32]} << shortq_shift_ff[5:0])) |\n', '                                    ({33{ run_state & ~(valid_ff_e1 | shortq_enable_ff)}} &  {q_ff[31:0], ~a_in[32]});\n', '\n', '   assign qff_enable              =  dp.valid | (run_state & ~shortq_enable);\n', '\n', '\n', '\n', '\n', '   assign dividend_eff[31:0]      = (sign_ff & dividend_neg_ff) ? dividend_comp[31:0] : q_ff[31:0];\n', '\n', '\n', '   assign m_eff[32:0]             = (add) ? m_ff[32:0] : ~m_ff[32:0];\n', '\n', ""   assign a_eff_shift[64:0]       = {33'b0, dividend_eff[31:0]} << shortq_shift_ff[5:0];\n"", '\n', '   assign a_eff[32:0]             = ({33{ rem_correct                    }} &  a_ff[32:0]           ) |\n', '                                    ({33{~rem_correct & ~shortq_enable_ff}} & {a_ff[31:0], q_ff[32]}) |\n', '                                    ({33{~rem_correct &  shortq_enable_ff}} &  a_eff_shift[64:32]   );\n', '\n', '   assign a_shift[32:0]           = {33{run_state}} & a_eff[32:0];\n', '\n', ""   assign a_in[32:0]              = {33{run_state}} & (a_shift[32:0] + m_eff[32:0] + {32'b0,~add});\n"", '\n', ""   assign aff_enable              =  dp.valid | (run_state & ~shortq_enable & (count[5:0]!=6'd33)) | rem_correct;\n"", '\n', '\n', '   assign m_already_comp          = (divisor_neg_ff & sign_ff);\n', '\n', '   // if m already complemented, then invert operation add->sub, sub->add\n', '   assign add                     = (a_ff[32] | rem_correct) ^ m_already_comp;\n', '\n', ""   assign rem_correct             = (count[5:0] == 6'd33) & rem_ff & a_ff[32];\n"", '\n', '\n', '\n', '   assign q_ff_eff[31:0]          = (sign_ff & (dividend_neg_ff ^ divisor_neg_ff)) ? q_ff_comp[31:0] : q_ff[31:0];\n', '\n', '   assign a_ff_eff[31:0]          = (sign_ff &  dividend_neg_ff) ? a_ff_comp[31:0] : a_ff[31:0];\n', '\n', ""   assign out[31:0]               = ({32{ smallnum_case_ff          }} & {28'b0, smallnum_ff[3:0]}) |\n"", '                                    ({32{                     rem_ff}} &  a_ff_eff[31:0]          ) |\n', '                                    ({32{~smallnum_case_ff & ~rem_ff}} &  q_ff_eff[31:0]          );\n', '\n', '\n', 'endmodule // exu_div_ctl\n']"
"['// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '\n', '\n', 'module exu_mul_ctl\n', '   import veer_types::*;\n', '(\n', '   input logic         clk,              // Top level clock\n', '   input logic         active_clk,       // Level 1 active clock\n', '   input logic         clk_override,     // Override clock enables\n', '   input logic         rst_l,            // Reset\n', '   input logic         scan_mode,        // Scan mode\n', '\n', '   input logic [31:0]  a,                // A operand\n', '   input logic [31:0]  b,                // B operand\n', '\n', '   input logic [31:0]  lsu_result_dc3,   // Load result used in E1 bypass\n', '\n', '   input logic         freeze,           // Pipeline freeze\n', '\n', '   input mul_pkt_t     mp,               // valid, rs1_sign, rs2_sign, low, load_mul_rs1_bypass_e1, load_mul_rs2_bypass_e1\n', '\n', '\n', '   output logic [31:0] out               // Result\n', '\n', '   );\n', '\n', '\n', '   logic                valid_e1, valid_e2;\n', '   logic                mul_c1_e1_clken,   mul_c1_e2_clken,   mul_c1_e3_clken;\n', '   logic                exu_mul_c1_e1_clk, exu_mul_c1_e2_clk, exu_mul_c1_e3_clk;\n', '\n', '   logic        [31:0]  a_ff_e1, a_e1;\n', '   logic        [31:0]  b_ff_e1, b_e1;\n', '   logic                load_mul_rs1_bypass_e1, load_mul_rs2_bypass_e1;\n', '   logic                rs1_sign_e1, rs1_neg_e1;\n', '   logic                rs2_sign_e1, rs2_neg_e1;\n', '   logic signed [32:0]  a_ff_e2, b_ff_e2;\n', '   logic        [63:0]  prod_e3;\n', '   logic                low_e1, low_e2, low_e3;\n', '\n', '\n', '   // --------------------------- Clock gating   ----------------------------------\n', '\n', '   // C1 clock enables\n', '   assign mul_c1_e1_clken        = (mp.valid | clk_override) & ~freeze;\n', '   assign mul_c1_e2_clken        = (valid_e1 | clk_override) & ~freeze;\n', '   assign mul_c1_e3_clken        = (valid_e2 | clk_override) & ~freeze;\n', '\n', '`ifndef RV_FPGA_OPTIMIZE\n', '   // C1 - 1 clock pulse for data\n', '   rvclkhdr exu_mul_c1e1_cgc     (.*, .en(mul_c1_e1_clken),   .l1clk(exu_mul_c1_e1_clk));   // ifndef FPGA_OPTIMIZE\n', '   rvclkhdr exu_mul_c1e2_cgc     (.*, .en(mul_c1_e2_clken),   .l1clk(exu_mul_c1_e2_clk));   // ifndef FPGA_OPTIMIZE\n', '   rvclkhdr exu_mul_c1e3_cgc     (.*, .en(mul_c1_e3_clken),   .l1clk(exu_mul_c1_e3_clk));   // ifndef FPGA_OPTIMIZE\n', '`endif\n', '\n', '\n', '   // --------------------------- Input flops    ----------------------------------\n', '\n', '   rvdffs      #(1)  valid_e1_ff      (.*, .din(mp.valid),                  .dout(valid_e1),               .clk(active_clk),        .en(~freeze));\n', '\n', '   rvdff_fpga  #(1)  rs1_sign_e1_ff   (.*, .din(mp.rs1_sign),               .dout(rs1_sign_e1),            .clk(exu_mul_c1_e1_clk), .clken(mul_c1_e1_clken), .rawclk(clk));\n', '   rvdff_fpga  #(1)  rs2_sign_e1_ff   (.*, .din(mp.rs2_sign),               .dout(rs2_sign_e1),            .clk(exu_mul_c1_e1_clk), .clken(mul_c1_e1_clken), .rawclk(clk));\n', '   rvdff_fpga  #(1)  low_e1_ff        (.*, .din(mp.low),                    .dout(low_e1),                 .clk(exu_mul_c1_e1_clk), .clken(mul_c1_e1_clken), .rawclk(clk));\n', '   rvdff_fpga  #(1)  ld_rs1_byp_e1_ff (.*, .din(mp.load_mul_rs1_bypass_e1), .dout(load_mul_rs1_bypass_e1), .clk(exu_mul_c1_e1_clk), .clken(mul_c1_e1_clken), .rawclk(clk));\n', '   rvdff_fpga  #(1)  ld_rs2_byp_e1_ff (.*, .din(mp.load_mul_rs2_bypass_e1), .dout(load_mul_rs2_bypass_e1), .clk(exu_mul_c1_e1_clk), .clken(mul_c1_e1_clken), .rawclk(clk));\n', '\n', '   rvdffe  #(32) a_e1_ff          (.*, .din(a[31:0]),                   .dout(a_ff_e1[31:0]),          .en(mul_c1_e1_clken));\n', '   rvdffe  #(32) b_e1_ff          (.*, .din(b[31:0]),                   .dout(b_ff_e1[31:0]),          .en(mul_c1_e1_clken));\n', '\n', '\n', '\n', '   // --------------------------- E1 Logic Stage ----------------------------------\n', '\n', '   assign a_e1[31:0]             = (load_mul_rs1_bypass_e1)  ?  lsu_result_dc3[31:0]  :  a_ff_e1[31:0];\n', '   assign b_e1[31:0]             = (load_mul_rs2_bypass_e1)  ?  lsu_result_dc3[31:0]  :  b_ff_e1[31:0];\n', '\n', '   assign rs1_neg_e1             =  rs1_sign_e1 & a_e1[31];\n', '   assign rs2_neg_e1             =  rs2_sign_e1 & b_e1[31];\n', '\n', '\n', '   rvdffs       #(1)  valid_e2_ff      (.*, .din(valid_e1),                  .dout(valid_e2),          .clk(active_clk),        .en(~freeze));\n', '\n', '   rvdff_fpga   #(1)    low_e2_ff      (.*, .din(low_e1),                    .dout(low_e2),            .clk(exu_mul_c1_e2_clk), .clken(mul_c1_e2_clken), .rawclk(clk));\n', '\n', '   rvdffe  #(33) a_e2_ff          (.*, .din({rs1_neg_e1, a_e1[31:0]}),  .dout(a_ff_e2[32:0]),          .en(mul_c1_e2_clken));\n', '   rvdffe  #(33) b_e2_ff          (.*, .din({rs2_neg_e1, b_e1[31:0]}),  .dout(b_ff_e2[32:0]),          .en(mul_c1_e2_clken));\n', '\n', '\n', '\n', '   // ---------------------- E2 Logic Stage --------------------------\n', '\n', '\n', '   logic signed [65:0]  prod_e2;\n', '\n', '   assign prod_e2[65:0]          =  a_ff_e2  *  b_ff_e2;\n', '\n', '   rvdff_fpga  #(1)    low_e3_ff      (.*, .din(low_e2),                    .dout(low_e3),                 .clk(exu_mul_c1_e3_clk), .clken(mul_c1_e3_clken), .rawclk(clk));\n', '\n', '   rvdffe      #(64) prod_e3_ff       (.*, .din(prod_e2[63:0]),             .dout(prod_e3[63:0]),          .en(mul_c1_e3_clken));\n', '\n', '\n', '\n', '   // ----------------------- E3 Logic Stage -------------------------\n', '\n', '\n', '   assign out[31:0]            = low_e3  ?  prod_e3[31:0]  :  prod_e3[63:32];\n', '\n', '\n', 'endmodule // exu_mul_ctl\n']"
"['//********************************************************************************\n', '// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '//********************************************************************************\n', '//********************************************************************************\n', '// Function: Top level file for Icache, Fetch, Branch prediction & Aligner\n', '// BFF -> F1 -> F2 -> A\n', '//********************************************************************************\n', '\n', 'module ifu\n', '   import veer_types::*;\n', '(\n', '   input logic free_clk,\n', '   input logic active_clk,\n', '   input logic clk,\n', '   input logic clk_override,\n', '   input logic rst_l,\n', '\n', '   input logic dec_ib3_valid_d, dec_ib2_valid_d, // mass balance for decode buffer\n', '\n', '   input logic dec_ib0_valid_eff_d,   // effective valid taking decode into account\n', '   input logic dec_ib1_valid_eff_d,   // effective valid taking decode into account\n', '\n', '   input logic        exu_i0_br_ret_e4, // i0 branch commit is a ret\n', '   input logic        exu_i1_br_ret_e4, // i1 branch commit is a ret\n', '   input logic        exu_i0_br_call_e4, // i0 branch commit is a call\n', '   input logic        exu_i1_br_call_e4, // i1 branch commit is a call\n', '\n', '   input logic exu_flush_final, // flush, includes upper and lower\n', '   input logic dec_tlu_flush_err_wb , // flush due to parity error.\n', ""   input logic dec_tlu_flush_noredir_wb, // don't fetch, validated with exu_flush_final\n"", '   input logic dec_tlu_dbg_halted, // halted, used for leaving IDLE state\n', '   input logic dec_tlu_pmu_fw_halted, // Core is halted\n', '   input logic [31:1] exu_flush_path_final, // flush fetch address\n', '   input logic        exu_flush_upper_e2,    // flush upper, either i0 or i1\n', '\n', '   input logic [31:0]  dec_tlu_mrac_ff ,// Side_effect , cacheable for each region\n', '   input logic         dec_tlu_fence_i_wb, // fence.i, invalidate icache, validated with exu_flush_final\n', '   input logic         dec_tlu_flush_leak_one_wb, // ignore bp for leak one fetches\n', '\n', '   input logic                       dec_tlu_bpred_disable, // disable all branch prediction\n', '   input logic                       dec_tlu_core_ecc_disable,  // disable ecc checking and flagging\n', '\n', '   // AXI Write Channels - IFU never writes. So, 0 out mostly\n', '   output logic                           ifu_axi_awvalid,\n', '   input  logic                           ifu_axi_awready,\n', '   output logic [`RV_IFU_BUS_TAG-1:0]     ifu_axi_awid,\n', '   output logic [31:0]                    ifu_axi_awaddr,\n', '   output logic [3:0]                     ifu_axi_awregion,\n', '   output logic [7:0]                     ifu_axi_awlen,\n', '   output logic [2:0]                     ifu_axi_awsize,\n', '   output logic [1:0]                     ifu_axi_awburst,\n', '   output logic                           ifu_axi_awlock,\n', '   output logic [3:0]                     ifu_axi_awcache,\n', '   output logic [2:0]                     ifu_axi_awprot,\n', '   output logic [3:0]                     ifu_axi_awqos,\n', '\n', '   output logic                           ifu_axi_wvalid,\n', '   input  logic                           ifu_axi_wready,\n', '   output logic [63:0]                    ifu_axi_wdata,\n', '   output logic [7:0]                     ifu_axi_wstrb,\n', '   output logic                           ifu_axi_wlast,\n', '\n', '   input  logic                           ifu_axi_bvalid,\n', '   output logic                           ifu_axi_bready,\n', '   input  logic [1:0]                     ifu_axi_bresp,\n', '   input  logic [`RV_IFU_BUS_TAG-1:0]     ifu_axi_bid,\n', '\n', '   // AXI Read Channels\n', '   output logic                           ifu_axi_arvalid,\n', '   input  logic                           ifu_axi_arready,\n', '   output logic [`RV_IFU_BUS_TAG-1:0]     ifu_axi_arid,\n', '   output logic [31:0]                    ifu_axi_araddr,\n', '   output logic [3:0]                     ifu_axi_arregion,\n', '   output logic [7:0]                     ifu_axi_arlen,\n', '   output logic [2:0]                     ifu_axi_arsize,\n', '   output logic [1:0]                     ifu_axi_arburst,\n', '   output logic                           ifu_axi_arlock,\n', '   output logic [3:0]                     ifu_axi_arcache,\n', '   output logic [2:0]                     ifu_axi_arprot,\n', '   output logic [3:0]                     ifu_axi_arqos,\n', '\n', '   input  logic                           ifu_axi_rvalid,\n', '   output logic                           ifu_axi_rready,\n', '   input  logic [`RV_IFU_BUS_TAG-1:0]     ifu_axi_rid,\n', '   input  logic [63:0]                    ifu_axi_rdata,\n', '   input  logic [1:0]                     ifu_axi_rresp,\n', '   input  logic                           ifu_axi_rlast,\n', '\n', ' //// AHB LITE BUS\n', '//`ifdef RV_BUILD_AHB_LITE\n', '   input  logic                      ifu_bus_clk_en,\n', '\n', '\n', '   input  logic                      dma_iccm_req,\n', '   input  logic                      dma_iccm_stall_any,\n', '   input  logic [31:0]               dma_mem_addr,\n', '   input  logic [2:0]                dma_mem_sz,\n', '   input  logic                      dma_mem_write,\n', '   input  logic [63:0]               dma_mem_wdata,\n', '\n', '   output logic                      iccm_dma_ecc_error,\n', '   output logic                      iccm_dma_rvalid,\n', '   output logic [63:0]               iccm_dma_rdata,\n', '   output logic                      iccm_ready,\n', '\n', '//`endif\n', '\n', '   output logic [1:0] ifu_pmu_instr_aligned,\n', '   output logic       ifu_pmu_align_stall,\n', '   output logic       ifu_pmu_fetch_stall,\n', '\n', '//   I$ & ITAG Ports\n', '   output logic [31:2]               ic_rw_addr,         // Read/Write addresss to the Icache.\n', '   output logic [3:0]                ic_wr_en,           // Icache write enable, when filling the Icache.\n', '   output logic                      ic_rd_en,           // Icache read  enable.\n', '`ifdef RV_ICACHE_ECC\n', '   output logic [83:0]               ic_wr_data,         // Data to fill to the Icache. With ECC\n', '   input  logic [167:0]              ic_rd_data ,        // Data read from Icache. 2x64bits + parity bits. F2 stage. With ECC\n', '   input  logic [24:0]               ictag_debug_rd_data,// Debug icache tag.\n', '   output logic [41:0]               ic_debug_wr_data,   // Debug wr cache.\n', '   output logic [41:0]               ifu_ic_debug_rd_data,\n', '`else\n', '   output logic [67:0]               ic_wr_data,         // Data to fill to the Icache. With Parity\n', '   input  logic [135:0]              ic_rd_data ,        // Data read from Icache. 2x64bits + parity bits. F2 stage. With Parity\n', '   input  logic [20:0]               ictag_debug_rd_data,// Debug icache tag.\n', '   output logic [33:0]               ic_debug_wr_data,   // Debug wr cache.\n', '   output logic [33:0]               ifu_ic_debug_rd_data,\n', '`endif\n', '\n', '\n', '   output logic [127:0]              ic_premux_data,     // Premux data to be muxed with each way of the Icache.\n', '   output logic                      ic_sel_premux_data, // Select the premux data.\n', '\n', '   output logic [15:2]               ic_debug_addr,      // Read/Write addresss to the Icache.\n', '   output logic                      ic_debug_rd_en,     // Icache debug rd\n', '   output logic                      ic_debug_wr_en,     // Icache debug wr\n', '   output logic                      ic_debug_tag_array, // Debug tag array\n', '   output logic [3:0]                ic_debug_way,       // Debug way. Rd or Wr.\n', '\n', '\n', '   output logic [3:0]                ic_tag_valid,       // Valid bits when accessing the Icache. One valid bit per way. F2 stage\n', '\n', '   input  logic [3:0]                ic_rd_hit,          // Compare hits from Icache tags. Per way.  F2 stage\n', '   input  logic                      ic_tag_perr,        // Icache Tag parity error\n', '\n', '\n', '`ifdef RV_ICCM_ENABLE\n', '   // ICCM ports\n', '   output logic [`RV_ICCM_BITS-1:2]               iccm_rw_addr,       // ICCM read/write address.\n', '   output logic                      iccm_wren,          // ICCM write enable (through the DMA)\n', '   output logic                      iccm_rden,          // ICCM read enable.\n', '   output logic [77:0]               iccm_wr_data,       // ICCM write data.\n', '   output logic [2:0]                iccm_wr_size,       // ICCM write location within DW.\n', '\n', '   input  logic [155:0]              iccm_rd_data,       // Data read from ICCM.\n', '`endif\n', '\n', '// Perf counter sigs\n', '   output logic       ifu_pmu_ic_miss, // ic miss\n', '   output logic       ifu_pmu_ic_hit, // ic hit\n', '   output logic       ifu_pmu_bus_error, // iside bus error\n', '   output logic       ifu_pmu_bus_busy,  // iside bus busy\n', '   output logic       ifu_pmu_bus_trxn, // iside bus transactions\n', '\n', '\n', '   output logic  ifu_i0_valid,        // Instruction 0 valid. From Aligner to Decode\n', '   output logic  ifu_i1_valid,        // Instruction 1 valid. From Aligner to Decode\n', '   output logic  ifu_i0_icaf,         // Instruction 0 access fault. From Aligner to Decode\n', '   output logic  ifu_i1_icaf,         // Instruction 1 access fault. From Aligner to Decode\n', '   output logic  ifu_i0_icaf_second,      // Instruction 0 has access fault on second 2B of 4B inst\n', '   output logic  ifu_i1_icaf_second,      // Instruction 1 has access fault on second 2B of 4B inst\n', '   output logic  ifu_i0_perr,         // Instruction 0 parity error. From Aligner to Decode\n', '   output logic  ifu_i1_perr,         // Instruction 1 parity error. From Aligner to Decode\n', '   output logic  ifu_i0_sbecc,        // Instruction 0 has single bit ecc error\n', '   output logic  ifu_i1_sbecc,        // Instruction 1 has single bit ecc error\n', '   output logic  ifu_i0_dbecc,        // Instruction 0 has double bit ecc error\n', '   output logic  ifu_i1_dbecc,        // Instruction 1 has double bit ecc error\n', '   output logic  iccm_dma_sb_error,   // Single Bit ECC error from a DMA access\n', '   output logic[31:0] ifu_i0_instr,   // Instruction 0 . From Aligner to Decode\n', '   output logic[31:0] ifu_i1_instr,   // Instruction 1 . From Aligner to Decode\n', '   output logic[31:1] ifu_i0_pc,      // Instruction 0 pc. From Aligner to Decode\n', '   output logic[31:1] ifu_i1_pc,      // Instruction 1 pc. From Aligner to Decode\n', '   output logic ifu_i0_pc4,           // Instruction 0 is 4 byte. From Aligner to Decode\n', '   output logic ifu_i1_pc4,           // Instruction 1 is 4 byte. From Aligner to Decode\n', '   output logic [15:0] ifu_illegal_inst, // Illegal instruction.\n', '\n', '   output logic ifu_miss_state_idle,   // There is no outstanding miss. Cache miss state is idle.\n', '\n', '\n', '   output br_pkt_t i0_brp,           // Instruction 0 branch packet. From Aligner to Decode\n', '   output br_pkt_t i1_brp,           // Instruction 1 branch packet. From Aligner to Decode\n', '\n', '   input predict_pkt_t  exu_mp_pkt, // mispredict packet\n', '   input logic [`RV_BHT_GHR_RANGE] exu_mp_eghr, // execute ghr\n', '\n', '   input br_tlu_pkt_t dec_tlu_br0_wb_pkt, // slot0 update/error pkt\n', '   input br_tlu_pkt_t dec_tlu_br1_wb_pkt, // slot1 update/error pkt\n', '   input dec_tlu_flush_lower_wb,\n', '\n', '   input rets_pkt_t exu_rets_e1_pkt, // E1 return stack packet\n', '   input rets_pkt_t exu_rets_e4_pkt, // E4 return stack packet\n', '\n', ""   // pc's  used to maintain and update the BP RET stacks\n"", '`ifdef REAL_COMM_RS\n', '   input logic [31:1] exu_i0_pc_e1,\n', '   input logic [31:1] exu_i1_pc_e1,\n', '   input logic [31:1] dec_tlu_i0_pc_e4,\n', '   input logic [31:1] dec_tlu_i1_pc_e4,\n', '`endif\n', '\n', '   output logic [15:0] ifu_i0_cinst,\n', '   output logic [15:0] ifu_i1_cinst,\n', '\n', '\n', '/// Icache debug\n', '   input  cache_debug_pkt_t        dec_tlu_ic_diag_pkt ,\n', '   output logic                    ifu_ic_debug_rd_data_valid,\n', '\n', '\n', '\n', '   input logic scan_mode\n', '   );\n', '\n', '   localparam TAGWIDTH = 2 ;\n', '   localparam IDWIDTH  = 2 ;\n', '\n', '   logic                   ifu_fb_consume1, ifu_fb_consume2;\n', '   logic [31:1]            ifc_fetch_addr_f2;\n', '   logic                   ifc_fetch_uncacheable_f1;\n', '\n', '   logic [7:0]   ifu_fetch_val;  // valids on a 2B boundary, left justified [7] implies valid fetch\n', '   logic [31:1]  ifu_fetch_pc;   // starting pc of fetch\n', '\n', '   logic [31:1] ifc_fetch_addr_f1;\n', '\n', '   logic        ic_crit_wd_rdy;\n', '   logic        ic_write_stall;\n', '   logic        ic_dma_active;\n', '   logic        ifc_dma_access_ok;\n', '   logic        ifc_iccm_access_f1;\n', '   logic        ifc_region_acc_fault_f1;\n', '   logic [7:0]  ic_access_fault_f2;\n', '   logic        ifu_ic_mb_empty;\n', '\n', '\n', '   logic ic_hit_f2;\n', '\n', '\n', '`ifdef RV_BTB_48\n', '   logic [7:0][1:0] ifu_bp_way_f2; // way indication; right justified\n', '`else\n', '   logic [7:0]  ifu_bp_way_f2; // way indication; right justified\n', '`endif\n', '   logic  ifu_bp_kill_next_f2; // kill next fetch; taken target found\n', '   logic [31:1] ifu_bp_btb_target_f2; //  predicted target PC\n', '   logic [7:1]  ifu_bp_inst_mask_f2; // tell ic which valids to kill because of a taken branch; right justified\n', '   logic [7:0]  ifu_bp_hist1_f2; // history counters for all 4 potential branches; right justified\n', '   logic [7:0]  ifu_bp_hist0_f2; // history counters for all 4 potential branches; right justified\n', '   logic [11:0] ifu_bp_poffset_f2; // predicted target\n', '   logic [7:0]  ifu_bp_ret_f2; // predicted ret ; right justified\n', '   logic [7:0]  ifu_bp_pc4_f2; // pc4 indication; right justified\n', '   logic [7:0]  ifu_bp_valid_f2; // branch valid, right justified\n', '   logic [`RV_BHT_GHR_RANGE] ifu_bp_fghr_f2;\n', '\n', '   logic [7:0]   ic_fetch_val_f2;\n', '   logic [127:0] ic_data_f2;\n', '   logic [127:0] ifu_fetch_data;\n', '   logic ifc_fetch_req_f1_raw, ifc_fetch_req_f1, ifc_fetch_req_f2;\n', '   logic ic_rd_parity_final_err;  // This fetch has a  data_cache or tag  parity error.\n', '   logic iccm_rd_ecc_single_err;  // This fetch has an iccm single error.\n', '   logic [7:0] iccm_rd_ecc_double_err;  // This fetch has an iccm double error.\n', '\n', '   icache_err_pkt_t ic_error_f2;\n', '\n', '   logic         ifu_icache_fetch_f2 ;\n', '   logic [16:2]  ifu_icache_error_index;       //  Index with parity error\n', '   logic         ifu_icache_error_val;   //  Parity error\n', '   logic         ifu_icache_sb_error_val;\n', '\n', '   assign ifu_fetch_data[127:0] = ic_data_f2[127:0];\n', '   assign ifu_fetch_val[7:0] = ic_fetch_val_f2[7:0];\n', '   assign ifu_fetch_pc[31:1] = ifc_fetch_addr_f2[31:1];\n', '\n', '   // fetch control\n', '   ifu_ifc_ctl ifc (.*\n', '                    );\n', '\n', '   // aligner\n', '   ifu_aln_ctl aln (.*\n', '                    );\n', '\n', '   // branch predictor\n', '   ifu_bp_ctl bp (.*);\n', '\n', '   // icache\n', '   ifu_mem_ctl mem_ctl\n', '     (.*,\n', '      .fetch_addr_f1(ifc_fetch_addr_f1),\n', '      .ifu_icache_error_index(ifu_icache_error_index[16:6]),\n', '      .ic_hit_f2(ic_hit_f2),\n', '      .ic_data_f2(ic_data_f2[127:0])\n', '      );\n', '\n', '\n', '\n', '   // Performance debug info\n', '   //\n', '   //\n', '`ifdef DUMP_BTB_ON\n', '   logic              exu_mp_valid; // conditional branch mispredict\n', '   logic exu_mp_way; // conditional branch mispredict\n', '   logic exu_mp_ataken; // direction is actual taken\n', '   logic exu_mp_boffset; // branch offsett\n', '   logic exu_mp_pc4; // branch is a 4B inst\n', '   logic exu_mp_call; // branch is a call inst\n', '   logic exu_mp_ret; // branch is a ret inst\n', '   logic exu_mp_ja; // branch is a jump always\n', '   logic [1:0] exu_mp_hist; // new history\n', '   logic [11:0] exu_mp_tgt; // target offset\n', '   logic [`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] exu_mp_addr; // BTB/BHT address\n', '   logic [1:0]                          exu_mp_bank; // write bank; based on branch PC[3:2]\n', '   logic [`RV_BTB_BTAG_SIZE-1:0] exu_mp_btag; // branch tag\n', '   logic [`RV_BHT_GHR_RANGE] exu_mp_fghr; // original fetch ghr (for correcting dir)\n', '\n', '   assign exu_mp_valid = exu_mp_pkt.misp; // conditional branch mispredict\n', '   assign exu_mp_ataken = exu_mp_pkt.ataken;  // direction is actual taken\n', '   assign exu_mp_boffset = exu_mp_pkt.boffset;  // branch offset\n', '   assign exu_mp_pc4 = exu_mp_pkt.pc4;  // branch is a 4B inst\n', '   assign exu_mp_call = exu_mp_pkt.pcall;  // branch is a call inst\n', '   assign exu_mp_ret = exu_mp_pkt.pret;  // branch is a ret inst\n', '   assign exu_mp_ja = exu_mp_pkt.pja;  // branch is a jump always\n', '   assign exu_mp_way = exu_mp_pkt.way;  // branch is a jump always\n', '   assign exu_mp_hist[1:0] = exu_mp_pkt.hist[1:0];  // new history\n', '   assign exu_mp_tgt[11:0]  = exu_mp_pkt.toffset[11:0] ;  // target offset\n', '   assign exu_mp_addr[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO]  = exu_mp_pkt.index[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] ;  // BTB/BHT address\n', '   assign exu_mp_bank[1:0]  = exu_mp_pkt.bank[1:0] ;  // write bank = exu_mp_pkt.;  based on branch PC[3:2]\n', '   assign exu_mp_btag = exu_mp_pkt.btag[`RV_BTB_BTAG_SIZE-1:0] ;  // branch tag\n', '   assign exu_mp_fghr[`RV_BHT_GHR_RANGE]  = exu_mp_pkt.fghr[`RV_BHT_GHR_RANGE] ;  // original fetch ghr (for correcting dir)\n', '\n', '   logic [`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] btb_rd_addr_f2;\n', ' `define DEC `CPU_TOP.dec\n', ' `define EXU `CPU_TOP.exu\n', '   rvbtb_addr_hash f2hash(.pc(ifc_fetch_addr_f2[31:1]), .hash(btb_rd_addr_f2[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO]));\n', '   logic [31:0] mppc_ns, mppc;\n', '   assign mppc_ns[31:1] = `EXU.exu_i0_flush_upper_e1 ? `DEC.decode.i0_pc_e1[31:1] : (`EXU.exu_i1_flush_upper_e1 ? `DEC.decode.i1_pc_e1[31:1] : (`EXU.exu_i0_flush_lower_e4 ?  `DEC.decode.i0_pc_e4[31:1] :  `DEC.decode.i1_pc_e4[31:1]));\n', ""   assign mppc_ns[0] = 1'b0;\n"", '   logic [3:0] ic_rd_hit_f2;\n', '   rvdff #(36)  junk_ff (.*, .clk(free_clk), .din({mppc_ns[31:0], mem_ctl.ic_rd_hit[3:0]}), .dout({mppc[31:0],ic_rd_hit_f2[3:0]}));\n', 'logic [2:0] tmp_bnk;\n', 'assign tmp_bnk[2:0] = encode8_3(bp.btb_sel_f2[7:0]);\n', '   always @(negedge clk) begin\n', ""      if(`DEC.tlu.mcyclel[31:0] == 32'h0000_0010) begin\n"", '         $display(""BTB_CONFIG: %d"",`RV_BTB_ARRAY_DEPTH*4);\n', '         `ifndef BP_NOGSHARE\n', '         $display(""BHT_CONFIG: %d gshare: 1"",`RV_BHT_ARRAY_DEPTH*4);\n', '         `else\n', '         $display(""BHT_CONFIG: %d gshare: 0"",`RV_BHT_ARRAY_DEPTH*4);\n', '         `endif\n', '         $display(""RS_CONFIG: %d"", `RV_RET_STACK_SIZE);\n', '      end\n', '       if(exu_flush_final & ~(dec_tlu_br0_wb_pkt.br_error | dec_tlu_br0_wb_pkt.br_start_error | dec_tlu_br1_wb_pkt.br_error | dec_tlu_br1_wb_pkt.br_start_error) & (exu_mp_pkt.misp | exu_mp_pkt.ataken))\n', '         $display(""%7d BTB_MP  : index: %0h bank: %0h call: %b ret: %b ataken: %b hist: %h valid: %b tag: %h targ: %h eghr: %b pred: %b ghr_index: %h brpc: %h way: %h"", `DEC.tlu.mcyclel[31:0]+32\'ha, exu_mp_addr[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO], exu_mp_bank[1:0], exu_mp_call, exu_mp_ret, exu_mp_ataken, exu_mp_hist[1:0], exu_mp_valid, exu_mp_pkt.btag[`RV_BTB_BTAG_SIZE-1:0], {exu_flush_path_final[31:1], 1\'b0}, exu_mp_eghr[`RV_BHT_GHR_RANGE], exu_mp_valid, bp.bht_wr_addr0, mppc[31:0], exu_mp_pkt.way);\n', '     for(int i = 0; i < 8; i++) begin\n', '      if(ifu_bp_valid_f2[i] & ifc_fetch_req_f2)\n', '        $display(""%7d BTB_HIT : index: %0h bank: %0h call: %b ret: %b taken: %b strength: %b tag: %h targ: %h ghr: %4b ghr_index: %h way: %h"", `DEC.tlu.mcyclel[31:0]+32\'ha,btb_rd_addr_f2[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO],encode8_3(bp.btb_sel_f2[7:0]), bp.btb_rd_call_f2, bp.btb_rd_ret_f2, ifu_bp_hist1_f2[tmp_bnk], ifu_bp_hist0_f2[tmp_bnk], bp.fetch_rd_tag_f2[`RV_BTB_BTAG_SIZE-1:0], {ifu_bp_btb_target_f2[31:1], 1\'b0}, bp.fghr[`RV_BHT_GHR_RANGE], bp.bht_rd_addr_f1, ifu_bp_way_f2[tmp_bnk]);\n', '     end\n', '`ifdef RV_BTB_48\n', '      for(int y = 0; y < 4; y++) begin\n', '         for(int z = 0; z < 4; z++) begin\n', '            if(bp.lru_bank_sel[y][z])\n', '              $display(""%7d BTB_LRU: index: %0h bank: %0h newlru %h"", `DEC.tlu.mcyclel[31:0]+32\'ha, z,y,bp.lru_bank_wr_data[y][z]);\n', '         end\n', '      end\n', '`endif\n', '      if(dec_tlu_br0_wb_pkt.valid & ~(dec_tlu_br0_wb_pkt.br_error | dec_tlu_br0_wb_pkt.br_start_error))\n', '        $display(""%7d BTB_UPD0: ghr_index: %0h bank: %0h hist: %h  way: %h"", `DEC.tlu.mcyclel[31:0]+32\'ha,bp.br0_hashed_wb[`RV_BHT_ADDR_HI:`RV_BHT_ADDR_LO],{dec_tlu_br0_wb_pkt.bank[1:0],dec_tlu_br0_wb_pkt.middle}, dec_tlu_br0_wb_pkt.hist, dec_tlu_br0_wb_pkt.way);\n', '      if(dec_tlu_br1_wb_pkt.valid & ~(dec_tlu_br1_wb_pkt.br_error | dec_tlu_br1_wb_pkt.br_start_error))\n', '        $display(""%7d BTB_UPD1: ghr_index: %0h bank: %0h hist: %h  way: %h"", `DEC.tlu.mcyclel[31:0]+32\'ha,bp.br1_hashed_wb[`RV_BHT_ADDR_HI:`RV_BHT_ADDR_LO],{dec_tlu_br1_wb_pkt.bank[1:0],dec_tlu_br1_wb_pkt.middle}, dec_tlu_br1_wb_pkt.hist, dec_tlu_br1_wb_pkt.way);\n', '      if(dec_tlu_br0_wb_pkt.br_error | dec_tlu_br0_wb_pkt.br_start_error)\n', '        $display(""%7d BTB_ERR0: index: %0h bank: %0h start: %b rfpc: %h way: %h"", `DEC.tlu.mcyclel[31:0]+32\'ha,dec_tlu_br0_wb_pkt.index[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO],dec_tlu_br0_wb_pkt.bank[1:0], dec_tlu_br0_wb_pkt.br_start_error, {exu_flush_path_final[31:1], 1\'b0}, dec_tlu_br0_wb_pkt.way);\n', '      if(dec_tlu_br1_wb_pkt.br_error | dec_tlu_br1_wb_pkt.br_start_error)\n', '        $display(""%7d BTB_ERR1: index: %0h bank: %0h start: %b rfpc: %h way: %h"", `DEC.tlu.mcyclel[31:0]+32\'ha,dec_tlu_br1_wb_pkt.index[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO],dec_tlu_br1_wb_pkt.bank[1:0], dec_tlu_br1_wb_pkt.br_start_error, {exu_flush_path_final[31:1], 1\'b0}, dec_tlu_br1_wb_pkt.way);\n', '   end // always @ (negedge clk)\n', '      function [2:0] encode8_3;\n', '      input [7:0] in;\n', '\n', '      encode8_3[2] = |in[7:4];\n', '      encode8_3[1] = in[7] | in[6] | in[3] | in[2];\n', '      encode8_3[0] = in[7] | in[5] | in[3] | in[1];\n', '\n', '   endfunction\n', '`endif\n', 'endmodule // ifu\n']"
"['//********************************************************************************\n', '// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '//********************************************************************************\n', '\n', '//********************************************************************************\n', '// Function: Instruction aligner\n', '//********************************************************************************\n', 'module ifu_aln_ctl\n', '   import veer_types::*;\n', '(\n', '\n', '   input logic        active_clk,\n', '\n', '   input logic        iccm_rd_ecc_single_err,         // This fetch has a single ICCM ecc  error.\n', '   input logic [7:0]  iccm_rd_ecc_double_err,         // This fetch has a double ICCM ecc  error.\n', '   input logic        ic_rd_parity_final_err,         // for tag parity errors\n', '\n', '   input logic        ifu_icache_fetch_f2,\n', '\n', '   input logic [7:0]  ic_access_fault_f2,             // Instruction access fault for the current fetch.\n', '   input logic [`RV_BHT_GHR_RANGE]  ifu_bp_fghr_f2,   // fetch GHR\n', '   input logic [31:1] ifu_bp_btb_target_f2,           //  predicted RET target\n', '   input logic [11:0] ifu_bp_poffset_f2,              // predicted target offset\n', '\n', '   input logic [7:0]  ifu_bp_hist0_f2,    // history counters for all 4 potential branches, bit 1, right justified\n', '   input logic [7:0]  ifu_bp_hist1_f2,    // history counters for all 4 potential branches, bit 1, right justified\n', '   input logic [7:0]  ifu_bp_pc4_f2,      // pc4 indication, right justified\n', '`ifdef RV_BTB_48\n', '   input logic [7:0][1:0]  ifu_bp_way_f2, // way indication, right justified\n', '`else\n', '   input logic [7:0]  ifu_bp_way_f2,      // way indication, right justified\n', '`endif\n', '   input logic [7:0]  ifu_bp_valid_f2,    // branch valid, right justified\n', '   input logic [7:0]  ifu_bp_ret_f2,      // predicted ret indication, right justified\n', '\n', '   input logic exu_flush_final,           // Flush from the pipeline.\n', '\n', '   input logic dec_ib3_valid_d,           // valids for top 2 instruction buffers at decode\n', '   input logic dec_ib2_valid_d,\n', '\n', '   input logic dec_ib0_valid_eff_d,       // effective valid taking decode into account\n', '   input logic dec_ib1_valid_eff_d,\n', '\n', '\n', '   input logic [127:0] ifu_fetch_data,      // fetch data in memory format - not right justified\n', '\n', '   input icache_err_pkt_t ic_error_f2,      // based on configuration: either parity or ecc\n', '\n', '\n', '   input logic [7:0]   ifu_fetch_val,       // valids on a 2B boundary, right justified\n', '   input logic [31:1]  ifu_fetch_pc,        // starting pc of fetch\n', '\n', '\n', '   input logic   rst_l,\n', '   input logic   clk,\n', '   input logic   dec_tlu_core_ecc_disable,  // disable ecc checking and flagging\n', '\n', '   output logic ifu_i0_valid,            // Instruction 0 is valid\n', '   output logic ifu_i1_valid,            // Instruction 1 is valid\n', '   output logic ifu_i0_icaf,             // Instruction 0 has access fault\n', '   output logic ifu_i1_icaf,             // Instruction 1 has access fault\n', '   output logic ifu_i0_icaf_second,      // Instruction 0 has access fault on second 2B of 4B inst\n', '   output logic ifu_i1_icaf_second,      // Instruction 1 has access fault on second 2B of 4B inst\n', '   output logic ifu_i0_perr,             // Instruction 0 has parity error\n', '   output logic ifu_i1_perr,             // Instruction 1 has parity error\n', '   output logic ifu_i0_sbecc,            // Instruction 0 has single bit ecc error\n', '   output logic ifu_i1_sbecc,            // Instruction 1 has single bit ecc error\n', '   output logic ifu_i0_dbecc,            // Instruction 0 has double bit ecc error\n', '   output logic ifu_i1_dbecc,            // Instruction 1 has double bit ecc error\n', '   output logic [31:0] ifu_i0_instr,     // Instruction 0\n', '   output logic [31:0] ifu_i1_instr,     // Instruction 1\n', '   output logic [31:1] ifu_i0_pc,        // Instruction 0 PC\n', '   output logic [31:1] ifu_i1_pc,        // Instruction 1 PC\n', '   output logic ifu_i0_pc4,\n', '   output logic ifu_i1_pc4,\n', '\n', '   output logic ifu_fb_consume1,         // Consumed one buffer. To fetch control fetch for buffer mass balance\n', '   output logic ifu_fb_consume2,         // Consumed two buffers.To fetch control fetch for buffer mass balance\n', '   output logic [15:0] ifu_illegal_inst, // Illegal Instruction.\n', '\n', '   output br_pkt_t i0_brp,               // Branch packet for I0.\n', '   output br_pkt_t i1_brp,               // Branch packet for I1.\n', '\n', '   output logic [1:0] ifu_pmu_instr_aligned,         // number of inst aligned this cycle\n', '   output logic       ifu_pmu_align_stall,           // aligner stalled this cycle\n', '\n', '   output logic [16:2] ifu_icache_error_index,   // Icache Error address index\n', '   output logic        ifu_icache_error_val,     // Icache error valid\n', '   output logic        ifu_icache_sb_error_val,\n', '\n', '   output logic [15:0] ifu_i0_cinst,                 // 16b compress inst for i0\n', '   output logic [15:0] ifu_i1_cinst,                 // 16b compress inst for i1\n', '\n', '   input  logic    scan_mode\n', '\n', '\n', '   );\n', '\n', '`include ""global.h""\n', '\n', '   logic         ifvalid;\n', '   logic         shift_f1_f0, shift_f2_f0, shift_f2_f1;\n', '   logic         fetch_to_f0, fetch_to_f1, fetch_to_f2;\n', '\n', '   logic [7:0]   f2val_in, f2val;\n', '   logic [7:0]   f1val_in, f1val;\n', '   logic [7:0]   f0val_in, f0val;\n', '\n', '   logic [7:0]   sf1val, sf0val;\n', '\n', '   logic [31:1]  f2pc_in, f2pc;\n', '   logic [31:1]  f1pc_in, f1pc;\n', '   logic [31:1]  f0pc_in, f0pc;\n', '   logic [31:1]  sf1pc, sf0pc;\n', '\n', '   logic [63:0]  aligndata;\n', '   logic         first4B, first2B;\n', '   logic         second4B, second2B;\n', '\n', '   logic         third4B, third2B;\n', '   logic [31:0]  uncompress0, uncompress1, uncompress2;\n', '   logic         ibuffer_room1_more;\n', '   logic         ibuffer_room2_more;\n', '   logic         i0_shift, i1_shift;\n', '   logic         shift_2B, shift_4B, shift_6B, shift_8B;\n', '   logic         f1_shift_2B, f1_shift_4B, f1_shift_6B;\n', '   logic         f2_valid, sf1_valid, sf0_valid;\n', '\n', '   logic [31:0]  ifirst, isecond, ithird;\n', '   logic [31:1]  f0pc_plus1, f0pc_plus2, f0pc_plus3, f0pc_plus4;\n', '   logic [31:1]  f1pc_plus1, f1pc_plus2, f1pc_plus3;\n', '   logic [3:0]   alignval;\n', '   logic [31:1]  firstpc, secondpc, thirdpc, fourthpc;\n', '\n', '   logic [11:0]  f1poffset;\n', '   logic [11:0]  f0poffset;\n', '   logic [`RV_BHT_GHR_RANGE]  f1fghr;\n', '   logic [`RV_BHT_GHR_RANGE]  f0fghr;\n', '   logic [7:0]               f1hist1;\n', '   logic [7:0]               f0hist1;\n', '   logic [7:0]               f1hist0;\n', '   logic [7:0]               f0hist0;\n', '   logic [7:0]             f1pc4;\n', '   logic [7:0]             f0pc4;\n', '\n', '   logic [7:0]             f1ret;\n', '   logic [7:0]             f0ret;\n', '`ifdef RV_BTB_48\n', '   logic [7:0][1:0]      f1way;\n', '   logic [7:0][1:0]      f0way;\n', '`else\n', '   logic [7:0]             f1way;\n', '   logic [7:0]             f0way;\n', '`endif\n', '\n', '   logic [7:0]               f1brend;\n', '   logic [7:0]               f0brend;\n', '\n', '   logic [3:0]   alignbrend;\n', '   logic [3:0]   alignpc4;\n', '`ifdef RV_ICACHE_ECC\n', '   logic [19:0]  alignecc;\n', '`else\n', '   logic [3:0]   alignparity;\n', '`endif\n', '   logic [3:0]   alignret;\n', '   logic [3:0]   alignway;\n', '   logic [3:0]   alignhist1;\n', '\n', '   logic [3:0]   alignhist0;\n', '   logic [3:1]   alignfromf1;\n', '   logic         i0_ends_f1, i1_ends_f1;\n', '   logic         i0_br_start_error, i1_br_start_error;\n', '\n', '   logic [31:1]  f1prett;\n', '   logic [31:1]  f0prett;\n', '   logic [7:0]   f1dbecc;\n', '   logic [7:0]   f0dbecc;\n', '   logic         f1sbecc;\n', '   logic         f0sbecc;\n', '   logic         f1perr;\n', '   logic         f0perr;\n', '   logic         f1icfetch;\n', '   logic         f0icfetch;\n', '   logic [7:0]   f1icaf;\n', '   logic [7:0]   f0icaf;\n', '\n', '   logic [3:0]   alignicfetch;\n', '   logic [3:0]   aligntagperr;\n', '   logic [3:0]   aligndataperr;\n', '   logic [3:0]   alignsbecc;\n', '   logic [3:0]   aligndbecc;\n', '   logic [3:0]   alignicaf;\n', '   logic         i0_brp_pc4, i1_brp_pc4;\n', '\n', '   logic [`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] firstpc_hash, secondpc_hash, thirdpc_hash, fourthpc_hash;\n', '\n', '   logic         i0_illegal, i1_illegal;\n', '   logic         shift_illegal;\n', '   logic         first_legal, second_legal, third_legal;\n', '   logic [15:0]  illegal_inst;\n', '   logic         illegal_inst_en;\n', '   logic         illegal_lockout_in, illegal_lockout;\n', '\n', '   logic [3:0]   alignfinalperr;\n', '\n', '   logic f2_wr_en;\n', '\n', '   assign f2_wr_en = fetch_to_f2;\n', '\n', '   logic f0_shift_wr_en;\n', '\n', '   assign f0_shift_wr_en = (fetch_to_f0 | shift_f2_f0 | shift_f1_f0 | shift_2B | shift_4B | shift_6B | shift_8B);\n', '\n', '   logic f1_shift_wr_en;\n', '\n', '   assign f1_shift_wr_en = (fetch_to_f1 | shift_f2_f1 | f1_shift_2B | f1_shift_4B | f1_shift_6B);\n', '\n', '   logic [1:0] wrptr, wrptr_in;\n', '   logic [1:0] rdptr, rdptr_in;\n', '   logic [2:0] qwen;\n', '   logic [127:0] q2,q1,q0;\n', '   logic [2:0]   first_offset, second_offset;\n', '   logic [2:0]   q2off_eff, q2off_in, q2off;\n', '   logic [2:0]   q1off_eff, q1off_in, q1off;\n', '   logic [2:0]   q0off_eff, q0off_in, q0off;\n', '   logic         f0_shift_2B, f0_shift_4B, f0_shift_6B, f0_shift_8B;\n', '\n', '   logic [127:0] q0eff;\n', '   logic [127:0] q0final;\n', '   logic [2:0]   q0ptr;\n', '   logic [7:0]   q0sel;\n', '\n', '   logic [127:0] q1eff;\n', '   logic [127:0] q1final;\n', '   logic [2:0]   q1ptr;\n', '   logic [7:0]   q1sel;\n', '\n', '   logic [2:0]   qren;\n', '\n', '   logic         consume_fb1, consume_fb0;\n', '   logic [3:0]   icaf_eff;\n', '\n', '`ifdef RV_ICACHE_ECC\n', '   logic [39:0]          q0ecc, q1ecc, q2ecc;\n', '   logic [39:0]          q0ecceff, q1ecceff;\n', '   logic [39:0]          q0eccfinal, q1eccfinal;\n', '`else\n', '   logic [7:0]   q0parity, q1parity, q2parity;\n', '   logic [7:0]   q0parityeff, q1parityeff;\n', '   logic [7:0]   q0parityfinal, q1parityfinal;\n', '`endif\n', '\n', '   // new queue control logic\n', '\n', ""   assign wrptr_in[1:0] =  (({2{wrptr[1:0]==2'b00 & ifvalid}} & 2'b01) |\n"", ""                            ({2{wrptr[1:0]==2'b01 & ifvalid}} & 2'b10) |\n"", ""                            ({2{wrptr[1:0]==2'b10 & ifvalid}} & 2'b00) |\n"", '                            ({2{~ifvalid}} & wrptr[1:0])) & ~{2{exu_flush_final}};\n', '\n', '   rvdff #(2) wrpff (.*, .clk(active_clk), .din(wrptr_in[1:0]), .dout(wrptr[1:0]));\n', '\n', ""   assign rdptr_in[1:0] =  (({2{rdptr[1:0]==2'b00 & ifu_fb_consume1}} & 2'b01) |\n"", ""                            ({2{rdptr[1:0]==2'b01 & ifu_fb_consume1}} & 2'b10) |\n"", ""                            ({2{rdptr[1:0]==2'b10 & ifu_fb_consume1}} & 2'b00) |\n"", ""                            ({2{rdptr[1:0]==2'b00 & ifu_fb_consume2}} & 2'b10) |\n"", ""                            ({2{rdptr[1:0]==2'b01 & ifu_fb_consume2}} & 2'b00) |\n"", ""                            ({2{rdptr[1:0]==2'b10 & ifu_fb_consume2}} & 2'b01) |\n"", '                            ({2{~ifu_fb_consume1&~ifu_fb_consume2}} & rdptr[1:0])) & ~{2{exu_flush_final}};\n', '\n', '   rvdff #(2) rdpff (.*, .clk(active_clk), .din(rdptr_in[1:0]), .dout(rdptr[1:0]));\n', '\n', ""   assign qren[2:0] = { rdptr[1:0]==2'b10,\n"", ""                        rdptr[1:0]==2'b01,\n"", ""                        rdptr[1:0]==2'b00\n"", '                        };\n', '\n', ""   assign qwen[2:0] = { wrptr[1:0]==2'b10 & ifvalid,\n"", ""                        wrptr[1:0]==2'b01 & ifvalid,\n"", ""                        wrptr[1:0]==2'b00 & ifvalid\n"", '                        };\n', '\n', '\n', '   assign first_offset[2:0]  = {f0_shift_8B,  f0_shift_6B|f0_shift_4B,  f0_shift_6B|f0_shift_2B };\n', '\n', ""   assign second_offset[2:0] = {1'b0,         f1_shift_6B|f1_shift_4B,  f1_shift_6B|f1_shift_2B };\n"", '\n', '\n', ""   assign q2off_eff[2:0] = (rdptr[1:0]==2'd2) ? (q2off[2:0] + first_offset[2:0])  :\n"", ""                           (rdptr[1:0]==2'd1) ? (q2off[2:0] + second_offset[2:0]) :\n"", '                                                 q2off[2:0];\n', '\n', '   assign q2off_in[2:0] = (qwen[2]) ? ifu_fetch_pc[3:1] : q2off_eff[2:0];\n', '\n', '   rvdff #(3) q2offsetff (.*, .clk(active_clk), .din(q2off_in[2:0]), .dout(q2off[2:0]));\n', '\n', ""   assign q1off_eff[2:0] = (rdptr[1:0]==2'd1) ? (q1off[2:0] + first_offset[2:0])  :\n"", ""                           (rdptr[1:0]==2'd0) ? (q1off[2:0] + second_offset[2:0]) :\n"", '                                                 q1off[2:0];\n', '\n', '\n', '   assign q1off_in[2:0] = (qwen[1]) ? ifu_fetch_pc[3:1] : q1off_eff[2:0];\n', '\n', '   rvdff #(3) q1offsetff (.*, .clk(active_clk), .din(q1off_in[2:0]), .dout(q1off[2:0]));\n', '\n', '\n', ""   assign q0off_eff[2:0] = (rdptr[1:0]==2'd0) ? (q0off[2:0] + first_offset[2:0])  :\n"", ""                           (rdptr[1:0]==2'd2) ? (q0off[2:0] + second_offset[2:0]) :\n"", '                                                 q0off[2:0];\n', '\n', '\n', '   assign q0off_in[2:0] = (qwen[0]) ? ifu_fetch_pc[3:1] : q0off_eff[2:0];\n', '\n', '\n', '   rvdff #(3) q0offsetff (.*, .clk(active_clk), .din(q0off_in[2:0]), .dout(q0off[2:0]));\n', '\n', ""   assign q0ptr[2:0] = (({3{rdptr[1:0]==2'b00}} & q0off[2:0]) |\n"", ""                        ({3{rdptr[1:0]==2'b01}} & q1off[2:0]) |\n"", ""                        ({3{rdptr[1:0]==2'b10}} & q2off[2:0]));\n"", '\n', ""   assign q1ptr[2:0] = (({3{rdptr[1:0]==2'b00}} & q1off[2:0]) |\n"", ""                        ({3{rdptr[1:0]==2'b01}} & q2off[2:0]) |\n"", ""                        ({3{rdptr[1:0]==2'b10}} & q0off[2:0]));\n"", '\n', ""   assign q0sel[7:0] = { q0ptr[2:0]==3'b111,\n"", ""                         q0ptr[2:0]==3'b110,\n"", ""                         q0ptr[2:0]==3'b101,\n"", ""                         q0ptr[2:0]==3'b100,\n"", ""                         q0ptr[2:0]==3'b011,\n"", ""                         q0ptr[2:0]==3'b010,\n"", ""                         q0ptr[2:0]==3'b001,\n"", ""                         q0ptr[2:0]==3'b000\n"", '                         };\n', '\n', ""   assign q1sel[7:0] = { q1ptr[2:0]==3'b111,\n"", ""                         q1ptr[2:0]==3'b110,\n"", ""                         q1ptr[2:0]==3'b101,\n"", ""                         q1ptr[2:0]==3'b100,\n"", ""                         q1ptr[2:0]==3'b011,\n"", ""                         q1ptr[2:0]==3'b010,\n"", ""                         q1ptr[2:0]==3'b001,\n"", ""                         q1ptr[2:0]==3'b000\n"", '                         };\n', '\n', '   // end new queue control logic\n', '\n', '\n', '   // misc data that is associated with each fetch buffer\n', '\n', '   localparam MHI   = 45+`RV_BHT_GHR_SIZE;\n', '   localparam MSIZE = 46+`RV_BHT_GHR_SIZE;\n', '\n', '   logic [MHI:0] misc_data_in, misc2, misc1, misc0;\n', '   logic [MHI:0] misc1eff, misc0eff;\n', '\n', '   assign misc_data_in[MHI:0] = {\n', '                                  iccm_rd_ecc_single_err,\n', '                                  ifu_icache_fetch_f2,\n', '                                  ic_rd_parity_final_err,\n', '\n', '                                  ifu_bp_btb_target_f2[31:1],\n', '                                  ifu_bp_poffset_f2[11:0],\n', '                                  ifu_bp_fghr_f2[`RV_BHT_GHR_RANGE]\n', '                                  };\n', '\n', '   rvdffe #(MSIZE) misc2ff (.*, .en(qwen[2]), .din(misc_data_in[MHI:0]), .dout(misc2[MHI:0]));\n', '   rvdffe #(MSIZE) misc1ff (.*, .en(qwen[1]), .din(misc_data_in[MHI:0]), .dout(misc1[MHI:0]));\n', '   rvdffe #(MSIZE) misc0ff (.*, .en(qwen[0]), .din(misc_data_in[MHI:0]), .dout(misc0[MHI:0]));\n', '\n', '\n', '   assign {misc1eff[MHI:0],misc0eff[MHI:0]} = (({MSIZE*2{qren[0]}} & {misc1[MHI:0],misc0[MHI:0]}) |\n', '                                               ({MSIZE*2{qren[1]}} & {misc2[MHI:0],misc1[MHI:0]}) |\n', '                                               ({MSIZE*2{qren[2]}} & {misc0[MHI:0],misc2[MHI:0]}));\n', '   assign {\n', '            f1sbecc,\n', '            f1icfetch,\n', '            f1perr,\n', '\n', '            f1prett[31:1],\n', '            f1poffset[11:0],\n', '            f1fghr[`RV_BHT_GHR_RANGE]\n', '            } = misc1eff[MHI:0];\n', '\n', '   assign {\n', '            f0sbecc,\n', '            f0icfetch,\n', '            f0perr,\n', '\n', '            f0prett[31:1],\n', '            f0poffset[11:0],\n', '            f0fghr[`RV_BHT_GHR_RANGE]\n', '            } = misc0eff[MHI:0];\n', '\n', '\n', '`ifdef RV_BTB_48\n', '   localparam BRDATA_SIZE=72;\n', '   localparam BRDATA_WIDTH = 9;\n', '`else\n', '   localparam BRDATA_SIZE=64;\n', '   localparam BRDATA_WIDTH = 8;\n', '`endif\n', '   logic [BRDATA_SIZE-1:0] brdata_in, brdata2, brdata1, brdata0;\n', '   logic [BRDATA_SIZE-1:0] brdata1eff, brdata0eff;\n', '   logic [BRDATA_SIZE-1:0] brdata1final, brdata0final;\n', '   assign brdata_in[BRDATA_SIZE-1:0] = {\n', '                              iccm_rd_ecc_double_err[7],ic_access_fault_f2[7],ifu_bp_hist1_f2[7],ifu_bp_hist0_f2[7],ifu_bp_pc4_f2[7],ifu_bp_way_f2[7],ifu_bp_valid_f2[7],ifu_bp_ret_f2[7],\n', '                              iccm_rd_ecc_double_err[6],ic_access_fault_f2[6],ifu_bp_hist1_f2[6],ifu_bp_hist0_f2[6],ifu_bp_pc4_f2[6],ifu_bp_way_f2[6],ifu_bp_valid_f2[6],ifu_bp_ret_f2[6],\n', '                              iccm_rd_ecc_double_err[5],ic_access_fault_f2[5],ifu_bp_hist1_f2[5],ifu_bp_hist0_f2[5],ifu_bp_pc4_f2[5],ifu_bp_way_f2[5],ifu_bp_valid_f2[5],ifu_bp_ret_f2[5],\n', '                              iccm_rd_ecc_double_err[4],ic_access_fault_f2[4],ifu_bp_hist1_f2[4],ifu_bp_hist0_f2[4],ifu_bp_pc4_f2[4],ifu_bp_way_f2[4],ifu_bp_valid_f2[4],ifu_bp_ret_f2[4],\n', '                              iccm_rd_ecc_double_err[3],ic_access_fault_f2[3],ifu_bp_hist1_f2[3],ifu_bp_hist0_f2[3],ifu_bp_pc4_f2[3],ifu_bp_way_f2[3],ifu_bp_valid_f2[3],ifu_bp_ret_f2[3],\n', '                              iccm_rd_ecc_double_err[2],ic_access_fault_f2[2],ifu_bp_hist1_f2[2],ifu_bp_hist0_f2[2],ifu_bp_pc4_f2[2],ifu_bp_way_f2[2],ifu_bp_valid_f2[2],ifu_bp_ret_f2[2],\n', '                              iccm_rd_ecc_double_err[1],ic_access_fault_f2[1],ifu_bp_hist1_f2[1],ifu_bp_hist0_f2[1],ifu_bp_pc4_f2[1],ifu_bp_way_f2[1],ifu_bp_valid_f2[1],ifu_bp_ret_f2[1],\n', '                              iccm_rd_ecc_double_err[0],ic_access_fault_f2[0],ifu_bp_hist1_f2[0],ifu_bp_hist0_f2[0],ifu_bp_pc4_f2[0],ifu_bp_way_f2[0],ifu_bp_valid_f2[0],ifu_bp_ret_f2[0]\n', '                              };\n', '//\n', '   rvdffe #(BRDATA_SIZE) brdata2ff (.*, .en(qwen[2]), .din(brdata_in[BRDATA_SIZE-1:0]), .dout(brdata2[BRDATA_SIZE-1:0]));\n', '   rvdffe #(BRDATA_SIZE) brdata1ff (.*, .en(qwen[1]), .din(brdata_in[BRDATA_SIZE-1:0]), .dout(brdata1[BRDATA_SIZE-1:0]));\n', '   rvdffe #(BRDATA_SIZE) brdata0ff (.*, .en(qwen[0]), .din(brdata_in[BRDATA_SIZE-1:0]), .dout(brdata0[BRDATA_SIZE-1:0]));\n', '\n', '\n', '   assign {brdata1eff[BRDATA_SIZE-1:0],brdata0eff[BRDATA_SIZE-1:0]} = (({BRDATA_SIZE*2{qren[0]}} & {brdata1[BRDATA_SIZE-1:0],brdata0[BRDATA_SIZE-1:0]}) |\n', '                                                                       ({BRDATA_SIZE*2{qren[1]}} & {brdata2[BRDATA_SIZE-1:0],brdata1[BRDATA_SIZE-1:0]}) |\n', '                                                                       ({BRDATA_SIZE*2{qren[2]}} & {brdata0[BRDATA_SIZE-1:0],brdata2[BRDATA_SIZE-1:0]}));\n', '\n', '   assign brdata0final[BRDATA_SIZE-1:0] = (({BRDATA_SIZE{q0sel[0]}} & {            brdata0eff[BRDATA_SIZE-1:0]}) |\n', ""                                ({BRDATA_SIZE{q0sel[1]}} & {{1*BRDATA_WIDTH{1'b0}},brdata0eff[BRDATA_SIZE-1:1*BRDATA_WIDTH]}) |\n"", ""                                ({BRDATA_SIZE{q0sel[2]}} & {{2*BRDATA_WIDTH{1'b0}},brdata0eff[BRDATA_SIZE-1:2*BRDATA_WIDTH]}) |\n"", ""                                ({BRDATA_SIZE{q0sel[3]}} & {{3*BRDATA_WIDTH{1'b0}},brdata0eff[BRDATA_SIZE-1:3*BRDATA_WIDTH]}) |\n"", ""                                ({BRDATA_SIZE{q0sel[4]}} & {{4*BRDATA_WIDTH{1'b0}},brdata0eff[BRDATA_SIZE-1:4*BRDATA_WIDTH]}) |\n"", ""                                ({BRDATA_SIZE{q0sel[5]}} & {{5*BRDATA_WIDTH{1'b0}},brdata0eff[BRDATA_SIZE-1:5*BRDATA_WIDTH]}) |\n"", ""                                ({BRDATA_SIZE{q0sel[6]}} & {{6*BRDATA_WIDTH{1'b0}},brdata0eff[BRDATA_SIZE-1:6*BRDATA_WIDTH]}) |\n"", ""                                ({BRDATA_SIZE{q0sel[7]}} & {{7*BRDATA_WIDTH{1'b0}},brdata0eff[BRDATA_SIZE-1:7*BRDATA_WIDTH]}));\n"", '\n', '   assign brdata1final[BRDATA_SIZE-1:0] = (({BRDATA_SIZE{q1sel[0]}} & {            brdata1eff[BRDATA_SIZE-1:0]}) |\n', ""                                ({BRDATA_SIZE{q1sel[1]}} & {{1*BRDATA_WIDTH{1'b0}},brdata1eff[BRDATA_SIZE-1:1*BRDATA_WIDTH]}) |\n"", ""                                ({BRDATA_SIZE{q1sel[2]}} & {{2*BRDATA_WIDTH{1'b0}},brdata1eff[BRDATA_SIZE-1:2*BRDATA_WIDTH]}) |\n"", ""                                ({BRDATA_SIZE{q1sel[3]}} & {{3*BRDATA_WIDTH{1'b0}},brdata1eff[BRDATA_SIZE-1:3*BRDATA_WIDTH]}) |\n"", ""                                ({BRDATA_SIZE{q1sel[4]}} & {{4*BRDATA_WIDTH{1'b0}},brdata1eff[BRDATA_SIZE-1:4*BRDATA_WIDTH]}) |\n"", ""                                ({BRDATA_SIZE{q1sel[5]}} & {{5*BRDATA_WIDTH{1'b0}},brdata1eff[BRDATA_SIZE-1:5*BRDATA_WIDTH]}) |\n"", ""                                ({BRDATA_SIZE{q1sel[6]}} & {{6*BRDATA_WIDTH{1'b0}},brdata1eff[BRDATA_SIZE-1:6*BRDATA_WIDTH]}) |\n"", ""                                ({BRDATA_SIZE{q1sel[7]}} & {{7*BRDATA_WIDTH{1'b0}},brdata1eff[BRDATA_SIZE-1:7*BRDATA_WIDTH]}));\n"", '\n', '   assign {\n', '            f0dbecc[7],f0icaf[7],f0hist1[7],f0hist0[7],f0pc4[7],f0way[7],f0brend[7],f0ret[7],\n', '            f0dbecc[6],f0icaf[6],f0hist1[6],f0hist0[6],f0pc4[6],f0way[6],f0brend[6],f0ret[6],\n', '            f0dbecc[5],f0icaf[5],f0hist1[5],f0hist0[5],f0pc4[5],f0way[5],f0brend[5],f0ret[5],\n', '            f0dbecc[4],f0icaf[4],f0hist1[4],f0hist0[4],f0pc4[4],f0way[4],f0brend[4],f0ret[4],\n', '            f0dbecc[3],f0icaf[3],f0hist1[3],f0hist0[3],f0pc4[3],f0way[3],f0brend[3],f0ret[3],\n', '            f0dbecc[2],f0icaf[2],f0hist1[2],f0hist0[2],f0pc4[2],f0way[2],f0brend[2],f0ret[2],\n', '            f0dbecc[1],f0icaf[1],f0hist1[1],f0hist0[1],f0pc4[1],f0way[1],f0brend[1],f0ret[1],\n', '            f0dbecc[0],f0icaf[0],f0hist1[0],f0hist0[0],f0pc4[0],f0way[0],f0brend[0],f0ret[0]\n', '            } = brdata0final[BRDATA_SIZE-1:0];\n', '\n', '   assign {\n', '            f1dbecc[7],f1icaf[7],f1hist1[7],f1hist0[7],f1pc4[7],f1way[7],f1brend[7],f1ret[7],\n', '            f1dbecc[6],f1icaf[6],f1hist1[6],f1hist0[6],f1pc4[6],f1way[6],f1brend[6],f1ret[6],\n', '            f1dbecc[5],f1icaf[5],f1hist1[5],f1hist0[5],f1pc4[5],f1way[5],f1brend[5],f1ret[5],\n', '            f1dbecc[4],f1icaf[4],f1hist1[4],f1hist0[4],f1pc4[4],f1way[4],f1brend[4],f1ret[4],\n', '            f1dbecc[3],f1icaf[3],f1hist1[3],f1hist0[3],f1pc4[3],f1way[3],f1brend[3],f1ret[3],\n', '            f1dbecc[2],f1icaf[2],f1hist1[2],f1hist0[2],f1pc4[2],f1way[2],f1brend[2],f1ret[2],\n', '            f1dbecc[1],f1icaf[1],f1hist1[1],f1hist0[1],f1pc4[1],f1way[1],f1brend[1],f1ret[1],\n', '            f1dbecc[0],f1icaf[0],f1hist1[0],f1hist0[0],f1pc4[0],f1way[0],f1brend[0],f1ret[0]\n', '            } = brdata1final[BRDATA_SIZE-1:0];\n', '\n', '\n', '   // possible states of { sf0_valid, sf1_valid, f2_valid }\n', '\n', '   // 000 if->f0\n', '\n', '   // 100 if->f1\n', '\n', '   // 101 illegal\n', '\n', '   // 010 f1->f0, if->f1\n', '\n', '   // 110 if->f2\n', '\n', '   // 001 if->f1, f2->f0\n', '\n', '   // 011 f1->f0, f2->f1, if->f2\n', '\n', '   // 111 !if, no shift\n', '\n', '   assign f2_valid = f2val[0];\n', '\n', '   assign sf1_valid = sf1val[0];\n', '\n', '   assign sf0_valid = sf0val[0];\n', '\n', '   // interface to fetch\n', '\n', '   assign consume_fb0 = ~sf0val[0] & f0val[0];\n', '\n', '   assign consume_fb1 = ~sf1val[0] & f1val[0];\n', '\n', '   assign ifu_fb_consume1 = consume_fb0 & ~consume_fb1 & ~exu_flush_final;\n', '\n', '   assign ifu_fb_consume2 = consume_fb0 &  consume_fb1 & ~exu_flush_final;\n', '\n', '   assign ifvalid = ifu_fetch_val[0];\n', '\n', '   assign shift_f1_f0 =  ~sf0_valid & sf1_valid;\n', '\n', '   assign shift_f2_f0 =  ~sf0_valid & ~sf1_valid & f2_valid;\n', '\n', '   assign shift_f2_f1 =  ~sf0_valid & sf1_valid & f2_valid;\n', '\n', '   assign fetch_to_f0 =  ~sf0_valid & ~sf1_valid & ~f2_valid & ifvalid;\n', '\n', '   assign fetch_to_f1 =  (~sf0_valid & ~sf1_valid &  f2_valid & ifvalid)  |\n', '                         (~sf0_valid &  sf1_valid & ~f2_valid & ifvalid)  |\n', '                         ( sf0_valid & ~sf1_valid & ~f2_valid & ifvalid);\n', '\n', '   assign fetch_to_f2 =  (~sf0_valid &  sf1_valid &  f2_valid & ifvalid)  |\n', '                         ( sf0_valid &  sf1_valid & ~f2_valid & ifvalid);\n', '\n', '   // f0 valid states\n', '   //\n', '   // 11111111\n', '   // 11111110\n', '   // 11111100\n', '   // 11111000\n', '   // 11110000\n', '\n', '   // 11100000\n', '   // 11000000\n', '   // 10000000\n', '   // 00000000\n', '\n', '\n', '\n', '   // make this two incrementors with some logic on the lower bits\n', '\n', ""   assign f0pc_plus1[31:1] = f0pc[31:1] + 31'd1;\n"", ""   assign f0pc_plus2[31:1] = f0pc[31:1] + 31'd2;\n"", ""   assign f0pc_plus3[31:1] = f0pc[31:1] + 31'd3;\n"", ""   assign f0pc_plus4[31:1] = f0pc[31:1] + 31'd4;\n"", '\n', ""   assign f1pc_plus1[31:1] = f1pc[31:1] + 31'd1;\n"", ""   assign f1pc_plus2[31:1] = f1pc[31:1] + 31'd2;\n"", ""   assign f1pc_plus3[31:1] = f1pc[31:1] + 31'd3;\n"", '\n', '   assign f2pc_in[31:1] = ifu_fetch_pc[31:1];\n', '\n', '   rvdffe #(31) f2pcff (.*, .en(f2_wr_en), .din(f2pc_in[31:1]), .dout(f2pc[31:1]));\n', '\n', '   assign sf1pc[31:1] = ({31{f1_shift_2B}} & (f1pc_plus1[31:1])) |\n', '                        ({31{f1_shift_4B}} & (f1pc_plus2[31:1])) |\n', '                        ({31{f1_shift_6B}} & (f1pc_plus3[31:1])) |\n', '                        ({31{~f1_shift_2B&~f1_shift_4B&~f1_shift_6B}} & f1pc[31:1]);\n', '\n', '   assign f1pc_in[31:1] = ({31{fetch_to_f1}} & ifu_fetch_pc[31:1]) |\n', '                          ({31{shift_f2_f1}} & f2pc[31:1]) |\n', '                          ({31{~fetch_to_f1&~shift_f2_f1}} & sf1pc[31:1]);\n', '\n', '   rvdffe #(31) f1pcff (.*, .en(f1_shift_wr_en), .din(f1pc_in[31:1]), .dout(f1pc[31:1]));\n', '\n', '   assign sf0pc[31:1] = ({31{shift_2B}} & (f0pc_plus1[31:1])) |\n', '                        ({31{shift_4B}} & (f0pc_plus2[31:1])) |\n', '                        ({31{shift_6B}} & (f0pc_plus3[31:1])) |\n', '                        ({31{shift_8B}} & (f0pc_plus4[31:1]));\n', '\n', '   assign f0pc_in[31:1] = ({31{fetch_to_f0}} & ifu_fetch_pc[31:1]) |\n', '                          ({31{shift_f2_f0}} & f2pc[31:1]) |\n', '                          ({31{shift_f1_f0}} & sf1pc[31:1]) |\n', '                          ({31{~fetch_to_f0&~shift_f2_f0&~shift_f1_f0}} & sf0pc[31:1]);\n', '\n', '   rvdffe #(31) f0pcff (.*, .en(f0_shift_wr_en), .din(f0pc_in[31:1]), .dout(f0pc[31:1]));\n', '\n', '   // on flush_final all valids go to 0\n', '\n', '   // no clock-gating on the valids\n', '\n', '   assign f2val_in[7:0] = (({8{fetch_to_f2}} & ifu_fetch_val[7:0]) |\n', '                           ({8{~fetch_to_f2&~shift_f2_f1&~shift_f2_f0}} & f2val[7:0])) & ~{8{exu_flush_final}};\n', '\n', '   rvdff #(8) f2valff (.*, .clk(active_clk), .din(f2val_in[7:0]), .dout(f2val[7:0]));\n', '\n', ""   assign sf1val[7:0] = ({8{f1_shift_2B}} & {1'b0,f1val[7:1]}) |\n"", ""                        ({8{f1_shift_4B}} & {2'b0,f1val[7:2]}) |\n"", ""                        ({8{f1_shift_6B}} & {3'b0,f1val[7:3]}) |\n"", '                        ({8{~f1_shift_2B&~f1_shift_4B&~f1_shift_6B}} & f1val[7:0]);\n', '\n', '   assign f1val_in[7:0] = (({8{fetch_to_f1}} & ifu_fetch_val[7:0]) |\n', '                           ({8{shift_f2_f1}} & f2val[7:0]) |\n', '                           ({8{~fetch_to_f1&~shift_f2_f1&~shift_f1_f0}} & sf1val[7:0])) & ~{8{exu_flush_final}};\n', '\n', '   rvdff #(8) f1valff (.*, .clk(active_clk), .din(f1val_in[7:0]), .dout(f1val[7:0]));\n', '\n', '\n', ""   assign sf0val[7:0] = ({8{shift_2B}} & {1'b0,f0val[7:1]}) |\n"", ""                        ({8{shift_4B}} & {2'b0,f0val[7:2]}) |\n"", ""                        ({8{shift_6B}} & {3'b0,f0val[7:3]}) |\n"", ""                        ({8{shift_8B}} & {4'b0,f0val[7:4]}) |\n"", '                        ({8{~shift_2B&~shift_4B&~shift_6B&~shift_8B}} & f0val[7:0]);\n', '\n', '   assign f0val_in[7:0] = (({8{fetch_to_f0}} & ifu_fetch_val[7:0]) |\n', '                           ({8{shift_f2_f0}} & f2val[7:0]) |\n', '                           ({8{shift_f1_f0}} & sf1val[7:0]) |\n', '                           ({8{~fetch_to_f0&~shift_f2_f0&~shift_f1_f0}} & sf0val[7:0])) & ~{8{exu_flush_final}};\n', '\n', '   rvdff #(8) f0valff (.*, .clk(active_clk), .din(f0val_in[7:0]), .dout(f0val[7:0]));\n', '\n', '// parity\n', '\n', '`ifdef RV_ICACHE_ECC\n', '   rvdffe #(40) q2eccff (.*, .en(qwen[2]), .din(ic_error_f2.ecc[39:0]), .dout(q2ecc[39:0]));\n', '   rvdffe #(40) q1eccff (.*, .en(qwen[1]), .din(ic_error_f2.ecc[39:0]), .dout(q1ecc[39:0]));\n', '   rvdffe #(40) q0eccff (.*, .en(qwen[0]), .din(ic_error_f2.ecc[39:0]), .dout(q0ecc[39:0]));\n', '\n', '\n', '   assign {q1ecceff[39:0],q0ecceff[39:0]} = (({80{qren[0]}} & {q1ecc[39:0],q0ecc[39:0]}) |\n', '                                             ({80{qren[1]}} & {q2ecc[39:0],q1ecc[39:0]}) |\n', '                                             ({80{qren[2]}} & {q0ecc[39:0],q2ecc[39:0]}));\n', '\n', '   assign q0eccfinal[39:0] =     (({40{q0sel[0]}} & {      q0ecceff[8*5-1:0*5]}) |\n', ""                                  ({40{q0sel[1]}} & { 5'b0,q0ecceff[8*5-1:1*5]}) |\n"", ""                                  ({40{q0sel[2]}} & {10'b0,q0ecceff[8*5-1:2*5]}) |\n"", ""                                  ({40{q0sel[3]}} & {15'b0,q0ecceff[8*5-1:3*5]}) |\n"", ""                                  ({40{q0sel[4]}} & {20'b0,q0ecceff[8*5-1:4*5]}) |\n"", ""                                  ({40{q0sel[5]}} & {25'b0,q0ecceff[8*5-1:5*5]}) |\n"", ""                                  ({40{q0sel[6]}} & {30'b0,q0ecceff[8*5-1:6*5]}) |\n"", ""                                  ({40{q0sel[7]}} & {35'b0,q0ecceff[8*5-1:7*5]}));\n"", '\n', '   assign q1eccfinal[39:0] =     (({40{q1sel[0]}} & {      q1ecceff[8*5-1:0*5]}) |\n', ""                                  ({40{q1sel[1]}} & { 5'b0,q1ecceff[8*5-1:1*5]}) |\n"", ""                                  ({40{q1sel[2]}} & {10'b0,q1ecceff[8*5-1:2*5]}) |\n"", ""                                  ({40{q1sel[3]}} & {15'b0,q1ecceff[8*5-1:3*5]}) |\n"", ""                                  ({40{q1sel[4]}} & {20'b0,q1ecceff[8*5-1:4*5]}) |\n"", ""                                  ({40{q1sel[5]}} & {25'b0,q1ecceff[8*5-1:5*5]}) |\n"", ""                                  ({40{q1sel[6]}} & {30'b0,q1ecceff[8*5-1:6*5]}) |\n"", ""                                  ({40{q1sel[7]}} & {35'b0,q1ecceff[8*5-1:7*5]}));\n"", '\n', '`else\n', '   rvdffe #(8) q2parityff (.*, .en(qwen[2]), .din(ic_error_f2.parity[7:0]), .dout(q2parity[7:0]));\n', '   rvdffe #(8) q1parityff (.*, .en(qwen[1]), .din(ic_error_f2.parity[7:0]), .dout(q1parity[7:0]));\n', '   rvdffe #(8) q0parityff (.*, .en(qwen[0]), .din(ic_error_f2.parity[7:0]), .dout(q0parity[7:0]));\n', '\n', '\n', '   assign {q1parityeff[7:0],q0parityeff[7:0]} = (({16{qren[0]}} & {q1parity[7:0],q0parity[7:0]}) |\n', '                                                 ({16{qren[1]}} & {q2parity[7:0],q1parity[7:0]}) |\n', '                                                 ({16{qren[2]}} & {q0parity[7:0],q2parity[7:0]}));\n', '\n', '   assign q0parityfinal[7:0] =   (({8{q0sel[0]}} & {     q0parityeff[7:0]}) |\n', ""                                  ({8{q0sel[1]}} & {1'b0,q0parityeff[7:1]}) |\n"", ""                                  ({8{q0sel[2]}} & {2'b0,q0parityeff[7:2]}) |\n"", ""                                  ({8{q0sel[3]}} & {3'b0,q0parityeff[7:3]}) |\n"", ""                                  ({8{q0sel[4]}} & {4'b0,q0parityeff[7:4]}) |\n"", ""                                  ({8{q0sel[5]}} & {5'b0,q0parityeff[7:5]}) |\n"", ""                                  ({8{q0sel[6]}} & {6'b0,q0parityeff[7:6]}) |\n"", ""                                  ({8{q0sel[7]}} & {7'b0,q0parityeff[7]}));\n"", '\n', '   assign q1parityfinal[7:0] =   (({8{q1sel[0]}} & {     q1parityeff[7:0]}) |\n', ""                                  ({8{q1sel[1]}} & {1'b0,q1parityeff[7:1]}) |\n"", ""                                  ({8{q1sel[2]}} & {2'b0,q1parityeff[7:2]}) |\n"", ""                                  ({8{q1sel[3]}} & {3'b0,q1parityeff[7:3]}) |\n"", ""                                  ({8{q1sel[4]}} & {4'b0,q1parityeff[7:4]}) |\n"", ""                                  ({8{q1sel[5]}} & {5'b0,q1parityeff[7:5]}) |\n"", ""                                  ({8{q1sel[6]}} & {6'b0,q1parityeff[7:6]}) |\n"", ""                                  ({8{q1sel[7]}} & {7'b0,q1parityeff[7]}));\n"", '`endif // !`ifdef RV_ICACHE_ECC\n', '\n', '   rvdffe #(128) q2ff (.*, .en(qwen[2]), .din(ifu_fetch_data[127:0]), .dout(q2[127:0]));\n', '   rvdffe #(128) q1ff (.*, .en(qwen[1]), .din(ifu_fetch_data[127:0]), .dout(q1[127:0]));\n', '   rvdffe #(128) q0ff (.*, .en(qwen[0]), .din(ifu_fetch_data[127:0]), .dout(q0[127:0]));\n', '\n', '\n', '   assign {q1eff[127:0],q0eff[127:0]} = (({256{qren[0]}} & {q1[127:0],q0[127:0]}) |\n', '                                         ({256{qren[1]}} & {q2[127:0],q1[127:0]}) |\n', '                                         ({256{qren[2]}} & {q0[127:0],q2[127:0]}));\n', '\n', '   assign q0final[127:0] = (({128{q0sel[0]}} & {             q0eff[8*16-1:16*0]}) |\n', ""                            ({128{q0sel[1]}} & {{16*1{1'b0}},q0eff[8*16-1:16*1]}) |\n"", ""                            ({128{q0sel[2]}} & {{16*2{1'b0}},q0eff[8*16-1:16*2]}) |\n"", ""                            ({128{q0sel[3]}} & {{16*3{1'b0}},q0eff[8*16-1:16*3]}) |\n"", ""                            ({128{q0sel[4]}} & {{16*4{1'b0}},q0eff[8*16-1:16*4]}) |\n"", ""                            ({128{q0sel[5]}} & {{16*5{1'b0}},q0eff[8*16-1:16*5]}) |\n"", ""                            ({128{q0sel[6]}} & {{16*6{1'b0}},q0eff[8*16-1:16*6]}) |\n"", ""                            ({128{q0sel[7]}} & {{16*7{1'b0}},q0eff[8*16-1:16*7]}));\n"", '\n', '   assign q1final[127:0] = (({128{q1sel[0]}} & {             q1eff[8*16-1:16*0]}) |\n', ""                            ({128{q1sel[1]}} & {{16*1{1'b0}},q1eff[8*16-1:16*1]}) |\n"", ""                            ({128{q1sel[2]}} & {{16*2{1'b0}},q1eff[8*16-1:16*2]}) |\n"", ""                            ({128{q1sel[3]}} & {{16*3{1'b0}},q1eff[8*16-1:16*3]}) |\n"", ""                            ({128{q1sel[4]}} & {{16*4{1'b0}},q1eff[8*16-1:16*4]}) |\n"", ""                            ({128{q1sel[5]}} & {{16*5{1'b0}},q1eff[8*16-1:16*5]}) |\n"", ""                            ({128{q1sel[6]}} & {{16*6{1'b0}},q1eff[8*16-1:16*6]}) |\n"", ""                            ({128{q1sel[7]}} & {{16*7{1'b0}},q1eff[8*16-1:16*7]}));\n"", '\n', '\n', '   assign aligndata[63:0] = ({64{(f0val[3])}} &                  {q0final[4*16-1:0]}) |\n', '                            ({64{(f0val[2]&~f0val[3])}} &        {q1final[1*16-1:0],q0final[3*16-1:0]}) |\n', '                            ({64{(f0val[1]&~f0val[2])}} &        {q1final[2*16-1:0],q0final[2*16-1:0]}) |\n', '                            ({64{(f0val[0]&~f0val[1])}} &        {q1final[3*16-1:0],q0final[1*16-1:0]});\n', '\n', ""   assign alignval[3:0] =   ({4{(f0val[3])}} &                   4'b1111) |\n"", ""                            ({4{(f0val[2]&~f0val[3])}} &        {f1val[0],3'b111}) |\n"", ""                            ({4{(f0val[1]&~f0val[2])}} &        {f1val[1:0],2'b11}) |\n"", ""                            ({4{(f0val[0]&~f0val[1])}} &        {f1val[2:0],1'b1});\n"", '\n', '   assign alignicaf[3:0] =   ({4{(f0val[3])}} &                   f0icaf[3:0]) |\n', '                             ({4{(f0val[2]&~f0val[3])}} &        {f1icaf[0],f0icaf[2:0]}) |\n', '                             ({4{(f0val[1]&~f0val[2])}} &        {f1icaf[1:0],f0icaf[1:0]}) |\n', '                             ({4{(f0val[0]&~f0val[1])}} &        {f1icaf[2:0],f0icaf[0]});\n', '\n', '   assign alignsbecc[3:0] =   ({4{(f0val[3])}} &                  {4{f0sbecc}}) |\n', '                              ({4{(f0val[2]&~f0val[3])}} &        {{1{f1sbecc}},{3{f0sbecc}}}) |\n', '                              ({4{(f0val[1]&~f0val[2])}} &        {{2{f1sbecc}},{2{f0sbecc}}}) |\n', '                              ({4{(f0val[0]&~f0val[1])}} &        {{3{f1sbecc}},{1{f0sbecc}}});\n', '\n', '\n', '   assign aligndbecc[3:0] =   ({4{(f0val[3])}} &                   f0dbecc[3:0]) |\n', '                              ({4{(f0val[2]&~f0val[3])}} &        {f1dbecc[0],f0dbecc[2:0]}) |\n', '                              ({4{(f0val[1]&~f0val[2])}} &        {f1dbecc[1:0],f0dbecc[1:0]}) |\n', '                              ({4{(f0val[0]&~f0val[1])}} &        {f1dbecc[2:0],f0dbecc[0]});\n', '\n', '   // for branch prediction\n', '   assign alignbrend[3:0] =   ({4{(f0val[3])}} &                   f0brend[3:0]) |\n', '                              ({4{(f0val[2]&~f0val[3])}} &        {f1brend[0],f0brend[2:0]}) |\n', '                              ({4{(f0val[1]&~f0val[2])}} &        {f1brend[1:0],f0brend[1:0]}) |\n', '                              ({4{(f0val[0]&~f0val[1])}} &        {f1brend[2:0],f0brend[0]});\n', '\n', '   assign alignpc4[3:0] =   ({4{(f0val[3])}} &                   f0pc4[3:0]) |\n', '                            ({4{(f0val[2]&~f0val[3])}} &        {f1pc4[0],f0pc4[2:0]}) |\n', '                            ({4{(f0val[1]&~f0val[2])}} &        {f1pc4[1:0],f0pc4[1:0]}) |\n', '                            ({4{(f0val[0]&~f0val[1])}} &        {f1pc4[2:0],f0pc4[0]});\n', '\n', '`ifdef RV_ICACHE_ECC\n', '   assign alignecc[19:0] =   ({20{(f0val[3])}} &                                    q0eccfinal[19:0]) |\n', '                             ({20{(f0val[2]&~f0val[3])}} &        {q1eccfinal[4:0], q0eccfinal[14:0]}) |\n', '                             ({20{(f0val[1]&~f0val[2])}} &        {q1eccfinal[9:0], q0eccfinal[9:0]}) |\n', '                             ({20{(f0val[0]&~f0val[1])}} &        {q1eccfinal[14:0],q0eccfinal[4:0]});\n', '`else\n', '   assign alignparity[3:0] =   ({4{(f0val[3])}} &                                      q0parityfinal[3:0]) |\n', '                               ({4{(f0val[2]&~f0val[3])}} &        {q1parityfinal[0],  q0parityfinal[2:0]}) |\n', '                               ({4{(f0val[1]&~f0val[2])}} &        {q1parityfinal[1:0],q0parityfinal[1:0]}) |\n', '                               ({4{(f0val[0]&~f0val[1])}} &        {q1parityfinal[2:0],q0parityfinal[0]});\n', '`endif\n', '\n', '   assign aligntagperr[3:0] =   ({4{(f0val[3])}} &                  {4{f0perr}}) |\n', '                                ({4{(f0val[2]&~f0val[3])}} &        {{1{f1perr}},{3{f0perr}}}) |\n', '                                ({4{(f0val[1]&~f0val[2])}} &        {{2{f1perr}},{2{f0perr}}}) |\n', '                                ({4{(f0val[0]&~f0val[1])}} &        {{3{f1perr}},{1{f0perr}}});\n', '\n', '   assign alignicfetch[3:0] =   ({4{(f0val[3])}} &                  {4{f0icfetch}}) |\n', '                                ({4{(f0val[2]&~f0val[3])}} &        {{1{f1icfetch}},{3{f0icfetch}}}) |\n', '                                ({4{(f0val[1]&~f0val[2])}} &        {{2{f1icfetch}},{2{f0icfetch}}}) |\n', '                                ({4{(f0val[0]&~f0val[1])}} &        {{3{f1icfetch}},{1{f0icfetch}}});\n', '\n', '\n', '   assign alignret[3:0] =   ({4{(f0val[3])}} &                   f0ret[3:0]) |\n', '                            ({4{(f0val[2]&~f0val[3])}} &        {f1ret[0],f0ret[2:0]}) |\n', '                            ({4{(f0val[1]&~f0val[2])}} &        {f1ret[1:0],f0ret[1:0]}) |\n', '                            ({4{(f0val[0]&~f0val[1])}} &        {f1ret[2:0],f0ret[0]});\n', '\n', '`ifdef RV_BTB_48\n', '\n', '   logic [3:0]             f0way_b0, f0way_b1, alignway_b0, alignway_b1;\n', '   logic [2:0]             f1way_b0, f1way_b1;\n', '   assign f0way_b0[3:0] = {f0way[3][0], f0way[2][0], f0way[1][0], f0way[0][0]};\n', '   assign f0way_b1[3:0] = {f0way[3][1], f0way[2][1], f0way[1][1], f0way[0][1]};\n', '   assign f1way_b0[2:0] = {f1way[2][0], f1way[1][0], f1way[0][0]};\n', '   assign f1way_b1[2:0] = {f1way[2][1], f1way[1][1], f1way[0][1]};\n', '\n', '   assign alignway_b0[3:0] =   ({4{(f0val[3])}} &                   f0way_b0[3:0]) |\n', '                               ({4{(f0val[2]&~f0val[3])}} &        {f1way_b0[0],  f0way_b0[2:0]}) |\n', '                               ({4{(f0val[1]&~f0val[2])}} &        {f1way_b0[1:0],f0way_b0[1:0]}) |\n', '                               ({4{(f0val[0]&~f0val[1])}} &        {f1way_b0[2:0],f0way_b0[0]});\n', '   assign alignway_b1[3:0] =   ({4{(f0val[3])}} &                   f0way_b1[3:0]) |\n', '                               ({4{(f0val[2]&~f0val[3])}} &        {f1way_b1[0],  f0way_b1[2:0]}) |\n', '                               ({4{(f0val[1]&~f0val[2])}} &        {f1way_b1[1:0],f0way_b1[1:0]}) |\n', '                               ({4{(f0val[0]&~f0val[1])}} &        {f1way_b1[2:0],f0way_b1[0]});\n', '`else\n', '   assign alignway[3:0] =   ({4{(f0val[3])}} &                   f0way[3:0]) |\n', '                            ({4{(f0val[2]&~f0val[3])}} &        {f1way[0],f0way[2:0]}) |\n', '                            ({4{(f0val[1]&~f0val[2])}} &        {f1way[1:0],f0way[1:0]}) |\n', '                            ({4{(f0val[0]&~f0val[1])}} &        {f1way[2:0],f0way[0]});\n', '`endif\n', '   assign alignhist1[3:0] =   ({4{(f0val[3])}} &                   f0hist1[3:0]) |\n', '                              ({4{(f0val[2]&~f0val[3])}} &        {f1hist1[0],f0hist1[2:0]}) |\n', '                              ({4{(f0val[1]&~f0val[2])}} &        {f1hist1[1:0],f0hist1[1:0]}) |\n', '                              ({4{(f0val[0]&~f0val[1])}} &        {f1hist1[2:0],f0hist1[0]});\n', '\n', '   assign alignhist0[3:0] =   ({4{(f0val[3])}} &                   f0hist0[3:0]) |\n', '                              ({4{(f0val[2]&~f0val[3])}} &        {f1hist0[0],f0hist0[2:0]}) |\n', '                              ({4{(f0val[1]&~f0val[2])}} &        {f1hist0[1:0],f0hist0[1:0]}) |\n', '                              ({4{(f0val[0]&~f0val[1])}} &        {f1hist0[2:0],f0hist0[0]});\n', '\n', ""   assign alignfromf1[3:1] =     ({3{(f0val[3])}} &                   3'b0) |\n"", ""                                 ({3{(f0val[2]&~f0val[3])}} &        {1'b1,2'b0}) |\n"", ""                                 ({3{(f0val[1]&~f0val[2])}} &        {2'b11,1'b0}) |\n"", ""                                 ({3{(f0val[0]&~f0val[1])}} &        {3'b111});\n"", '\n', '\n', '   assign { secondpc[31:1],\n', '            thirdpc[31:1],\n', '            fourthpc[31:1] } =   ({3*31{(f0val[3])}}           & {f0pc_plus1[31:1], f0pc_plus2[31:1], f0pc_plus3[31:1]}) |\n', '                                 ({3*31{(f0val[2]&~f0val[3])}} & {f0pc_plus1[31:1], f0pc_plus2[31:1], f1pc[31:1]}) |\n', '                                 ({3*31{(f0val[1]&~f0val[2])}} & {f0pc_plus1[31:1], f1pc[31:1],       f1pc_plus1[31:1]})   |\n', '                                 ({3*31{(f0val[0]&~f0val[1])}} & {f1pc[31:1],       f1pc_plus1[31:1], f1pc_plus2[31:1]});\n', '\n', '\n', '   assign ifu_i0_pc[31:1] = f0pc[31:1];\n', '\n', '   assign firstpc[31:1] = f0pc[31:1];\n', '\n', '   assign ifu_i1_pc[31:1] = (first2B) ? secondpc[31:1] : thirdpc[31:1];\n', '\n', '\n', '   assign ifu_i0_pc4 = first4B;\n', '\n', '   assign ifu_i1_pc4 = (first2B & second4B) |\n', '                       (first4B & third4B);\n', '\n', '   // parity checking\n', '\n', '`ifdef RV_ICACHE_ECC\n', '\n', '   logic [3:0] [31:0] ic_corrected_data_nc;\n', '   logic [3:0] [6:0]  ic_corrected_ecc_nc;\n', '   logic [3:0]        ic_single_ecc_error;\n', '   logic [3:0]        ic_double_ecc_error;\n', '   logic [3:0]        aligneccerr;\n', '\n', '  for (genvar i=0; i < 4 ; i++) begin : ic_ecc_error\n', '   rvecc_decode  ecc_decode (\n', '                           .en(~dec_tlu_core_ecc_disable),\n', ""                           .sed_ded(1'b1),\n"", ""                           .din({16'b0, aligndata[16*(i+1)-1: (16*i)]}),\n"", ""                           //.ecc_in({alignecc[(i*6)+5], 1'b0, alignecc[(i*6)+4:(i*6)]}),\n"", ""                           .ecc_in({2'b0, alignecc[(i*5)+4:(i*5)]}),\n"", '                           .dout(ic_corrected_data_nc[i][31:0]),\n', '                           .ecc_out(ic_corrected_ecc_nc[i][6:0]),\n', '                           .single_ecc_error(ic_single_ecc_error[i]),\n', '                           .double_ecc_error(ic_double_ecc_error[i]));\n', '\n', '    // or the sb and db error detects into 1 signal called aligndataperr[i] where i corresponds to 2B position\n', '   assign aligneccerr[i] = ic_single_ecc_error[i] | ic_double_ecc_error[i];\n', '   assign aligndataperr[i] = aligneccerr[i] ;\n', '  end // block: ic_ecc_error\n', '\n', '`else // !`ifdef RV_ICACHE_ECC\n', '\n', '  for (genvar i=0; i<4 ; i++) begin : ic_par_error\n', '   rveven_paritycheck pchk (\n', '                           .data_in(aligndata[16*(i+1)-1: 16*i]),\n', '                           .parity_in(alignparity[i]),\n', '                           .parity_err(aligndataperr[i])\n', '                           );\n', '  end\n', '\n', ' `endif // !`ifdef RV_ICACHE_ECC\n', '\n', '   // logic for trace\n', '   assign ifu_i0_cinst[15:0] = aligndata[15:0];\n', '   assign ifu_i1_cinst[15:0] = (first4B) ? aligndata[47:32] : aligndata[31:16];\n', '   // end trace\n', '\n', '   // check on 16B boundaries\n', '   //\n', ""   assign first4B = aligndata[16*0+1:16*0] == 2'b11;\n"", '   assign first2B = ~first4B;\n', '\n', ""   assign second4B = aligndata[16*1+1:16*1] == 2'b11;\n"", '   assign second2B = ~second4B;\n', '\n', ""   assign third4B = aligndata[16*2+1:16*2] == 2'b11;\n"", '   assign third2B = ~third4B;\n', '\n', '   assign ifu_i0_valid = ((first4B & alignval[1]) |\n', '                          (first2B & alignval[0])) & ~exu_flush_final;\n', '\n', '   assign ifu_i1_valid = ((first4B & third4B & alignval[3])  |\n', '                          (first4B & third2B & alignval[2])  |\n', '                          (first2B & second4B & alignval[2]) |\n', '                          (first2B & second2B & alignval[1])) & ~exu_flush_final;\n', '\n', '   // inst access fault on any byte of inst results in access fault for the inst\n', '   assign ifu_i0_icaf = ((first4B & (|alignicaf[1:0])) |\n', '                         (first2B &   alignicaf[0])) & ~exu_flush_final;\n', '\n', '\n', '\n', '   assign icaf_eff[3:0] = alignicaf[3:0] | aligndbecc[3:0];\n', '\n', '   assign ifu_i0_icaf_second = first4B & ~icaf_eff[0] & icaf_eff[1];\n', '\n', '   assign ifu_i1_icaf = ((first4B & third4B &  (|alignicaf[3:2])) |\n', '                         (first4B & third2B &    alignicaf[2])    |\n', '                         (first2B & second4B & (|alignicaf[2:1])) |\n', '                         (first2B & second2B &   alignicaf[1])) & ~exu_flush_final;\n', '\n', '   assign ifu_i1_icaf_second = (first4B & third4B  & ~icaf_eff[2] & icaf_eff[3]) |\n', '                               (first2B & second4B & ~icaf_eff[1] & icaf_eff[2]);\n', '\n', '   // inst parity error on any byte of inst results in parity error for the inst\n', '\n', '\n', '   assign alignfinalperr[3:0] = (aligntagperr[3:0] | aligndataperr[3:0]) & alignicfetch[3:0];\n', '\n', '   assign ifu_i0_perr = ((first4B & (|alignfinalperr[1:0])) |\n', '                         (first2B &   alignfinalperr[0])) & ~exu_flush_final;\n', '\n', '   assign ifu_i1_perr = ((first4B & third4B &  (|alignfinalperr[3:2])) |\n', '                         (first4B & third2B &    alignfinalperr[2])    |\n', '                         (first2B & second4B & (|alignfinalperr[2:1])) |\n', '                         (first2B & second2B &   alignfinalperr[1])) & ~exu_flush_final;\n', '\n', '   assign ifu_i0_sbecc = ((first4B & (|alignsbecc[1:0])) |\n', '                          (first2B &   alignsbecc[0])) & ~exu_flush_final;\n', '\n', '   assign ifu_i1_sbecc = ((first4B & third4B &  (|alignsbecc[3:2])) |\n', '                          (first4B & third2B &    alignsbecc[2])    |\n', '                          (first2B & second4B & (|alignsbecc[2:1])) |\n', '                          (first2B & second2B &   alignsbecc[1])) & ~exu_flush_final;\n', '\n', '   assign ifu_i0_dbecc = ((first4B & (|aligndbecc[1:0])) |\n', '                          (first2B &   aligndbecc[0])) & ~exu_flush_final;\n', '\n', '   assign ifu_i1_dbecc = ((first4B & third4B &  (|aligndbecc[3:2])) |\n', '                          (first4B & third2B &    aligndbecc[2])    |\n', '                          (first2B & second4B & (|aligndbecc[2:1])) |\n', '                          (first2B & second2B &   aligndbecc[1])) & ~exu_flush_final;\n', '\n', '   // send index information to the icache on a parity or single-bit ecc error\n', '   // parity error is orthogonal to single-bit ecc error; icache vs iccm\n', '\n', '   logic [2:0]  alignicerr;\n', '\n', '   assign alignicerr[2:0] = alignfinalperr[2:0] | alignsbecc[2:0];\n', '\n', '   assign ifu_icache_error_index[16:2] = (alignicerr[0]) ?  firstpc[16:2] :\n', '                                          (alignicerr[1]) ? secondpc[16:2] :\n', '                                          (alignicerr[2]) ?  thirdpc[16:2] :\n', '                                                            fourthpc[16:2];\n', '\n', '   assign ifu_icache_error_val = (i0_shift & ifu_i0_perr) |\n', '                                 (i1_shift & ifu_i1_perr & ~ifu_i0_sbecc);\n', '\n', '   assign ifu_icache_sb_error_val = (i0_shift & ifu_i0_sbecc) |\n', '                                    (i1_shift & ifu_i1_sbecc & ~ifu_i0_perr);\n', '\n', '`ifdef ASSERT_ON\n', '   assert_ifu_icache_parity_with_sbecc_error:   assert #0 ($onehot0({ifu_icache_error_val,ifu_icache_sb_error_val}));\n', '`endif\n', '   // big endian 4B instructions\n', '\n', '\n', '   assign ifirst[31:0] =  aligndata[2*16-1:0*16];\n', '\n', '   assign isecond[31:0] = aligndata[3*16-1:1*16];\n', '\n', '   assign ithird[31:0] =  aligndata[4*16-1:2*16];\n', '\n', '\n', '\n', '   assign ifu_i0_instr[31:0] = ({32{first4B}} & ifirst[31:0]) |\n', '                               ({32{first2B}} & uncompress0[31:0]);\n', '\n', '\n', '   assign ifu_i1_instr[31:0] = ({32{first4B & third4B}} & ithird[31:0]) |\n', '                               ({32{first4B & third2B}} & uncompress2[31:0]) |\n', '                               ({32{first2B & second4B}} & isecond[31:0]) |\n', '                               ({32{first2B & second2B}} & uncompress1[31:0]);\n', '\n', '   // if you detect br does not start on instruction boundary\n', '\n', '   rvbtb_addr_hash firsthash(.pc(firstpc[31:1]), .hash(firstpc_hash[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO]));\n', '   rvbtb_addr_hash secondhash(.pc(secondpc[31:1]), .hash(secondpc_hash[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO]));\n', '   rvbtb_addr_hash thirdhash(.pc(thirdpc[31:1]), .hash(thirdpc_hash[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO]));\n', '   rvbtb_addr_hash fourthhash(.pc(fourthpc[31:1]), .hash(fourthpc_hash[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO]));\n', '\n', '   logic [`RV_BTB_BTAG_SIZE-1:0] firstbrtag_hash, secondbrtag_hash, thirdbrtag_hash, fourthbrtag_hash;\n', '\n', '   rvbtb_tag_hash first_brhash(.pc(firstpc[31:1]), .hash(firstbrtag_hash[`RV_BTB_BTAG_SIZE-1:0]));\n', '   rvbtb_tag_hash second_brhash(.pc(secondpc[31:1]), .hash(secondbrtag_hash[`RV_BTB_BTAG_SIZE-1:0]));\n', '   rvbtb_tag_hash third_brhash(.pc(thirdpc[31:1]), .hash(thirdbrtag_hash[`RV_BTB_BTAG_SIZE-1:0]));\n', '   rvbtb_tag_hash fourth_brhash(.pc(fourthpc[31:1]), .hash(fourthbrtag_hash[`RV_BTB_BTAG_SIZE-1:0]));\n', '\n', '   // start_indexing - you want pc to be based on where the end of branch is prediction\n', ""   // normal indexing pc based that's incorrect now for pc4 cases it's pc4 + 2\n"", '\n', '   always_comb begin\n', '\n', ""      i0_brp = '0;\n"", '\n', '      i0_br_start_error = (first4B & alignval[1] & alignbrend[0]);\n', '\n', '      i0_brp.valid = (first2B & alignbrend[0]) |\n', '                     (first4B & alignbrend[1]) |\n', '                     i0_br_start_error;\n', '\n', '      i0_brp_pc4 = (first2B & alignpc4[0]) |\n', '                   (first4B & alignpc4[1]);\n', '\n', '      i0_brp.ret = (first2B & alignret[0]) |\n', '                   (first4B & alignret[1]);\n', '\n', '`ifdef RV_BTB_48\n', '      i0_brp.way = (first2B | alignbrend[0]) ? {alignway_b1[0], alignway_b0[0]} : {alignway_b1[1], alignway_b0[1]};\n', '`else\n', '      i0_brp.way = (first2B | alignbrend[0]) ? alignway[0] : alignway[1];\n', '`endif\n', '      i0_brp.hist[1] = (first2B & alignhist1[0]) |\n', '                       (first4B & alignhist1[1]);\n', '\n', '      i0_brp.hist[0] = (first2B & alignhist0[0]) |\n', '                       (first4B & alignhist0[1]);\n', '\n', '      i0_ends_f1 = (first4B & alignfromf1[1]);\n', '\n', '      i0_brp.toffset[11:0] = (i0_ends_f1) ? f1poffset[11:0] : f0poffset[11:0];\n', '\n', '      i0_brp.fghr[`RV_BHT_GHR_RANGE] = (i0_ends_f1) ? f1fghr[`RV_BHT_GHR_RANGE] : f0fghr[`RV_BHT_GHR_RANGE];\n', '\n', '      i0_brp.prett[31:1] = (i0_ends_f1) ? f1prett[31:1] : f0prett[31:1];\n', '\n', '      i0_brp.br_start_error = i0_br_start_error;\n', '\n', '      i0_brp.index[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] = (first2B | alignbrend[0]) ? firstpc_hash[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO]:\n', '                                                                                  secondpc_hash[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO];\n', '\n', '      i0_brp.btag[`RV_BTB_BTAG_SIZE-1:0] = (first2B | alignbrend[0]) ? firstbrtag_hash[`RV_BTB_BTAG_SIZE-1:0]:\n', '                                                                       secondbrtag_hash[`RV_BTB_BTAG_SIZE-1:0];\n', '\n', '      i0_brp.bank[1:0] = (first2B | alignbrend[0]) ? firstpc[3:2] :\n', '                                                     secondpc[3:2];\n', '\n', '\n', '      i0_brp.br_error = (i0_brp.valid &  i0_brp_pc4 &  first2B) |\n', '                        (i0_brp.valid & ~i0_brp_pc4 &  first4B);\n', '\n', ""      i1_brp = '0;\n"", '\n', '      i1_br_start_error = (first2B & second4B & alignval[2] & alignbrend[1]) |\n', '                          (first4B & third4B  & alignval[3] & alignbrend[2]);\n', '\n', '      i1_brp.valid = (first4B & third2B & alignbrend[2]) |\n', '                     (first4B & third4B & alignbrend[3]) |\n', '                     (first2B & second2B & alignbrend[1]) |\n', '                     (first2B & second4B & alignbrend[2]) |\n', '                     i1_br_start_error;\n', '\n', '      i1_brp_pc4 = (first4B & third2B & alignpc4[2]) |\n', '                   (first4B & third4B & alignpc4[3]) |\n', '                   (first2B & second2B & alignpc4[1]) |\n', '                   (first2B & second4B & alignpc4[2]);\n', '\n', '      i1_brp.ret = (first4B & third2B & alignret[2]) |\n', '                   (first4B & third4B & alignret[3]) |\n', '                   (first2B & second2B & alignret[1]) |\n', '                   (first2B & second4B & alignret[2]);\n', '`ifdef RV_BTB_48\n', '      i1_brp.way = ({2{first4B & third2B                  }} & {alignway_b1[2], alignway_b0[2]} ) |\n', '                   ({2{first4B & third4B &  alignbrend[2] }} & {alignway_b1[2], alignway_b0[2]} ) |\n', '                   ({2{first4B & third4B & ~alignbrend[2] }} & {alignway_b1[3], alignway_b0[3]} ) |\n', '                   ({2{first2B & second2B                 }} & {alignway_b1[1], alignway_b0[1]} ) |\n', '                   ({2{first2B & second4B &  alignbrend[1]}} & {alignway_b1[1], alignway_b0[1]} ) |\n', '                   ({2{first2B & second4B & ~alignbrend[1]}} & {alignway_b1[2], alignway_b0[2]} );\n', '`else\n', '      i1_brp.way = (first4B & third2B                   & alignway[2] ) |\n', '                   (first4B & third4B &  alignbrend[2]  & alignway[2] ) |\n', '                   (first4B & third4B & ~alignbrend[2]  & alignway[3] ) |\n', '                   (first2B & second2B                  & alignway[1] ) |\n', '                   (first2B & second4B &  alignbrend[1] & alignway[1] ) |\n', '                   (first2B & second4B & ~alignbrend[1] & alignway[2] );\n', '`endif\n', '      i1_brp.hist[1] = (first4B & third2B & alignhist1[2]) |\n', '                       (first4B & third4B & alignhist1[3]) |\n', '                       (first2B & second2B & alignhist1[1]) |\n', '                       (first2B & second4B & alignhist1[2]);\n', '\n', '      i1_brp.hist[0] = (first4B & third2B & alignhist0[2]) |\n', '                       (first4B & third4B & alignhist0[3]) |\n', '                       (first2B & second2B & alignhist0[1]) |\n', '                       (first2B & second4B & alignhist0[2]);\n', '\n', '      i1_ends_f1 = (first4B & third2B & alignfromf1[2]) |\n', '                   (first4B & third4B & alignfromf1[3]) |\n', '                   (first2B & second2B & alignfromf1[1]) |\n', '                   (first2B & second4B & alignfromf1[2]);\n', '\n', '      i1_brp.toffset[11:0] = (i1_ends_f1) ? f1poffset[11:0] : f0poffset[11:0];\n', '\n', '      i1_brp.fghr[`RV_BHT_GHR_RANGE] = (i1_ends_f1) ? f1fghr[`RV_BHT_GHR_RANGE] : f0fghr[`RV_BHT_GHR_RANGE];\n', '\n', '      i1_brp.prett[31:1] = (i1_ends_f1) ? f1prett[31:1] : f0prett[31:1];\n', '\n', '      i1_brp.br_start_error = i1_br_start_error;\n', '\n', '`define RV_BTB_RANGE  `RV_BTB_ADDR_HI-`RV_BTB_ADDR_LO+1\n', '\n', '      i1_brp.index[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] = ({`RV_BTB_RANGE{first4B & third2B }}                  & thirdpc_hash[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] ) |\n', '                                                ({`RV_BTB_RANGE{first4B & third4B &  alignbrend[2] }} & thirdpc_hash[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] ) |\n', '                                                ({`RV_BTB_RANGE{first4B & third4B & ~alignbrend[2] }} & fourthpc_hash[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] ) |\n', '                                                ({`RV_BTB_RANGE{first2B & second2B}}                  & secondpc_hash[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] ) |\n', '                                                ({`RV_BTB_RANGE{first2B & second4B &  alignbrend[1]}} & secondpc_hash[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] ) |\n', '                                                ({`RV_BTB_RANGE{first2B & second4B & ~alignbrend[1]}} & thirdpc_hash[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] );\n', '\n', '      i1_brp.btag[`RV_BTB_BTAG_SIZE-1:0] = ({`RV_BTB_BTAG_SIZE{first4B & third2B }}                  &  thirdbrtag_hash[`RV_BTB_BTAG_SIZE-1:0] ) |\n', '                                           ({`RV_BTB_BTAG_SIZE{first4B & third4B &  alignbrend[2] }} &  thirdbrtag_hash[`RV_BTB_BTAG_SIZE-1:0] ) |\n', '                                           ({`RV_BTB_BTAG_SIZE{first4B & third4B & ~alignbrend[2] }} & fourthbrtag_hash[`RV_BTB_BTAG_SIZE-1:0] ) |\n', '                                           ({`RV_BTB_BTAG_SIZE{first2B & second2B}}                  & secondbrtag_hash[`RV_BTB_BTAG_SIZE-1:0] ) |\n', '                                           ({`RV_BTB_BTAG_SIZE{first2B & second4B &  alignbrend[1]}} & secondbrtag_hash[`RV_BTB_BTAG_SIZE-1:0] ) |\n', '                                           ({`RV_BTB_BTAG_SIZE{first2B & second4B & ~alignbrend[1]}} &  thirdbrtag_hash[`RV_BTB_BTAG_SIZE-1:0] );\n', '\n', '      i1_brp.bank[1:0] = ({2{first4B & third2B }}                  & thirdpc[3:2] ) |\n', '                         ({2{first4B & third4B &  alignbrend[2] }} & thirdpc[3:2] ) |\n', '                         ({2{first4B & third4B & ~alignbrend[2] }} & fourthpc[3:2] ) |\n', '                         ({2{first2B & second2B}}                  & secondpc[3:2] ) |\n', '                         ({2{first2B & second4B &  alignbrend[1]}} & secondpc[3:2] ) |\n', '                         ({2{first2B & second4B & ~alignbrend[1]}} & thirdpc[3:2] );\n', '\n', '      i1_brp.br_error = (i1_brp.valid &  i1_brp_pc4 & first4B & third2B ) |\n', '                        (i1_brp.valid & ~i1_brp_pc4 & first4B & third4B ) |\n', '                        (i1_brp.valid &  i1_brp_pc4 & first2B & second2B) |\n', '                        (i1_brp.valid & ~i1_brp_pc4 & first2B & second4B);\n', '   end\n', '\n', '// figure out 2B illegal insts\n', '\n', '   assign i0_illegal = (first2B & ~first_legal);\n', '\n', '   assign i1_illegal = (first2B & second2B & ~second_legal) |\n', '                       (first4B & third2B & ~third_legal);\n', '\n', '   assign shift_illegal = (i0_shift & i0_illegal) |\n', '                          (i1_shift & i1_illegal);\n', '\n', '   assign illegal_inst[15:0] =   (first2B & ~first_legal)             ? aligndata[1*16-1:0*16] :\n', '                                ((first2B & second2B & ~second_legal) ? aligndata[2*16-1:1*16] : aligndata[3*16-1:2*16]);\n', '\n', '   assign illegal_inst_en = shift_illegal & ~illegal_lockout;\n', '\n', '   rvdffe #(16) illegal_any_ff (.*, .en(illegal_inst_en), .din(illegal_inst[15:0]), .dout(ifu_illegal_inst[15:0]));\n', '\n', '   assign illegal_lockout_in = (shift_illegal | illegal_lockout) & ~exu_flush_final;\n', '\n', '   rvdff #(1) illegal_lockout_any_ff (.*, .clk(active_clk), .din(illegal_lockout_in), .dout(illegal_lockout));\n', '\n', '\n', '   // decompress\n', '\n', '   ifu_compress_ctl compress0 (.din(aligndata[16*1-1:0*16]), .dout(uncompress0[31:0]), .legal(first_legal)  );\n', '\n', '   ifu_compress_ctl compress1 (.din(aligndata[16*2-1:1*16]), .dout(uncompress1[31:0]), .legal(second_legal) );\n', '\n', '   ifu_compress_ctl compress2 (.din(aligndata[16*3-1:2*16]), .dout(uncompress2[31:0]), .legal(third_legal)  );\n', '\n', '\n', '\n', '   assign i0_shift = ifu_i0_valid & ibuffer_room1_more;\n', '\n', '   assign i1_shift = ifu_i1_valid & ibuffer_room2_more;\n', '\n', '   if (DEC_INSTBUF_DEPTH==4) begin\n', '      assign ibuffer_room1_more = ~dec_ib3_valid_d;\n', '      assign ibuffer_room2_more = ~dec_ib2_valid_d;\n', '   end\n', '   else begin\n', '      assign ibuffer_room1_more = ~dec_ib0_valid_eff_d | ~dec_ib1_valid_eff_d;\n', '      assign ibuffer_room2_more = ~dec_ib0_valid_eff_d & ~dec_ib1_valid_eff_d;\n', '   end\n', '\n', '\n', '\n', '   assign ifu_pmu_instr_aligned[1:0] = { i1_shift, i0_shift };\n', '\n', '   assign ifu_pmu_align_stall = ifu_i0_valid & ~ibuffer_room1_more;\n', '\n', '   // compute how many bytes are being shifted from f0\n', '\n', '   // assign shift_0B = ~i0_shift;\n', '\n', '   assign shift_2B = i0_shift & ~i1_shift & first2B;\n', '\n', '\n', '   assign shift_4B = (i0_shift & ~i1_shift & first4B) |\n', '                     (i0_shift &  i1_shift & first2B & second2B);\n', '\n', '   assign shift_6B = (i0_shift &  i1_shift & first2B & second4B) |\n', '                     (i0_shift &  i1_shift & first4B & third2B);\n', '\n', '   assign shift_8B = i0_shift &  i1_shift & first4B & third4B;\n', '\n', '   // exact equations for the queue logic\n', '   assign f0_shift_2B = (shift_2B & f0val[0]) |\n', '                        ((shift_4B | shift_6B | shift_8B) & f0val[0] & ~f0val[1]);\n', '\n', '   assign f0_shift_4B = (shift_4B & f0val[1]) |\n', '                        ((shift_6B & shift_8B) & f0val[1] & ~f0val[2]);\n', '\n', '\n', '   assign f0_shift_6B = (shift_6B & f0val[2]) |\n', '                        (shift_8B & f0val[2] & ~f0val[3]);\n', '\n', '   assign f0_shift_8B =  shift_8B & f0val[3];\n', '\n', '\n', '\n', '   // f0 valid states\n', '   //\n', '   // 11111111\n', '   // 11111110\n', '   // 11111100\n', '   // 11111000\n', '   // 11110000\n', '\n', '   // 11100000\n', '   // 11000000\n', '   // 10000000\n', '   // 00000000\n', '\n', '   // assign f1_shift_0B = shift_0B;\n', '\n', '   assign f1_shift_2B = (f0val[2] & ~f0val[3] & shift_8B) |\n', '                        (f0val[1] & ~f0val[2] & shift_6B) |\n', '                        (f0val[0] & ~f0val[1] & shift_4B);\n', '\n', '   assign f1_shift_4B = (f0val[1] & ~f0val[2] & shift_8B) |\n', '                        (f0val[0] & ~f0val[1] & shift_6B);\n', '\n', '   assign f1_shift_6B = (f0val[0] & ~f0val[1] & shift_8B);\n', '\n', '\n', '\n', 'endmodule\n', '\n']"
"['//********************************************************************************\n', '// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '//********************************************************************************\n', '\n', '//********************************************************************************\n', '// Function: Branch predictor\n', '// Comments:\n', '//\n', '//\n', '//  Bank3 : Bank2 : Bank1 : Bank0\n', '//  FA  C       8       4       0\n', '//********************************************************************************\n', '\n', 'module ifu_bp_ctl\n', '   import veer_types::*;\n', '(\n', '\n', '   input logic clk,\n', '   input logic active_clk,\n', '   input logic clk_override,\n', '   input logic rst_l,\n', '\n', '   input logic ic_hit_f2,      // Icache hit, enables F2 address capture\n', '\n', '   input logic [31:1] ifc_fetch_addr_f1, // look up btb address\n', '   input logic [31:1] ifc_fetch_addr_f2, // to tgt calc\n', '   input logic ifc_fetch_req_f1,  // F1 valid\n', '   input logic ifc_fetch_req_f2,  // F2 valid\n', '\n', '   input br_tlu_pkt_t dec_tlu_br0_wb_pkt, // BP commit update packet, includes errors\n', '   input br_tlu_pkt_t dec_tlu_br1_wb_pkt, // BP commit update packet, includes errors\n', '\n', '   input logic dec_tlu_flush_lower_wb, // used to move EX4 RS to EX1 and F\n', ""   input logic dec_tlu_flush_leak_one_wb, // don't hit for leak one fetches\n"", '\n', '   input logic dec_tlu_bpred_disable, // disable all branch prediction\n', '\n', '   input logic        exu_i0_br_ret_e4, // EX4 ret stack update\n', '   input logic        exu_i1_br_ret_e4, // EX4 ret stack update\n', '   input logic        exu_i0_br_call_e4, // EX4 ret stack update\n', '   input logic        exu_i1_br_call_e4, // EX4 ret stack update\n', '\n', '   input predict_pkt_t  exu_mp_pkt, // mispredict packet\n', '\n', '   input rets_pkt_t exu_rets_e1_pkt, // EX1 rets packet\n', '   input rets_pkt_t exu_rets_e4_pkt, // EX4 rets packet\n', '\n', '`ifdef REAL_COMM_RS\n', '   input logic [31:1] exu_i0_pc_e1, // Used for RS computation\n', '   input logic [31:1] exu_i1_pc_e1, // Used for RS computation\n', '   input logic [31:1] dec_tlu_i0_pc_e4,  // Used for RS computation\n', '   input logic [31:1] dec_tlu_i1_pc_e4,  // Used for RS computation\n', '`endif\n', '\n', '   input logic [`RV_BHT_GHR_RANGE] exu_mp_eghr, // execute ghr (for patching fghr)\n', '\n', '   input logic exu_flush_final, // all flushes\n', '   input logic exu_flush_upper_e2, // flush upper, either i0 or i1, cp EX1 RS to F RS\n', '\n', '   output logic ifu_bp_kill_next_f2, // kill next fetch, taken target found\n', '   output logic [31:1] ifu_bp_btb_target_f2, //  predicted target PC\n', '   output logic [7:1] ifu_bp_inst_mask_f2, // tell ic which valids to kill because of a taken branch, right justified\n', '\n', '   output logic [`RV_BHT_GHR_RANGE] ifu_bp_fghr_f2, // fetch ghr\n', '\n', '`ifdef RV_BTB_48\n', '   output logic [7:0][1:0] ifu_bp_way_f2, // way\n', '`else\n', '   output logic [7:0] ifu_bp_way_f2, // way\n', '`endif\n', '   output logic [7:0] ifu_bp_ret_f2, // predicted ret\n', '   output logic [7:0] ifu_bp_hist1_f2, // history counters for all 4 potential branches, bit 1, right justified\n', '   output logic [7:0] ifu_bp_hist0_f2, // history counters for all 4 potential branches, bit 0, right justified\n', '   output logic [11:0] ifu_bp_poffset_f2, // predicted target\n', '   output logic [7:0] ifu_bp_pc4_f2, // pc4 indication, right justified\n', '   output logic [7:0] ifu_bp_valid_f2, // branch valid, right justified\n', '\n', '   input  logic       scan_mode\n', '   );\n', '\n', '`define TAG 16+`RV_BTB_BTAG_SIZE:17\n', '\n', '   localparam PC4=4;\n', '   localparam BOFF=3;\n', '   localparam CALL=2;\n', '   localparam RET=1;\n', '   localparam BV=0;\n', '\n', '   localparam LRU_SIZE=`RV_BTB_ARRAY_DEPTH;\n', '   localparam NUM_BHT_LOOP = (`RV_BHT_ARRAY_DEPTH > 16 ) ? 16 : `RV_BHT_ARRAY_DEPTH;\n', '   localparam NUM_BHT_LOOP_INNER_HI =  (`RV_BHT_ARRAY_DEPTH > 16 ) ?`RV_BHT_ADDR_LO+3 : `RV_BHT_ADDR_HI;\n', '   localparam NUM_BHT_LOOP_OUTER_LO =  (`RV_BHT_ARRAY_DEPTH > 16 ) ?`RV_BHT_ADDR_LO+4 : `RV_BHT_ADDR_LO;\n', '   localparam BHT_NO_ADDR_MATCH  = ( `RV_BHT_ARRAY_DEPTH <= 16 );\n', '\n', '   logic exu_mp_valid_write;\n', '   logic exu_mp_ataken;\n', '   logic exu_mp_valid; // conditional branch mispredict\n', '   logic exu_mp_boffset; // branch offsett\n', '   logic exu_mp_pc4; // branch is a 4B inst\n', '   logic exu_mp_call; // branch is a call inst\n', '   logic exu_mp_ret; // branch is a ret inst\n', '   logic exu_mp_ja; // branch is a jump always\n', '   logic [1:0] exu_mp_hist; // new history\n', '   logic [11:0] exu_mp_tgt; // target offset\n', '   logic [`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] exu_mp_addr; // BTB/BHT address\n', '   logic [1:0]                             exu_mp_bank; // write bank; based on branch PC[3:2]\n', '   logic [`RV_BTB_BTAG_SIZE-1:0]           exu_mp_btag; // branch tag\n', '   logic [`RV_BHT_GHR_RANGE]               exu_mp_fghr; // original fetch ghr (for bht update)\n', '   logic                                   dec_tlu_br0_v_wb; // WB stage history update\n', '   logic [1:0]                             dec_tlu_br0_hist_wb; // new history\n', '   logic [`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] dec_tlu_br0_addr_wb; // addr\n', '   logic [1:0]                             dec_tlu_br0_bank_wb; // write bank; based on branch PC[3:2]\n', '   logic                                   dec_tlu_br0_error_wb; // error; invalidate bank\n', '   logic                                   dec_tlu_br0_start_error_wb; // error; invalidate all 4 banks in fg\n', '   logic [`RV_BHT_GHR_RANGE]               dec_tlu_br0_fghr_wb;\n', '\n', '   logic                                   dec_tlu_br1_v_wb; // WB stage history update\n', '   logic [1:0]                             dec_tlu_br1_hist_wb; // new history\n', '   logic [`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] dec_tlu_br1_addr_wb; // addr\n', '   logic [1:0]                             dec_tlu_br1_bank_wb; // write bank; based on branch PC[3:2]\n', '   logic                                   dec_tlu_br1_error_wb; // error\n', '   logic                                   dec_tlu_br1_start_error_wb; // error; invalidate all 4 banks in fg\n', '   logic [`RV_BHT_GHR_RANGE]               dec_tlu_br1_fghr_wb;\n', '\n', '   logic [3:0]        use_mp_way;\n', '   logic [`RV_RET_STACK_SIZE-1:0][31:1] rets_out, rets_in, e1_rets_out, e1_rets_in, e4_rets_out, e4_rets_in;\n', '   logic [`RV_RET_STACK_SIZE-1:0]       rsenable;\n', '\n', '\n', '   logic [11:0]       btb_rd_tgt_f2;\n', '   logic              btb_rd_pc4_f2, btb_rd_boffset_f2,  btb_rd_call_f2, btb_rd_ret_f2;\n', '   logic [3:1]        bp_total_branch_offset_f2;\n', '\n', '   logic [31:1]       bp_btb_target_adder_f2;\n', '   logic [31:1]       bp_rs_call_target_f2;\n', '   logic              rs_push, rs_pop, rs_hold;\n', '   logic [`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] btb_rd_addr_f1, btb_wr_addr, btb_rd_addr_f2;\n', '   logic [`RV_BTB_BTAG_SIZE-1:0] btb_wr_tag, fetch_rd_tag_f1, fetch_rd_tag_f2;\n', '   logic [16+`RV_BTB_BTAG_SIZE:0]        btb_wr_data;\n', '   logic [3:0]         btb_wr_en_way0, btb_wr_en_way1;\n', '\n', '\n', '   logic               dec_tlu_error_wb, dec_tlu_all_banks_error_wb, btb_valid, dec_tlu_br0_middle_wb, dec_tlu_br1_middle_wb;\n', '   logic [`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO]        btb_error_addr_wb;\n', '   logic [1:0]         dec_tlu_error_bank_wb;\n', '   logic branch_error_collision_f1, fetch_mp_collision_f1, fetch_mp_collision_f2;\n', '\n', '   logic [6:0] fgmask_f2;\n', '   logic [3:0] branch_error_bank_conflict_f1, branch_error_bank_conflict_f2;\n', '   logic [`RV_BHT_GHR_RANGE] merged_ghr, fghr_ns, fghr;\n', '   logic [3:0] num_valids;\n', '   logic [LRU_SIZE-1:0] btb_lru_b0_f, btb_lru_b0_hold, btb_lru_b0_ns, btb_lru_b1_f, btb_lru_b1_hold, btb_lru_b1_ns,\n', '                        btb_lru_b2_f, btb_lru_b2_hold, btb_lru_b2_ns, btb_lru_b3_f, btb_lru_b3_hold, btb_lru_b3_ns,\n', '                        fetch_wrindex_dec, fetch_wrlru_b0, fetch_wrlru_b1, fetch_wrlru_b2, fetch_wrlru_b3,\n', '                        mp_wrindex_dec, mp_wrlru_b0, mp_wrlru_b1, mp_wrlru_b2, mp_wrlru_b3;\n', '   logic [3:0]          btb_lru_rd_f2, mp_bank_decoded, mp_bank_decoded_f, lru_update_valid_f2;\n', '   logic [3:0] tag_match_way0_f2, tag_match_way1_f2;\n', '   logic [7:0] way_raw, bht_dir_f2, btb_sel_f2, wayhit_f2;\n', '   logic [7:0] btb_sel_mask_f2, bht_valid_f2, bht_force_taken_f2;\n', '\n', '   logic leak_one_f1, leak_one_f2, ifc_fetch_req_f2_raw;\n', '\n', '   logic [LRU_SIZE-1:0][16+`RV_BTB_BTAG_SIZE:0]  btb_bank0_rd_data_way0_out ;\n', '   logic [LRU_SIZE-1:0][16+`RV_BTB_BTAG_SIZE:0]  btb_bank1_rd_data_way0_out ;\n', '   logic [LRU_SIZE-1:0][16+`RV_BTB_BTAG_SIZE:0]  btb_bank2_rd_data_way0_out ;\n', '   logic [LRU_SIZE-1:0][16+`RV_BTB_BTAG_SIZE:0]  btb_bank3_rd_data_way0_out ;\n', '\n', '   logic [LRU_SIZE-1:0][16+`RV_BTB_BTAG_SIZE:0]  btb_bank0_rd_data_way1_out ;\n', '   logic [LRU_SIZE-1:0][16+`RV_BTB_BTAG_SIZE:0]  btb_bank1_rd_data_way1_out ;\n', '   logic [LRU_SIZE-1:0][16+`RV_BTB_BTAG_SIZE:0]  btb_bank2_rd_data_way1_out ;\n', '   logic [LRU_SIZE-1:0][16+`RV_BTB_BTAG_SIZE:0]  btb_bank3_rd_data_way1_out ;\n', '\n', '   logic                [16+`RV_BTB_BTAG_SIZE:0] btb_bank0_rd_data_way0_f2_in ;\n', '   logic                [16+`RV_BTB_BTAG_SIZE:0] btb_bank1_rd_data_way0_f2_in ;\n', '   logic                [16+`RV_BTB_BTAG_SIZE:0] btb_bank2_rd_data_way0_f2_in ;\n', '   logic                [16+`RV_BTB_BTAG_SIZE:0] btb_bank3_rd_data_way0_f2_in ;\n', '\n', '   logic                [16+`RV_BTB_BTAG_SIZE:0] btb_bank0_rd_data_way1_f2_in ;\n', '   logic                [16+`RV_BTB_BTAG_SIZE:0] btb_bank1_rd_data_way1_f2_in ;\n', '   logic                [16+`RV_BTB_BTAG_SIZE:0] btb_bank2_rd_data_way1_f2_in ;\n', '   logic                [16+`RV_BTB_BTAG_SIZE:0] btb_bank3_rd_data_way1_f2_in ;\n', '\n', '\n', '   logic                [16+`RV_BTB_BTAG_SIZE:0] btb_bank0_rd_data_way0_f2 ;\n', '   logic                [16+`RV_BTB_BTAG_SIZE:0] btb_bank1_rd_data_way0_f2 ;\n', '   logic                [16+`RV_BTB_BTAG_SIZE:0] btb_bank2_rd_data_way0_f2 ;\n', '   logic                [16+`RV_BTB_BTAG_SIZE:0] btb_bank3_rd_data_way0_f2 ;\n', '\n', '   logic                [16+`RV_BTB_BTAG_SIZE:0] btb_bank0_rd_data_way1_f2 ;\n', '   logic                [16+`RV_BTB_BTAG_SIZE:0] btb_bank1_rd_data_way1_f2 ;\n', '   logic                [16+`RV_BTB_BTAG_SIZE:0] btb_bank2_rd_data_way1_f2 ;\n', '   logic                [16+`RV_BTB_BTAG_SIZE:0] btb_bank3_rd_data_way1_f2 ;\n', '\n', '   logic                                         final_h;\n', '   logic                                         btb_fg_crossing_f2;\n', '   logic                                         rs_correct;\n', '   logic                                         middle_of_bank;\n', '\n', '`ifdef RV_BTB_48\n', '   logic                [16+`RV_BTB_BTAG_SIZE:0] btb_bank0_rd_data_way2_f2_in ;\n', '   logic                [16+`RV_BTB_BTAG_SIZE:0] btb_bank1_rd_data_way2_f2_in ;\n', '   logic                [16+`RV_BTB_BTAG_SIZE:0] btb_bank2_rd_data_way2_f2_in ;\n', '   logic                [16+`RV_BTB_BTAG_SIZE:0] btb_bank3_rd_data_way2_f2_in ;\n', '   logic                [16+`RV_BTB_BTAG_SIZE:0] btb_bank0_rd_data_way2_f2 ;\n', '   logic                [16+`RV_BTB_BTAG_SIZE:0] btb_bank1_rd_data_way2_f2 ;\n', '   logic                [16+`RV_BTB_BTAG_SIZE:0] btb_bank2_rd_data_way2_f2 ;\n', '   logic                [16+`RV_BTB_BTAG_SIZE:0] btb_bank3_rd_data_way2_f2 ;\n', '   logic [LRU_SIZE-1:0][16+`RV_BTB_BTAG_SIZE:0]  btb_bank0_rd_data_way2_out ;\n', '   logic [LRU_SIZE-1:0][16+`RV_BTB_BTAG_SIZE:0]  btb_bank1_rd_data_way2_out ;\n', '   logic [LRU_SIZE-1:0][16+`RV_BTB_BTAG_SIZE:0]  btb_bank2_rd_data_way2_out ;\n', '   logic [LRU_SIZE-1:0][16+`RV_BTB_BTAG_SIZE:0]  btb_bank3_rd_data_way2_out ;\n', '   logic [3:0]                                   btb_wr_en_way2, tag_match_way2_f2, fetch_lru_bank_hit_f2;\n', '   logic [7:0]                                   tag_match_way2_expanded_f2;\n', '\n', '   logic [1:0] exu_mp_way, exu_mp_way_f, dec_tlu_br0_way_wb, dec_tlu_br1_way_wb, dec_tlu_way_wb, dec_tlu_way_wb_f;\n', '\n', '`else // !`ifdef RV_BTB_48\n', '   logic exu_mp_way, exu_mp_way_f, dec_tlu_br0_way_wb, dec_tlu_br1_way_wb, dec_tlu_way_wb, dec_tlu_way_wb_f;\n', '\n', '`endif\n', '   logic                [16+`RV_BTB_BTAG_SIZE:0] btb_bank0e_rd_data_f2 ;\n', '   logic                [16+`RV_BTB_BTAG_SIZE:0] btb_bank1e_rd_data_f2 ;\n', '   logic                [16+`RV_BTB_BTAG_SIZE:0] btb_bank2e_rd_data_f2 ;\n', '   logic                [16+`RV_BTB_BTAG_SIZE:0] btb_bank3e_rd_data_f2 ;\n', '\n', '   logic                [16+`RV_BTB_BTAG_SIZE:0] btb_bank0o_rd_data_f2 ;\n', '   logic                [16+`RV_BTB_BTAG_SIZE:0] btb_bank1o_rd_data_f2 ;\n', '   logic                [16+`RV_BTB_BTAG_SIZE:0] btb_bank2o_rd_data_f2 ;\n', '   logic                [16+`RV_BTB_BTAG_SIZE:0] btb_bank3o_rd_data_f2 ;\n', '\n', '   logic [7:0] tag_match_way0_expanded_f2, tag_match_way1_expanded_f2;\n', '\n', '\n', '    logic [1:0]                                  bht_bank0_rd_data_f2 ;\n', '    logic [1:0]                                  bht_bank1_rd_data_f2 ;\n', '    logic [1:0]                                  bht_bank2_rd_data_f2 ;\n', '    logic [1:0]                                  bht_bank3_rd_data_f2 ;\n', '    logic [1:0]                                  bht_bank4_rd_data_f2 ;\n', '    logic [1:0]                                  bht_bank5_rd_data_f2 ;\n', '    logic [1:0]                                  bht_bank6_rd_data_f2 ;\n', '    logic [1:0]                                  bht_bank7_rd_data_f2 ;\n', '\n', '   assign exu_mp_valid = exu_mp_pkt.misp & ~leak_one_f2; // conditional branch mispredict\n', '   assign exu_mp_boffset = exu_mp_pkt.boffset;  // branch offset\n', '   assign exu_mp_pc4 = exu_mp_pkt.pc4;  // branch is a 4B inst\n', '   assign exu_mp_call = exu_mp_pkt.pcall;  // branch is a call inst\n', '   assign exu_mp_ret = exu_mp_pkt.pret;  // branch is a ret inst\n', '   assign exu_mp_ja = exu_mp_pkt.pja;  // branch is a jump always\n', '   assign exu_mp_way = exu_mp_pkt.way;  // repl way\n', '   assign exu_mp_hist[1:0] = exu_mp_pkt.hist[1:0];  // new history\n', '   assign exu_mp_tgt[11:0]  = exu_mp_pkt.toffset[11:0] ;  // target offset\n', '   assign exu_mp_addr[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO]  = exu_mp_pkt.index[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] ;  // BTB/BHT address\n', '   assign exu_mp_bank[1:0]  = exu_mp_pkt.bank[1:0] ;  // write bank = exu_mp_pkt.;  based on branch PC[3:2]\n', '   assign exu_mp_btag[`RV_BTB_BTAG_SIZE-1:0]  = exu_mp_pkt.btag[`RV_BTB_BTAG_SIZE-1:0] ;  // branch tag\n', '   assign exu_mp_fghr[`RV_BHT_GHR_RANGE]  = exu_mp_pkt.fghr[`RV_BHT_GHR_RANGE] ;  // original fetch ghr (for bht update)\n', '   assign exu_mp_ataken = exu_mp_pkt.ataken;\n', '\n', '   assign dec_tlu_br0_v_wb = dec_tlu_br0_wb_pkt.valid;\n', '   assign dec_tlu_br0_hist_wb[1:0]  = dec_tlu_br0_wb_pkt.hist[1:0];\n', '   assign dec_tlu_br0_addr_wb[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] = dec_tlu_br0_wb_pkt.index[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO];\n', '   assign dec_tlu_br0_bank_wb[1:0]  = dec_tlu_br0_wb_pkt.bank[1:0];\n', '   assign dec_tlu_br0_error_wb = dec_tlu_br0_wb_pkt.br_error;\n', '   assign dec_tlu_br0_middle_wb = dec_tlu_br0_wb_pkt.middle;\n', '   assign dec_tlu_br0_way_wb = dec_tlu_br0_wb_pkt.way;\n', '   assign dec_tlu_br0_start_error_wb = dec_tlu_br0_wb_pkt.br_start_error;\n', '   assign dec_tlu_br0_fghr_wb[`RV_BHT_GHR_RANGE] = dec_tlu_br0_wb_pkt.fghr[`RV_BHT_GHR_RANGE];\n', '\n', '   assign dec_tlu_br1_v_wb = dec_tlu_br1_wb_pkt.valid;\n', '   assign dec_tlu_br1_hist_wb[1:0]  = dec_tlu_br1_wb_pkt.hist[1:0];\n', '   assign dec_tlu_br1_addr_wb[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] = dec_tlu_br1_wb_pkt.index[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO];\n', '   assign dec_tlu_br1_bank_wb[1:0]  = dec_tlu_br1_wb_pkt.bank[1:0];\n', '   assign dec_tlu_br1_middle_wb = dec_tlu_br1_wb_pkt.middle;\n', '   assign dec_tlu_br1_error_wb = dec_tlu_br1_wb_pkt.br_error;\n', '   assign dec_tlu_br1_way_wb = dec_tlu_br1_wb_pkt.way;\n', '   assign dec_tlu_br1_start_error_wb = dec_tlu_br1_wb_pkt.br_start_error;\n', '   assign  dec_tlu_br1_fghr_wb[`RV_BHT_GHR_RANGE] = dec_tlu_br1_wb_pkt.fghr[`RV_BHT_GHR_RANGE];\n', '\n', '\n', '\n', '   // ----------------------------------------------------------------------\n', '   // READ\n', '   // ----------------------------------------------------------------------\n', '\n', '\n', '   // hash the incoming fetch PC, first guess at hashing algorithm\n', '   rvbtb_addr_hash f1hash(.pc(ifc_fetch_addr_f1[31:1]), .hash(btb_rd_addr_f1[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO]));\n', '   rvbtb_addr_hash f2hash(.pc(ifc_fetch_addr_f2[31:1]), .hash(btb_rd_addr_f2[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO]));\n', '\n', '\n', '   // based on the fetch group offset(PC[3:2]) and direction bits, findfirst from fetchPC\n', '   // this sel is zero/onehot\n', '   // Put the table below in a file and run espresso to generate the btb_sel_f2 and btb_vmask_raw_f2 equations\n', '   // espresso -oeqntott -eeat <file> | addassign\n', '//\n', '// .i 11\n', '// .o 15\n', '// .ilb ifc_fetch_addr_f2[3] ifc_fetch_addr_f2[2] ifc_fetch_addr_f2[1] bht_dir_f2[7] bht_dir_f2[6] bht_dir_f2[5] bht_dir_f2[4] bht_dir_f2[3] bht_dir_f2[2] bht_dir_f2[1] bht_dir_f2[0]\n', '// .ob btb_sel_f2[7] btb_sel_f2[6] btb_sel_f2[5] btb_sel_f2[4] btb_sel_f2[3] btb_sel_f2[2] btb_sel_f2[1] btb_sel_f2[0] btb_vmask_raw_f2[7] btb_vmask_raw_f2[6] btb_vmask_raw_f2[5] btb_vmask_raw_f2[4] btb_vmask_raw_f2[3] btb_vmask_raw_f2[2] btb_vmask_raw_f2[1]\n', '// .type fr\n', '// ##faddress[3:1] dir[7:0] sel[7:0] mask[7:1]\n', '// 000             -------1 00000001 0000000\n', '// 000             ------10 00000010 0000001\n', '// 000             -----100 00000100 0000010\n', '// 000             ----1000 00001000 0000100\n', '// 000             ---10000 00010000 0001000\n', '// 000             --100000 00100000 0010000\n', '// 000             -1000000 01000000 0100000\n', '// 000             10000000 10000000 1000000\n', '//\n', '// 001             ------1- 00000010 0000000\n', '// 001             -----10- 00000100 0000001\n', '// 001             ----100- 00001000 0000010\n', '// 001             ---1000- 00010000 0000100\n', '// 001             --10000- 00100000 0001000\n', '// 001             -100000- 01000000 0010000\n', '// 001             1000000- 10000000 0110000\n', '//\n', '// 010             -----1-- 00000100 0000000\n', '// 010             ----10-- 00001000 0000001\n', '// 010             ---100-- 00010000 0000010\n', '// 010             --1000-- 00100000 0000100\n', '// 010             -10000-- 01000000 0001000\n', '// 010             100000-- 10000000 0010000\n', '//\n', '// 011             ----1--- 00001000 0000000\n', '// 011             ---10--- 00010000 0000001\n', '// 011             --100--- 00100000 0000010\n', '// 011             -1000--- 01000000 0000100\n', '// 011             10000--- 10000000 0001000\n', '//\n', '// 100             ---1---- 00010000 0000000\n', '// 100             --10---- 00100000 0000001\n', '// 100             -100---- 01000000 0000010\n', '// 100             1000---- 10000000 0000100\n', '//\n', '// 101             --1----- 00100000 0000000\n', '// 101             -10----- 01000000 0000001\n', '// 101             100----- 10000000 0000010\n', '//\n', '// 110             -1------ 01000000 0000000\n', '// 110             10------ 10000000 0000001\n', '//\n', '// 111             1------- 10000000 0000000\n', '\n', '\n', '\n', 'assign btb_sel_f2[7] = (~ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2]\n', '     & ~ifc_fetch_addr_f2[1] & ~bht_dir_f2[6] & ~bht_dir_f2[5] & ~bht_dir_f2[4]\n', '     & ~bht_dir_f2[3] & ~bht_dir_f2[2] & ~bht_dir_f2[1] & ~bht_dir_f2[0]) | (\n', '    ~ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2] & ifc_fetch_addr_f2[1]\n', '     & ~bht_dir_f2[6] & ~bht_dir_f2[5] & ~bht_dir_f2[4] & ~bht_dir_f2[3]\n', '     & ~bht_dir_f2[2] & ~bht_dir_f2[1]) | (~ifc_fetch_addr_f2[3]\n', '     & ifc_fetch_addr_f2[2] & ~ifc_fetch_addr_f2[1] & ~bht_dir_f2[6]\n', '     & ~bht_dir_f2[5] & ~bht_dir_f2[4] & ~bht_dir_f2[3] & ~bht_dir_f2[2]) | (\n', '    ~ifc_fetch_addr_f2[3] & ifc_fetch_addr_f2[2] & ifc_fetch_addr_f2[1]\n', '     & ~bht_dir_f2[6] & ~bht_dir_f2[5] & ~bht_dir_f2[4] & ~bht_dir_f2[3]) | (\n', '    ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2] & ~ifc_fetch_addr_f2[1]\n', '     & ~bht_dir_f2[6] & ~bht_dir_f2[5] & ~bht_dir_f2[4]) | (\n', '    ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2] & ifc_fetch_addr_f2[1]\n', '     & ~bht_dir_f2[6] & ~bht_dir_f2[5]) | (ifc_fetch_addr_f2[3]\n', '     & ifc_fetch_addr_f2[2] & ~ifc_fetch_addr_f2[1] & ~bht_dir_f2[6]) | (\n', '    ifc_fetch_addr_f2[3] & ifc_fetch_addr_f2[2] & ifc_fetch_addr_f2[1]);\n', 'assign btb_sel_f2[6] = (~ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2]\n', '     & ifc_fetch_addr_f2[1] & bht_dir_f2[6] & ~bht_dir_f2[5] & ~bht_dir_f2[4]\n', '     & ~bht_dir_f2[3] & ~bht_dir_f2[2] & ~bht_dir_f2[1]) | (\n', '    ~ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2] & ~ifc_fetch_addr_f2[1]\n', '     & bht_dir_f2[6] & ~bht_dir_f2[5] & ~bht_dir_f2[4] & ~bht_dir_f2[3]\n', '     & ~bht_dir_f2[2] & ~bht_dir_f2[1] & ~bht_dir_f2[0]) | (\n', '    ~ifc_fetch_addr_f2[3] & ifc_fetch_addr_f2[2] & ~ifc_fetch_addr_f2[1]\n', '     & bht_dir_f2[6] & ~bht_dir_f2[5] & ~bht_dir_f2[4] & ~bht_dir_f2[3]\n', '     & ~bht_dir_f2[2]) | (~ifc_fetch_addr_f2[3] & ifc_fetch_addr_f2[2]\n', '     & ifc_fetch_addr_f2[1] & bht_dir_f2[6] & ~bht_dir_f2[5] & ~bht_dir_f2[4]\n', '     & ~bht_dir_f2[3]) | (ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2]\n', '     & ~ifc_fetch_addr_f2[1] & bht_dir_f2[6] & ~bht_dir_f2[5] & ~bht_dir_f2[4]) | (\n', '    ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2] & ifc_fetch_addr_f2[1]\n', '     & bht_dir_f2[6] & ~bht_dir_f2[5]) | (ifc_fetch_addr_f2[3]\n', '     & ifc_fetch_addr_f2[2] & ~ifc_fetch_addr_f2[1] & bht_dir_f2[6]);\n', 'assign btb_sel_f2[5] = (~ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2]\n', '     & ~ifc_fetch_addr_f2[1] & bht_dir_f2[5] & ~bht_dir_f2[4] & ~bht_dir_f2[3]\n', '     & ~bht_dir_f2[2] & ~bht_dir_f2[1] & ~bht_dir_f2[0]) | (\n', '    ~ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2] & ifc_fetch_addr_f2[1]\n', '     & bht_dir_f2[5] & ~bht_dir_f2[4] & ~bht_dir_f2[3] & ~bht_dir_f2[2]\n', '     & ~bht_dir_f2[1]) | (~ifc_fetch_addr_f2[3] & ifc_fetch_addr_f2[2]\n', '     & ~ifc_fetch_addr_f2[1] & bht_dir_f2[5] & ~bht_dir_f2[4] & ~bht_dir_f2[3]\n', '     & ~bht_dir_f2[2]) | (~ifc_fetch_addr_f2[3] & ifc_fetch_addr_f2[2]\n', '     & ifc_fetch_addr_f2[1] & bht_dir_f2[5] & ~bht_dir_f2[4] & ~bht_dir_f2[3]) | (\n', '    ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2] & ~ifc_fetch_addr_f2[1]\n', '     & bht_dir_f2[5] & ~bht_dir_f2[4]) | (ifc_fetch_addr_f2[3]\n', '     & ~ifc_fetch_addr_f2[2] & ifc_fetch_addr_f2[1] & bht_dir_f2[5]);\n', 'assign btb_sel_f2[4] = (~ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2]\n', '     & ~ifc_fetch_addr_f2[1] & bht_dir_f2[4] & ~bht_dir_f2[3] & ~bht_dir_f2[2]\n', '     & ~bht_dir_f2[1] & ~bht_dir_f2[0]) | (~ifc_fetch_addr_f2[3]\n', '     & ~ifc_fetch_addr_f2[2] & ifc_fetch_addr_f2[1] & bht_dir_f2[4]\n', '     & ~bht_dir_f2[3] & ~bht_dir_f2[2] & ~bht_dir_f2[1]) | (\n', '    ~ifc_fetch_addr_f2[3] & ifc_fetch_addr_f2[2] & ~ifc_fetch_addr_f2[1]\n', '     & bht_dir_f2[4] & ~bht_dir_f2[3] & ~bht_dir_f2[2]) | (\n', '    ~ifc_fetch_addr_f2[3] & ifc_fetch_addr_f2[2] & ifc_fetch_addr_f2[1]\n', '     & bht_dir_f2[4] & ~bht_dir_f2[3]) | (ifc_fetch_addr_f2[3]\n', '     & ~ifc_fetch_addr_f2[2] & ~ifc_fetch_addr_f2[1] & bht_dir_f2[4]);\n', 'assign btb_sel_f2[3] = (~ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2]\n', '     & ~ifc_fetch_addr_f2[1] & bht_dir_f2[3] & ~bht_dir_f2[2] & ~bht_dir_f2[1]\n', '     & ~bht_dir_f2[0]) | (~ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2]\n', '     & ifc_fetch_addr_f2[1] & bht_dir_f2[3] & ~bht_dir_f2[2] & ~bht_dir_f2[1]) | (\n', '    ~ifc_fetch_addr_f2[3] & ifc_fetch_addr_f2[2] & ~ifc_fetch_addr_f2[1]\n', '     & bht_dir_f2[3] & ~bht_dir_f2[2]) | (~ifc_fetch_addr_f2[3]\n', '     & ifc_fetch_addr_f2[2] & ifc_fetch_addr_f2[1] & bht_dir_f2[3]);\n', 'assign btb_sel_f2[2] = (~ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2]\n', '     & ~ifc_fetch_addr_f2[1] & bht_dir_f2[2] & ~bht_dir_f2[1] & ~bht_dir_f2[0]) | (\n', '    ~ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2] & ifc_fetch_addr_f2[1]\n', '     & bht_dir_f2[2] & ~bht_dir_f2[1]) | (~ifc_fetch_addr_f2[3]\n', '     & ifc_fetch_addr_f2[2] & ~ifc_fetch_addr_f2[1] & bht_dir_f2[2]);\n', 'assign btb_sel_f2[1] = (~ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2]\n', '     & ~ifc_fetch_addr_f2[1] & bht_dir_f2[1] & ~bht_dir_f2[0]) | (\n', '    ~ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2] & ifc_fetch_addr_f2[1]\n', '     & bht_dir_f2[1]);\n', 'assign btb_sel_f2[0] = (~ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2]\n', '     & ~ifc_fetch_addr_f2[1] & bht_dir_f2[0]);\n', '\n', '\n', '\n', '   // vmask[0] is always 1\n', 'logic [7:0] btb_vmask_raw_f2;\n', 'assign btb_vmask_raw_f2[7] = (~ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2]\n', '     & ~ifc_fetch_addr_f2[1] & ~bht_dir_f2[6] & ~bht_dir_f2[5] & ~bht_dir_f2[4]\n', '     & ~bht_dir_f2[3] & ~bht_dir_f2[2] & ~bht_dir_f2[1] & ~bht_dir_f2[0]);\n', 'assign btb_vmask_raw_f2[6] = (~ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2]\n', '     & ifc_fetch_addr_f2[1] & ~bht_dir_f2[6] & ~bht_dir_f2[5] & ~bht_dir_f2[4]\n', '     & ~bht_dir_f2[3] & ~bht_dir_f2[2] & ~bht_dir_f2[1]) | (\n', '    ~ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2] & ~ifc_fetch_addr_f2[1]\n', '     & bht_dir_f2[6] & ~bht_dir_f2[5] & ~bht_dir_f2[4] & ~bht_dir_f2[3]\n', '     & ~bht_dir_f2[2] & ~bht_dir_f2[1] & ~bht_dir_f2[0]);\n', 'assign btb_vmask_raw_f2[5] = (~ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2]\n', '     & ifc_fetch_addr_f2[1] & bht_dir_f2[6] & ~bht_dir_f2[5] & ~bht_dir_f2[4]\n', '     & ~bht_dir_f2[3] & ~bht_dir_f2[2] & ~bht_dir_f2[1]) | (\n', '    ~ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2] & ifc_fetch_addr_f2[1]\n', '     & ~bht_dir_f2[6] & ~bht_dir_f2[5] & ~bht_dir_f2[4] & ~bht_dir_f2[3]\n', '     & ~bht_dir_f2[2] & ~bht_dir_f2[1]) | (~ifc_fetch_addr_f2[3]\n', '     & ifc_fetch_addr_f2[2] & ~ifc_fetch_addr_f2[1] & ~bht_dir_f2[6]\n', '     & ~bht_dir_f2[5] & ~bht_dir_f2[4] & ~bht_dir_f2[3] & ~bht_dir_f2[2]) | (\n', '    ~ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2] & ~ifc_fetch_addr_f2[1]\n', '     & bht_dir_f2[5] & ~bht_dir_f2[4] & ~bht_dir_f2[3] & ~bht_dir_f2[2]\n', '     & ~bht_dir_f2[1] & ~bht_dir_f2[0]);\n', 'assign btb_vmask_raw_f2[4] = (~ifc_fetch_addr_f2[3] & ifc_fetch_addr_f2[2]\n', '     & ifc_fetch_addr_f2[1] & ~bht_dir_f2[6] & ~bht_dir_f2[5] & ~bht_dir_f2[4]\n', '     & ~bht_dir_f2[3]) | (~ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2]\n', '     & ~ifc_fetch_addr_f2[1] & bht_dir_f2[4] & ~bht_dir_f2[3] & ~bht_dir_f2[2]\n', '     & ~bht_dir_f2[1] & ~bht_dir_f2[0]) | (~ifc_fetch_addr_f2[3]\n', '     & ifc_fetch_addr_f2[2] & ~ifc_fetch_addr_f2[1] & bht_dir_f2[6]\n', '     & ~bht_dir_f2[5] & ~bht_dir_f2[4] & ~bht_dir_f2[3] & ~bht_dir_f2[2]) | (\n', '    ~ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2] & ifc_fetch_addr_f2[1]\n', '     & bht_dir_f2[5] & ~bht_dir_f2[4] & ~bht_dir_f2[3] & ~bht_dir_f2[2]\n', '     & ~bht_dir_f2[1]);\n', 'assign btb_vmask_raw_f2[3] = (ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2]\n', '     & ~ifc_fetch_addr_f2[1] & ~bht_dir_f2[6] & ~bht_dir_f2[5] & ~bht_dir_f2[4]) | (\n', '    ~ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2] & ~ifc_fetch_addr_f2[1]\n', '     & bht_dir_f2[3] & ~bht_dir_f2[2] & ~bht_dir_f2[1] & ~bht_dir_f2[0]) | (\n', '    ~ifc_fetch_addr_f2[3] & ifc_fetch_addr_f2[2] & ifc_fetch_addr_f2[1]\n', '     & bht_dir_f2[6] & ~bht_dir_f2[5] & ~bht_dir_f2[4] & ~bht_dir_f2[3]) | (\n', '    ~ifc_fetch_addr_f2[3] & ifc_fetch_addr_f2[2] & ~ifc_fetch_addr_f2[1]\n', '     & bht_dir_f2[5] & ~bht_dir_f2[4] & ~bht_dir_f2[3] & ~bht_dir_f2[2]) | (\n', '    ~ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2] & ifc_fetch_addr_f2[1]\n', '     & bht_dir_f2[4] & ~bht_dir_f2[3] & ~bht_dir_f2[2] & ~bht_dir_f2[1]);\n', 'assign btb_vmask_raw_f2[2] = (ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2]\n', '     & ifc_fetch_addr_f2[1] & ~bht_dir_f2[6] & ~bht_dir_f2[5]) | (\n', '    ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2] & ~ifc_fetch_addr_f2[1]\n', '     & bht_dir_f2[6] & ~bht_dir_f2[5] & ~bht_dir_f2[4]) | (\n', '    ~ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2] & ~ifc_fetch_addr_f2[1]\n', '     & bht_dir_f2[2] & ~bht_dir_f2[1] & ~bht_dir_f2[0]) | (\n', '    ~ifc_fetch_addr_f2[3] & ifc_fetch_addr_f2[2] & ifc_fetch_addr_f2[1]\n', '     & bht_dir_f2[5] & ~bht_dir_f2[4] & ~bht_dir_f2[3]) | (\n', '    ~ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2] & ifc_fetch_addr_f2[1]\n', '     & bht_dir_f2[3] & ~bht_dir_f2[2] & ~bht_dir_f2[1]) | (\n', '    ~ifc_fetch_addr_f2[3] & ifc_fetch_addr_f2[2] & ~ifc_fetch_addr_f2[1]\n', '     & bht_dir_f2[4] & ~bht_dir_f2[3] & ~bht_dir_f2[2]);\n', 'assign btb_vmask_raw_f2[1] = (ifc_fetch_addr_f2[3] & ifc_fetch_addr_f2[2]\n', '     & ~ifc_fetch_addr_f2[1] & ~bht_dir_f2[6]) | (ifc_fetch_addr_f2[3]\n', '     & ~ifc_fetch_addr_f2[2] & ifc_fetch_addr_f2[1] & bht_dir_f2[6]\n', '     & ~bht_dir_f2[5]) | (ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2]\n', '     & ~ifc_fetch_addr_f2[1] & bht_dir_f2[5] & ~bht_dir_f2[4]) | (\n', '    ~ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2] & ~ifc_fetch_addr_f2[1]\n', '     & bht_dir_f2[1] & ~bht_dir_f2[0]) | (~ifc_fetch_addr_f2[3]\n', '     & ifc_fetch_addr_f2[2] & ifc_fetch_addr_f2[1] & bht_dir_f2[4]\n', '     & ~bht_dir_f2[3]) | (~ifc_fetch_addr_f2[3] & ifc_fetch_addr_f2[2]\n', '     & ~ifc_fetch_addr_f2[1] & bht_dir_f2[3] & ~bht_dir_f2[2]) | (\n', '    ~ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2] & ifc_fetch_addr_f2[1]\n', '     & bht_dir_f2[2] & ~bht_dir_f2[1]);\n', '\n', '   // end of espresso generated equations\n', '\n', '\n', '   logic[7:1] btb_vmask_f2;\n', '   assign btb_vmask_f2[7:1] = {btb_vmask_raw_f2[7],\n', '                              |btb_vmask_raw_f2[7:6],\n', '                              |btb_vmask_raw_f2[7:5],\n', '                              |btb_vmask_raw_f2[7:4],\n', '                              |btb_vmask_raw_f2[7:3],\n', '                              |btb_vmask_raw_f2[7:2],\n', '                              |btb_vmask_raw_f2[7:1]};\n', '\n', '\n', '   // Errors colliding with fetches must kill the btb/bht hit.\n', '\n', '   assign branch_error_collision_f1 = dec_tlu_error_wb & (btb_error_addr_wb[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] == btb_rd_addr_f1[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO]);\n', '   assign branch_error_bank_conflict_f1[3:0] = {4{branch_error_collision_f1}} & (decode2_4(dec_tlu_error_bank_wb[1:0]) | {4{dec_tlu_all_banks_error_wb}});\n', '\n', '   assign fetch_mp_collision_f1 = ( (exu_mp_btag[`RV_BTB_BTAG_SIZE-1:0] == fetch_rd_tag_f1[`RV_BTB_BTAG_SIZE-1:0]) &\n', '                                    exu_mp_valid & ifc_fetch_req_f1 &\n', '                                    (exu_mp_addr[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] == btb_rd_addr_f1[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO])\n', '                                    );\n', '   // set on leak one, hold until next flush without leak one\n', '   assign leak_one_f1 = (dec_tlu_flush_leak_one_wb & dec_tlu_flush_lower_wb) | (leak_one_f2 & ~dec_tlu_flush_lower_wb);\n', '\n', '`ifdef RV_BTB_48\n', '   rvdff #(15) coll_ff (.*, .clk(active_clk),\n', '`else\n', '   rvdff #(13) coll_ff (.*, .clk(active_clk),\n', '`endif\n', '                         .din({branch_error_bank_conflict_f1[3:0], fetch_mp_collision_f1, mp_bank_decoded[3:0], exu_mp_way, dec_tlu_way_wb, leak_one_f1, ifc_fetch_req_f1}),\n', '                        .dout({branch_error_bank_conflict_f2[3:0], fetch_mp_collision_f2, mp_bank_decoded_f[3:0], exu_mp_way_f, dec_tlu_way_wb_f, leak_one_f2, ifc_fetch_req_f2_raw}));\n', '`ifdef RV_BTB_48\n', '\n', '   // 2 -way SA, figure out the way hit and mux accordingly\n', '   assign tag_match_way0_f2[3:0] = {btb_bank3_rd_data_way0_f2[BV] & (btb_bank3_rd_data_way0_f2[`TAG] == fetch_rd_tag_f2[`RV_BTB_BTAG_SIZE-1:0]),\n', '                                    btb_bank2_rd_data_way0_f2[BV] & (btb_bank2_rd_data_way0_f2[`TAG] == fetch_rd_tag_f2[`RV_BTB_BTAG_SIZE-1:0]),\n', '                                    btb_bank1_rd_data_way0_f2[BV] & (btb_bank1_rd_data_way0_f2[`TAG] == fetch_rd_tag_f2[`RV_BTB_BTAG_SIZE-1:0]),\n', '                                    btb_bank0_rd_data_way0_f2[BV] & (btb_bank0_rd_data_way0_f2[`TAG] == fetch_rd_tag_f2[`RV_BTB_BTAG_SIZE-1:0])} &\n', ""                                   ~({4{dec_tlu_way_wb_f==2'b0}} & branch_error_bank_conflict_f2[3:0]) & {4{ifc_fetch_req_f2_raw & ~leak_one_f2}};\n"", '\n', '   assign tag_match_way1_f2[3:0] = {btb_bank3_rd_data_way1_f2[BV] & (btb_bank3_rd_data_way1_f2[`TAG] == fetch_rd_tag_f2[`RV_BTB_BTAG_SIZE-1:0]),\n', '                                    btb_bank2_rd_data_way1_f2[BV] & (btb_bank2_rd_data_way1_f2[`TAG] == fetch_rd_tag_f2[`RV_BTB_BTAG_SIZE-1:0]),\n', '                                    btb_bank1_rd_data_way1_f2[BV] & (btb_bank1_rd_data_way1_f2[`TAG] == fetch_rd_tag_f2[`RV_BTB_BTAG_SIZE-1:0]),\n', '                                    btb_bank0_rd_data_way1_f2[BV] & (btb_bank0_rd_data_way1_f2[`TAG] == fetch_rd_tag_f2[`RV_BTB_BTAG_SIZE-1:0])} &\n', '                                   ~({4{dec_tlu_way_wb_f[0]}} & branch_error_bank_conflict_f2[3:0]) & {4{ifc_fetch_req_f2_raw & ~leak_one_f2}};\n', '\n', '   assign tag_match_way2_f2[3:0] = {btb_bank3_rd_data_way2_f2[BV] & (btb_bank3_rd_data_way2_f2[`TAG] == fetch_rd_tag_f2[`RV_BTB_BTAG_SIZE-1:0]),\n', '                                    btb_bank2_rd_data_way2_f2[BV] & (btb_bank2_rd_data_way2_f2[`TAG] == fetch_rd_tag_f2[`RV_BTB_BTAG_SIZE-1:0]),\n', '                                    btb_bank1_rd_data_way2_f2[BV] & (btb_bank1_rd_data_way2_f2[`TAG] == fetch_rd_tag_f2[`RV_BTB_BTAG_SIZE-1:0]),\n', '                                    btb_bank0_rd_data_way2_f2[BV] & (btb_bank0_rd_data_way2_f2[`TAG] == fetch_rd_tag_f2[`RV_BTB_BTAG_SIZE-1:0])} &\n', '                                   ~({4{dec_tlu_way_wb_f[1]}} & branch_error_bank_conflict_f2[3:0]) & {4{ifc_fetch_req_f2_raw & ~leak_one_f2}};\n', '\n', '`else\n', '   // 2 -way SA, figure out the way hit and mux accordingly\n', '   assign tag_match_way0_f2[3:0] = {btb_bank3_rd_data_way0_f2[BV] & (btb_bank3_rd_data_way0_f2[`TAG] == fetch_rd_tag_f2[`RV_BTB_BTAG_SIZE-1:0]),\n', '                                    btb_bank2_rd_data_way0_f2[BV] & (btb_bank2_rd_data_way0_f2[`TAG] == fetch_rd_tag_f2[`RV_BTB_BTAG_SIZE-1:0]),\n', '                                    btb_bank1_rd_data_way0_f2[BV] & (btb_bank1_rd_data_way0_f2[`TAG] == fetch_rd_tag_f2[`RV_BTB_BTAG_SIZE-1:0]),\n', '                                    btb_bank0_rd_data_way0_f2[BV] & (btb_bank0_rd_data_way0_f2[`TAG] == fetch_rd_tag_f2[`RV_BTB_BTAG_SIZE-1:0])} &\n', '                                   ~({4{~dec_tlu_way_wb_f}} & branch_error_bank_conflict_f2[3:0]) & {4{ifc_fetch_req_f2_raw & ~leak_one_f2}};\n', '\n', '   assign tag_match_way1_f2[3:0] = {btb_bank3_rd_data_way1_f2[BV] & (btb_bank3_rd_data_way1_f2[`TAG] == fetch_rd_tag_f2[`RV_BTB_BTAG_SIZE-1:0]),\n', '                                    btb_bank2_rd_data_way1_f2[BV] & (btb_bank2_rd_data_way1_f2[`TAG] == fetch_rd_tag_f2[`RV_BTB_BTAG_SIZE-1:0]),\n', '                                    btb_bank1_rd_data_way1_f2[BV] & (btb_bank1_rd_data_way1_f2[`TAG] == fetch_rd_tag_f2[`RV_BTB_BTAG_SIZE-1:0]),\n', '                                    btb_bank0_rd_data_way1_f2[BV] & (btb_bank0_rd_data_way1_f2[`TAG] == fetch_rd_tag_f2[`RV_BTB_BTAG_SIZE-1:0])} &\n', '                                   ~({4{dec_tlu_way_wb_f}} & branch_error_bank_conflict_f2[3:0]) & {4{ifc_fetch_req_f2_raw & ~leak_one_f2}};\n', '\n', '`endif\n', '\n', '   // Both ways could hit, use the offset bit to reorder\n', '\n', '   assign tag_match_way0_expanded_f2[7:0] = {tag_match_way0_f2[3] &  (btb_bank3_rd_data_way0_f2[BOFF] ^ btb_bank3_rd_data_way0_f2[PC4]),\n', '                                             tag_match_way0_f2[3] & ~(btb_bank3_rd_data_way0_f2[BOFF] ^ btb_bank3_rd_data_way0_f2[PC4]),\n', '                                             tag_match_way0_f2[2] &  (btb_bank2_rd_data_way0_f2[BOFF] ^ btb_bank2_rd_data_way0_f2[PC4]),\n', '                                             tag_match_way0_f2[2] & ~(btb_bank2_rd_data_way0_f2[BOFF] ^ btb_bank2_rd_data_way0_f2[PC4]),\n', '                                             tag_match_way0_f2[1] &  (btb_bank1_rd_data_way0_f2[BOFF] ^ btb_bank1_rd_data_way0_f2[PC4]),\n', '                                             tag_match_way0_f2[1] & ~(btb_bank1_rd_data_way0_f2[BOFF] ^ btb_bank1_rd_data_way0_f2[PC4]),\n', '                                             tag_match_way0_f2[0] &  (btb_bank0_rd_data_way0_f2[BOFF] ^ btb_bank0_rd_data_way0_f2[PC4]),\n', '                                             tag_match_way0_f2[0] & ~(btb_bank0_rd_data_way0_f2[BOFF] ^ btb_bank0_rd_data_way0_f2[PC4])};\n', '\n', '   assign tag_match_way1_expanded_f2[7:0] = {tag_match_way1_f2[3] &  (btb_bank3_rd_data_way1_f2[BOFF] ^ btb_bank3_rd_data_way1_f2[PC4]),\n', '                                             tag_match_way1_f2[3] & ~(btb_bank3_rd_data_way1_f2[BOFF] ^ btb_bank3_rd_data_way1_f2[PC4]),\n', '                                             tag_match_way1_f2[2] &  (btb_bank2_rd_data_way1_f2[BOFF] ^ btb_bank2_rd_data_way1_f2[PC4]),\n', '                                             tag_match_way1_f2[2] & ~(btb_bank2_rd_data_way1_f2[BOFF] ^ btb_bank2_rd_data_way1_f2[PC4]),\n', '                                             tag_match_way1_f2[1] &  (btb_bank1_rd_data_way1_f2[BOFF] ^ btb_bank1_rd_data_way1_f2[PC4]),\n', '                                             tag_match_way1_f2[1] & ~(btb_bank1_rd_data_way1_f2[BOFF] ^ btb_bank1_rd_data_way1_f2[PC4]),\n', '                                             tag_match_way1_f2[0] &  (btb_bank0_rd_data_way1_f2[BOFF] ^ btb_bank0_rd_data_way1_f2[PC4]),\n', '                                             tag_match_way1_f2[0] & ~(btb_bank0_rd_data_way1_f2[BOFF] ^ btb_bank0_rd_data_way1_f2[PC4])};\n', '\n', '`ifdef RV_BTB_48\n', '   assign tag_match_way2_expanded_f2[7:0] = {tag_match_way2_f2[3] &  (btb_bank3_rd_data_way2_f2[BOFF] ^ btb_bank3_rd_data_way2_f2[PC4]),\n', '                                             tag_match_way2_f2[3] & ~(btb_bank3_rd_data_way2_f2[BOFF] ^ btb_bank3_rd_data_way2_f2[PC4]),\n', '                                             tag_match_way2_f2[2] &  (btb_bank2_rd_data_way2_f2[BOFF] ^ btb_bank2_rd_data_way2_f2[PC4]),\n', '                                             tag_match_way2_f2[2] & ~(btb_bank2_rd_data_way2_f2[BOFF] ^ btb_bank2_rd_data_way2_f2[PC4]),\n', '                                             tag_match_way2_f2[1] &  (btb_bank1_rd_data_way2_f2[BOFF] ^ btb_bank1_rd_data_way2_f2[PC4]),\n', '                                             tag_match_way2_f2[1] & ~(btb_bank1_rd_data_way2_f2[BOFF] ^ btb_bank1_rd_data_way2_f2[PC4]),\n', '                                             tag_match_way2_f2[0] &  (btb_bank0_rd_data_way2_f2[BOFF] ^ btb_bank0_rd_data_way2_f2[PC4]),\n', '                                             tag_match_way2_f2[0] & ~(btb_bank0_rd_data_way2_f2[BOFF] ^ btb_bank0_rd_data_way2_f2[PC4])};\n', '\n', '   assign wayhit_f2[7:0] = tag_match_way0_expanded_f2[7:0] | tag_match_way1_expanded_f2[7:0] | tag_match_way2_expanded_f2[7:0];\n', '\n', '   assign btb_bank3o_rd_data_f2[16+`RV_BTB_BTAG_SIZE:0] = ( ({17+`RV_BTB_BTAG_SIZE{tag_match_way0_expanded_f2[7]}} & btb_bank3_rd_data_way0_f2[16+`RV_BTB_BTAG_SIZE:0]) |\n', '                                                            ({17+`RV_BTB_BTAG_SIZE{tag_match_way1_expanded_f2[7]}} & btb_bank3_rd_data_way1_f2[16+`RV_BTB_BTAG_SIZE:0]) |\n', '                                                            ({17+`RV_BTB_BTAG_SIZE{tag_match_way2_expanded_f2[7]}} & btb_bank3_rd_data_way2_f2[16+`RV_BTB_BTAG_SIZE:0]) );\n', '   assign btb_bank3e_rd_data_f2[16+`RV_BTB_BTAG_SIZE:0] = ( ({17+`RV_BTB_BTAG_SIZE{tag_match_way0_expanded_f2[6]}} & btb_bank3_rd_data_way0_f2[16+`RV_BTB_BTAG_SIZE:0]) |\n', '                                                            ({17+`RV_BTB_BTAG_SIZE{tag_match_way1_expanded_f2[6]}} & btb_bank3_rd_data_way1_f2[16+`RV_BTB_BTAG_SIZE:0]) |\n', '                                                            ({17+`RV_BTB_BTAG_SIZE{tag_match_way2_expanded_f2[6]}} & btb_bank3_rd_data_way2_f2[16+`RV_BTB_BTAG_SIZE:0]) );\n', '\n', '   assign btb_bank2o_rd_data_f2[16+`RV_BTB_BTAG_SIZE:0] = ( ({17+`RV_BTB_BTAG_SIZE{tag_match_way0_expanded_f2[5]}} & btb_bank2_rd_data_way0_f2[16+`RV_BTB_BTAG_SIZE:0]) |\n', '                                                            ({17+`RV_BTB_BTAG_SIZE{tag_match_way1_expanded_f2[5]}} & btb_bank2_rd_data_way1_f2[16+`RV_BTB_BTAG_SIZE:0]) |\n', '                                                            ({17+`RV_BTB_BTAG_SIZE{tag_match_way2_expanded_f2[5]}} & btb_bank2_rd_data_way2_f2[16+`RV_BTB_BTAG_SIZE:0]) );\n', '   assign btb_bank2e_rd_data_f2[16+`RV_BTB_BTAG_SIZE:0] = ( ({17+`RV_BTB_BTAG_SIZE{tag_match_way0_expanded_f2[4]}} & btb_bank2_rd_data_way0_f2[16+`RV_BTB_BTAG_SIZE:0]) |\n', '                                                            ({17+`RV_BTB_BTAG_SIZE{tag_match_way1_expanded_f2[4]}} & btb_bank2_rd_data_way1_f2[16+`RV_BTB_BTAG_SIZE:0]) |\n', '                                                            ({17+`RV_BTB_BTAG_SIZE{tag_match_way2_expanded_f2[4]}} & btb_bank2_rd_data_way2_f2[16+`RV_BTB_BTAG_SIZE:0]) );\n', '\n', '   assign btb_bank1o_rd_data_f2[16+`RV_BTB_BTAG_SIZE:0] = ( ({17+`RV_BTB_BTAG_SIZE{tag_match_way0_expanded_f2[3]}} & btb_bank1_rd_data_way0_f2[16+`RV_BTB_BTAG_SIZE:0]) |\n', '                                                            ({17+`RV_BTB_BTAG_SIZE{tag_match_way1_expanded_f2[3]}} & btb_bank1_rd_data_way1_f2[16+`RV_BTB_BTAG_SIZE:0]) |\n', '                                                            ({17+`RV_BTB_BTAG_SIZE{tag_match_way2_expanded_f2[3]}} & btb_bank1_rd_data_way2_f2[16+`RV_BTB_BTAG_SIZE:0]) );\n', '   assign btb_bank1e_rd_data_f2[16+`RV_BTB_BTAG_SIZE:0] = ( ({17+`RV_BTB_BTAG_SIZE{tag_match_way0_expanded_f2[2]}} & btb_bank1_rd_data_way0_f2[16+`RV_BTB_BTAG_SIZE:0]) |\n', '                                                            ({17+`RV_BTB_BTAG_SIZE{tag_match_way1_expanded_f2[2]}} & btb_bank1_rd_data_way1_f2[16+`RV_BTB_BTAG_SIZE:0]) |\n', '                                                            ({17+`RV_BTB_BTAG_SIZE{tag_match_way2_expanded_f2[2]}} & btb_bank1_rd_data_way2_f2[16+`RV_BTB_BTAG_SIZE:0]) );\n', '\n', '   assign btb_bank0o_rd_data_f2[16+`RV_BTB_BTAG_SIZE:0] = ( ({17+`RV_BTB_BTAG_SIZE{tag_match_way0_expanded_f2[1]}} & btb_bank0_rd_data_way0_f2[16+`RV_BTB_BTAG_SIZE:0]) |\n', '                                                            ({17+`RV_BTB_BTAG_SIZE{tag_match_way1_expanded_f2[1]}} & btb_bank0_rd_data_way1_f2[16+`RV_BTB_BTAG_SIZE:0]) |\n', '                                                            ({17+`RV_BTB_BTAG_SIZE{tag_match_way2_expanded_f2[1]}} & btb_bank0_rd_data_way2_f2[16+`RV_BTB_BTAG_SIZE:0]) );\n', '   assign btb_bank0e_rd_data_f2[16+`RV_BTB_BTAG_SIZE:0] = ( ({17+`RV_BTB_BTAG_SIZE{tag_match_way0_expanded_f2[0]}} & btb_bank0_rd_data_way0_f2[16+`RV_BTB_BTAG_SIZE:0]) |\n', '                                                            ({17+`RV_BTB_BTAG_SIZE{tag_match_way1_expanded_f2[0]}} & btb_bank0_rd_data_way1_f2[16+`RV_BTB_BTAG_SIZE:0]) |\n', '                                                            ({17+`RV_BTB_BTAG_SIZE{tag_match_way2_expanded_f2[0]}} & btb_bank0_rd_data_way2_f2[16+`RV_BTB_BTAG_SIZE:0]) );\n', '\n', '\n', '`else // !`ifdef RV_BTB_48\n', '\n', '   assign wayhit_f2[7:0] = tag_match_way0_expanded_f2[7:0] | tag_match_way1_expanded_f2[7:0];\n', '   assign btb_bank3o_rd_data_f2[16+`RV_BTB_BTAG_SIZE:0] = ( ({17+`RV_BTB_BTAG_SIZE{tag_match_way0_expanded_f2[7]}} & btb_bank3_rd_data_way0_f2[16+`RV_BTB_BTAG_SIZE:0]) |\n', '                                                            ({17+`RV_BTB_BTAG_SIZE{tag_match_way1_expanded_f2[7]}} & btb_bank3_rd_data_way1_f2[16+`RV_BTB_BTAG_SIZE:0]) );\n', '   assign btb_bank3e_rd_data_f2[16+`RV_BTB_BTAG_SIZE:0] = ( ({17+`RV_BTB_BTAG_SIZE{tag_match_way0_expanded_f2[6]}} & btb_bank3_rd_data_way0_f2[16+`RV_BTB_BTAG_SIZE:0]) |\n', '                                                            ({17+`RV_BTB_BTAG_SIZE{tag_match_way1_expanded_f2[6]}} & btb_bank3_rd_data_way1_f2[16+`RV_BTB_BTAG_SIZE:0]) );\n', '\n', '   assign btb_bank2o_rd_data_f2[16+`RV_BTB_BTAG_SIZE:0] = ( ({17+`RV_BTB_BTAG_SIZE{tag_match_way0_expanded_f2[5]}} & btb_bank2_rd_data_way0_f2[16+`RV_BTB_BTAG_SIZE:0]) |\n', '                                                            ({17+`RV_BTB_BTAG_SIZE{tag_match_way1_expanded_f2[5]}} & btb_bank2_rd_data_way1_f2[16+`RV_BTB_BTAG_SIZE:0]) );\n', '   assign btb_bank2e_rd_data_f2[16+`RV_BTB_BTAG_SIZE:0] = ( ({17+`RV_BTB_BTAG_SIZE{tag_match_way0_expanded_f2[4]}} & btb_bank2_rd_data_way0_f2[16+`RV_BTB_BTAG_SIZE:0]) |\n', '                                                            ({17+`RV_BTB_BTAG_SIZE{tag_match_way1_expanded_f2[4]}} & btb_bank2_rd_data_way1_f2[16+`RV_BTB_BTAG_SIZE:0]) );\n', '\n', '   assign btb_bank1o_rd_data_f2[16+`RV_BTB_BTAG_SIZE:0] = ( ({17+`RV_BTB_BTAG_SIZE{tag_match_way0_expanded_f2[3]}} & btb_bank1_rd_data_way0_f2[16+`RV_BTB_BTAG_SIZE:0]) |\n', '                                                            ({17+`RV_BTB_BTAG_SIZE{tag_match_way1_expanded_f2[3]}} & btb_bank1_rd_data_way1_f2[16+`RV_BTB_BTAG_SIZE:0]) );\n', '   assign btb_bank1e_rd_data_f2[16+`RV_BTB_BTAG_SIZE:0] = ( ({17+`RV_BTB_BTAG_SIZE{tag_match_way0_expanded_f2[2]}} & btb_bank1_rd_data_way0_f2[16+`RV_BTB_BTAG_SIZE:0]) |\n', '                                                            ({17+`RV_BTB_BTAG_SIZE{tag_match_way1_expanded_f2[2]}} & btb_bank1_rd_data_way1_f2[16+`RV_BTB_BTAG_SIZE:0]) );\n', '\n', '   assign btb_bank0o_rd_data_f2[16+`RV_BTB_BTAG_SIZE:0] = ( ({17+`RV_BTB_BTAG_SIZE{tag_match_way0_expanded_f2[1]}} & btb_bank0_rd_data_way0_f2[16+`RV_BTB_BTAG_SIZE:0]) |\n', '                                                            ({17+`RV_BTB_BTAG_SIZE{tag_match_way1_expanded_f2[1]}} & btb_bank0_rd_data_way1_f2[16+`RV_BTB_BTAG_SIZE:0]) );\n', '   assign btb_bank0e_rd_data_f2[16+`RV_BTB_BTAG_SIZE:0] = ( ({17+`RV_BTB_BTAG_SIZE{tag_match_way0_expanded_f2[0]}} & btb_bank0_rd_data_way0_f2[16+`RV_BTB_BTAG_SIZE:0]) |\n', '                                                            ({17+`RV_BTB_BTAG_SIZE{tag_match_way1_expanded_f2[0]}} & btb_bank0_rd_data_way1_f2[16+`RV_BTB_BTAG_SIZE:0]) );\n', '\n', '`endif\n', '\n', '\n', '\n', '   // --------------------------------------------------------------------------------\n', '   // --------------------------------------------------------------------------------\n', '   // update lru\n', '   // mp\n', '\n', '   assign mp_bank_decoded[3:0] = decode2_4(exu_mp_bank[1:0]);\n', '   // create a onehot lru write vector\n', ""   assign mp_wrindex_dec[LRU_SIZE-1:0] = {{LRU_SIZE-1{1'b0}},1'b1} <<  exu_mp_addr[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO];\n"", '\n', '   // fetch\n', ""   assign fetch_wrindex_dec[LRU_SIZE-1:0] = {{LRU_SIZE-1{1'b0}},1'b1} <<  btb_rd_addr_f2[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO];\n"", '\n', '   assign mp_wrlru_b0[LRU_SIZE-1:0] = mp_wrindex_dec[LRU_SIZE-1:0] & {LRU_SIZE{mp_bank_decoded[0] & exu_mp_valid}};\n', '   assign mp_wrlru_b1[LRU_SIZE-1:0] = mp_wrindex_dec[LRU_SIZE-1:0] & {LRU_SIZE{mp_bank_decoded[1] & exu_mp_valid}};\n', '   assign mp_wrlru_b2[LRU_SIZE-1:0] = mp_wrindex_dec[LRU_SIZE-1:0] & {LRU_SIZE{mp_bank_decoded[2] & exu_mp_valid}};\n', '   assign mp_wrlru_b3[LRU_SIZE-1:0] = mp_wrindex_dec[LRU_SIZE-1:0] & {LRU_SIZE{mp_bank_decoded[3] & exu_mp_valid}};\n', '\n', '   genvar     j, i;\n', '\n', '\n', '`ifdef BTB_ROUND_ROBIN\n', ""   assign fetch_wrlru_b0[LRU_SIZE-1:0] = {LRU_SIZE-1{1'b0}};\n"", ""   assign fetch_wrlru_b1[LRU_SIZE-1:0] = {LRU_SIZE-1{1'b0}};\n"", ""   assign fetch_wrlru_b2[LRU_SIZE-1:0] = {LRU_SIZE-1{1'b0}};\n"", ""   assign fetch_wrlru_b3[LRU_SIZE-1:0] = {LRU_SIZE-1{1'b0}};\n"", '\n', ""   assign lru_update_valid_f2[3:0] = 4'b0;\n"", '\n', '`else\n', '\n', '   assign lru_update_valid_f2[3:0] = {((bht_valid_f2[6] & btb_sel_mask_f2[6]) | (bht_valid_f2[7] & btb_sel_mask_f2[7])) & ifc_fetch_req_f2 & ~leak_one_f2,\n', '                                      ((bht_valid_f2[4] & btb_sel_mask_f2[4]) | (bht_valid_f2[5] & btb_sel_mask_f2[5])) & ifc_fetch_req_f2 & ~leak_one_f2,\n', '                                      ((bht_valid_f2[2] & btb_sel_mask_f2[2]) | (bht_valid_f2[3] & btb_sel_mask_f2[3])) & ifc_fetch_req_f2 & ~leak_one_f2,\n', '                                      ((bht_valid_f2[0] & btb_sel_mask_f2[0]) | (bht_valid_f2[1] & btb_sel_mask_f2[1])) & ifc_fetch_req_f2 & ~leak_one_f2};\n', '\n', '   assign fetch_wrlru_b0[LRU_SIZE-1:0] = fetch_wrindex_dec[LRU_SIZE-1:0] &\n', '                                         {LRU_SIZE{lru_update_valid_f2[0]}};\n', '   assign fetch_wrlru_b1[LRU_SIZE-1:0] = fetch_wrindex_dec[LRU_SIZE-1:0] &\n', '                                         {LRU_SIZE{lru_update_valid_f2[1]}};\n', '   assign fetch_wrlru_b2[LRU_SIZE-1:0] = fetch_wrindex_dec[LRU_SIZE-1:0] &\n', '                                         {LRU_SIZE{lru_update_valid_f2[2]}};\n', '   assign fetch_wrlru_b3[LRU_SIZE-1:0] = fetch_wrindex_dec[LRU_SIZE-1:0] &\n', '                                         {LRU_SIZE{lru_update_valid_f2[3]}};\n', '\n', '`endif\n', '\n', '   assign btb_lru_b0_hold[LRU_SIZE-1:0] = ~mp_wrlru_b0[LRU_SIZE-1:0] & ~fetch_wrlru_b0[LRU_SIZE-1:0];\n', '   assign btb_lru_b1_hold[LRU_SIZE-1:0] = ~mp_wrlru_b1[LRU_SIZE-1:0] & ~fetch_wrlru_b1[LRU_SIZE-1:0];\n', '   assign btb_lru_b2_hold[LRU_SIZE-1:0] = ~mp_wrlru_b2[LRU_SIZE-1:0] & ~fetch_wrlru_b2[LRU_SIZE-1:0];\n', '   assign btb_lru_b3_hold[LRU_SIZE-1:0] = ~mp_wrlru_b3[LRU_SIZE-1:0] & ~fetch_wrlru_b3[LRU_SIZE-1:0];\n', '\n', '   // Forward the mp lru information to the fetch, avoids multiple way hits later\n', '   assign use_mp_way[3:0] = {4{fetch_mp_collision_f2}} & mp_bank_decoded_f[3:0];\n', '\n', '\n', '\n', '\n', '`ifdef RV_BTB_48\n', '   logic [3:0][3:0] [2:0] lru_bank_wr_data ;\n', '   logic [3:0][3:0]       lru_bank_sel ;\n', '   logic [3:0] [1:0]      hitway_enc;\n', '   logic [3:0] [2:0]      fetch_new_lru;\n', '   logic [2:0]            lru_bank0_rd_data_f2_in, lru_bank1_rd_data_f2_in, lru_bank2_rd_data_f2_in, lru_bank3_rd_data_f2_in;\n', '   logic [2:0]            lru_bank0_rd_data_f2, lru_bank1_rd_data_f2, lru_bank2_rd_data_f2, lru_bank3_rd_data_f2;\n', '   logic [1:0]            lru_bank0_next_way, lru_bank1_next_way, lru_bank2_next_way, lru_bank3_next_way,\n', '                          fetch_replway_bank0_enc, fetch_replway_bank1_enc, fetch_replway_bank2_enc, fetch_replway_bank3_enc,\n', '                          fetch_replway_bank4_enc, fetch_replway_bank5_enc, fetch_replway_bank6_enc, fetch_replway_bank7_enc;\n', '   logic [3:0][3:0] [2:0] lru_bank_rd_data_out;\n', '\n', '//   // could have 2 ways hit for case where same bank, different offset hit. Update LRU accordingly\n', 'logic [3:0] two_hits;\n', '   assign two_hits[3:0] = (tag_match_way0_f2[3:0] & tag_match_way1_f2[3:0]) |\n', '                          (tag_match_way0_f2[3:0] & tag_match_way2_f2[3:0]) |\n', '                          (tag_match_way1_f2[3:0] & tag_match_way2_f2[3:0]) ;\n', '\n', '  logic [2:0] mp_new_lru;\n', '  assign mp_new_lru[2:0] = newlru(lru_bank_rd_data_out[exu_mp_bank[1:0]][exu_mp_addr[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO]], exu_mp_way[1:0]);\n', '\n', '\n', '   assign fetch_lru_bank_hit_f2[3:0] = lru_update_valid_f2[3:0] & (tag_match_way0_f2[3:0] | tag_match_way1_f2[3:0] | tag_match_way2_f2[3:0]);\n', '\n', '   // banks\n', '   for ( i=0; i<4; i++) begin : LRUBANKS\n', '      // only 4 indices here\n', '      // encode the hit way in case the fetch hits\n', ""      assign hitway_enc[i] = tag_match_way1_f2[i] ? 2'b01 : tag_match_way2_f2[i] ? 2'b10 : 'b0;\n"", '      // update the lru assuming a hit\n', '      assign fetch_new_lru[i] = newlru(lru_bank_rd_data_out[i][btb_rd_addr_f2[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO]], hitway_enc[i][1:0]);\n', '\n', '      // index\n', '      for (j=0 ; j<4 ; j++) begin : LRUFLOPS\n', '\n', '         // mux the write data\n', ""         assign lru_bank_wr_data[i][j]  = (exu_mp_valid & mp_bank_decoded[i]) ? mp_new_lru[2:0] : fetch_lru_bank_hit_f2[i] ? fetch_new_lru[i] : 'b0;\n"", '\n', '         // bank enable if there was a fetch hit or a mispredict\n', '         // simul mp and fetch, mp has priority\n', '         assign lru_bank_sel[i][j] = (~exu_mp_valid & fetch_lru_bank_hit_f2[i] & (btb_rd_addr_f2[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] == j)) |\n', '                                     ( exu_mp_valid & mp_bank_decoded[i]    & (exu_mp_addr[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] == j));\n', '\n', '\n', '         rvdffs #(3) lru_bank (.*,\n', '                               .clk        (active_clk),\n', '                               .en         (lru_bank_sel[i][j]),\n', '                               .din        (lru_bank_wr_data[i][j]),\n', '                               .dout       (lru_bank_rd_data_out[i][j]));\n', '\n', '      end // block: LRUFLOPS\n', '   end // block: LRUBANKS\n', '\n', 'always_comb begin : LRU_rd_mux\n', ""     lru_bank0_rd_data_f2_in[2:0] = '0 ;\n"", ""     lru_bank1_rd_data_f2_in[2:0] = '0 ;\n"", ""     lru_bank2_rd_data_f2_in[2:0] = '0 ;\n"", ""     lru_bank3_rd_data_f2_in[2:0] = '0 ;\n"", '     for (int j=0; j<4; j++) begin\n', '       if (btb_rd_addr_f1[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] == j) begin\n', '         lru_bank0_rd_data_f2_in[2:0] = lru_bank_rd_data_out[0][j];\n', '         lru_bank1_rd_data_f2_in[2:0] = lru_bank_rd_data_out[1][j];\n', '         lru_bank2_rd_data_f2_in[2:0] = lru_bank_rd_data_out[2][j];\n', '         lru_bank3_rd_data_f2_in[2:0] = lru_bank_rd_data_out[3][j];\n', '       end\n', '     end\n', 'end // block: LRU_rd_mux\n', '\n', '\n', '   rvdffe #(12) lru_dataoutf (.*, .en         (ifc_fetch_req_f1),\n', '                                 .din        ({lru_bank0_rd_data_f2_in[2:0],\n', '                                               lru_bank1_rd_data_f2_in[2:0],\n', '                                               lru_bank2_rd_data_f2_in[2:0],\n', '                                               lru_bank3_rd_data_f2_in[2:0]\n', '                                               }),\n', '                                 .dout       ({lru_bank0_rd_data_f2   [2:0],\n', '                                               lru_bank1_rd_data_f2   [2:0],\n', '                                               lru_bank2_rd_data_f2   [2:0],\n', '                                               lru_bank3_rd_data_f2   [2:0]\n', '                                               }));\n', '\n', '   // Create the replacement way to send down the pipe. First is hitway, then consider invalid ways first, then lru way\n', '   assign lru_bank0_next_way[1:0] = use_mp_way[0] ? exu_mp_way_f[1:0] : lru2way(lru_bank0_rd_data_f2[2:0], {btb_bank0_rd_data_way2_f2[BV],btb_bank0_rd_data_way1_f2[BV],btb_bank0_rd_data_way0_f2[BV]});\n', '   assign lru_bank1_next_way[1:0] = use_mp_way[1] ? exu_mp_way_f[1:0] : lru2way(lru_bank1_rd_data_f2[2:0], {btb_bank1_rd_data_way2_f2[BV],btb_bank1_rd_data_way1_f2[BV],btb_bank1_rd_data_way0_f2[BV]});\n', '   assign lru_bank2_next_way[1:0] = use_mp_way[2] ? exu_mp_way_f[1:0] : lru2way(lru_bank2_rd_data_f2[2:0], {btb_bank2_rd_data_way2_f2[BV],btb_bank2_rd_data_way1_f2[BV],btb_bank2_rd_data_way0_f2[BV]});\n', '   assign lru_bank3_next_way[1:0] = use_mp_way[3] ? exu_mp_way_f[1:0] : lru2way(lru_bank3_rd_data_f2[2:0], {btb_bank3_rd_data_way2_f2[BV],btb_bank3_rd_data_way1_f2[BV],btb_bank3_rd_data_way0_f2[BV]});\n', '\n', ""   assign fetch_replway_bank0_enc[1:0] = ( ({2{tag_match_way0_expanded_f2[0]}} & 2'b00) |\n"", ""                                           ({2{tag_match_way1_expanded_f2[0] & ~tag_match_way0_expanded_f2[0]}} & 2'b01) |\n"", ""                                           ({2{tag_match_way2_expanded_f2[0] & ~tag_match_way1_expanded_f2[0] & ~tag_match_way0_expanded_f2[0]}} & 2'b10) |\n"", '                                           ({2{~tag_match_way2_expanded_f2[0] & ~tag_match_way1_expanded_f2[0] & ~tag_match_way0_expanded_f2[0]}} & lru_bank0_next_way[1:0]));\n', ""   assign fetch_replway_bank1_enc[1:0] = ( ({2{tag_match_way0_expanded_f2[1]}} & 2'b00) |\n"", ""                                           ({2{tag_match_way1_expanded_f2[1] & ~tag_match_way0_expanded_f2[1]}} & 2'b01) |\n"", ""                                           ({2{tag_match_way2_expanded_f2[1] & ~tag_match_way1_expanded_f2[1] & ~tag_match_way0_expanded_f2[1]}} & 2'b10) |\n"", '                                           ({2{~tag_match_way2_expanded_f2[1] & ~tag_match_way1_expanded_f2[1] & ~tag_match_way0_expanded_f2[1]}} & lru_bank0_next_way[1:0]));\n', ""   assign fetch_replway_bank2_enc[1:0] = ( ({2{tag_match_way0_expanded_f2[2]}} & 2'b00) |\n"", ""                                           ({2{tag_match_way1_expanded_f2[2] & ~tag_match_way0_expanded_f2[2]}} & 2'b01) |\n"", ""                                           ({2{tag_match_way2_expanded_f2[2] & ~tag_match_way1_expanded_f2[2] & ~tag_match_way0_expanded_f2[2]}} & 2'b10) |\n"", '                                           ({2{~tag_match_way2_expanded_f2[2] & ~tag_match_way1_expanded_f2[2] & ~tag_match_way0_expanded_f2[2]}} & lru_bank1_next_way[1:0]));\n', ""   assign fetch_replway_bank3_enc[1:0] = ( ({2{tag_match_way0_expanded_f2[3]}} & 2'b00) |\n"", ""                                           ({2{tag_match_way1_expanded_f2[3] & ~tag_match_way0_expanded_f2[3]}} & 2'b01) |\n"", ""                                           ({2{tag_match_way2_expanded_f2[3] & ~tag_match_way1_expanded_f2[3] & ~tag_match_way0_expanded_f2[3]}} & 2'b10) |\n"", '                                           ({2{~tag_match_way2_expanded_f2[3] & ~tag_match_way1_expanded_f2[3] & ~tag_match_way0_expanded_f2[3]}} & lru_bank1_next_way[1:0]));\n', ""   assign fetch_replway_bank4_enc[1:0] = ( ({2{tag_match_way0_expanded_f2[4]}} & 2'b00) |\n"", ""                                           ({2{tag_match_way1_expanded_f2[4] & ~tag_match_way0_expanded_f2[4]}} & 2'b01) |\n"", ""                                           ({2{tag_match_way2_expanded_f2[4] & ~tag_match_way1_expanded_f2[4] & ~tag_match_way0_expanded_f2[4]}} & 2'b10) |\n"", '                                           ({2{~tag_match_way2_expanded_f2[4] & ~tag_match_way1_expanded_f2[4] & ~tag_match_way0_expanded_f2[4]}} & lru_bank2_next_way[1:0]));\n', ""   assign fetch_replway_bank5_enc[1:0] = ( ({2{tag_match_way0_expanded_f2[5]}} & 2'b00) |\n"", ""                                           ({2{tag_match_way1_expanded_f2[5] & ~tag_match_way0_expanded_f2[5]}} & 2'b01) |\n"", ""                                           ({2{tag_match_way2_expanded_f2[5] & ~tag_match_way1_expanded_f2[5] & ~tag_match_way0_expanded_f2[5]}} & 2'b10) |\n"", '                                           ({2{~tag_match_way2_expanded_f2[5] & ~tag_match_way1_expanded_f2[5] & ~tag_match_way0_expanded_f2[5]}} & lru_bank2_next_way[1:0]));\n', ""   assign fetch_replway_bank6_enc[1:0] = ( ({2{tag_match_way0_expanded_f2[6]}} & 2'b00) |\n"", ""                                           ({2{tag_match_way1_expanded_f2[6] & ~tag_match_way0_expanded_f2[6]}} & 2'b01) |\n"", ""                                           ({2{tag_match_way2_expanded_f2[6] & ~tag_match_way1_expanded_f2[6] & ~tag_match_way0_expanded_f2[6]}} & 2'b10) |\n"", '                                           ({2{~tag_match_way2_expanded_f2[6] & ~tag_match_way1_expanded_f2[6] & ~tag_match_way0_expanded_f2[6]}} & lru_bank3_next_way[1:0]));\n', ""   assign fetch_replway_bank7_enc[1:0] = ( ({2{tag_match_way0_expanded_f2[7]}} & 2'b00) |\n"", ""                                           ({2{tag_match_way1_expanded_f2[7] & ~tag_match_way0_expanded_f2[7]}} & 2'b01) |\n"", ""                                           ({2{tag_match_way2_expanded_f2[7] & ~tag_match_way1_expanded_f2[7] & ~tag_match_way0_expanded_f2[7]}} & 2'b10) |\n"", '                                           ({2{~tag_match_way2_expanded_f2[7] & ~tag_match_way1_expanded_f2[7] & ~tag_match_way0_expanded_f2[7]}} & lru_bank3_next_way[1:0]));\n', '\n', '`else\n', '\n', '\n', '\n', '   assign btb_lru_b0_ns[LRU_SIZE-1:0] = ( (btb_lru_b0_hold[LRU_SIZE-1:0] & btb_lru_b0_f[LRU_SIZE-1:0]) |\n', '                                          (mp_wrlru_b0[LRU_SIZE-1:0] & {LRU_SIZE{~exu_mp_way}}) |\n', '                                          (fetch_wrlru_b0[LRU_SIZE-1:0] & {LRU_SIZE{tag_match_way0_f2[0]}}) );\n', '\n', '   assign btb_lru_b1_ns[LRU_SIZE-1:0] = ( (btb_lru_b1_hold[LRU_SIZE-1:0] & btb_lru_b1_f[LRU_SIZE-1:0]) |\n', '                                          (mp_wrlru_b1[LRU_SIZE-1:0] & {LRU_SIZE{~exu_mp_way}}) |\n', '                                          (fetch_wrlru_b1[LRU_SIZE-1:0] & {LRU_SIZE{tag_match_way0_f2[1]}}) );\n', '\n', '   assign btb_lru_b2_ns[LRU_SIZE-1:0] = ( (btb_lru_b2_hold[LRU_SIZE-1:0] & btb_lru_b2_f[LRU_SIZE-1:0]) |\n', '                                          (mp_wrlru_b2[LRU_SIZE-1:0] & {LRU_SIZE{~exu_mp_way}}) |\n', '                                          (fetch_wrlru_b2[LRU_SIZE-1:0] & {LRU_SIZE{tag_match_way0_f2[2]}}) );\n', '\n', '   assign btb_lru_b3_ns[LRU_SIZE-1:0] = ( (btb_lru_b3_hold[LRU_SIZE-1:0] & btb_lru_b3_f[LRU_SIZE-1:0]) |\n', '                                          (mp_wrlru_b3[LRU_SIZE-1:0] & {LRU_SIZE{~exu_mp_way}}) |\n', '                                          (fetch_wrlru_b3[LRU_SIZE-1:0] & {LRU_SIZE{tag_match_way0_f2[3]}}) );\n', '\n', '   assign btb_lru_rd_f2[0] = use_mp_way[0] ? exu_mp_way_f : |(fetch_wrindex_dec[LRU_SIZE-1:0] & btb_lru_b0_f[LRU_SIZE-1:0]);\n', '   assign btb_lru_rd_f2[1] = use_mp_way[1] ? exu_mp_way_f : |(fetch_wrindex_dec[LRU_SIZE-1:0] & btb_lru_b1_f[LRU_SIZE-1:0]);\n', '   assign btb_lru_rd_f2[2] = use_mp_way[2] ? exu_mp_way_f : |(fetch_wrindex_dec[LRU_SIZE-1:0] & btb_lru_b2_f[LRU_SIZE-1:0]);\n', '   assign btb_lru_rd_f2[3] = use_mp_way[3] ? exu_mp_way_f : |(fetch_wrindex_dec[LRU_SIZE-1:0] & btb_lru_b3_f[LRU_SIZE-1:0]);\n', '\n', '   assign way_raw[7:0] =  tag_match_way1_expanded_f2[7:0] | (~wayhit_f2[7:0] & {{2{btb_lru_rd_f2[3]}}, {2{btb_lru_rd_f2[2]}}, {2{btb_lru_rd_f2[1]}}, {2{btb_lru_rd_f2[0]}}});\n', '\n', '   rvdffe #(LRU_SIZE*4) btb_lru_ff (.*, .en(ifc_fetch_req_f2 | exu_mp_valid),\n', '                                   .din({btb_lru_b0_ns[(LRU_SIZE)-1:0],\n', '                                         btb_lru_b1_ns[(LRU_SIZE)-1:0],\n', '                                         btb_lru_b2_ns[(LRU_SIZE)-1:0],\n', '                                         btb_lru_b3_ns[(LRU_SIZE)-1:0]}),\n', '                                   .dout({btb_lru_b0_f[(LRU_SIZE)-1:0],\n', '                                          btb_lru_b1_f[(LRU_SIZE)-1:0],\n', '                                          btb_lru_b2_f[(LRU_SIZE)-1:0],\n', '                                          btb_lru_b3_f[(LRU_SIZE)-1:0]}));\n', '`endif // !`ifdef RV_BTB_48\n', '\n', '\n', '   // --------------------------------------------------------------------------------\n', '   // --------------------------------------------------------------------------------\n', '\n', '   // mux out critical hit bank for pc computation\n', '   // This is only useful for the first taken branch in the fetch group\n', '   logic [16:1] btb_sel_data_f2;\n', '   assign {\n', '           btb_rd_tgt_f2[11:0],\n', '           btb_rd_pc4_f2,\n', '           btb_rd_boffset_f2,\n', '           btb_rd_call_f2,\n', '           btb_rd_ret_f2} = btb_sel_data_f2[16:1];\n', '\n', '   assign btb_sel_data_f2[16:1] = ( ({16{btb_sel_f2[7]}} & btb_bank3o_rd_data_f2[16:1]) |\n', '                                    ({16{btb_sel_f2[6]}} & btb_bank3e_rd_data_f2[16:1]) |\n', '                                    ({16{btb_sel_f2[5]}} & btb_bank2o_rd_data_f2[16:1]) |\n', '                                    ({16{btb_sel_f2[4]}} & btb_bank2e_rd_data_f2[16:1]) |\n', '                                    ({16{btb_sel_f2[3]}} & btb_bank1o_rd_data_f2[16:1]) |\n', '                                    ({16{btb_sel_f2[2]}} & btb_bank1e_rd_data_f2[16:1]) |\n', '                                    ({16{btb_sel_f2[1]}} & btb_bank0o_rd_data_f2[16:1]) |\n', '                                    ({16{btb_sel_f2[0]}} & btb_bank0e_rd_data_f2[16:1]) );\n', '\n', '\n', '   logic [7:0] bp_valid_f2, bp_hist1_f2;\n', '\n', '   // a valid taken target needs to kill the next fetch as we compute the target address\n', '   assign ifu_bp_kill_next_f2 = |(bp_valid_f2[7:0] & bp_hist1_f2[7:0]) & ifc_fetch_req_f2 & ~leak_one_f2 & ~dec_tlu_bpred_disable;\n', '\n', '\n', ""   // Don't put calls/rets/ja in the predictor, force the bht taken instead\n"", '   assign bht_force_taken_f2[7:0] = {(btb_bank3o_rd_data_f2[CALL] | btb_bank3o_rd_data_f2[RET]),\n', '                                     (btb_bank3e_rd_data_f2[CALL] | btb_bank3e_rd_data_f2[RET]),\n', '                                     (btb_bank2o_rd_data_f2[CALL] | btb_bank2o_rd_data_f2[RET]),\n', '                                     (btb_bank2e_rd_data_f2[CALL] | btb_bank2e_rd_data_f2[RET]),\n', '                                     (btb_bank1o_rd_data_f2[CALL] | btb_bank1o_rd_data_f2[RET]),\n', '                                     (btb_bank1e_rd_data_f2[CALL] | btb_bank1e_rd_data_f2[RET]),\n', '                                     (btb_bank0o_rd_data_f2[CALL] | btb_bank0o_rd_data_f2[RET]),\n', '                                     (btb_bank0e_rd_data_f2[CALL] | btb_bank0e_rd_data_f2[RET])};\n', '\n', '\n', '   // taken and valid, otherwise, branch errors must clear the bht\n', '   assign bht_valid_f2[7:0] = wayhit_f2[7:0];\n', '\n', '   assign bht_dir_f2[7:0] = {(bht_force_taken_f2[7] | bht_bank7_rd_data_f2[1]) & bht_valid_f2[7],\n', '                             (bht_force_taken_f2[6] | bht_bank6_rd_data_f2[1]) & bht_valid_f2[6],\n', '                             (bht_force_taken_f2[5] | bht_bank5_rd_data_f2[1]) & bht_valid_f2[5],\n', '                             (bht_force_taken_f2[4] | bht_bank4_rd_data_f2[1]) & bht_valid_f2[4],\n', '                             (bht_force_taken_f2[3] | bht_bank3_rd_data_f2[1]) & bht_valid_f2[3],\n', '                             (bht_force_taken_f2[2] | bht_bank2_rd_data_f2[1]) & bht_valid_f2[2],\n', '                             (bht_force_taken_f2[1] | bht_bank1_rd_data_f2[1]) & bht_valid_f2[1],\n', '                             (bht_force_taken_f2[0] | bht_bank0_rd_data_f2[1]) & bht_valid_f2[0]};\n', '\n', '   // final inst_valid_mask.\n', '   // vmask[7] is a 0, vmask[0] is a 1, initially\n', '   // (assumes pc2 with boffset 0)\n', '   //\n', '   logic       minus1, plus1;\n', '\n', '   assign plus1 = ( (~btb_rd_pc4_f2 &   btb_rd_boffset_f2 &  ~ifc_fetch_addr_f2[1]) |\n', '                    ( btb_rd_pc4_f2 &  ~btb_rd_boffset_f2 &  ~ifc_fetch_addr_f2[1]) );\n', '\n', '   assign minus1 = ( (~btb_rd_pc4_f2 &  ~btb_rd_boffset_f2 &   ifc_fetch_addr_f2[1]) |\n', '                     ( btb_rd_pc4_f2 &   btb_rd_boffset_f2 &   ifc_fetch_addr_f2[1]) );\n', '\n', '   assign ifu_bp_inst_mask_f2[7:1] = ( ({7{ ifu_bp_kill_next_f2}} & btb_vmask_f2[7:1]) |\n', ""                                       ({7{~ifu_bp_kill_next_f2}} & 7'b1111111) );\n"", '\n', '   logic [7:0] hist0_raw, hist1_raw, pc4_raw, pret_raw;\n', '\n', '\n', '   // Branch prediction info is sent with the 2byte lane associated with the end of the branch.\n', '   // Cases\n', '   //       BANK1         BANK0\n', '   // -------------------------------\n', '   // |      :       |      :       |\n', '   // -------------------------------\n', '   //         <------------>                   : PC4 branch, offset, should be in B1 (indicated on [2])\n', '   //                <------------>            : PC4 branch, no offset, indicate PC4, VALID, HIST on [1]\n', '   //                       <------------>     : PC4 branch, offset, indicate PC4, VALID, HIST on [0]\n', '   //                <------>                  : PC2 branch, offset, indicate VALID, HIST on [1]\n', '   //                       <------>           : PC2 branch, no offset, indicate VALID, HIST on [0]\n', '   //\n', '\n', '    assign hist1_raw[7:0] = bht_force_taken_f2[7:0] | {bht_bank7_rd_data_f2[1],\n', '                                                      bht_bank6_rd_data_f2[1],\n', '                                                      bht_bank5_rd_data_f2[1],\n', '                                                      bht_bank4_rd_data_f2[1],\n', '                                                      bht_bank3_rd_data_f2[1],\n', '                                                      bht_bank2_rd_data_f2[1],\n', '                                                      bht_bank1_rd_data_f2[1],\n', '                                                      bht_bank0_rd_data_f2[1]};\n', '\n', '   assign hist0_raw[7:0] = {bht_bank7_rd_data_f2[0],\n', '                            bht_bank6_rd_data_f2[0],\n', '                            bht_bank5_rd_data_f2[0],\n', '                            bht_bank4_rd_data_f2[0],\n', '                            bht_bank3_rd_data_f2[0],\n', '                            bht_bank2_rd_data_f2[0],\n', '                            bht_bank1_rd_data_f2[0],\n', '                            bht_bank0_rd_data_f2[0]};\n', '\n', '\n', '   assign pc4_raw[7:0] = {wayhit_f2[7] & btb_bank3o_rd_data_f2[PC4],\n', '                          wayhit_f2[6] & btb_bank3e_rd_data_f2[PC4],\n', '                          wayhit_f2[5] & btb_bank2o_rd_data_f2[PC4],\n', '                          wayhit_f2[4] & btb_bank2e_rd_data_f2[PC4],\n', '                          wayhit_f2[3] & btb_bank1o_rd_data_f2[PC4],\n', '                          wayhit_f2[2] & btb_bank1e_rd_data_f2[PC4],\n', '                          wayhit_f2[1] & btb_bank0o_rd_data_f2[PC4],\n', '                          wayhit_f2[0] & btb_bank0e_rd_data_f2[PC4]};\n', '\n', '   assign pret_raw[7:0] = {wayhit_f2[3] & ~btb_bank3o_rd_data_f2[CALL] & btb_bank3o_rd_data_f2[RET],\n', '                           wayhit_f2[3] & ~btb_bank3e_rd_data_f2[CALL] & btb_bank3e_rd_data_f2[RET],\n', '                           wayhit_f2[2] & ~btb_bank2o_rd_data_f2[CALL] & btb_bank2o_rd_data_f2[RET],\n', '                           wayhit_f2[2] & ~btb_bank2e_rd_data_f2[CALL] & btb_bank2e_rd_data_f2[RET],\n', '                           wayhit_f2[1] & ~btb_bank1o_rd_data_f2[CALL] & btb_bank1o_rd_data_f2[RET],\n', '                           wayhit_f2[1] & ~btb_bank1e_rd_data_f2[CALL] & btb_bank1e_rd_data_f2[RET],\n', '                           wayhit_f2[0] & ~btb_bank0o_rd_data_f2[CALL] & btb_bank0o_rd_data_f2[RET],\n', '                           wayhit_f2[0] & ~btb_bank0e_rd_data_f2[CALL] & btb_bank0e_rd_data_f2[RET]};\n', '\n', '   // GHR\n', '\n', '   // Figure out how many valid branches are in the fetch group\n', 'assign fgmask_f2[6] = (~ifc_fetch_addr_f2[1]) | (~ifc_fetch_addr_f2[2]) | (\n', '    ~ifc_fetch_addr_f2[3]);\n', 'assign fgmask_f2[5] = (~ifc_fetch_addr_f2[2]) | (~ifc_fetch_addr_f2[3]);\n', 'assign fgmask_f2[4] = (~ifc_fetch_addr_f2[2] & ~ifc_fetch_addr_f2[1]) | (\n', '    ~ifc_fetch_addr_f2[3]);\n', 'assign fgmask_f2[3] = (~ifc_fetch_addr_f2[3]);\n', 'assign fgmask_f2[2] = (~ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[1]) | (\n', '    ~ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2]);\n', 'assign fgmask_f2[1] = (~ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2]);\n', 'assign fgmask_f2[0] = (~ifc_fetch_addr_f2[3] & ~ifc_fetch_addr_f2[2]\n', '     & ~ifc_fetch_addr_f2[1]);\n', '\n', '   assign btb_sel_mask_f2[7:0] = {btb_sel_f2[7],\n', '                                  |btb_sel_f2[7:6] & fgmask_f2[6],\n', '                                  |btb_sel_f2[7:5] & fgmask_f2[5],\n', '                                  |btb_sel_f2[7:4] & fgmask_f2[4],\n', '                                  |btb_sel_f2[7:3] & fgmask_f2[3],\n', '                                  |btb_sel_f2[7:2] & fgmask_f2[2],\n', '                                  |btb_sel_f2[7:1] & fgmask_f2[1],\n', '                                  |btb_sel_f2[7:0] & fgmask_f2[0]};\n', '\n', '  // count the valids with masking based on first taken\n', '   assign num_valids[3:0] = countones(bht_valid_f2[7:0] & btb_sel_mask_f2[7:0]);\n', '\n', '   // Note that the following property holds\n', '   // P: prior ghr, H: history bit of last valid branch in line (could be 1 or 0)\n', '   // Num valid branches   What new GHR must be\n', '   // >=4                  000H\n', '   // 3                    P00H\n', '   // 2                    PP0H\n', '   // 1                    PPPH\n', '   // 0                    PPPP\n', '\n', '   assign final_h = |(btb_sel_f2[7:0] & bht_dir_f2[7:0]);\n', '\n', ""    assign merged_ghr[`RV_BHT_GHR_RANGE] = ( ({`RV_BHT_GHR_SIZE{num_valids[3:0] >= 4'h4}} & {`RV_BHT_GHR_PAD,  final_h }) | // 000H\n"", ""                                            ({`RV_BHT_GHR_SIZE{num_valids[3:0] == 4'h3}} & {`RV_BHT_GHR_PAD2, final_h}) | // P00H\n"", '`ifdef RV_BHT_GHR_SIZE_2\n', ""                                            ({`RV_BHT_GHR_SIZE{num_valids[3:0] == 4'h2}} & {                            1'b0, final_h}) | // PP0H\n"", '`else\n', ""                                            ({`RV_BHT_GHR_SIZE{num_valids[3:0] == 4'h2}} & {fghr[`RV_BHT_GHR_SIZE-3:0], 1'b0, final_h}) | // PP0H\n"", '`endif\n', ""                                            ({`RV_BHT_GHR_SIZE{num_valids[3:0] == 4'h1}} & {fghr[`RV_BHT_GHR_SIZE-2:0], final_h}) | // PPPH\n"", ""                                            ({`RV_BHT_GHR_SIZE{num_valids[3:0] == 4'h0}} & {fghr[`RV_BHT_GHR_RANGE]}) ); // PPPP\n"", '\n', '   logic [`RV_BHT_GHR_RANGE] exu_flush_ghr;\n', '   assign exu_flush_ghr[`RV_BHT_GHR_RANGE] = exu_mp_fghr[`RV_BHT_GHR_RANGE];\n', '\n', '   assign fghr_ns[`RV_BHT_GHR_RANGE] = ( ({`RV_BHT_GHR_SIZE{exu_flush_final}} & exu_flush_ghr[`RV_BHT_GHR_RANGE]) |\n', '                                         ({`RV_BHT_GHR_SIZE{~exu_flush_final & ifc_fetch_req_f2_raw & ~leak_one_f2}} & merged_ghr[`RV_BHT_GHR_RANGE]) |\n', '                                         ({`RV_BHT_GHR_SIZE{~exu_flush_final & ~(ifc_fetch_req_f2_raw & ~leak_one_f2)}} & fghr[`RV_BHT_GHR_RANGE]));\n', '\n', '   rvdff #(`RV_BHT_GHR_SIZE) fetchghr (.*, .clk(active_clk), .din(fghr_ns[`RV_BHT_GHR_RANGE]), .dout(fghr[`RV_BHT_GHR_RANGE]));\n', '   assign ifu_bp_fghr_f2[`RV_BHT_GHR_RANGE] = fghr[`RV_BHT_GHR_RANGE];\n', '\n', '\n', '`ifdef RV_BTB_48\n', '   assign ifu_bp_way_f2 = {fetch_replway_bank7_enc[1:0],\n', '                                fetch_replway_bank6_enc[1:0],\n', '                                     fetch_replway_bank5_enc[1:0],\n', '                                     fetch_replway_bank4_enc[1:0],\n', '                                     fetch_replway_bank3_enc[1:0],\n', '                                     fetch_replway_bank2_enc[1:0],\n', '                                     fetch_replway_bank1_enc[1:0],\n', '                                     fetch_replway_bank0_enc[1:0]};\n', '\n', '`else\n', '   assign ifu_bp_way_f2[7:0] = way_raw[7:0];\n', '`endif\n', '   assign ifu_bp_hist1_f2[7:0]    = hist1_raw[7:0];\n', '   assign ifu_bp_hist0_f2[7:0]    = hist0_raw[7:0];\n', '   assign ifu_bp_pc4_f2[7:0]     = pc4_raw[7:0];\n', '   assign ifu_bp_valid_f2[7:0]   = wayhit_f2[7:0] & ~{8{dec_tlu_bpred_disable}};\n', '   assign ifu_bp_ret_f2[7:0]     = pret_raw[7:0];\n', '\n', '\n', '    // Truncate taken and valid, used for detecting a taken branch in the fetch group\n', '    always_comb begin\n', '       casez(ifc_fetch_addr_f2[3:1])\n', ""        3'b000 : begin\n"", '           bp_hist1_f2[7:0]    = hist1_raw[7:0];\n', '           bp_valid_f2[7:0]   = wayhit_f2[7:0];\n', '        end\n', ""        3'b001 : begin\n"", ""           bp_hist1_f2[7:0]    = {1'b0, hist1_raw[7:1]};\n"", ""           bp_valid_f2[7:0]   = {1'b0, wayhit_f2[7:1]};\n"", '        end\n', ""        3'b010 : begin\n"", ""           bp_hist1_f2[7:0]    = {2'b0, hist1_raw[7:2]};\n"", ""           bp_valid_f2[7:0]   = {2'b0, wayhit_f2[7:2]};\n"", '        end\n', ""        3'b011 : begin\n"", ""           bp_hist1_f2[7:0]    = {3'b0, hist1_raw[7:3]};\n"", ""           bp_valid_f2[7:0]   = {3'b0, wayhit_f2[7:3]};\n"", '        end\n', ""        3'b100 : begin\n"", ""           bp_hist1_f2[7:0]    = {4'b0, hist1_raw[7:4]};\n"", ""           bp_valid_f2[7:0]   = {4'b0, wayhit_f2[7:4]};\n"", '        end\n', ""        3'b101 : begin\n"", ""           bp_hist1_f2[7:0]    = {5'b0, hist1_raw[7:5]};\n"", ""           bp_valid_f2[7:0]   = {5'b0, wayhit_f2[7:5]};\n"", '        end\n', ""        3'b110 : begin\n"", ""           bp_hist1_f2[7:0]    = {6'b0, hist1_raw[7:6]};\n"", ""           bp_valid_f2[7:0]   = {6'b0, wayhit_f2[7:6]};\n"", '           end\n', ""        3'b111 : begin\n"", ""           bp_hist1_f2[7:0]    = {7'b0, hist1_raw[7]};\n"", ""           bp_valid_f2[7:0]   = {7'b0, wayhit_f2[7]};\n"", '        end\n', '        default: begin\n', '          bp_hist1_f2[7:0] = hist1_raw[7:0];\n', '          bp_valid_f2[7:0] = wayhit_f2[7:0];\n', '        end\n', '    endcase // casex (ifc_fetch_addr_f1[3:2])\n', '\n', '    end\n', '   // compute target\n', '   // Form the fetch group offset based on the btb hit location and the location of the branch within the 4 byte chunk\n', '    assign btb_fg_crossing_f2 = btb_sel_f2[0] & btb_rd_pc4_f2;\n', '\n', '   wire [2:0] btb_sel_f2_enc, btb_sel_f2_enc_shift;\n', '   assign btb_sel_f2_enc[2:0] = encode8_3(btb_sel_f2[7:0]);\n', ""   assign btb_sel_f2_enc_shift[2:0] = encode8_3({1'b0,btb_sel_f2[7:1]});\n"", '\n', '   assign bp_total_branch_offset_f2[3:1] =  (({3{ btb_rd_pc4_f2}} &  btb_sel_f2_enc_shift[2:0]) |\n', '                                             ({3{~btb_rd_pc4_f2}} &  btb_sel_f2_enc[2:0]) |\n', '                                             ({3{btb_fg_crossing_f2}}));\n', '\n', '\n', '   logic [31:4] adder_pc_in_f2, ifc_fetch_adder_prior;\n', '   rvdffe #(28) faddrf2_ff (.*, .en(ifc_fetch_req_f2 & ~ifu_bp_kill_next_f2 & ic_hit_f2), .din(ifc_fetch_addr_f2[31:4]), .dout(ifc_fetch_adder_prior[31:4]));\n', '\n', '   assign ifu_bp_poffset_f2[11:0] = btb_rd_tgt_f2[11:0];\n', '\n', '   assign adder_pc_in_f2[31:4] = ( ({28{ btb_fg_crossing_f2}} & ifc_fetch_adder_prior[31:4]) |\n', '                                   ({28{~btb_fg_crossing_f2}} & ifc_fetch_addr_f2[31:4]));\n', '\n', '   rvbradder predtgt_addr (.pc({adder_pc_in_f2[31:4], bp_total_branch_offset_f2[3:1]}),\n', '                         .offset(btb_rd_tgt_f2[11:0]),\n', '                         .dout(bp_btb_target_adder_f2[31:1])\n', '                         );\n', '   // mux in the return stack address here for a predicted return\n', '   assign ifu_bp_btb_target_f2[31:1] = btb_rd_ret_f2 & ~btb_rd_call_f2 ? rets_out[0][31:1] : bp_btb_target_adder_f2[31:1];\n', '\n', '\n', '   // ----------------------------------------------------------------------\n', '   // Return Stack\n', '   // ----------------------------------------------------------------------\n', '\n', '   rvbradder rs_addr (.pc({adder_pc_in_f2[31:4], bp_total_branch_offset_f2[3:1]}),\n', ""                    .offset({10'b0, btb_rd_pc4_f2, ~btb_rd_pc4_f2}),\n"", '                    .dout(bp_rs_call_target_f2[31:1])\n', '                         );\n', '\n', ""   // Calls/Rets are always taken, so there shouldn't be a push and pop in the same fetch group\n"", '   logic rs_overpop_correct, rsoverpop_valid_ns, rsoverpop_valid_f;\n', '   logic [31:1] rsoverpop_ns, rsoverpop_f;\n', '   logic rsunderpop_valid_ns, rsunderpop_valid_f, rs_underpop_correct;\n', '`ifdef RS_COMMIT_EN\n', '   assign rs_overpop_correct = rsoverpop_valid_f & exu_flush_final & ~exu_mp_ret;\n', '   assign rs_underpop_correct = rsunderpop_valid_f & exu_flush_final & ~exu_mp_call;\n', '\n', '   assign rsunderpop_valid_ns = (rs_push | (rsunderpop_valid_f & ~(exu_i0_br_call_e4 | exu_i1_br_call_e4))) & ~exu_flush_final;\n', '   assign rsoverpop_valid_ns = (rs_pop | (rsoverpop_valid_f & ~(exu_i0_br_ret_e4 | exu_i1_br_ret_e4))) & ~exu_flush_final;\n', '   assign rsoverpop_ns[31:1] = ( ({31{rs_pop}}  & rets_out[0][31:1]) |\n', '                                 ({31{~rs_pop}} & rsoverpop_f[31:1]) );\n', '\n', '   rvdff #(33) retoverpop_ff (.*, .clk(active_clk), .din({rsunderpop_valid_ns, rsoverpop_valid_ns, rsoverpop_ns[31:1]}), .dout({rsunderpop_valid_f, rsoverpop_valid_f, rsoverpop_f[31:1]}));\n', '`else\n', ""   assign rs_overpop_correct = 1'b0;\n"", ""   assign rs_underpop_correct = 1'b0;\n"", ""   assign rsoverpop_f[31:1]  = 'b0;\n"", '`endif // !`ifdef RS_COMMIT_EN\n', '\n', '   logic e4_rs_correct;\n', '`ifdef REAL_COMM_RS\n', '   assign rs_correct = exu_flush_upper_e2  & ~e4_rs_correct;\n', '`else\n', ""   assign e4_rs_correct = 1'b0;\n"", ""   assign rs_correct = 1'b0;\n"", '`endif\n', '\n', '   assign rs_push = ((btb_rd_call_f2 & ~btb_rd_ret_f2 & ifu_bp_kill_next_f2) | (rs_overpop_correct & ~rs_underpop_correct)) & ~rs_correct & ~e4_rs_correct;\n', '   assign rs_pop = ((btb_rd_ret_f2 & ~btb_rd_call_f2 & ifu_bp_kill_next_f2) | (rs_underpop_correct & ~rs_overpop_correct)) & ~rs_correct & ~e4_rs_correct;\n', '   assign rs_hold = ~rs_push & ~rs_pop & ~rs_overpop_correct & ~rs_underpop_correct & ~rs_correct & ~e4_rs_correct;\n', '\n', '\n', '\n', '   // Fetch based\n', '   assign rets_in[0][31:1] = ( ({31{rs_overpop_correct & rs_underpop_correct}} & rsoverpop_f[31:1]) |\n', '                               ({31{rs_push & rs_overpop_correct}} & rsoverpop_f[31:1]) |\n', '                               ({31{rs_push & ~rs_overpop_correct}} & bp_rs_call_target_f2[31:1]) |\n', '`ifdef REAL_COMM_RS\n', '                               ({31{rs_correct}} & e1_rets_out[0][31:1]) |\n', '                               ({31{e4_rs_correct}} & e4_rets_out[0][31:1]) |\n', '`endif\n', '                               ({31{rs_pop}}  & rets_out[1][31:1]) );\n', '\n', '   assign rsenable[0] = ~rs_hold;\n', '\n', '   for (i=0; i<`RV_RET_STACK_SIZE; i++) begin : retstack\n', '\n', ""      // for the last entry in the stack, we don't have a pop position\n"", '      if(i==`RV_RET_STACK_SIZE-1) begin\n', '`ifdef REAL_COMM_RS\n', '         assign rets_in[i][31:1] = ( ({31{rs_push}} & rets_out[i-1][31:1]) |\n', '                                     ({31{rs_correct}} & e1_rets_out[i][31:1]) |\n', '                                     ({31{e4_rs_correct}} & e4_rets_out[i][31:1]) );\n', '`else\n', '         assign rets_in[i][31:1] = rets_out[i-1][31:1];\n', '`endif\n', '         assign rsenable[i] = rs_push | rs_correct | e4_rs_correct;\n', '      end\n', '      else if(i>0) begin\n', '`ifdef REAL_COMM_RS\n', '        assign rets_in[i][31:1] = ( ({31{rs_push}} & rets_out[i-1][31:1]) |\n', '                                    ({31{rs_pop}}  & rets_out[i+1][31:1]) |\n', '                                    ({31{rs_correct}} & e1_rets_out[i][31:1]) |\n', '                                    ({31{e4_rs_correct}} & e4_rets_out[i][31:1]) );\n', '`else\n', '        assign rets_in[i][31:1] = ( ({31{rs_push}} & rets_out[i-1][31:1]) |\n', '                                    ({31{rs_pop}}  & rets_out[i+1][31:1]) );\n', '`endif\n', '         assign rsenable[i] = rs_push | rs_pop | rs_correct | e4_rs_correct;\n', '      end\n', '      rvdffe #(31) rets_ff (.*, .en(rsenable[i]), .din(rets_in[i][31:1]), .dout(rets_out[i][31:1]));\n', '\n', '   end : retstack\n', '\n', '\n', '`ifdef REAL_COMM_RS\n', '   logic [31:1] e1_rs_call0_target_f2, e1_rs_call1_target_f2, e1_rs_call_target_f2, e4_rs_call0_target_f2, e4_rs_call1_target_f2, e4_rs_call_target_f2;\n', '   logic e1_null, e1_rs_push1, e1_rs_push2, e1_rs_pop1, e1_rs_pop2, e1_rs_hold;\n', '   logic e4_null, e4_rs_push1, e4_rs_push2, e4_rs_pop1, e4_rs_pop2, e4_rs_hold;\n', '   // E1 based\n', '   assign e4_rs_correct = dec_tlu_flush_lower_wb;\n', '   assign e1_null = exu_rets_e1_pkt.pc0_call & exu_rets_e1_pkt.pc1_ret;\n', '   assign e1_rs_push1 = (exu_rets_e1_pkt.pc0_call ^ exu_rets_e1_pkt.pc1_call) & ~e1_null & ~e4_rs_correct;\n', '   assign e1_rs_push2 = (exu_rets_e1_pkt.pc0_call & exu_rets_e1_pkt.pc1_call) & ~e4_rs_correct;\n', '   assign e1_rs_pop1 = (exu_rets_e1_pkt.pc0_ret ^ exu_rets_e1_pkt.pc1_ret) & ~e4_rs_correct;\n', '   assign e1_rs_pop2 = (exu_rets_e1_pkt.pc0_ret & exu_rets_e1_pkt.pc1_ret) & ~e4_rs_correct;\n', '   assign e1_rs_hold = (~e1_rs_push1 & ~e1_rs_push2 & ~e1_rs_pop1 & ~e1_rs_pop2 & ~e4_rs_correct);\n', '\n', '   rvbradder e1_rs_addr0 (.pc({exu_i0_pc_e1[31:1]}),\n', ""                        .offset({10'b0, exu_rets_e1_pkt.pc0_pc4, ~exu_rets_e1_pkt.pc0_pc4}),\n"", '                        .dout(e1_rs_call0_target_f2[31:1])\n', '                        );\n', '   rvbradder e1_rs_addr1 (.pc({exu_i1_pc_e1[31:1]}),\n', ""                        .offset({10'b0, exu_rets_e1_pkt.pc1_pc4, ~exu_rets_e1_pkt.pc1_pc4}),\n"", '                        .dout(e1_rs_call1_target_f2[31:1])\n', '                        );\n', '\n', '   assign e1_rs_call_target_f2[31:1] = exu_rets_e1_pkt.pc0_call ? e1_rs_call0_target_f2[31:1] : e1_rs_call1_target_f2[31:1];\n', '\n', '   assign e1_rets_in[0][31:1] = ( ({31{e1_rs_push1}} & e1_rs_call_target_f2[31:1]) |\n', '                                  ({31{e1_rs_push2}} & e1_rs_call1_target_f2[31:1]) |\n', '                                  ({31{e1_rs_pop1}}  & e1_rets_out[1][31:1]) |\n', '                                  ({31{e1_rs_pop2}}  & e1_rets_out[2][31:1]) |\n', '                                  ({31{e4_rs_correct}}  & e4_rets_out[0][31:1]) |\n', '                                  ({31{e1_rs_hold}}  & e1_rets_out[0][31:1]) );\n', '\n', '   assign e1_rets_in[1][31:1] = ( ({31{e1_rs_push1}} & e1_rets_out[0][31:1]) |\n', '                                  ({31{e1_rs_push2}} & e1_rs_call0_target_f2[31:1]) |\n', '                                  ({31{e1_rs_pop1}}  & e1_rets_out[2][31:1]) |\n', '                                  ({31{e1_rs_pop2}}  & e1_rets_out[3][31:1]) |\n', '                                  ({31{e4_rs_correct}}  & e4_rets_out[1][31:1]) |\n', '                                  ({31{e1_rs_hold}}  & e1_rets_out[0][31:1]) );\n', '\n', '\n', '   for (i=0; i<`RV_RET_STACK_SIZE; i++) begin : e1_retstack\n', '\n', ""      // for the last entry in the stack, we don't have a pop position\n"", '      if(i==`RV_RET_STACK_SIZE-1)\n', '        assign e1_rets_in[i][31:1] = ( ({31{e1_rs_push1}} & e1_rets_out[i-1][31:1]) |\n', '                                       ({31{e1_rs_push2}} & e1_rets_out[i-2][31:1]) |\n', '                                       ({31{e4_rs_correct}}  & e4_rets_out[i][31:1]) |\n', '                                       ({31{e1_rs_hold}}  & e1_rets_out[i][31:1]) );\n', '      else if(i==`RV_RET_STACK_SIZE-2)\n', '        assign e1_rets_in[i][31:1] = ( ({31{e1_rs_push1}} & e1_rets_out[i-1][31:1]) |\n', '                                       ({31{e1_rs_push2}} & e1_rets_out[i-2][31:1]) |\n', '                                       ({31{e1_rs_pop1}}  & e1_rets_out[i+1][31:1]) |\n', '                                       ({31{e4_rs_correct}} & e4_rets_out[i][31:1]) |\n', '                                       ({31{e1_rs_hold}}  & e1_rets_out[i][31:1]) );\n', '\n', '      else if(i>1)\n', '        assign e1_rets_in[i][31:1] = ( ({31{e1_rs_push1}} & e1_rets_out[i-1][31:1]) |\n', '                                       ({31{e1_rs_push2}} & e1_rets_out[i-2][31:1]) |\n', '                                       ({31{e1_rs_pop1}}  & e1_rets_out[i+1][31:1]) |\n', '                                       ({31{e1_rs_pop2}}  & e1_rets_out[i+2][31:1]) |\n', '                                       ({31{e4_rs_correct}} & e4_rets_out[i][31:1]) |\n', '                                       ({31{e1_rs_hold}}  & e1_rets_out[i][31:1]) );\n', '\n', '\n', '      rvdffe #(31) e1_rets_ff (.*, .en(~e1_rs_hold), .din(e1_rets_in[i][31:1]), .dout(e1_rets_out[i][31:1]));\n', '\n', '   end : e1_retstack\n', '\n', '   // E4 based\n', '   assign e4_null = exu_rets_e4_pkt.pc0_call & exu_rets_e4_pkt.pc1_ret;\n', '   assign e4_rs_push1 = (exu_rets_e4_pkt.pc0_call ^ exu_rets_e4_pkt.pc1_call) & ~e4_null;\n', '   assign e4_rs_push2 = (exu_rets_e4_pkt.pc0_call & exu_rets_e4_pkt.pc1_call);\n', '   assign e4_rs_pop1 = (exu_rets_e4_pkt.pc0_ret ^ exu_rets_e4_pkt.pc1_ret);\n', '   assign e4_rs_pop2 = (exu_rets_e4_pkt.pc0_ret & exu_rets_e4_pkt.pc1_ret);\n', '   assign e4_rs_hold = (~e4_rs_push1 & ~e4_rs_push2 & ~e4_rs_pop1 & ~e4_rs_pop2);\n', '\n', '   rvbradder e4_rs_addr0 (.pc({dec_tlu_i0_pc_e4[31:1]}),\n', ""                        .offset({10'b0, exu_rets_e4_pkt.pc0_pc4, ~exu_rets_e4_pkt.pc0_pc4}),\n"", '                        .dout(e4_rs_call0_target_f2[31:1])\n', '                        );\n', '   rvbradder e4_rs_addr1 (.pc({dec_tlu_i1_pc_e4[31:1]}),\n', ""                        .offset({10'b0, exu_rets_e4_pkt.pc1_pc4, ~exu_rets_e4_pkt.pc1_pc4}),\n"", '                        .dout(e4_rs_call1_target_f2[31:1])\n', '                        );\n', '\n', '   assign e4_rs_call_target_f2[31:1] = exu_rets_e4_pkt.pc0_call ? e4_rs_call0_target_f2[31:1] : e4_rs_call1_target_f2[31:1];\n', '\n', '   assign e4_rets_in[0][31:1] = ( ({31{e4_rs_push1}} & e4_rs_call_target_f2[31:1]) |\n', '                                  ({31{e4_rs_push2}} & e4_rs_call1_target_f2[31:1]) |\n', '                                  ({31{e4_rs_pop1}}  & e4_rets_out[1][31:1]) |\n', '                                  ({31{e4_rs_pop2}}  & e4_rets_out[2][31:1]) |\n', '                                  ({31{e4_rs_hold}}  & e4_rets_out[0][31:1]) );\n', '\n', '   assign e4_rets_in[1][31:1] = ( ({31{e4_rs_push1}} & e4_rets_out[0][31:1]) |\n', '                                  ({31{e4_rs_push2}} & e4_rs_call0_target_f2[31:1]) |\n', '                                  ({31{e4_rs_pop1}}  & e4_rets_out[2][31:1]) |\n', '                                  ({31{e4_rs_pop2}}  & e4_rets_out[3][31:1]) |\n', '                                  ({31{e4_rs_hold}}  & e4_rets_out[0][31:1]) );\n', '\n', '\n', '   for (i=0; i<`RV_RET_STACK_SIZE; i++) begin : e4_retstack\n', '\n', ""      // for the last entry in the stack, we don't have a pop position\n"", '      if(i==`RV_RET_STACK_SIZE-1)\n', '        assign e4_rets_in[i][31:1] = ( ({31{e4_rs_push1}} & e4_rets_out[i-1][31:1]) |\n', '                                       ({31{e4_rs_push2}} & e4_rets_out[i-2][31:1]) |\n', '                                       ({31{e4_rs_hold}}  & e4_rets_out[i][31:1]) );\n', '      else if(i==`RV_RET_STACK_SIZE-2)\n', '        assign e4_rets_in[i][31:1] = ( ({31{e4_rs_push1}} & e4_rets_out[i-1][31:1]) |\n', '                                       ({31{e4_rs_push2}} & e4_rets_out[i-2][31:1]) |\n', '                                       ({31{e4_rs_pop1}}  & e4_rets_out[i+1][31:1]) |\n', '                                       ({31{e4_rs_hold}}  & e4_rets_out[i][31:1]) );\n', '\n', '      else if(i>1)\n', '        assign e4_rets_in[i][31:1] = ( ({31{e4_rs_push1}} & e4_rets_out[i-1][31:1]) |\n', '                                       ({31{e4_rs_push2}} & e4_rets_out[i-2][31:1]) |\n', '                                       ({31{e4_rs_pop1}}  & e4_rets_out[i+1][31:1]) |\n', '                                       ({31{e4_rs_pop2}}  & e4_rets_out[i+2][31:1]) |\n', '                                       ({31{e4_rs_hold}}  & e4_rets_out[i][31:1]) );\n', '\n', '\n', '      rvdffe #(31) e4_rets_ff (.*, .en(~e4_rs_hold), .din(e4_rets_in[i][31:1]), .dout(e4_rets_out[i][31:1]));\n', '\n', '   end : e4_retstack\n', '\n', '`endif //  `ifdef REAL_COMM_RS\n', '\n', '\n', '\n', '   // ----------------------------------------------------------------------\n', '   // WRITE\n', '   // ----------------------------------------------------------------------\n', '\n', '\n', '   assign dec_tlu_error_wb = dec_tlu_br0_start_error_wb | dec_tlu_br0_error_wb | dec_tlu_br1_start_error_wb | dec_tlu_br1_error_wb;\n', '   assign dec_tlu_all_banks_error_wb = dec_tlu_br0_start_error_wb | (~dec_tlu_br0_error_wb & dec_tlu_br1_start_error_wb);\n', '\n', '   assign dec_tlu_error_bank_wb[1:0] = (dec_tlu_br0_error_wb | dec_tlu_br0_start_error_wb) ? dec_tlu_br0_bank_wb[1:0] : dec_tlu_br1_bank_wb[1:0];\n', '   assign btb_error_addr_wb[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] = (dec_tlu_br0_error_wb | dec_tlu_br0_start_error_wb) ? dec_tlu_br0_addr_wb[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] : dec_tlu_br1_addr_wb[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO];\n', '\n', '   assign dec_tlu_way_wb = (dec_tlu_br0_error_wb | dec_tlu_br0_start_error_wb) ? dec_tlu_br0_way_wb : dec_tlu_br1_way_wb;\n', '\n', '   assign btb_valid = exu_mp_valid & ~dec_tlu_error_wb;\n', '\n', '   assign btb_wr_tag[`RV_BTB_BTAG_SIZE-1:0] = exu_mp_btag[`RV_BTB_BTAG_SIZE-1:0];\n', ""   rvbtb_tag_hash rdtagf1(.hash(fetch_rd_tag_f1[`RV_BTB_BTAG_SIZE-1:0]), .pc({ifc_fetch_addr_f1[31:4], 3'b0}));\n"", '   rvdff #(`RV_BTB_BTAG_SIZE) rdtagf (.*, .clk(active_clk), .din({fetch_rd_tag_f1[`RV_BTB_BTAG_SIZE-1:0]}), .dout({fetch_rd_tag_f2[`RV_BTB_BTAG_SIZE-1:0]}));\n', '\n', '   assign btb_wr_data[16+`RV_BTB_BTAG_SIZE:0] = {btb_wr_tag[`RV_BTB_BTAG_SIZE-1:0], exu_mp_tgt[11:0], exu_mp_pc4, exu_mp_boffset, exu_mp_call | exu_mp_ja, exu_mp_ret | exu_mp_ja, btb_valid} ;\n', '\n', '   assign exu_mp_valid_write = exu_mp_valid & exu_mp_ataken;\n', '`ifdef RV_BTB_48\n', '\n', ""   assign btb_wr_en_way0[3:0] = ( ({4{(exu_mp_way==2'b0) & exu_mp_valid_write & ~dec_tlu_error_wb}} & decode2_4(exu_mp_bank[1:0])) |\n"", ""                                  ({4{(dec_tlu_way_wb==2'b0) & dec_tlu_error_wb & ~dec_tlu_all_banks_error_wb}} & decode2_4(dec_tlu_error_bank_wb[1:0])) |\n"", ""                                  ({4{(dec_tlu_way_wb==2'b0) & dec_tlu_all_banks_error_wb}}));\n"", '\n', '   assign btb_wr_en_way1[3:0] = ( ({4{exu_mp_way[0] & exu_mp_valid_write & ~dec_tlu_error_wb}} & decode2_4(exu_mp_bank[1:0])) |\n', '                                  ({4{dec_tlu_way_wb[0] & dec_tlu_error_wb & ~dec_tlu_all_banks_error_wb}} & decode2_4(dec_tlu_error_bank_wb[1:0])) |\n', '                                  ({4{dec_tlu_way_wb[0] & dec_tlu_all_banks_error_wb}}));\n', '\n', '   assign btb_wr_en_way2[3:0] = ( ({4{exu_mp_way[1] & exu_mp_valid_write & ~dec_tlu_error_wb}} & decode2_4(exu_mp_bank[1:0])) |\n', '                                  ({4{dec_tlu_way_wb[1] & dec_tlu_error_wb & ~dec_tlu_all_banks_error_wb}} & decode2_4(dec_tlu_error_bank_wb[1:0])) |\n', '                                  ({4{dec_tlu_way_wb[1] & dec_tlu_all_banks_error_wb}}));\n', '`else // !`ifdef RV_BTB_48\n', '   assign btb_wr_en_way0[3:0] = ( ({4{~exu_mp_way & exu_mp_valid_write & ~dec_tlu_error_wb}} & decode2_4(exu_mp_bank[1:0])) |\n', '                                  ({4{~dec_tlu_way_wb & dec_tlu_error_wb & ~dec_tlu_all_banks_error_wb}} & decode2_4(dec_tlu_error_bank_wb[1:0])) |\n', '                                  ({4{~dec_tlu_way_wb & dec_tlu_all_banks_error_wb}}));\n', '\n', '   assign btb_wr_en_way1[3:0] = ( ({4{exu_mp_way & exu_mp_valid_write & ~dec_tlu_error_wb}} & decode2_4(exu_mp_bank[1:0])) |\n', '                                  ({4{dec_tlu_way_wb & dec_tlu_error_wb & ~dec_tlu_all_banks_error_wb}} & decode2_4(dec_tlu_error_bank_wb[1:0])) |\n', '                                  ({4{dec_tlu_way_wb & dec_tlu_all_banks_error_wb}}));\n', '\n', '\n', '`endif\n', '\n', '   assign btb_wr_addr[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] = dec_tlu_error_wb ? btb_error_addr_wb[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] : exu_mp_addr[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO];\n', '\n', '   logic [1:0] bht_wr_data0, bht_wr_data1, bht_wr_data2;\n', '   logic [7:0] bht_wr_en0, bht_wr_en1, bht_wr_en2;\n', '\n', '   assign middle_of_bank = exu_mp_pc4 ^ exu_mp_boffset;\n', '   assign bht_wr_en0[7:0] = {8{exu_mp_valid & ~exu_mp_call & ~exu_mp_ret & ~exu_mp_ja}} & decode3_8({exu_mp_bank[1:0], middle_of_bank});\n', '   assign bht_wr_en1[7:0] = {8{dec_tlu_br1_v_wb}} & decode3_8({dec_tlu_br1_bank_wb[1:0], dec_tlu_br1_middle_wb});\n', '   assign bht_wr_en2[7:0] = {8{dec_tlu_br0_v_wb}} & decode3_8({dec_tlu_br0_bank_wb[1:0], dec_tlu_br0_middle_wb});\n', '\n', '   // Experiments show this is the best priority scheme for same bank/index writes at the same time.\n', '   assign bht_wr_data0[1:0] = exu_mp_hist[1:0]; // lowest priority\n', '   assign bht_wr_data1[1:0] = dec_tlu_br1_hist_wb[1:0];\n', '   assign bht_wr_data2[1:0] = dec_tlu_br0_hist_wb[1:0]; // highest priority\n', '\n', '\n', '\n', '   logic [`RV_BHT_ADDR_HI:`RV_BHT_ADDR_LO] bht_rd_addr_f1, bht_wr_addr0, bht_wr_addr1, bht_wr_addr2;\n', '\n', '   logic [`RV_BHT_ADDR_HI:`RV_BHT_ADDR_LO] mp_hashed, br0_hashed_wb, br1_hashed_wb, bht_rd_addr_hashed_f1;\n', '   rvbtb_ghr_hash mpghrhs  (.hashin(exu_mp_addr[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO]), .ghr(exu_mp_eghr[`RV_BHT_GHR_RANGE]), .hash(mp_hashed[`RV_BHT_ADDR_HI:`RV_BHT_ADDR_LO]));\n', '   rvbtb_ghr_hash br0ghrhs (.hashin(dec_tlu_br0_addr_wb[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO]), .ghr(dec_tlu_br0_fghr_wb[`RV_BHT_GHR_RANGE]), .hash(br0_hashed_wb[`RV_BHT_ADDR_HI:`RV_BHT_ADDR_LO]));\n', '   rvbtb_ghr_hash br1ghrhs (.hashin(dec_tlu_br1_addr_wb[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO]), .ghr(dec_tlu_br1_fghr_wb[`RV_BHT_GHR_RANGE]), .hash(br1_hashed_wb[`RV_BHT_ADDR_HI:`RV_BHT_ADDR_LO]));\n', '   rvbtb_ghr_hash fghrhs (.hashin(btb_rd_addr_f1[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO]), .ghr(fghr_ns[`RV_BHT_GHR_RANGE]), .hash(bht_rd_addr_hashed_f1[`RV_BHT_ADDR_HI:`RV_BHT_ADDR_LO]));\n', '\n', '   assign bht_wr_addr0[`RV_BHT_ADDR_HI:`RV_BHT_ADDR_LO] = mp_hashed[`RV_BHT_ADDR_HI:`RV_BHT_ADDR_LO];\n', '   assign bht_wr_addr1[`RV_BHT_ADDR_HI:`RV_BHT_ADDR_LO] = br1_hashed_wb[`RV_BHT_ADDR_HI:`RV_BHT_ADDR_LO];\n', '   assign bht_wr_addr2[`RV_BHT_ADDR_HI:`RV_BHT_ADDR_LO] = br0_hashed_wb[`RV_BHT_ADDR_HI:`RV_BHT_ADDR_LO];\n', '   assign bht_rd_addr_f1[`RV_BHT_ADDR_HI:`RV_BHT_ADDR_LO] = bht_rd_addr_hashed_f1[`RV_BHT_ADDR_HI:`RV_BHT_ADDR_LO];\n', '\n', '\n', '   // ----------------------------------------------------------------------\n', '   // Structures. Using FLOPS\n', '   // ----------------------------------------------------------------------\n', '   // BTB\n', '   // Entry -> tag[`RV_BTB_BTAG_SIZE-1:0], toffset[11:0], pc4, boffset, call, ret, valid\n', '\n', '\n', '    for (j=0 ; j<LRU_SIZE ; j++) begin : BTB_FLOPS\n', '      // Way 0\n', '          rvdffe #(17+`RV_BTB_BTAG_SIZE) btb_bank0_way0 (.*,\n', '                    .en(((btb_wr_addr[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] == j) & btb_wr_en_way0[0])),\n', '                    .din        (btb_wr_data[16+`RV_BTB_BTAG_SIZE:0]),\n', '                    .dout       (btb_bank0_rd_data_way0_out[j]));\n', '\n', '          rvdffe #(17+`RV_BTB_BTAG_SIZE) btb_bank1_way0 (.*,\n', '                    .en(((btb_wr_addr[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] == j) & btb_wr_en_way0[1])),\n', '                    .din        (btb_wr_data[16+`RV_BTB_BTAG_SIZE:0]),\n', '                    .dout       (btb_bank1_rd_data_way0_out[j]));\n', '\n', '          rvdffe #(17+`RV_BTB_BTAG_SIZE) btb_bank2_way0 (.*,\n', '                    .en(((btb_wr_addr[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] == j) & btb_wr_en_way0[2])),\n', '                    .din        (btb_wr_data[16+`RV_BTB_BTAG_SIZE:0]),\n', '                    .dout       (btb_bank2_rd_data_way0_out[j]));\n', '\n', '          rvdffe #(17+`RV_BTB_BTAG_SIZE) btb_bank3_way0 (.*,\n', '                    .en(((btb_wr_addr[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] == j) & btb_wr_en_way0[3])),\n', '                    .din        (btb_wr_data[16+`RV_BTB_BTAG_SIZE:0]),\n', '                    .dout       (btb_bank3_rd_data_way0_out[j]));\n', '\n', '      // Way 1\n', '          rvdffe #(17+`RV_BTB_BTAG_SIZE) btb_bank0_way1 (.*,\n', '                    .en(((btb_wr_addr[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] == j) & btb_wr_en_way1[0])),\n', '                    .din        (btb_wr_data[16+`RV_BTB_BTAG_SIZE:0]),\n', '                    .dout       (btb_bank0_rd_data_way1_out[j]));\n', '\n', '          rvdffe #(17+`RV_BTB_BTAG_SIZE) btb_bank1_way1 (.*,\n', '                    .en(((btb_wr_addr[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] == j) & btb_wr_en_way1[1])),\n', '                    .din        (btb_wr_data[16+`RV_BTB_BTAG_SIZE:0]),\n', '                    .dout       (btb_bank1_rd_data_way1_out[j]));\n', '\n', '          rvdffe #(17+`RV_BTB_BTAG_SIZE) btb_bank2_way1 (.*,\n', '                    .en(((btb_wr_addr[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] == j) & btb_wr_en_way1[2])),\n', '                    .din        (btb_wr_data[16+`RV_BTB_BTAG_SIZE:0]),\n', '                    .dout       (btb_bank2_rd_data_way1_out[j]));\n', '\n', '          rvdffe #(17+`RV_BTB_BTAG_SIZE) btb_bank3_way1 (.*,\n', '                    .en(((btb_wr_addr[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] == j) & btb_wr_en_way1[3])),\n', '                    .din        (btb_wr_data[16+`RV_BTB_BTAG_SIZE:0]),\n', '                    .dout       (btb_bank3_rd_data_way1_out[j]));\n', '`ifdef RV_BTB_48\n', '      // Way 2\n', '          rvdffe #(17+`RV_BTB_BTAG_SIZE) btb_bank0_way2 (.*,\n', '                    .en(((btb_wr_addr[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] == j) & btb_wr_en_way2[0])),\n', '                    .din        (btb_wr_data[16+`RV_BTB_BTAG_SIZE:0]),\n', '                    .dout       (btb_bank0_rd_data_way2_out[j]));\n', '\n', '          rvdffe #(17+`RV_BTB_BTAG_SIZE) btb_bank1_way2 (.*,\n', '                    .en(((btb_wr_addr[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] == j) & btb_wr_en_way2[1])),\n', '                    .din        (btb_wr_data[16+`RV_BTB_BTAG_SIZE:0]),\n', '                    .dout       (btb_bank1_rd_data_way2_out[j]));\n', '\n', '          rvdffe #(17+`RV_BTB_BTAG_SIZE) btb_bank2_way2 (.*,\n', '                    .en(((btb_wr_addr[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] == j) & btb_wr_en_way2[2])),\n', '                    .din        (btb_wr_data[16+`RV_BTB_BTAG_SIZE:0]),\n', '                    .dout       (btb_bank2_rd_data_way2_out[j]));\n', '\n', '          rvdffe #(17+`RV_BTB_BTAG_SIZE) btb_bank3_way2 (.*,\n', '                    .en(((btb_wr_addr[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] == j) & btb_wr_en_way2[3])),\n', '                    .din        (btb_wr_data[16+`RV_BTB_BTAG_SIZE:0]),\n', '                    .dout       (btb_bank3_rd_data_way2_out[j]));\n', '`endif\n', '    end\n', '\n', '   rvdffe #(17+`RV_BTB_BTAG_SIZE) btb_bank0_way0_data_out (.*,\n', '                    .en(ifc_fetch_req_f1),\n', '                    .din        (btb_bank0_rd_data_way0_f2_in[16+`RV_BTB_BTAG_SIZE:0]),\n', '                    .dout       (btb_bank0_rd_data_way0_f2   [16+`RV_BTB_BTAG_SIZE:0]));\n', '\n', '   rvdffe #(17+`RV_BTB_BTAG_SIZE) btb_bank1_way0_data_out (.*,\n', '                    .en(ifc_fetch_req_f1),\n', '                    .din        (btb_bank1_rd_data_way0_f2_in[16+`RV_BTB_BTAG_SIZE:0]),\n', '                    .dout       (btb_bank1_rd_data_way0_f2   [16+`RV_BTB_BTAG_SIZE:0]));\n', '\n', '   rvdffe #(17+`RV_BTB_BTAG_SIZE) btb_bank2_way0_data_out (.*,\n', '                    .en(ifc_fetch_req_f1),\n', '                    .din        (btb_bank2_rd_data_way0_f2_in[16+`RV_BTB_BTAG_SIZE:0]),\n', '                    .dout       (btb_bank2_rd_data_way0_f2   [16+`RV_BTB_BTAG_SIZE:0]));\n', '\n', '   rvdffe #(17+`RV_BTB_BTAG_SIZE) btb_bank3_way0_data_out (.*,\n', '                    .en(ifc_fetch_req_f1),\n', '                    .din        (btb_bank3_rd_data_way0_f2_in[16+`RV_BTB_BTAG_SIZE:0]),\n', '                    .dout       (btb_bank3_rd_data_way0_f2   [16+`RV_BTB_BTAG_SIZE:0]));\n', '\n', '   rvdffe #(17+`RV_BTB_BTAG_SIZE) btb_bank0_way1_data_out (.*,\n', '                    .en(ifc_fetch_req_f1),\n', '                    .din        (btb_bank0_rd_data_way1_f2_in[16+`RV_BTB_BTAG_SIZE:0]),\n', '                    .dout       (btb_bank0_rd_data_way1_f2   [16+`RV_BTB_BTAG_SIZE:0]));\n', '\n', '   rvdffe #(17+`RV_BTB_BTAG_SIZE) btb_bank1_way1_data_out (.*,\n', '                    .en(ifc_fetch_req_f1),\n', '                    .din        (btb_bank1_rd_data_way1_f2_in[16+`RV_BTB_BTAG_SIZE:0]),\n', '                    .dout       (btb_bank1_rd_data_way1_f2   [16+`RV_BTB_BTAG_SIZE:0]));\n', '\n', '   rvdffe #(17+`RV_BTB_BTAG_SIZE) btb_bank2_way1_data_out (.*,\n', '                    .en(ifc_fetch_req_f1),\n', '                    .din        (btb_bank2_rd_data_way1_f2_in[16+`RV_BTB_BTAG_SIZE:0]),\n', '                    .dout       (btb_bank2_rd_data_way1_f2   [16+`RV_BTB_BTAG_SIZE:0]));\n', '\n', '   rvdffe #(17+`RV_BTB_BTAG_SIZE) btb_bank3_way1_data_out (.*,\n', '                    .en(ifc_fetch_req_f1),\n', '                    .din        (btb_bank3_rd_data_way1_f2_in[16+`RV_BTB_BTAG_SIZE:0]),\n', '                    .dout       (btb_bank3_rd_data_way1_f2   [16+`RV_BTB_BTAG_SIZE:0]));\n', '\n', '`ifdef RV_BTB_48\n', '   rvdffe #(17+`RV_BTB_BTAG_SIZE) btb_bank0_way2_data_out (.*,\n', '                    .en(ifc_fetch_req_f1),\n', '                    .din        (btb_bank0_rd_data_way2_f2_in[16+`RV_BTB_BTAG_SIZE:0]),\n', '                    .dout       (btb_bank0_rd_data_way2_f2   [16+`RV_BTB_BTAG_SIZE:0]));\n', '\n', '   rvdffe #(17+`RV_BTB_BTAG_SIZE) btb_bank1_way2_data_out (.*,\n', '                    .en(ifc_fetch_req_f1),\n', '                    .din        (btb_bank1_rd_data_way2_f2_in[16+`RV_BTB_BTAG_SIZE:0]),\n', '                    .dout       (btb_bank1_rd_data_way2_f2   [16+`RV_BTB_BTAG_SIZE:0]));\n', '\n', '   rvdffe #(17+`RV_BTB_BTAG_SIZE) btb_bank2_way2_data_out (.*,\n', '                    .en(ifc_fetch_req_f1),\n', '                    .din        (btb_bank2_rd_data_way2_f2_in[16+`RV_BTB_BTAG_SIZE:0]),\n', '                    .dout       (btb_bank2_rd_data_way2_f2   [16+`RV_BTB_BTAG_SIZE:0]));\n', '\n', '   rvdffe #(17+`RV_BTB_BTAG_SIZE) btb_bank3_way2_data_out (.*,\n', '                    .en(ifc_fetch_req_f1),\n', '                    .din        (btb_bank3_rd_data_way2_f2_in[16+`RV_BTB_BTAG_SIZE:0]),\n', '                    .dout       (btb_bank3_rd_data_way2_f2   [16+`RV_BTB_BTAG_SIZE:0]));\n', '`endif //  `ifdef RV_BTB_48\n', '\n', '    always_comb begin : BTB_rd_mux\n', ""        btb_bank0_rd_data_way0_f2_in[16+`RV_BTB_BTAG_SIZE:0] = '0 ;\n"", ""        btb_bank1_rd_data_way0_f2_in[16+`RV_BTB_BTAG_SIZE:0] = '0 ;\n"", ""        btb_bank2_rd_data_way0_f2_in[16+`RV_BTB_BTAG_SIZE:0] = '0 ;\n"", ""        btb_bank3_rd_data_way0_f2_in[16+`RV_BTB_BTAG_SIZE:0] = '0 ;\n"", '\n', ""        btb_bank0_rd_data_way1_f2_in[16+`RV_BTB_BTAG_SIZE:0] = '0 ;\n"", ""        btb_bank1_rd_data_way1_f2_in[16+`RV_BTB_BTAG_SIZE:0] = '0 ;\n"", ""        btb_bank2_rd_data_way1_f2_in[16+`RV_BTB_BTAG_SIZE:0] = '0 ;\n"", ""        btb_bank3_rd_data_way1_f2_in[16+`RV_BTB_BTAG_SIZE:0] = '0 ;\n"", '\n', '`ifdef RV_BTB_48\n', ""       btb_bank0_rd_data_way2_f2_in[16+`RV_BTB_BTAG_SIZE:0] = '0 ;\n"", ""       btb_bank1_rd_data_way2_f2_in[16+`RV_BTB_BTAG_SIZE:0] = '0 ;\n"", ""       btb_bank2_rd_data_way2_f2_in[16+`RV_BTB_BTAG_SIZE:0] = '0 ;\n"", ""       btb_bank3_rd_data_way2_f2_in[16+`RV_BTB_BTAG_SIZE:0] = '0 ;\n"", '`endif\n', '        for (int j=0; j< LRU_SIZE; j++) begin\n', ""          if (btb_rd_addr_f1[`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] == (`RV_BTB_ADDR_HI-`RV_BTB_ADDR_LO+1)'(j)) begin\n"", '\n', '           btb_bank0_rd_data_way0_f2_in[16+`RV_BTB_BTAG_SIZE:0] =  btb_bank0_rd_data_way0_out[j];\n', '           btb_bank1_rd_data_way0_f2_in[16+`RV_BTB_BTAG_SIZE:0] =  btb_bank1_rd_data_way0_out[j];\n', '           btb_bank2_rd_data_way0_f2_in[16+`RV_BTB_BTAG_SIZE:0] =  btb_bank2_rd_data_way0_out[j];\n', '           btb_bank3_rd_data_way0_f2_in[16+`RV_BTB_BTAG_SIZE:0] =  btb_bank3_rd_data_way0_out[j];\n', '\n', '           btb_bank0_rd_data_way1_f2_in[16+`RV_BTB_BTAG_SIZE:0] =  btb_bank0_rd_data_way1_out[j];\n', '           btb_bank1_rd_data_way1_f2_in[16+`RV_BTB_BTAG_SIZE:0] =  btb_bank1_rd_data_way1_out[j];\n', '           btb_bank2_rd_data_way1_f2_in[16+`RV_BTB_BTAG_SIZE:0] =  btb_bank2_rd_data_way1_out[j];\n', '           btb_bank3_rd_data_way1_f2_in[16+`RV_BTB_BTAG_SIZE:0] =  btb_bank3_rd_data_way1_out[j];\n', '\n', '`ifdef RV_BTB_48\n', '           btb_bank0_rd_data_way2_f2_in[16+`RV_BTB_BTAG_SIZE:0] =  btb_bank0_rd_data_way2_out[j];\n', '           btb_bank1_rd_data_way2_f2_in[16+`RV_BTB_BTAG_SIZE:0] =  btb_bank1_rd_data_way2_out[j];\n', '           btb_bank2_rd_data_way2_f2_in[16+`RV_BTB_BTAG_SIZE:0] =  btb_bank2_rd_data_way2_out[j];\n', '           btb_bank3_rd_data_way2_f2_in[16+`RV_BTB_BTAG_SIZE:0] =  btb_bank3_rd_data_way2_out[j];\n', '`endif\n', '\n', '          end\n', '        end\n', '    end\n', '\n', '   //-----------------------------------------------------------------------------\n', '   // BHT\n', '   // 2 bit Entry -> direction, strength\n', '   //\n', '   //-----------------------------------------------------------------------------\n', '\n', '   logic [7:0] [(`RV_BHT_ARRAY_DEPTH/NUM_BHT_LOOP)-1:0][NUM_BHT_LOOP-1:0][1:0]      bht_bank_wr_data ;\n', '   logic [7:0] [`RV_BHT_ARRAY_DEPTH-1:0] [1:0]                bht_bank_rd_data_out ;\n', '   logic [1:0]                                                bht_bank0_rd_data_f2_in, bht_bank1_rd_data_f2_in, bht_bank2_rd_data_f2_in, bht_bank3_rd_data_f2_in;\n', '   logic [1:0]                                                bht_bank4_rd_data_f2_in, bht_bank5_rd_data_f2_in, bht_bank6_rd_data_f2_in, bht_bank7_rd_data_f2_in;\n', '   logic [7:0] [(`RV_BHT_ARRAY_DEPTH/NUM_BHT_LOOP)-1:0]                 bht_bank_clken ;\n', '   logic [7:0] [(`RV_BHT_ARRAY_DEPTH/NUM_BHT_LOOP)-1:0]                 bht_bank_clk   ;\n', '   logic [7:0] [(`RV_BHT_ARRAY_DEPTH/NUM_BHT_LOOP)-1:0][NUM_BHT_LOOP-1:0]           bht_bank_sel   ;\n', '\n', '   for ( i=0; i<8; i++) begin : BANKS\n', '     for (genvar k=0 ; k < (`RV_BHT_ARRAY_DEPTH)/NUM_BHT_LOOP ; k++) begin : BHT_CLK_GROUP\n', '     assign bht_bank_clken[i][k]  = (bht_wr_en0[i] & ((bht_wr_addr0[`RV_BHT_ADDR_HI: NUM_BHT_LOOP_OUTER_LO]==k) |  BHT_NO_ADDR_MATCH)) |\n', '                                    (bht_wr_en1[i] & ((bht_wr_addr1[`RV_BHT_ADDR_HI: NUM_BHT_LOOP_OUTER_LO]==k) |  BHT_NO_ADDR_MATCH)) |\n', '                                    (bht_wr_en2[i] & ((bht_wr_addr2[`RV_BHT_ADDR_HI: NUM_BHT_LOOP_OUTER_LO]==k) |  BHT_NO_ADDR_MATCH));\n', '\n', '`ifndef RV_FPGA_OPTIMIZE\n', '     rvclkhdr bht_bank_grp_cgc ( .en(bht_bank_clken[i][k]), .l1clk(bht_bank_clk[i][k]), .* );  // ifndef RV_FPGA_OPTIMIZE\n', '`else\n', ""     assign bht_bank_clk[i][k] = '0;\n"", '`endif\n', '\n', '     for (j=0 ; j<NUM_BHT_LOOP ; j++) begin : BHT_FLOPS\n', '       assign   bht_bank_sel[i][k][j]    = (bht_wr_en0[i] & (bht_wr_addr0[NUM_BHT_LOOP_INNER_HI :`RV_BHT_ADDR_LO] == j) & ((bht_wr_addr0[`RV_BHT_ADDR_HI: NUM_BHT_LOOP_OUTER_LO]==k) | BHT_NO_ADDR_MATCH)) |\n', '                                           (bht_wr_en1[i] & (bht_wr_addr1[NUM_BHT_LOOP_INNER_HI :`RV_BHT_ADDR_LO] == j) & ((bht_wr_addr1[`RV_BHT_ADDR_HI: NUM_BHT_LOOP_OUTER_LO]==k) | BHT_NO_ADDR_MATCH)) |\n', '                                           (bht_wr_en2[i] & (bht_wr_addr2[NUM_BHT_LOOP_INNER_HI :`RV_BHT_ADDR_LO] == j) & ((bht_wr_addr2[`RV_BHT_ADDR_HI: NUM_BHT_LOOP_OUTER_LO]==k) | BHT_NO_ADDR_MATCH)) ;\n', '\n', '       assign bht_bank_wr_data[i][k][j]  = (bht_wr_en2[i] & (bht_wr_addr2[NUM_BHT_LOOP_INNER_HI:`RV_BHT_ADDR_LO] == j) & ((bht_wr_addr2[`RV_BHT_ADDR_HI: NUM_BHT_LOOP_OUTER_LO]==k) | BHT_NO_ADDR_MATCH)) ? bht_wr_data2[1:0] :\n', '                                           (bht_wr_en1[i] & (bht_wr_addr1[NUM_BHT_LOOP_INNER_HI:`RV_BHT_ADDR_LO] == j) & ((bht_wr_addr1[`RV_BHT_ADDR_HI: NUM_BHT_LOOP_OUTER_LO]==k) | BHT_NO_ADDR_MATCH)) ? bht_wr_data1[1:0] :\n', '                                                                                                                      bht_wr_data0[1:0]   ;\n', '\n', '          rvdffs_fpga #(2) bht_bank (.*,\n', '                    .clk        (bht_bank_clk[i][k]),\n', '                    .clken      (bht_bank_sel[i][k][j]),\n', '                    .rawclk     (clk),\n', '                    .en         (bht_bank_sel[i][k][j]),\n', '                    .din        (bht_bank_wr_data[i][k][j]),\n', '                    .dout       (bht_bank_rd_data_out[i][(16*k)+j]));\n', '\n', '      end // block: BHT_FLOPS\n', '   end // block: BHT_CLK_GROUP\n', ' end // block: BANKS\n', '\n', '    always_comb begin : BHT_rd_mux\n', ""     bht_bank0_rd_data_f2_in[1:0] = '0 ;\n"", ""     bht_bank1_rd_data_f2_in[1:0] = '0 ;\n"", ""     bht_bank2_rd_data_f2_in[1:0] = '0 ;\n"", ""     bht_bank3_rd_data_f2_in[1:0] = '0 ;\n"", ""     bht_bank4_rd_data_f2_in[1:0] = '0 ;\n"", ""     bht_bank5_rd_data_f2_in[1:0] = '0 ;\n"", ""     bht_bank6_rd_data_f2_in[1:0] = '0 ;\n"", ""     bht_bank7_rd_data_f2_in[1:0] = '0 ;\n"", '     for (int j=0; j< `RV_BHT_ARRAY_DEPTH; j++) begin\n', ""       if (bht_rd_addr_f1[`RV_BHT_ADDR_HI:`RV_BHT_ADDR_LO] == (`RV_BHT_ADDR_HI-`RV_BHT_ADDR_LO+1)'(j)) begin\n"", '         bht_bank0_rd_data_f2_in[1:0] = bht_bank_rd_data_out[0][j];\n', '         bht_bank1_rd_data_f2_in[1:0] = bht_bank_rd_data_out[1][j];\n', '         bht_bank2_rd_data_f2_in[1:0] = bht_bank_rd_data_out[2][j];\n', '         bht_bank3_rd_data_f2_in[1:0] = bht_bank_rd_data_out[3][j];\n', '         bht_bank4_rd_data_f2_in[1:0] = bht_bank_rd_data_out[4][j];\n', '         bht_bank5_rd_data_f2_in[1:0] = bht_bank_rd_data_out[5][j];\n', '         bht_bank6_rd_data_f2_in[1:0] = bht_bank_rd_data_out[6][j];\n', '         bht_bank7_rd_data_f2_in[1:0] = bht_bank_rd_data_out[7][j];\n', '       end\n', '      end\n', '    end // block: BHT_rd_mux\n', '\n', '\n', '\n', '   rvdffe #(16) bht_dataoutf (.*, .en         (ifc_fetch_req_f1),\n', '                                 .din        ({bht_bank0_rd_data_f2_in[1:0],\n', '                                               bht_bank1_rd_data_f2_in[1:0],\n', '                                               bht_bank2_rd_data_f2_in[1:0],\n', '                                               bht_bank3_rd_data_f2_in[1:0],\n', '                                               bht_bank4_rd_data_f2_in[1:0],\n', '                                               bht_bank5_rd_data_f2_in[1:0],\n', '                                               bht_bank6_rd_data_f2_in[1:0],\n', '                                               bht_bank7_rd_data_f2_in[1:0]\n', '                                               }),\n', '                                 .dout       ({bht_bank0_rd_data_f2   [1:0],\n', '                                               bht_bank1_rd_data_f2   [1:0],\n', '                                               bht_bank2_rd_data_f2   [1:0],\n', '                                               bht_bank3_rd_data_f2   [1:0],\n', '                                               bht_bank4_rd_data_f2   [1:0],\n', '                                               bht_bank5_rd_data_f2   [1:0],\n', '                                               bht_bank6_rd_data_f2   [1:0],\n', '                                               bht_bank7_rd_data_f2   [1:0]\n', '                                               }));\n', '\n', '\n', '\n', '\n', '     function [2:0] encode8_3;\n', '      input [7:0] in;\n', '\n', '      encode8_3[2] = |in[7:4];\n', '      encode8_3[1] = in[7] | in[6] | in[3] | in[2];\n', '      encode8_3[0] = in[7] | in[5] | in[3] | in[1];\n', '\n', '   endfunction\n', '   function [7:0] decode3_8;\n', '      input [2:0] in;\n', '\n', '      decode3_8[7] =  in[2] &  in[1] &  in[0];\n', '      decode3_8[6] =  in[2] &  in[1] & ~in[0];\n', '      decode3_8[5] =  in[2] & ~in[1] &  in[0];\n', '      decode3_8[4] =  in[2] & ~in[1] & ~in[0];\n', '      decode3_8[3] = ~in[2] &  in[1] &  in[0];\n', '      decode3_8[2] = ~in[2] &  in[1] & ~in[0];\n', '      decode3_8[1] = ~in[2] & ~in[1] &  in[0];\n', '      decode3_8[0] = ~in[2] & ~in[1] & ~in[0];\n', '\n', '   endfunction\n', '   function [3:0] decode2_4;\n', '      input [1:0] in;\n', '\n', '      decode2_4[3] =  in[1] &  in[0];\n', '      decode2_4[2] =  in[1] & ~in[0];\n', '      decode2_4[1] = ~in[1] &  in[0];\n', '      decode2_4[0] = ~in[1] & ~in[0];\n', '\n', '   endfunction\n', '\n', '   function [3:0] countones;\n', '      input [7:0] valid;\n', '\n', '      begin\n', '\n', ""countones[3:0] = {3'b0, valid[7]} +\n"", ""                 {3'b0, valid[6]} +\n"", ""                 {3'b0, valid[5]} +\n"", ""                 {3'b0, valid[4]} +\n"", ""                 {3'b0, valid[3]} +\n"", ""                 {3'b0, valid[2]} +\n"", ""                 {3'b0, valid[1]} +\n"", ""                 {3'b0, valid[0]};\n"", '      end\n', '   endfunction\n', '   function [2:0] newlru; // updated lru\n', '      input [2:0] lru;// current lru\n', '      input [1:0] used;// hit way\n', '      begin\n', '`ifdef BTB_ROUND_ROBIN\n', ""newlru[2] = 1'b0;\n"", ""newlru[1:0] = (lru[1:0]==2'b10) ? 2'b0 : lru[1:0] + 2'b01;\n"", '`else\n', 'newlru[2] = (lru[2] & ~used[0]) | (~used[1] & ~used[0]);\n', 'newlru[1] = (~used[1] & ~used[0]) | (used[0]);\n', 'newlru[0] = (~lru[2] & lru[1] & ~used[1] & ~used[0]) | (~lru[1] & ~lru[0] & used[0]) | (\n', '    ~lru[2] & lru[0] & used[0]) | (lru[0] & ~used[1] & ~used[0]);\n', '`endif\n', '      end\n', '   endfunction //\n', '\n', '   function [1:0] lru2way; // new repl way taking invalid ways into account\n', '      input [2:0] lru; // current lru\n', '      input [2:0] v; // current way valids\n', '      begin\n', '`ifdef BTB_ROUND_ROBIN\n', '         lru2way[1:0] = lru[1:0];\n', '`else\n', '         lru2way[1] = (~lru[2] & lru[1] & ~lru[0] & v[1] & v[0]) | (lru[2] & lru[0] & v[1] & v[0]) | (~v[2] & v[1] & v[0]);\n', '         lru2way[0] = (lru[2] & ~lru[0] & v[2] & v[0]) | (~v[1] & v[0]);\n', '`endif\n', '      end\n', '   endfunction\n', '\n', 'endmodule // ifu_bp_ctl\n', '\n']"
"['//********************************************************************************\n', '// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '//********************************************************************************\n', '\n', '// purpose of this file is to convert 16b RISCV compressed instruction into 32b equivalent\n', '\n', 'module ifu_compress_ctl\n', '  (\n', '   input  logic [15:0] din,\n', '   output logic [31:0] dout,\n', '   output logic legal\n', '   );\n', '\n', '\n', '\n', '   logic [15:0]  i;\n', '\n', '   logic [31:0]  o,l1,l2,l3;\n', '\n', '\n', '   assign i[15:0] = din[15:0];\n', '\n', '\n', '   logic [4:0]   rs2d,rdd,rdpd,rs2pd;\n', '\n', 'logic rdrd;\n', 'logic rdrs1;\n', 'logic rs2rs2;\n', 'logic rdprd;\n', 'logic rdprs1;\n', 'logic rs2prs2;\n', 'logic rs2prd;\n', 'logic uimm9_2;\n', 'logic ulwimm6_2;\n', 'logic ulwspimm7_2;\n', 'logic rdeq2;\n', 'logic rdeq1;\n', 'logic rs1eq2;\n', 'logic sbroffset8_1;\n', 'logic simm9_4;\n', 'logic simm5_0;\n', 'logic sjaloffset11_1;\n', 'logic sluimm17_12;\n', 'logic uimm5_0;\n', 'logic uswimm6_2;\n', 'logic uswspimm7_2;\n', '\n', '\n', '\n', '   // form the opcodes\n', '\n', '   // formats\n', '   //\n', '   // c.add rd 11:7 rs2  6:2\n', '   // c.and rdp 9:7 rs2p 4:2\n', '   //\n', '   // add rs2 24:20 rs1 19:15  rd 11:7\n', '\n', '   assign rs2d[4:0] = i[6:2];\n', '\n', '   assign rdd[4:0] = i[11:7];\n', '\n', ""   assign rdpd[4:0] = {2'b01, i[9:7]};\n"", '\n', ""   assign rs2pd[4:0] = {2'b01, i[4:2]};\n"", '\n', '\n', '\n', '   // merge in rd, rs1, rs2\n', '\n', '\n', '   // rd\n', '   assign l1[6:0] = o[6:0];\n', '\n', '   assign l1[11:7] = o[11:7] |\n', '                     ({5{rdrd}} & rdd[4:0]) |\n', '                     ({5{rdprd}} & rdpd[4:0]) |\n', '                     ({5{rs2prd}} & rs2pd[4:0]) |\n', ""                     ({5{rdeq1}} & 5'd1) |\n"", ""                     ({5{rdeq2}} & 5'd2);\n"", '\n', '\n', '   // rs1\n', '   assign l1[14:12] = o[14:12];\n', '   assign l1[19:15] = o[19:15] |\n', '                      ({5{rdrs1}} & rdd[4:0]) |\n', '                      ({5{rdprs1}} & rdpd[4:0]) |\n', ""                      ({5{rs1eq2}} & 5'd2);\n"", '\n', '\n', '   // rs2\n', '   assign l1[24:20] = o[24:20] |\n', '                      ({5{rs2rs2}} & rs2d[4:0]) |\n', '                      ({5{rs2prs2}} & rs2pd[4:0]);\n', '\n', '   assign l1[31:25] = o[31:25];\n', '\n', '   logic [5:0] simm5d;\n', '   logic [9:2] uimm9d;\n', '\n', '   logic [9:4] simm9d;\n', '   logic [6:2] ulwimm6d;\n', '   logic [7:2] ulwspimm7d;\n', '   logic [5:0] uimm5d;\n', '   logic [20:1] sjald;\n', '\n', '   logic [31:12] sluimmd;\n', '\n', '   // merge in immediates + jal offset\n', '\n', '   assign simm5d[5:0] = { i[12], i[6:2] };\n', '\n', '   assign uimm9d[9:2] = { i[10:7], i[12:11], i[5], i[6] };\n', '\n', '   assign simm9d[9:4] = { i[12], i[4:3], i[5], i[2], i[6] };\n', '\n', '   assign ulwimm6d[6:2] = { i[5], i[12:10], i[6] };\n', '\n', '   assign ulwspimm7d[7:2] = { i[3:2], i[12], i[6:4] };\n', '\n', '   assign uimm5d[5:0] = { i[12], i[6:2] };\n', '\n', '   assign sjald[11:1] = { i[12], i[8], i[10:9], i[6], i[7], i[2], i[11], i[5:4], i[3] };\n', '\n', '   assign sjald[20:12] =  {9{i[12]}};\n', '\n', '\n', '\n', '   assign sluimmd[31:12] = { {15{i[12]}}, i[6:2] };\n', '\n', '\n', '   assign l2[31:20] = ( l1[31:20] ) |\n', '                      ( {12{simm5_0}}   &  {{7{simm5d[5]}},simm5d[4:0]} ) |\n', ""                      ( {12{uimm9_2}}   &  {2'b0,uimm9d[9:2],2'b0} ) |\n"", ""                      ( {12{simm9_4}}   &   {{3{simm9d[9]}},simm9d[8:4],4'b0} ) |\n"", ""                      ( {12{ulwimm6_2}} &   {5'b0,ulwimm6d[6:2],2'b0} ) |\n"", ""                      ( {12{ulwspimm7_2}}  & {4'b0,ulwspimm7d[7:2],2'b0} ) |\n"", ""                      ( {12{uimm5_0}}      &    {6'b0,uimm5d[5:0]} ) |\n"", '                      ( {12{sjaloffset11_1}} &  {sjald[20],sjald[10:1],sjald[11]} ) |\n', '                      ( {12{sluimm17_12}}    &  sluimmd[31:20] );\n', '\n', '\n', '\n', '   assign l2[19:12] = ( l1[19:12] ) |\n', '                      ( {8{sjaloffset11_1}} & sjald[19:12] ) |\n', '                      ( {8{sluimm17_12}} & sluimmd[19:12] );\n', '\n', '\n', '   assign l2[11:0] = l1[11:0];\n', '\n', '\n', '   // merge in branch offset and store immediates\n', '\n', '   logic [8:1]   sbr8d;\n', '   logic [6:2]   uswimm6d;\n', '   logic [7:2]   uswspimm7d;\n', '\n', '\n', '   assign sbr8d[8:1] =   { i[12], i[6], i[5], i[2], i[11], i[10], i[4], i[3] };\n', '\n', '   assign uswimm6d[6:2] = { i[5], i[12:10], i[6] };\n', '\n', '   assign uswspimm7d[7:2] = { i[8:7], i[12:9] };\n', '\n', '   assign l3[31:25] = ( l2[31:25] ) |\n', '                      ( {7{sbroffset8_1}} & { {4{sbr8d[8]}},sbr8d[7:5] } ) |\n', ""                      ( {7{uswimm6_2}}    & { 5'b0, uswimm6d[6:5] } ) |\n"", ""                      ( {7{uswspimm7_2}} & { 4'b0, uswspimm7d[7:5] } );\n"", '\n', '\n', '   assign l3[24:12] = l2[24:12];\n', '\n', '   assign l3[11:7] = ( l2[11:7] ) |\n', '                     ( {5{sbroffset8_1}} & { sbr8d[4:1], sbr8d[8] } ) |\n', ""                     ( {5{uswimm6_2}} & { uswimm6d[4:2], 2'b0 } ) |\n"", ""                     ( {5{uswspimm7_2}} & { uswspimm7d[4:2], 2'b0 } );\n"", '\n', '   assign l3[6:0] = l2[6:0];\n', '\n', '\n', '   assign dout[31:0] = l3[31:0] & {32{legal}};\n', '\n', '\n', '// file ""cdecode"" is human readable file that has all of the compressed instruction decodes defined and is part of git repo\n', '// modify this file as needed\n', '\n', '// to generate all the equations below from ""cdecode"" except legal equation:\n', '\n', '// 1) coredecode -in cdecode > cdecode.e\n', '\n', '// 2) espresso -Dso -oeqntott cdecode.e | addassign > compress_equations\n', '\n', '// to generate the legal (16b compressed instruction is legal)  equation below:\n', '\n', '// 1) coredecode -in cdecode -legal > clegal.e\n', '\n', '// 2) espresso -Dso -oeqntott clegal.e | addassign > clegal_equation\n', '\n', '\n', '\n', '\n', '\n', '// espresso decodes\n', 'assign rdrd = (!i[14]&i[6]&i[1]) | (!i[15]&i[14]&i[11]&i[0]) | (!i[14]&i[5]&i[1]) | (\n', '    !i[15]&i[14]&i[10]&i[0]) | (!i[14]&i[4]&i[1]) | (!i[15]&i[14]&i[9]\n', '    &i[0]) | (!i[14]&i[3]&i[1]) | (!i[15]&i[14]&!i[8]&i[0]) | (!i[14]\n', '    &i[2]&i[1]) | (!i[15]&i[14]&i[7]&i[0]) | (!i[15]&i[1]) | (!i[15]\n', '    &!i[13]&i[0]);\n', '\n', 'assign rdrs1 = (!i[14]&i[12]&i[11]&i[1]) | (!i[14]&i[12]&i[10]&i[1]) | (!i[14]\n', '    &i[12]&i[9]&i[1]) | (!i[14]&i[12]&i[8]&i[1]) | (!i[14]&i[12]&i[7]\n', '    &i[1]) | (!i[14]&!i[12]&!i[6]&!i[5]&!i[4]&!i[3]&!i[2]&i[1]) | (!i[14]\n', '    &i[12]&i[6]&i[1]) | (!i[14]&i[12]&i[5]&i[1]) | (!i[14]&i[12]&i[4]\n', '    &i[1]) | (!i[14]&i[12]&i[3]&i[1]) | (!i[14]&i[12]&i[2]&i[1]) | (\n', '    !i[15]&!i[14]&!i[13]&i[0]) | (!i[15]&!i[14]&i[1]);\n', '\n', 'assign rs2rs2 = (i[15]&i[6]&i[1]) | (i[15]&i[5]&i[1]) | (i[15]&i[4]&i[1]) | (\n', '    i[15]&i[3]&i[1]) | (i[15]&i[2]&i[1]) | (i[15]&i[14]&i[1]);\n', '\n', 'assign rdprd = (i[15]&!i[14]&!i[13]&i[0]);\n', '\n', 'assign rdprs1 = (i[15]&!i[13]&i[0]) | (i[15]&i[14]&i[0]) | (i[14]&!i[1]&!i[0]);\n', '\n', 'assign rs2prs2 = (i[15]&!i[14]&!i[13]&i[11]&i[10]&i[0]) | (i[15]&!i[1]&!i[0]);\n', '\n', 'assign rs2prd = (!i[15]&!i[1]&!i[0]);\n', '\n', 'assign uimm9_2 = (!i[14]&!i[1]&!i[0]);\n', '\n', 'assign ulwimm6_2 = (!i[15]&i[14]&!i[1]&!i[0]);\n', '\n', 'assign ulwspimm7_2 = (!i[15]&i[14]&i[1]);\n', '\n', 'assign rdeq2 = (!i[15]&i[14]&i[13]&!i[11]&!i[10]&!i[9]&i[8]&!i[7]);\n', '\n', 'assign rdeq1 = (!i[14]&i[12]&i[11]&!i[6]&!i[5]&!i[4]&!i[3]&!i[2]&i[1]) | (!i[14]\n', '    &i[12]&i[10]&!i[6]&!i[5]&!i[4]&!i[3]&!i[2]&i[1]) | (!i[14]&i[12]&i[9]\n', '    &!i[6]&!i[5]&!i[4]&!i[3]&!i[2]&i[1]) | (!i[14]&i[12]&i[8]&!i[6]&!i[5]\n', '    &!i[4]&!i[3]&!i[2]&i[1]) | (!i[14]&i[12]&i[7]&!i[6]&!i[5]&!i[4]&!i[3]\n', '    &!i[2]&i[1]) | (!i[15]&!i[14]&i[13]);\n', '\n', 'assign rs1eq2 = (!i[15]&i[14]&i[13]&!i[11]&!i[10]&!i[9]&i[8]&!i[7]) | (i[14]\n', '    &i[1]) | (!i[14]&!i[1]&!i[0]);\n', '\n', 'assign sbroffset8_1 = (i[15]&i[14]&i[0]);\n', '\n', 'assign simm9_4 = (!i[15]&i[14]&i[13]&!i[11]&!i[10]&!i[9]&i[8]&!i[7]);\n', '\n', 'assign simm5_0 = (!i[14]&!i[13]&i[11]&!i[10]&i[0]) | (!i[15]&!i[13]&i[0]);\n', '\n', 'assign sjaloffset11_1 = (!i[14]&i[13]);\n', '\n', 'assign sluimm17_12 = (!i[15]&i[14]&i[13]&i[7]) | (!i[15]&i[14]&i[13]&!i[8]) | (\n', '    !i[15]&i[14]&i[13]&i[9]) | (!i[15]&i[14]&i[13]&i[10]) | (!i[15]&i[14]\n', '    &i[13]&i[11]);\n', '\n', 'assign uimm5_0 = (i[15]&!i[14]&!i[13]&!i[11]&i[0]) | (!i[15]&!i[14]&i[1]);\n', '\n', 'assign uswimm6_2 = (i[15]&!i[1]&!i[0]);\n', '\n', 'assign uswspimm7_2 = (i[15]&i[14]&i[1]);\n', '\n', ""assign o[31]  = 1'b0;\n"", '\n', 'assign o[30] = (i[15]&!i[14]&!i[13]&i[10]&!i[6]&!i[5]&i[0]) | (i[15]&!i[14]\n', '    &!i[13]&!i[11]&i[10]&i[0]);\n', '\n', ""assign o[29]  = 1'b0;\n"", '\n', ""assign o[28]  = 1'b0;\n"", '\n', ""assign o[27]  = 1'b0;\n"", '\n', ""assign o[26]  = 1'b0;\n"", '\n', ""assign o[25]  = 1'b0;\n"", '\n', ""assign o[24]  = 1'b0;\n"", '\n', ""assign o[23]  = 1'b0;\n"", '\n', ""assign o[22]  = 1'b0;\n"", '\n', ""assign o[21]  = 1'b0;\n"", '\n', 'assign o[20] = (!i[14]&i[12]&!i[11]&!i[10]&!i[9]&!i[8]&!i[7]&!i[6]&!i[5]&!i[4]\n', '    &!i[3]&!i[2]&i[1]);\n', '\n', ""assign o[19]  = 1'b0;\n"", '\n', ""assign o[18]  = 1'b0;\n"", '\n', ""assign o[17]  = 1'b0;\n"", '\n', ""assign o[16]  = 1'b0;\n"", '\n', ""assign o[15]  = 1'b0;\n"", '\n', 'assign o[14] = (i[15]&!i[14]&!i[13]&!i[11]&i[0]) | (i[15]&!i[14]&!i[13]&!i[10]\n', '    &i[0]) | (i[15]&!i[14]&!i[13]&i[6]&i[0]) | (i[15]&!i[14]&!i[13]&i[5]\n', '    &i[0]);\n', '\n', 'assign o[13] = (i[15]&!i[14]&!i[13]&i[11]&!i[10]&i[0]) | (i[15]&!i[14]&!i[13]\n', '    &i[11]&i[6]&i[0]) | (i[14]&!i[0]);\n', '\n', 'assign o[12] = (i[15]&!i[14]&!i[13]&i[6]&i[5]&i[0]) | (i[15]&!i[14]&!i[13]&!i[11]\n', '    &i[0]) | (i[15]&!i[14]&!i[13]&!i[10]&i[0]) | (!i[15]&!i[14]&i[1]) | (\n', '    i[15]&i[14]&i[13]);\n', '\n', ""assign o[11]  = 1'b0;\n"", '\n', ""assign o[10]  = 1'b0;\n"", '\n', ""assign o[9]  = 1'b0;\n"", '\n', ""assign o[8]  = 1'b0;\n"", '\n', ""assign o[7]  = 1'b0;\n"", '\n', 'assign o[6] = (i[15]&!i[14]&!i[6]&!i[5]&!i[4]&!i[3]&!i[2]&!i[0]) | (!i[14]&i[13]) | (\n', '    i[15]&i[14]&i[0]);\n', '\n', 'assign o[5] = (i[15]&!i[0]) | (i[15]&i[11]&i[10]) | (i[13]&!i[8]) | (i[13]&i[7]) | (\n', '    i[13]&i[9]) | (i[13]&i[10]) | (i[13]&i[11]) | (!i[14]&i[13]) | (\n', '    i[15]&i[14]);\n', '\n', 'assign o[4] = (!i[14]&!i[11]&!i[10]&!i[9]&!i[8]&!i[7]&!i[0]) | (!i[15]&!i[14]\n', '    &!i[0]) | (!i[14]&i[6]&!i[0]) | (!i[15]&i[14]&i[0]) | (!i[14]&i[5]\n', '    &!i[0]) | (!i[14]&i[4]&!i[0]) | (!i[14]&!i[13]&i[0]) | (!i[14]&i[3]\n', '    &!i[0]) | (!i[14]&i[2]&!i[0]);\n', '\n', 'assign o[3] = (!i[14]&i[13]);\n', '\n', 'assign o[2] = (!i[14]&i[12]&i[11]&!i[6]&!i[5]&!i[4]&!i[3]&!i[2]&i[1]) | (!i[14]\n', '    &i[12]&i[10]&!i[6]&!i[5]&!i[4]&!i[3]&!i[2]&i[1]) | (!i[14]&i[12]&i[9]\n', '    &!i[6]&!i[5]&!i[4]&!i[3]&!i[2]&i[1]) | (!i[14]&i[12]&i[8]&!i[6]&!i[5]\n', '    &!i[4]&!i[3]&!i[2]&i[1]) | (!i[14]&i[12]&i[7]&!i[6]&!i[5]&!i[4]&!i[3]\n', '    &!i[2]&i[1]) | (i[15]&!i[14]&!i[12]&!i[6]&!i[5]&!i[4]&!i[3]&!i[2]\n', '    &!i[0]) | (!i[15]&i[13]&!i[8]) | (!i[15]&i[13]&i[7]) | (!i[15]&i[13]\n', '    &i[9]) | (!i[15]&i[13]&i[10]) | (!i[15]&i[13]&i[11]) | (!i[14]&i[13]);\n', '\n', ""// 32b instruction has lower two bits 2'b11\n"", '\n', ""assign o[1]  = 1'b1;\n"", '\n', ""assign o[0]  = 1'b1;\n"", '\n', 'assign legal = (!i[13]&!i[12]&i[11]&i[1]&!i[0]) | (!i[13]&!i[12]&i[6]&i[1]&!i[0]) | (\n', '    !i[15]&!i[13]&i[11]&!i[1]) | (!i[13]&!i[12]&i[5]&i[1]&!i[0]) | (\n', '    !i[13]&!i[12]&i[10]&i[1]&!i[0]) | (!i[15]&!i[13]&i[6]&!i[1]) | (\n', '    i[15]&!i[12]&!i[1]&i[0]) | (!i[13]&!i[12]&i[9]&i[1]&!i[0]) | (!i[12]\n', '    &i[6]&!i[1]&i[0]) | (!i[15]&!i[13]&i[5]&!i[1]) | (!i[13]&!i[12]&i[8]\n', '    &i[1]&!i[0]) | (!i[12]&i[5]&!i[1]&i[0]) | (!i[15]&!i[13]&i[10]&!i[1]) | (\n', '    !i[13]&!i[12]&i[7]&i[1]&!i[0]) | (i[12]&i[11]&!i[10]&!i[1]&i[0]) | (\n', '    !i[15]&!i[13]&i[9]&!i[1]) | (!i[13]&!i[12]&i[4]&i[1]&!i[0]) | (i[13]\n', '    &i[12]&!i[1]&i[0]) | (!i[15]&!i[13]&i[8]&!i[1]) | (!i[13]&!i[12]&i[3]\n', '    &i[1]&!i[0]) | (i[13]&i[4]&!i[1]&i[0]) | (!i[13]&!i[12]&i[2]&i[1]\n', '    &!i[0]) | (!i[15]&!i[13]&i[7]&!i[1]) | (i[13]&i[3]&!i[1]&i[0]) | (\n', '    i[13]&i[2]&!i[1]&i[0]) | (i[14]&!i[13]&!i[1]) | (!i[14]&!i[12]&!i[1]\n', '    &i[0]) | (i[15]&!i[13]&i[12]&i[1]&!i[0]) | (!i[15]&!i[13]&!i[12]&i[1]\n', '    &!i[0]) | (!i[15]&!i[13]&i[12]&!i[1]) | (i[14]&!i[13]&!i[0]);\n', '\n', '\n', '\n', '\n', 'endmodule\n']"
"['//********************************************************************************\n', '// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '//********************************************************************************\n', '\n', '//********************************************************************************\n', '// Icache closely coupled memory --- ICCM\n', '//********************************************************************************\n', '\n', 'module ifu_iccm_mem\n', '   import veer_types::*;\n', '\n', '(\n', '   input logic         clk,\n', '   input logic         free_clk,\n', '   input logic         rst_l,\n', '   input logic         clk_override,\n', '\n', '   input logic          iccm_wren,\n', '   input logic          iccm_rden,\n', '   input logic [`RV_ICCM_BITS-1:2]   iccm_rw_addr,\n', '\n', '   input logic [2:0]    iccm_wr_size,\n', '   input logic [77:0]   iccm_wr_data,\n', '\n', '\n', '   output logic [155:0] iccm_rd_data,\n', '   input  logic         scan_mode\n', '\n', ');\n', '\n', '`include ""global.h""\n', '\n', '\n', '   logic [ICCM_NUM_BANKS/4-1:0]               wren_bank;\n', '   logic [ICCM_NUM_BANKS/4-1:0]               rden_bank;\n', '   logic [ICCM_NUM_BANKS/4-1:0]               iccm_hi0_clken;\n', '   logic [ICCM_NUM_BANKS/4-1:0]               iccm_hi1_clken;\n', '   logic [ICCM_NUM_BANKS/4-1:0]               iccm_lo0_clken;\n', '   logic [ICCM_NUM_BANKS/4-1:0]               iccm_lo1_clken;\n', '   logic [ICCM_NUM_BANKS/4-1:0]               iccm_hi0_clk  ;\n', '   logic [ICCM_NUM_BANKS/4-1:0]               iccm_hi1_clk  ;\n', '   logic [ICCM_NUM_BANKS/4-1:0]               iccm_lo0_clk  ;\n', '   logic [ICCM_NUM_BANKS/4-1:0]               iccm_lo1_clk  ;\n', '\n', '\n', '   logic [ICCM_NUM_BANKS/4-1:0]               wren_bank_hi0;\n', '   logic [ICCM_NUM_BANKS/4-1:0]               wren_bank_lo0;\n', '   logic [ICCM_NUM_BANKS/4-1:0]               wren_bank_hi1;\n', '   logic [ICCM_NUM_BANKS/4-1:0]               wren_bank_lo1;\n', '   logic [ICCM_NUM_BANKS/4-1:0] [ICCM_INDEX_BITS-1:0] addr_bank;\n', '\n', '\n', '\n', '   logic [ICCM_NUM_BANKS/4-1:0] [77:0]   iccm_bank_dout_hi;\n', '   logic [ICCM_NUM_BANKS/4-1:0] [77:0]   iccm_bank_dout_lo;\n', '   logic [5:4]                           iccm_rw_addr_q;\n', '    // assign CLK = clk ;\n', '\n', '\n', '   for (genvar i=0; i<ICCM_NUM_BANKS/4; i++) begin: mem_bank\n', '      assign  wren_bank[i]         = iccm_wren & ( (iccm_rw_addr[ICCM_BANK_HI:4] == i) | (ICCM_BANK_BITS == 2));\n', '      assign  rden_bank[i]         = iccm_rden & ( (iccm_rw_addr[ICCM_BANK_HI:4] == i) | (ICCM_BANK_BITS == 2));\n', ""      assign  wren_bank_hi0[i]      = wren_bank[i] &  iccm_rw_addr[3] & (~iccm_rw_addr[2] | (iccm_wr_size[1:0] == 2'b11));\n"", ""      assign  wren_bank_hi1[i]      = wren_bank[i] &  iccm_rw_addr[3] & ( iccm_rw_addr[2] | (iccm_wr_size[1:0] == 2'b11));\n"", ""      assign  wren_bank_lo0[i]      = wren_bank[i] & ~iccm_rw_addr[3] & (~iccm_rw_addr[2] | (iccm_wr_size[1:0] == 2'b11));\n"", ""      assign  wren_bank_lo1[i]      = wren_bank[i] & ~iccm_rw_addr[3] & ( iccm_rw_addr[2] | (iccm_wr_size[1:0] == 2'b11));\n"", '\n', '      assign iccm_hi0_clken[i]      =  wren_bank_hi0[i] |  (rden_bank[i] | clk_override);   // Do not override the writes\n', '      assign iccm_hi1_clken[i]      =  wren_bank_hi1[i] |  (rden_bank[i] | clk_override);   // Do not override the writes\n', '      assign iccm_lo0_clken[i]      =  wren_bank_lo0[i] |  (rden_bank[i] | clk_override);   // Do not override the writes\n', '      assign iccm_lo1_clken[i]      =  wren_bank_lo1[i] |  (rden_bank[i] | clk_override);   // Do not override the writes\n', '\n', '      rvoclkhdr iccm_hi0_c1_cgc  ( .en(iccm_hi0_clken[i]), .l1clk(iccm_hi0_clk[i]), .* );\n', '      rvoclkhdr iccm_hi1_c1_cgc  ( .en(iccm_hi1_clken[i]), .l1clk(iccm_hi1_clk[i]), .* );\n', '      rvoclkhdr iccm_lo0_c1_cgc  ( .en(iccm_lo0_clken[i]), .l1clk(iccm_lo0_clk[i]), .* );\n', '      rvoclkhdr iccm_lo1_c1_cgc  ( .en(iccm_lo1_clken[i]), .l1clk(iccm_lo1_clk[i]), .* );\n', '\n', '\n', '      assign  addr_bank[i][ICCM_INDEX_BITS-1:0] = iccm_rw_addr[ICCM_BITS-1:(ICCM_BANK_BITS+2)];\n', '\n', '         `RV_ICCM_DATA_CELL iccm_bank_hi0 (\n', '                                     // Primary ports\n', '                                     .CLK(iccm_hi0_clk[i]),\n', '                                     .WE(wren_bank_hi0[i]),\n', '                                     .ADR(addr_bank[i]),\n', '                                     .D(iccm_wr_data[38:0]),\n', '                                     .Q(iccm_bank_dout_hi[i][38:0])\n', '                                      );\n', '          `RV_ICCM_DATA_CELL iccm_bank_hi1 (\n', '                                     // Primary ports\n', '                                     .CLK(iccm_hi1_clk[i]),\n', '                                     .WE(wren_bank_hi1[i]),\n', '                                     .ADR(addr_bank[i]),\n', '                                     .D(iccm_wr_data[77:39]),\n', '                                     .Q(iccm_bank_dout_hi[i][77:39])\n', '                                      );\n', '          `RV_ICCM_DATA_CELL iccm_bank_lo0 (\n', '                                     // Primary ports\n', '                                     .CLK(iccm_lo0_clk[i]),\n', '                                     .WE(wren_bank_lo0[i]),\n', '                                     .ADR(addr_bank[i]),\n', '                                     .D(iccm_wr_data[38:0]),\n', '                                     .Q(iccm_bank_dout_lo[i][38:0])\n', '                                      );\n', '         `RV_ICCM_DATA_CELL iccm_bank_lo1 (\n', '                                     // Primary ports\n', '                                     .CLK(iccm_lo1_clk[i]),\n', '                                     .WE(wren_bank_lo1[i]),\n', '                                     .ADR(addr_bank[i]),\n', '                                     .D(iccm_wr_data[77:39]),\n', '                                     .Q(iccm_bank_dout_lo[i][77:39])\n', '                                      );\n', '\n', '\n', '   end : mem_bank\n', '\n', '\n', '   assign iccm_rd_data[155:0] = (ICCM_BANK_BITS == 2) ?  {iccm_bank_dout_hi[0][77:0], iccm_bank_dout_lo[0][77:0]}   :\n', '                                                           { iccm_bank_dout_hi[iccm_rw_addr_q[ICCM_BANK_HI:4]][77:0], iccm_bank_dout_lo[iccm_rw_addr_q[ICCM_BANK_HI:4]][77:0] };\n', '\n', '\n', ' if (ICCM_BANK_BITS == 2) begin\n', ""    assign iccm_rw_addr_q[5:4] = '0;\n"", ' end\n', '   // 8 banks, each bank 8B, we index as 4 banks\n', ' else begin\n', '  rvdff  #(2) rd_addr_ff (.*, .clk(free_clk), .din(iccm_rw_addr[5:4]), .dout(iccm_rw_addr_q[5:4]) );\n', ' end\n', 'endmodule // ifu_iccm_mem\n', '\n', '\n']"
"['//********************************************************************************\n', '// SPDX-License-Identifier: Apache-2.0\n', ""// Copyright 2019 Western Digital Corporation or it's affiliates.\n"", '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '//********************************************************************************\n', '////////////////////////////////////////////////////\n', '//   ICACHE DATA & TAG MODULE WRAPPER              //\n', '/////////////////////////////////////////////////////\n', 'module ifu_ic_mem\n', '  (\n', '      input logic free_clk,\n', '      input logic clk,\n', '      input logic rst_l,\n', '      input logic clk_override,\n', '      input logic dec_tlu_core_ecc_disable,\n', '\n', '      input logic [31:2]  ic_rw_addr,\n', '      input logic [3:0]   ic_wr_en  ,  // Which way to write\n', '      input logic         ic_rd_en  ,  // Read enable\n', '\n', '      input logic [15:2]               ic_debug_addr,      // Read/Write addresss to the Icache.\n', '      input logic                      ic_debug_rd_en,     // Icache debug rd\n', '      input logic                      ic_debug_wr_en,     // Icache debug wr\n', '      input logic                      ic_debug_tag_array, // Debug tag array\n', '      input logic [3:0]                ic_debug_way,       // Debug way. Rd or Wr.\n', '      input logic [127:0]              ic_premux_data,     // Premux data to be muxed with each way of the Icache.\n', '      input logic                      ic_sel_premux_data, // Select the pre_muxed data\n', '\n', '\n', '\n', '`ifdef RV_ICACHE_ECC\n', '      input  logic [83:0]               ic_wr_data,         // Data to fill to the Icache. With ECC\n', '      output logic [167:0]              ic_rd_data ,        // Data read from Icache. 2x64bits + parity bits. F2 stage. With ECC\n', '      output logic [24:0]               ictag_debug_rd_data,// Debug icache tag.\n', '      input logic  [41:0]               ic_debug_wr_data,   // Debug wr cache.\n', '`else\n', '      input  logic [67:0]               ic_wr_data,         // Data to fill to the Icache. With Parity\n', '      output logic [135:0]              ic_rd_data ,        // Data read from Icache. 2x64bits + parity bits. F2 stage. With Parity\n', '      output logic [20:0]               ictag_debug_rd_data,// Debug icache tag.\n', '      input logic  [33:0]               ic_debug_wr_data,   // Debug wr cache.\n', '`endif\n', '\n', '\n', '      input logic [3:0]   ic_tag_valid,  // Valid from the I$ tag valid outside (in flops).\n', '\n', '      output logic [3:0]   ic_rd_hit,   // ic_rd_hit[3:0]\n', '      output logic         ic_tag_perr, // Tag Parity error\n', '      input  logic         scan_mode\n', '      ) ;\n', '\n', '`include ""global.h""\n', '\n', '   IC_TAG #( .ICACHE_TAG_HIGH(ICACHE_TAG_HIGH) ,\n', '             .ICACHE_TAG_LOW(ICACHE_TAG_LOW) ,\n', '             .ICACHE_TAG_DEPTH(ICACHE_TAG_DEPTH)\n', '             ) ic_tag_inst\n', '          (\n', '           .*,\n', '           .ic_wr_en     (ic_wr_en[3:0]),\n', '           .ic_debug_addr(ic_debug_addr[ICACHE_TAG_HIGH-1:2]),\n', '           .ic_rw_addr   (ic_rw_addr[31:3])\n', '           ) ;\n', '\n', '   IC_DATA #( .ICACHE_TAG_HIGH(ICACHE_TAG_HIGH) ,\n', '              .ICACHE_TAG_LOW(ICACHE_TAG_LOW) ,\n', '              .ICACHE_IC_DEPTH(ICACHE_IC_DEPTH)\n', '             ) ic_data_inst\n', '          (\n', '           .*,\n', '           .ic_wr_en     (ic_wr_en[3:0]),\n', '           .ic_debug_addr(ic_debug_addr[ICACHE_TAG_HIGH-1:2]),\n', '           .ic_rw_addr   (ic_rw_addr[ICACHE_TAG_HIGH-1:2])\n', '           ) ;\n', '\n', ' endmodule\n', '\n', '\n', '/////////////////////////////////////////////////\n', '////// ICACHE DATA MODULE    ////////////////////\n', '/////////////////////////////////////////////////\n', 'module IC_DATA #(parameter ICACHE_TAG_HIGH = 16 ,\n', '                           ICACHE_TAG_LOW=6 ,\n', '                           ICACHE_IC_DEPTH=1024\n', '                                        )\n', '     (\n', '      input logic free_clk,\n', '      input logic clk,\n', '      input logic rst_l,\n', '      input logic clk_override,\n', '\n', '      input logic [ICACHE_TAG_HIGH-1:2]  ic_rw_addr,\n', '      input logic [3:0]                  ic_wr_en,\n', '      input logic                        ic_rd_en,  // Read enable\n', '`ifdef RV_ICACHE_ECC\n', '      input  logic [83:0]               ic_wr_data,         // Data to fill to the Icache. With ECC\n', '      output logic [167:0]              ic_rd_data ,        // Data read from Icache. 2x64bits + parity bits. F2 stage. With ECC\n', '      input  logic [41:0]               ic_debug_wr_data,   // Debug wr cache.\n', '`else\n', '      input  logic [67:0]               ic_wr_data,         // Data to fill to the Icache. With Parity\n', '      output logic [135:0]              ic_rd_data ,        // Data read from Icache. 2x64bits + parity bits. F2 stage. With Parity\n', '      input  logic [33:0]               ic_debug_wr_data,   // Debug wr cache.\n', '`endif\n', '\n', '\n', '      input logic [ICACHE_TAG_HIGH-1:2]  ic_debug_addr,      // Read/Write addresss to the Icache.\n', '      input logic                        ic_debug_rd_en,     // Icache debug rd\n', '      input logic                        ic_debug_wr_en,     // Icache debug wr\n', '      input logic                        ic_debug_tag_array, // Debug tag array\n', '      input logic [3:0]                  ic_debug_way,       // Debug way. Rd or Wr.\n', '      input logic [127:0]                ic_premux_data,     // Premux data to be muxed with each way of the Icache.\n', '      input logic                        ic_sel_premux_data, // Select the pre_muxed data\n', '\n', '      input logic [3:0]          ic_rd_hit,\n', '\n', '      input  logic               scan_mode\n', '\n', '      ) ;\n', '\n', '   logic [5:4]             ic_rw_addr_ff;\n', '\n', '\n', '   logic [3:0][3:0]       ic_b_sb_wren, ic_bank_way_clken, ic_bank_way_clk;    // way, bank\n', '\n', '   logic                   ic_debug_sel_sb0 ;\n', '   logic                   ic_debug_sel_sb1 ;\n', '   logic                   ic_debug_sel_sb2 ;\n', '   logic                   ic_debug_sel_sb3 ;\n', '\n', '\n', '`ifdef RV_ICACHE_ECC\n', '   logic [3:0] [167:0]     bank_set_dout;\n', '   logic [3:0][167:0]      wb_dout ; //\n', '   logic [3:0][41:0]       ic_sb_wr_data;\n', '`else\n', '   logic [3:0] [135:0]     bank_set_dout;\n', '   logic [3:0] [135:0]     wb_dout ; // bank , way , size\n', '   logic [3:0] [33:0]      ic_sb_wr_data;\n', '`endif\n', '\n', '   logic                   ic_b_rden;\n', '   logic [3:0]             ic_debug_rd_way_en;   // debug wr_way\n', '   logic [3:0]             ic_debug_rd_way_en_ff;   // debug wr_way\n', '   logic [3:0]             ic_debug_wr_way_en;   // debug wr_way\n', '   logic [ICACHE_TAG_HIGH-1:4]  ic_rw_addr_q;\n', '\n', '   assign  ic_debug_rd_way_en[3:0] =  {4{ic_debug_rd_en & ~ic_debug_tag_array}} & ic_debug_way[3:0] ;\n', '   assign  ic_debug_wr_way_en[3:0] =  {4{ic_debug_wr_en & ~ic_debug_tag_array}} & ic_debug_way[3:0] ;\n', '\n', '   assign  ic_b_sb_wren[0][3:0]  = (ic_wr_en[3:0]           & {4{~ic_rw_addr[3]}} ) |\n', ""                                   (ic_debug_wr_way_en[3:0] & {4{ic_debug_addr[3:2] == 2'b00}}) ;\n"", '   assign  ic_b_sb_wren[1][3:0]  = (ic_wr_en[3:0]           & {4{~ic_rw_addr[3]}} ) |\n', ""                                   (ic_debug_wr_way_en[3:0] & {4{ic_debug_addr[3:2] == 2'b01}}) ;\n"", '   assign  ic_b_sb_wren[2][3:0]  = (ic_wr_en[3:0]           & {4{ic_rw_addr[3]}} ) |\n', ""                                   (ic_debug_wr_way_en[3:0] & {4{ic_debug_addr[3:2] == 2'b10}}) ;\n"", '   assign  ic_b_sb_wren[3][3:0]  = (ic_wr_en[3:0]           & {4{ic_rw_addr[3]}} ) |\n', ""                                   (ic_debug_wr_way_en[3:0] & {4{ic_debug_addr[3:2] == 2'b11}}) ;\n"", '\n', ""   assign  ic_debug_sel_sb0       =  (ic_debug_addr[3:2] == 2'b00 ) ;\n"", ""   assign  ic_debug_sel_sb1       =  (ic_debug_addr[3:2] == 2'b01 ) ;\n"", ""   assign  ic_debug_sel_sb2       =  (ic_debug_addr[3:2] == 2'b10 ) ;\n"", ""   assign  ic_debug_sel_sb3       =  (ic_debug_addr[3:2] == 2'b11 ) ;\n"", '\n', '`ifdef RV_ICACHE_ECC\n', '\n', '   assign  ic_sb_wr_data[0][41:0]   =  (ic_debug_sel_sb0 & ic_debug_wr_en) ? {ic_debug_wr_data[41:0]} :\n', '                                                                             ic_wr_data[41:0] ;\n', '   assign  ic_sb_wr_data[1][41:0]   =  (ic_debug_sel_sb1 & ic_debug_wr_en) ? {ic_debug_wr_data[41:0]} :\n', '                                                                             ic_wr_data[83:42] ;\n', '   assign  ic_sb_wr_data[2][41:0]   =  (ic_debug_sel_sb2 & ic_debug_wr_en) ? {ic_debug_wr_data[41:0]} :\n', '                                                                             ic_wr_data[41:0] ;\n', '   assign  ic_sb_wr_data[3][41:0]   =  (ic_debug_sel_sb3 & ic_debug_wr_en) ? {ic_debug_wr_data[41:0]} :\n', '                                                                             ic_wr_data[83:42] ;\n', '`else\n', '   assign  ic_sb_wr_data[0][33:0]   =  (ic_debug_sel_sb0 & ic_debug_wr_en) ? ic_debug_wr_data[33:0] :\n', '                                                                             ic_wr_data[33:0] ;\n', '   assign  ic_sb_wr_data[1][33:0]   =  (ic_debug_sel_sb1 & ic_debug_wr_en) ? ic_debug_wr_data[33:0] :\n', '                                                                             ic_wr_data[67:34] ;\n', '   assign  ic_sb_wr_data[2][33:0]   =  (ic_debug_sel_sb2 & ic_debug_wr_en) ? ic_debug_wr_data[33:0] :\n', '                                                                             ic_wr_data[33:0] ;\n', '   assign  ic_sb_wr_data[3][33:0]   =  (ic_debug_sel_sb3 & ic_debug_wr_en) ? ic_debug_wr_data[33:0] :\n', '                                                                             ic_wr_data[67:34] ;\n', '`endif\n', '\n', '\n', '// bank read enables\n', '\n', '   assign  ic_b_rden       = (ic_rd_en   | ic_debug_rd_en );\n', '\n', '   logic [3:0] ic_bank_read;\n', '   logic [3:0] ic_bank_read_ff;\n', '   assign ic_bank_read[0] = (ic_b_rden) & (~|ic_rw_addr[3:2] | ic_debug_rd_en);\n', '   assign ic_bank_read[1] = (ic_b_rden) & (~ic_rw_addr[3] | ic_debug_rd_en);\n', '   assign ic_bank_read[2] = (ic_b_rden) & (~&ic_rw_addr[3:2] | ic_debug_rd_en);\n', '   assign ic_bank_read[3] = (ic_b_rden) | ic_debug_rd_en;\n', '\n', '    assign ic_rw_addr_q[ICACHE_TAG_HIGH-1:4] = (ic_debug_rd_en | ic_debug_wr_en) ?\n', '                                                ic_debug_addr[ICACHE_TAG_HIGH-1:4] :\n', '                                                ic_rw_addr[ICACHE_TAG_HIGH-1:4] ;\n', '\n', '   logic ic_debug_rd_en_ff;\n', '\n', '   rvdff #(2) adr_ff (.*,\n', '                    .clk(free_clk),\n', '                    .din ({ic_rw_addr_q[5:4]}),\n', '                    .dout({ic_rw_addr_ff[5:4]}));\n', '\n', '   rvdff #(4) bank_adr_ff (.*,\n', '                    .clk(free_clk),\n', '                    .din (ic_bank_read[3:0]),\n', '                    .dout(ic_bank_read_ff[3:0]));\n', '\n', '   rvdff #(5) debug_rd_wy_ff (.*,\n', '                    .clk(free_clk),\n', '                    .din ({ic_debug_rd_way_en[3:0], ic_debug_rd_en}),\n', '                    .dout({ic_debug_rd_way_en_ff[3:0], ic_debug_rd_en_ff}));\n', '\n', 'localparam NUM_WAYS=4 ;\n', 'localparam NUM_SUBBANKS=4 ;\n', '\n', '\n', '     for (genvar i=0; i<NUM_WAYS; i++) begin: WAYS\n', '\n', '\n', '        for (genvar k=0; k<NUM_SUBBANKS; k++) begin: SUBBANKS   // 16B subbank\n', '\n', '           // way3-bank3, way3-bank2, ... way0-bank0\n', '           assign  ic_bank_way_clken[i][k]   = ic_bank_read[k] |  ic_b_sb_wren[k][i];\n', '\n', '           rvoclkhdr bank_way_bank_c1_cgc  ( .en(ic_bank_way_clken[i][k] | clk_override), .l1clk(ic_bank_way_clk[i][k]), .* );\n', '\n', '        `ifdef RV_ICACHE_ECC\n', '         `RV_ICACHE_DATA_CELL  ic_bank_sb_way_data (\n', '                                     .CLK(ic_bank_way_clk[i][k]),\n', '                                     .WE (ic_b_sb_wren[k][i]),\n', '                                     .D  (ic_sb_wr_data[k][41:0]),\n', '                                     .ADR(ic_rw_addr_q[ICACHE_TAG_HIGH-1:4]),\n', '                                     .Q  (wb_dout[i][(k+1)*42-1:k*42])\n', '                                    );\n', '        `else\n', '         `RV_ICACHE_DATA_CELL  ic_bank_sb_way_data (\n', '                                     .CLK(ic_bank_way_clk[i][k]),\n', '                                     .WE (ic_b_sb_wren[k][i]),\n', '                                     .D  (ic_sb_wr_data[k][33:0]),\n', '                                     .ADR(ic_rw_addr_q[ICACHE_TAG_HIGH-1:4]),\n', '                                     .Q  (wb_dout[i][(k+1)*34-1:k*34])\n', '                                    );\n', '        `endif\n', '        end // block: SUBBANKS\n', '\n', '      end\n', '\n', '\n', '   logic [3:0] ic_rd_hit_q;\n', '   assign ic_rd_hit_q[3:0] = ic_debug_rd_en_ff ? ic_debug_rd_way_en_ff[3:0] : ic_rd_hit[3:0] ;\n', '\n', '   // set mux\n', '`ifdef RV_ICACHE_ECC\n', '   logic [167:0] ic_premux_data_ext;\n', '   logic [3:0] [167:0] wb_dout_way;\n', '   logic [3:0] [167:0] wb_dout_way_with_premux;\n', '\n', ""   assign ic_premux_data_ext[167:0] =  {10'b0,ic_premux_data[127:96],10'b0,ic_premux_data[95:64] ,10'b0,ic_premux_data[63:32],10'b0,ic_premux_data[31:0]};\n"", '   assign wb_dout_way[0][167:0]       = wb_dout[0][167:0] & {  {42{ic_bank_read_ff[3]}} ,  {42{ic_bank_read_ff[2]}}  ,  {42{ic_bank_read_ff[1]}}  ,  {42{ic_bank_read_ff[0]}} };\n', '   assign wb_dout_way[1][167:0]       = wb_dout[1][167:0] & {  {42{ic_bank_read_ff[3]}} ,  {42{ic_bank_read_ff[2]}}  ,  {42{ic_bank_read_ff[1]}}  ,  {42{ic_bank_read_ff[0]}} };\n', '   assign wb_dout_way[2][167:0]       = wb_dout[2][167:0] & {  {42{ic_bank_read_ff[3]}} ,  {42{ic_bank_read_ff[2]}}  ,  {42{ic_bank_read_ff[1]}}  ,  {42{ic_bank_read_ff[0]}} };\n', '   assign wb_dout_way[3][167:0]       = wb_dout[3][167:0] & {  {42{ic_bank_read_ff[3]}} ,  {42{ic_bank_read_ff[2]}}  ,  {42{ic_bank_read_ff[1]}}  ,  {42{ic_bank_read_ff[0]}} };\n', '\n', '\n', '   assign wb_dout_way_with_premux[0][167:0]  =  ic_sel_premux_data ? ic_premux_data_ext[167:0] : wb_dout_way[0][167:0] ;\n', '   assign wb_dout_way_with_premux[1][167:0]  =  ic_sel_premux_data ? ic_premux_data_ext[167:0] : wb_dout_way[1][167:0] ;\n', '   assign wb_dout_way_with_premux[2][167:0]  =  ic_sel_premux_data ? ic_premux_data_ext[167:0] : wb_dout_way[2][167:0] ;\n', '   assign wb_dout_way_with_premux[3][167:0]  =  ic_sel_premux_data ? ic_premux_data_ext[167:0] : wb_dout_way[3][167:0] ;\n', '\n', '   assign ic_rd_data[167:0]       = ({168{ic_rd_hit_q[0] | ic_sel_premux_data}} &  wb_dout_way_with_premux[0][167:0]) |\n', '                                    ({168{ic_rd_hit_q[1] | ic_sel_premux_data}} &  wb_dout_way_with_premux[1][167:0]) |\n', '                                    ({168{ic_rd_hit_q[2] | ic_sel_premux_data}} &  wb_dout_way_with_premux[2][167:0]) |\n', '                                    ({168{ic_rd_hit_q[3] | ic_sel_premux_data}} &  wb_dout_way_with_premux[3][167:0]) ;\n', '\n', '`else\n', '   logic       [135:0] ic_premux_data_ext;\n', '   logic [3:0] [135:0] wb_dout_way;\n', '   logic [3:0] [135:0] wb_dout_way_with_premux;\n', '\n', ""   assign ic_premux_data_ext[135:0]   = {2'b0,ic_premux_data[127:96],2'b0,ic_premux_data[95:64] ,2'b0,ic_premux_data[63:32],2'b0,ic_premux_data[31:0]};\n"", '   assign wb_dout_way[0][135:0]       = wb_dout[0][135:0] &  {  {34{ic_bank_read_ff[3]}} ,  {34{ic_bank_read_ff[2]}}  ,  {34{ic_bank_read_ff[1]}}  ,  {34{ic_bank_read_ff[0]}} };\n', '   assign wb_dout_way[1][135:0]       = wb_dout[1][135:0] &  {  {34{ic_bank_read_ff[3]}} ,  {34{ic_bank_read_ff[2]}}  ,  {34{ic_bank_read_ff[1]}}  ,  {34{ic_bank_read_ff[0]}} };\n', '   assign wb_dout_way[2][135:0]       = wb_dout[2][135:0] &  {  {34{ic_bank_read_ff[3]}} ,  {34{ic_bank_read_ff[2]}}  ,  {34{ic_bank_read_ff[1]}}  ,  {34{ic_bank_read_ff[0]}} };\n', '   assign wb_dout_way[3][135:0]       = wb_dout[3][135:0] &  {  {34{ic_bank_read_ff[3]}} ,  {34{ic_bank_read_ff[2]}}  ,  {34{ic_bank_read_ff[1]}}  ,  {34{ic_bank_read_ff[0]}} };\n', '\n', '   assign wb_dout_way_with_premux[0][135:0]  =  ic_sel_premux_data ? ic_premux_data_ext[135:0] : wb_dout_way[0][135:0] ;\n', '   assign wb_dout_way_with_premux[1][135:0]  =  ic_sel_premux_data ? ic_premux_data_ext[135:0] : wb_dout_way[1][135:0] ;\n', '   assign wb_dout_way_with_premux[2][135:0]  =  ic_sel_premux_data ? ic_premux_data_ext[135:0] : wb_dout_way[2][135:0] ;\n', '   assign wb_dout_way_with_premux[3][135:0]  =  ic_sel_premux_data ? ic_premux_data_ext[135:0] : wb_dout_way[3][135:0] ;\n', '\n', '   assign ic_rd_data[135:0]       = ({136{ic_rd_hit_q[0] | ic_sel_premux_data}} &  wb_dout_way_with_premux[0][135:0]) |\n', '                                    ({136{ic_rd_hit_q[1] | ic_sel_premux_data}} &  wb_dout_way_with_premux[1][135:0]) |\n', '                                    ({136{ic_rd_hit_q[2] | ic_sel_premux_data}} &  wb_dout_way_with_premux[2][135:0]) |\n', '                                    ({136{ic_rd_hit_q[3] | ic_sel_premux_data}} &  wb_dout_way_with_premux[3][135:0]) ;\n', '\n', '`endif\n', '\n', ' endmodule\n', '\n', '\n', '/////////////////////////////////////////////////\n', '////// ICACHE TAG MODULE     ////////////////////\n', '/////////////////////////////////////////////////\n', 'module IC_TAG #(parameter ICACHE_TAG_HIGH = 16 ,\n', '                          ICACHE_TAG_LOW=6 ,\n', '                          ICACHE_TAG_DEPTH=1024\n', '                                        )\n', '     (\n', '      input logic free_clk,\n', '      input logic clk,\n', '      input logic rst_l,\n', '      input logic clk_override,\n', '      input logic dec_tlu_core_ecc_disable,\n', '\n', '      input logic [31:3]  ic_rw_addr,\n', '\n', '      input logic [3:0]   ic_wr_en,  // way\n', '      input logic [3:0]   ic_tag_valid,\n', '      input logic         ic_rd_en,\n', '\n', '      input logic [ICACHE_TAG_HIGH-1:2]  ic_debug_addr,      // Read/Write addresss to the Icache.\n', '      input logic                        ic_debug_rd_en,     // Icache debug rd\n', '      input logic                        ic_debug_wr_en,     // Icache debug wr\n', '      input logic                        ic_debug_tag_array, // Debug tag array\n', '      input logic [3:0]                  ic_debug_way,       // Debug way. Rd or Wr.\n', '\n', '\n', '\n', '\n', '`ifdef RV_ICACHE_ECC\n', '      output logic [24:0]  ictag_debug_rd_data,\n', '      input  logic [41:0]  ic_debug_wr_data,   // Debug wr cache.\n', '`else\n', '      output logic [20:0]  ictag_debug_rd_data,\n', '      input  logic [33:0]  ic_debug_wr_data,   // Debug wr cache.\n', '`endif\n', '      output logic [3:0]   ic_rd_hit,\n', '      output logic         ic_tag_perr,\n', '      input  logic         scan_mode\n', '\n', '      ) ;\n', '\n', '`ifdef RV_ICACHE_ECC\n', '   logic [3:0] [24:0] ic_tag_data_raw;\n', '   logic [3:0] [37:ICACHE_TAG_HIGH] w_tout;\n', '   logic [24:0] ic_tag_wr_data ;\n', '   logic [3:0] [31:0] ic_tag_corrected_data_unc;\n', '   logic [3:0] [06:0] ic_tag_corrected_ecc_unc;\n', '   logic [3:0]        ic_tag_single_ecc_error;\n', '   logic [3:0]        ic_tag_double_ecc_error;\n', '`else\n', '   logic [3:0] [20:0] ic_tag_data_raw;\n', '   logic [3:0] [32:ICACHE_TAG_HIGH] w_tout;\n', '   logic [20:0] ic_tag_wr_data ;\n', '`endif\n', '\n', '   logic [3:0]  ic_tag_way_perr ;\n', '   logic [3:0]  ic_debug_rd_way_en ;\n', '   logic [3:0]  ic_debug_rd_way_en_ff ;\n', '\n', '   logic [ICACHE_TAG_HIGH-1:6]  ic_rw_addr_q;\n', '   logic [31:4]         ic_rw_addr_ff;\n', '   logic [3:0]          ic_tag_wren   ; // way\n', '   logic [3:0]          ic_tag_wren_q   ; // way\n', '   logic [3:0]          ic_tag_clk ;\n', '   logic [3:0]          ic_tag_clken ;\n', '   logic [3:0]          ic_debug_wr_way_en;   // debug wr_way\n', '\n', ""   assign  ic_tag_wren [3:0]  = ic_wr_en[3:0] & {4{ic_rw_addr[5:3] == 3'b111}} ;\n"", '   assign  ic_tag_clken[3:0]  = {4{ic_rd_en | clk_override}} | ic_wr_en[3:0] | ic_debug_wr_way_en[3:0] | ic_debug_rd_way_en[3:0];\n', '\n', '   rvdff #(32-ICACHE_TAG_HIGH) adr_ff (.*,\n', '                    .clk(free_clk),\n', '                    .din ({ic_rw_addr[31:ICACHE_TAG_HIGH]}),\n', '                    .dout({ic_rw_addr_ff[31:ICACHE_TAG_HIGH]}));\n', '\n', '\n', '   localparam TOP_BITS = 21+ICACHE_TAG_HIGH-33 ;\n', '   localparam NUM_WAYS=4 ;\n', '   // tags\n', '\n', '\n', '\n', '   assign  ic_debug_rd_way_en[3:0] =  {4{ic_debug_rd_en & ic_debug_tag_array}} & ic_debug_way[3:0] ;\n', '   assign  ic_debug_wr_way_en[3:0] =  {4{ic_debug_wr_en & ic_debug_tag_array}} & ic_debug_way[3:0] ;\n', '\n', '   assign  ic_tag_wren_q[3:0]  =  ic_tag_wren[3:0]          |\n', '                                  ic_debug_wr_way_en[3:0]   ;\n', '\n', 'if (ICACHE_TAG_HIGH == 12) begin: SMALLEST\n', ' `ifdef RV_ICACHE_ECC\n', '     logic [6:0] ic_tag_ecc;\n', '           rvecc_encode  tag_ecc_encode (\n', ""                                  .din    ({{ICACHE_TAG_HIGH{1'b0}}, ic_rw_addr[31:ICACHE_TAG_HIGH]}),\n"", '                                  .ecc_out({ ic_tag_ecc[6:0]}));\n', '\n', '   assign  ic_tag_wr_data[24:0] = (ic_debug_wr_en & ic_debug_tag_array) ?\n', '                                  {ic_debug_wr_data[36:32], ic_debug_wr_data[31:12]} :\n', '                                  {ic_tag_ecc[4:0], ic_rw_addr[31:ICACHE_TAG_HIGH]} ;\n', ' `else\n', '   logic   ic_tag_parity ;\n', '           rveven_paritygen #(32-ICACHE_TAG_HIGH) pargen  (.data_in   (ic_rw_addr[31:ICACHE_TAG_HIGH]),\n', '                                                 .parity_out(ic_tag_parity));\n', '\n', '   assign  ic_tag_wr_data[20:0] = (ic_debug_wr_en & ic_debug_tag_array) ?\n', '                                  {ic_debug_wr_data[32], ic_debug_wr_data[31:12]} :\n', '                                  {ic_tag_parity, ic_rw_addr[31:ICACHE_TAG_HIGH]} ;\n', ' `endif\n', 'end else begin: OTHERS\n', ' `ifdef RV_ICACHE_ECC\n', '   logic [6:0] ic_tag_ecc;\n', '           rvecc_encode  tag_ecc_encode (\n', ""                                  .din    ({{ICACHE_TAG_HIGH{1'b0}}, ic_rw_addr[31:ICACHE_TAG_HIGH]}),\n"", '                                  .ecc_out({ ic_tag_ecc[6:0]}));\n', '\n', '   assign  ic_tag_wr_data[24:0] = (ic_debug_wr_en & ic_debug_tag_array) ?\n', '                                  {ic_debug_wr_data[36:32], ic_debug_wr_data[31:12]} :\n', ""                                  {ic_tag_ecc[4:0], {TOP_BITS{1'b0}},ic_rw_addr[31:ICACHE_TAG_HIGH]} ;\n"", '\n', ' `else\n', '   logic   ic_tag_parity ;\n', '           rveven_paritygen #(32-ICACHE_TAG_HIGH) pargen  (.data_in   (ic_rw_addr[31:ICACHE_TAG_HIGH]),\n', '                                                 .parity_out(ic_tag_parity));\n', '   assign  ic_tag_wr_data[20:0] = (ic_debug_wr_en & ic_debug_tag_array) ?\n', '                                  {ic_debug_wr_data[32], ic_debug_wr_data[31:12]} :\n', ""                                  {ic_tag_parity, {TOP_BITS{1'b0}},ic_rw_addr[31:ICACHE_TAG_HIGH]} ;\n"", ' `endif\n', 'end\n', '\n', '    assign ic_rw_addr_q[ICACHE_TAG_HIGH-1:6] = (ic_debug_rd_en | ic_debug_wr_en) ?\n', '                                                ic_debug_addr[ICACHE_TAG_HIGH-1:6] :\n', '                                                ic_rw_addr[ICACHE_TAG_HIGH-1:6] ;\n', '\n', '\n', '   rvdff #(4) tag_rd_wy_ff (.*,\n', '                    .clk(free_clk),\n', '                    .din ({ic_debug_rd_way_en[3:0]}),\n', '                    .dout({ic_debug_rd_way_en_ff[3:0]}));\n', '\n', '\n', '\n', '\n', '   for (genvar i=0; i<NUM_WAYS; i++) begin: WAYS\n', '\n', '      rvoclkhdr ic_tag_c1_cgc  ( .en(ic_tag_clken[i]), .l1clk(ic_tag_clk[i]), .* );\n', '\n', '     if (ICACHE_TAG_DEPTH == 64 ) begin : ICACHE_SZ_16\n', '      `ifdef RV_ICACHE_ECC\n', '         ram_64x25  ic_way_tag (\n', '                                     .CLK(ic_tag_clk[i]),\n', '                                     .WE (ic_tag_wren_q[i]),\n', '                                     .D  (ic_tag_wr_data[24:0]),\n', '                                     .ADR(ic_rw_addr_q[ICACHE_TAG_HIGH-1:ICACHE_TAG_LOW]),\n', '                                     .Q  (ic_tag_data_raw[i][24:0])\n', '                                    );\n', '\n', '\n', '         assign w_tout[i][31:ICACHE_TAG_HIGH] = ic_tag_data_raw[i][31-ICACHE_TAG_HIGH:0] ;\n', '         assign w_tout[i][36:32]              = ic_tag_data_raw[i][24:20] ;\n', '\n', '         rvecc_decode  ecc_decode (\n', '                           .en(~dec_tlu_core_ecc_disable),\n', ""                           .sed_ded ( 1'b1 ),    // 1 : means only detection\n"", ""                           .din({12'b0,ic_tag_data_raw[i][19:0]}),\n"", ""                           .ecc_in({2'b0, ic_tag_data_raw[i][24:20]}),\n"", '                           .dout(ic_tag_corrected_data_unc[i][31:0]),\n', '                           .ecc_out(ic_tag_corrected_ecc_unc[i][6:0]),\n', '                           .single_ecc_error(ic_tag_single_ecc_error[i]),\n', '                           .double_ecc_error(ic_tag_double_ecc_error[i]));\n', '\n', '          assign ic_tag_way_perr[i]= ic_tag_single_ecc_error[i] | ic_tag_double_ecc_error[i]  ;\n', '      `else\n', '         ram_64x21  ic_way_tag (\n', '                                     .CLK(ic_tag_clk[i]),\n', '                                     .WE (ic_tag_wren_q[i]),\n', '                                     .D  (ic_tag_wr_data[20:0]),\n', '                                     .ADR(ic_rw_addr_q[ICACHE_TAG_HIGH-1:ICACHE_TAG_LOW]),\n', '                                     .Q  (ic_tag_data_raw[i][20:0])\n', '                                    );\n', '\n', '         assign w_tout[i][31:ICACHE_TAG_HIGH] = ic_tag_data_raw[i][31-ICACHE_TAG_HIGH:0] ;\n', '         assign w_tout[i][32]                 = ic_tag_data_raw[i][20] ;\n', '\n', '         rveven_paritycheck #(32-ICACHE_TAG_HIGH) parcheck(.data_in   (w_tout[i][31:ICACHE_TAG_HIGH]),\n', '                                                   .parity_in (w_tout[i][32]),\n', '                                                   .parity_err(ic_tag_way_perr[i]));\n', '      `endif\n', '\n', '   end // block: ICACHE_SZ_16\n', '\n', '   else begin : tag_not_64\n', '    `ifdef RV_ICACHE_ECC\n', '     `RV_ICACHE_TAG_CELL  ic_way_tag (\n', '                                     .CLK(ic_tag_clk[i]),\n', '                                     .WE (ic_tag_wren_q[i]),\n', '                                     .D  (ic_tag_wr_data[24:0]),\n', '                                     .ADR(ic_rw_addr_q[ICACHE_TAG_HIGH-1:ICACHE_TAG_LOW]),\n', '                                     .Q  (ic_tag_data_raw[i][24:0])\n', '                                    );\n', '\n', '         assign w_tout[i][31:ICACHE_TAG_HIGH] = ic_tag_data_raw[i][31-ICACHE_TAG_HIGH:0] ;\n', '         assign w_tout[i][36:32]              = ic_tag_data_raw[i][24:20] ;\n', '\n', '         rvecc_decode  ecc_decode (\n', '                           .en(~dec_tlu_core_ecc_disable),\n', ""                           .sed_ded ( 1'b1 ), // 1 : if only need detection\n"", ""                           .din({12'b0,ic_tag_data_raw[i][19:0]}),\n"", ""                           .ecc_in({2'b0, ic_tag_data_raw[i][24:20]}),\n"", '                           .dout(ic_tag_corrected_data_unc[i][31:0]),\n', '                           .ecc_out(ic_tag_corrected_ecc_unc[i][6:0]),\n', '                           .single_ecc_error(ic_tag_single_ecc_error[i]),\n', '                           .double_ecc_error(ic_tag_double_ecc_error[i]));\n', '\n', '          assign ic_tag_way_perr[i]= ic_tag_single_ecc_error[i] | ic_tag_double_ecc_error[i]  ;\n', '\n', '     `else\n', '        `RV_ICACHE_TAG_CELL  ic_way_tag (\n', '                                     .CLK(ic_tag_clk[i]),\n', '                                     .WE (ic_tag_wren_q[i]),\n', '                                     .D  (ic_tag_wr_data[20:0]),\n', '                                     .ADR(ic_rw_addr_q[ICACHE_TAG_HIGH-1:ICACHE_TAG_LOW]),\n', '                                     .Q  ({ic_tag_data_raw[i][20:0]})\n', '                                    );\n', '\n', '         assign w_tout[i][31:ICACHE_TAG_HIGH] = ic_tag_data_raw[i][31-ICACHE_TAG_HIGH:0] ;\n', '         assign w_tout[i][32]                 = ic_tag_data_raw[i][20] ;\n', '\n', '       rveven_paritycheck #(32-ICACHE_TAG_HIGH) parcheck(.data_in   (w_tout[i][31:ICACHE_TAG_HIGH]),\n', '                                                   .parity_in (w_tout[i][32]),\n', '                                                   .parity_err(ic_tag_way_perr[i]));\n', '\n', '      `endif\n', '   end // block: tag_not_64\n', 'end // block: WAYS\n', '\n', '\n', '`ifdef RV_ICACHE_ECC\n', '   assign ictag_debug_rd_data[24:0] =  ({25{ic_debug_rd_way_en_ff[0]}} &  ic_tag_data_raw[0] ) |\n', '                                       ({25{ic_debug_rd_way_en_ff[1]}} &  ic_tag_data_raw[1] ) |\n', '                                       ({25{ic_debug_rd_way_en_ff[2]}} &  ic_tag_data_raw[2] ) |\n', '                                       ({25{ic_debug_rd_way_en_ff[3]}} &  ic_tag_data_raw[3] ) ;\n', '\n', '`else\n', '   assign ictag_debug_rd_data[20:0] =  ({21{ic_debug_rd_way_en_ff[0]}} &  ic_tag_data_raw[0] ) |\n', '                                       ({21{ic_debug_rd_way_en_ff[1]}} &  ic_tag_data_raw[1] ) |\n', '                                       ({21{ic_debug_rd_way_en_ff[2]}} &  ic_tag_data_raw[2] ) |\n', '                                       ({21{ic_debug_rd_way_en_ff[3]}} &  ic_tag_data_raw[3] ) ;\n', '\n', '`endif\n', '   assign ic_rd_hit[0] = (w_tout[0][31:ICACHE_TAG_HIGH] == ic_rw_addr_ff[31:ICACHE_TAG_HIGH]) & ic_tag_valid[0];\n', '   assign ic_rd_hit[1] = (w_tout[1][31:ICACHE_TAG_HIGH] == ic_rw_addr_ff[31:ICACHE_TAG_HIGH]) & ic_tag_valid[1];\n', '   assign ic_rd_hit[2] = (w_tout[2][31:ICACHE_TAG_HIGH] == ic_rw_addr_ff[31:ICACHE_TAG_HIGH]) & ic_tag_valid[2];\n', '   assign ic_rd_hit[3] = (w_tout[3][31:ICACHE_TAG_HIGH] == ic_rw_addr_ff[31:ICACHE_TAG_HIGH]) & ic_tag_valid[3];\n', '\n', '   assign  ic_tag_perr  = | (ic_tag_way_perr[3:0] & ic_tag_valid[3:0] ) ;\n', 'endmodule\n', '\n', '\n', '\n']"
"['// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '\n', '//********************************************************************************\n', '// ifu_ifc_ctl.sv\n', '// Function: Fetch pipe control\n', '//\n', '// Comments:\n', '//********************************************************************************\n', '\n', 'module ifu_ifc_ctl\n', '  (\n', '   input logic clk,\n', '   input logic free_clk,\n', '   input logic active_clk,\n', '\n', '   input logic clk_override, // overrides clock gating\n', '   input logic rst_l, // reset enable, from core pin\n', '   input logic scan_mode, // scan\n', '\n', '   input logic ic_hit_f2,      // Icache hit\n', '   input logic ic_crit_wd_rdy, // Crit word ready to be forwarded\n', '   input logic ifu_ic_mb_empty, // Miss buffer empty\n', '\n', '   input logic ifu_fb_consume1,  // Aligner consumed 1 fetch buffer\n', '   input logic ifu_fb_consume2,  // Aligner consumed 2 fetch buffers\n', '\n', ""   input logic dec_tlu_flush_noredir_wb, // Don't fetch on flush\n"", '   input logic dec_tlu_dbg_halted, // Core is halted\n', '   input logic dec_tlu_pmu_fw_halted, // Core is halted\n', '   input logic exu_flush_final, // FLush\n', '   input logic [31:1] exu_flush_path_final, // Flush path\n', '\n', '   input logic ifu_bp_kill_next_f2, // kill next fetch, taken target found\n', '   input logic [31:1] ifu_bp_btb_target_f2, //  predicted target PC\n', '\n', '   input logic ic_dma_active, // IC DMA active, stop fetching\n', '   input logic ic_write_stall, // IC is writing, stop fetching\n', '   input logic dma_iccm_stall_any, // force a stall in the fetch pipe for DMA ICCM access\n', '\n', '   input logic [31:0]  dec_tlu_mrac_ff ,   // side_effect and cacheable for each region\n', '\n', '   output logic  ifc_fetch_uncacheable_f1, // fetch to uncacheable address as determined by MRAC\n', '\n', '   output logic [31:1] ifc_fetch_addr_f1, // fetch addr F1\n', '   output logic [31:1] ifc_fetch_addr_f2,  // fetch addr F2\n', '\n', '   output logic  ifc_fetch_req_f1,  // fetch request valid F1\n', '   output logic  ifc_fetch_req_f1_raw, // for clock-gating in mem_ctl\n', '   output logic  ifc_fetch_req_f2,  // fetch request valid F2\n', '\n', '   output logic  ifu_pmu_fetch_stall, // pmu event measuring fetch stall\n', '\n', '   output logic  ifc_iccm_access_f1, // fetch to ICCM region\n', '   output logic  ifc_region_acc_fault_f1, // fetch access fault\n', '   output logic  ifc_dma_access_ok // fetch is not accessing the ICCM, DMA can proceed\n', '\n', '   );\n', '\n', '\n', '   logic [31:1]  fetch_addr_bf,  miss_addr, ifc_fetch_addr_f1_raw;\n', '   logic [31:1]  fetch_addr_next;\n', '   logic [31:1]  miss_addr_ns;\n', '   logic [4:0]   cacheable_select;\n', '   logic [3:0]   fb_write_f1, fb_write_ns;\n', '\n', '   logic         ifc_fetch_req_bf;\n', '   logic         overflow_nc;\n', '   logic         fb_full_f1_ns, fb_full_f1;\n', '   logic         fb_right, fb_right2, fb_right3, fb_left, wfm, fetch_ns, idle;\n', '   logic         fetch_req_f2_ns;\n', '   logic         missff_en;\n', '   logic         fetch_crit_word, ic_crit_wd_rdy_d1, fetch_crit_word_d1, fetch_crit_word_d2;\n', '   logic         reset_delayed, reset_detect, reset_detected;\n', '   logic         sel_last_addr_bf, sel_miss_addr_bf, sel_btb_addr_bf, sel_next_addr_bf;\n', '   logic         miss_f2, miss_a;\n', '   logic         flush_fb, dma_iccm_stall_any_f;\n', '   logic         dec_tlu_halted_f;\n', '   logic         mb_empty_mod, goto_idle, leave_idle;\n', '   logic         ic_crit_wd_rdy_mod;\n', '   logic         miss_sel_flush;\n', '   logic         miss_sel_f2;\n', '   logic         miss_sel_f1;\n', '   logic         miss_sel_bf;\n', '   logic         fetch_bf_en;\n', '   logic         ifc_fetch_req_f2_raw;\n', '\n', '   logic ifc_f2_clk;\n', '   rvoclkhdr ifu_fa2_cgc ( .en(ifc_fetch_req_f1 | clk_override), .l1clk(ifc_f2_clk), .* );\n', '\n', '   // FSM assignment\n', ""   typedef enum  logic [1:0] { IDLE=2'b00, FETCH=2'b01, STALL=2'b10, WFM=2'b11} state_t;\n"", '   state_t state, next_state;\n', '\n', '   logic dma_stall;\n', '   assign dma_stall = ic_dma_active | dma_iccm_stall_any_f;\n', '\n', '   // detect a reset and start fetching the reset vector\n', ""   rvdff #(2) reset_ff (.*, .clk(free_clk), .din({1'b1, reset_detect}), .dout({reset_detect, reset_detected}));\n"", '\n', '   assign reset_delayed = reset_detect ^ reset_detected;\n', '\n', '   rvdff #(3) ran_ff (.*, .clk(free_clk), .din({dma_iccm_stall_any, dec_tlu_dbg_halted | dec_tlu_pmu_fw_halted, miss_f2}), .dout({dma_iccm_stall_any_f, dec_tlu_halted_f, miss_a}));\n', '\n', '   // If crit word fetch is blocked, try again\n', '   assign ic_crit_wd_rdy_mod = ic_crit_wd_rdy & ~(fetch_crit_word_d2 & ~ifc_fetch_req_f2);\n', '\n', '   // For Ifills, we fetch the critical word. Needed for perf and for rom bypass\n', '   assign fetch_crit_word = ic_crit_wd_rdy_mod & ~ic_crit_wd_rdy_d1 & ~exu_flush_final & ~ic_write_stall;\n', '\n', '   assign missff_en = exu_flush_final | (~ic_hit_f2 & ifc_fetch_req_f2) | ifu_bp_kill_next_f2 | fetch_crit_word_d1 | ifu_bp_kill_next_f2 | (ifc_fetch_req_f2 & ~ifc_fetch_req_f1 & ~fetch_crit_word_d2);\n', '   assign miss_sel_flush = exu_flush_final & (((wfm | idle) & ~fetch_crit_word_d1)  | dma_stall | ic_write_stall);\n', '   assign miss_sel_f2 = ~exu_flush_final & ~ic_hit_f2 & ifc_fetch_req_f2;\n', '   assign miss_sel_f1 = ~exu_flush_final & ~miss_sel_f2 & ~ifc_fetch_req_f1 & ifc_fetch_req_f2 & ~fetch_crit_word_d2 & ~ifu_bp_kill_next_f2;\n', '   assign miss_sel_bf = ~miss_sel_f2 & ~miss_sel_f1 & ~miss_sel_flush;\n', '\n', '   assign miss_addr_ns[31:1] = ( ({31{miss_sel_flush}} & exu_flush_path_final[31:1]) |\n', '                                 ({31{miss_sel_f2}} & ifc_fetch_addr_f2[31:1]) |\n', '                                 ({31{miss_sel_f1}} & ifc_fetch_addr_f1[31:1]) |\n', '                                 ({31{miss_sel_bf}} & fetch_addr_bf[31:1]));\n', '\n', '\n', '\n', '   rvdffe #(31) faddmiss_ff (.*, .en(missff_en), .din(miss_addr_ns[31:1]), .dout(miss_addr[31:1]));\n', '\n', '\n', '   // Fetch address mux\n', '   // - flush\n', '   // - Miss *or* flush during WFM (icache miss buffer is blocking)\n', '   // - Sequential\n', '\n', '   assign sel_last_addr_bf = ~miss_sel_flush & ~ifc_fetch_req_f1 & ifc_fetch_req_f2 & ~ifu_bp_kill_next_f2;\n', '   assign sel_miss_addr_bf = ~miss_sel_flush & ~ifu_bp_kill_next_f2 & ~ifc_fetch_req_f1 & ~ifc_fetch_req_f2;\n', '   assign sel_btb_addr_bf  = ~miss_sel_flush & ifu_bp_kill_next_f2;\n', '   assign sel_next_addr_bf = ~miss_sel_flush & ifc_fetch_req_f1;\n', '\n', '\n', '   assign fetch_addr_bf[31:1] = ( ({31{miss_sel_flush}} &  exu_flush_path_final[31:1]) | // FLUSH path\n', '                                   ({31{sel_miss_addr_bf}} & miss_addr[31:1]) | // MISS path\n', '                                   ({31{sel_btb_addr_bf}} & {ifu_bp_btb_target_f2[31:1]})| // BTB target\n', '                                   ({31{sel_last_addr_bf}} & {ifc_fetch_addr_f1[31:1]})| // Last cycle\n', '                                   ({31{sel_next_addr_bf}} & {fetch_addr_next[31:1]})); // SEQ path\n', '\n', ""   assign {overflow_nc, fetch_addr_next[31:1]} = {({1'b0, ifc_fetch_addr_f1[31:4]} + 29'b1), 3'b0};\n"", '\n', '   assign ifc_fetch_req_bf = (fetch_ns | fetch_crit_word) ;\n', '   assign fetch_bf_en = (fetch_ns | fetch_crit_word);\n', '\n', '   assign miss_f2 = ifc_fetch_req_f2 & ~ic_hit_f2;\n', '\n', '   assign mb_empty_mod = (ifu_ic_mb_empty | exu_flush_final) & ~dma_stall & ~miss_f2 & ~miss_a;\n', '\n', '   // Halt flushes and takes us to IDLE\n', '   assign goto_idle = exu_flush_final & dec_tlu_flush_noredir_wb;\n', ""   // If we're in IDLE, and we get a flush, goto FETCH\n"", '   assign leave_idle = exu_flush_final & ~dec_tlu_flush_noredir_wb & idle;\n', '\n', '//.i 7\n', '//.o 2\n', '//.ilb state[1] state[0] reset_delayed miss_f2 mb_empty_mod  goto_idle leave_idle\n', '//.ob next_state[1] next_state[0]\n', '//.type fr\n', '//\n', '//# fetch 01, stall 10, wfm 11, idle 00\n', '//-- 1---- 01\n', '//-- 0--1- 00\n', '//00 0--00 00\n', '//00 0--01 01\n', '//\n', '//01 01-0- 11\n', '//01 00-0- 01\n', '//\n', '//11 0-10- 01\n', '//11 0-00- 11\n', '\n', '   assign next_state[1] = (~state[1] & state[0] & ~reset_delayed & miss_f2 & ~goto_idle) |\n', '                          (state[1] & ~reset_delayed & ~mb_empty_mod & ~goto_idle);\n', '\n', '   assign next_state[0] = (~goto_idle & leave_idle) | (state[0] & ~goto_idle) |\n', '                          (reset_delayed);\n', '\n', '   assign flush_fb = exu_flush_final;\n', '\n', '   // model fb write logic to mass balance the fetch buffers\n', '   assign fb_right = (~ifu_fb_consume1 & ~ifu_fb_consume2 & miss_f2) |  // F2 cache miss, repair mass balance\n', '                     ( ifu_fb_consume1 & ~ifu_fb_consume2 & ~ifc_fetch_req_f1 & ~miss_f2) | // Consumed and no new fetch\n', '                      (ifu_fb_consume2 &  ifc_fetch_req_f1 & ~miss_f2); // Consumed 2 and new fetch\n', '\n', '\n', '   assign fb_right2 = (ifu_fb_consume1 & ~ifu_fb_consume2 & miss_f2) | // consume 1 and miss 1\n', '                      (ifu_fb_consume2 & ~ifc_fetch_req_f1); // Consumed 2 and no new fetch\n', '\n', '   assign fb_right3 = (ifu_fb_consume2 & miss_f2); // consume 2 and miss\n', '\n', '   assign fb_left = ifc_fetch_req_f1 & ~(ifu_fb_consume1 | ifu_fb_consume2) & ~miss_f2;\n', '\n', ""   assign fb_write_ns[3:0] = ( ({4{(flush_fb & ~ifc_fetch_req_f1)}} & 4'b0001) |\n"", ""                               ({4{(flush_fb & ifc_fetch_req_f1)}} & 4'b0010) |\n"", ""                               ({4{~flush_fb & fb_right }} & {1'b0, fb_write_f1[3:1]}) |\n"", ""                               ({4{~flush_fb & fb_right2}} & {2'b0, fb_write_f1[3:2]}) |\n"", ""                               ({4{~flush_fb & fb_right3}} & {3'b0, fb_write_f1[3]}  ) |\n"", ""                               ({4{~flush_fb & fb_left  }} & {fb_write_f1[2:0], 1'b0}) |\n"", '                               ({4{~flush_fb & ~fb_right & ~fb_right2 & ~fb_left & ~fb_right3}}  & fb_write_f1[3:0]));\n', '\n', '\n', '   assign fb_full_f1_ns = fb_write_ns[3];\n', '\n', '   assign idle = state[1:0] == IDLE;\n', '   assign wfm = state[1:0] == WFM;\n', '   assign fetch_ns = next_state[1:0] == FETCH;\n', '\n', '   rvdff #(2) fsm_ff (.*, .clk(active_clk), .din({next_state[1:0]}), .dout({state[1:0]}));\n', '   rvdff #(5) fbwrite_ff (.*, .clk(active_clk), .din({fb_full_f1_ns, fb_write_ns[3:0]}), .dout({fb_full_f1, fb_write_f1[3:0]}));\n', '\n', '   assign ifu_pmu_fetch_stall = wfm |\n', '                                (ifc_fetch_req_f1_raw &\n', '                                ( (fb_full_f1 & ~(ifu_fb_consume2 | ifu_fb_consume1 | exu_flush_final)) |\n', '                                  dma_stall));\n', '   // BTB hit kills this fetch\n', '   assign ifc_fetch_req_f1 = ( ifc_fetch_req_f1_raw &\n', '                               ~ifu_bp_kill_next_f2 &\n', '                               ~(fb_full_f1 & ~(ifu_fb_consume2 | ifu_fb_consume1 | exu_flush_final)) &\n', '                               ~dma_stall &\n', '                               ~ic_write_stall &\n', '                               ~dec_tlu_flush_noredir_wb );\n', '\n', '   // kill F2 request if we flush or if the prior fetch missed the cache/mem\n', '   assign fetch_req_f2_ns = ifc_fetch_req_f1 & ~miss_f2;\n', '\n', '   rvdff #(2) req_ff (.*, .clk(active_clk), .din({ifc_fetch_req_bf, fetch_req_f2_ns}), .dout({ifc_fetch_req_f1_raw, ifc_fetch_req_f2_raw}));\n', '\n', '   assign ifc_fetch_req_f2 = ifc_fetch_req_f2_raw & ~exu_flush_final;\n', '\n', '   rvdffe #(31) faddrf1_ff  (.*, .en(fetch_bf_en), .din(fetch_addr_bf[31:1]), .dout(ifc_fetch_addr_f1_raw[31:1]));\n', '   rvdff #(31) faddrf2_ff (.*,  .clk(ifc_f2_clk), .din(ifc_fetch_addr_f1[31:1]), .dout(ifc_fetch_addr_f2[31:1]));\n', '\n', '   assign ifc_fetch_addr_f1[31:1] = ( ({31{exu_flush_final}} & exu_flush_path_final[31:1]) |\n', '                                      ({31{~exu_flush_final}} & ifc_fetch_addr_f1_raw[31:1]));\n', '\n', '   rvdff #(3) iccrit_ff (.*, .clk(active_clk), .din({ic_crit_wd_rdy_mod, fetch_crit_word,    fetch_crit_word_d1}),\n', '                                              .dout({ic_crit_wd_rdy_d1,  fetch_crit_word_d1, fetch_crit_word_d2}));\n', '\n', '`ifdef RV_ICCM_ENABLE\n', '   logic iccm_acc_in_region_f1;\n', '   logic iccm_acc_in_range_f1;\n', '   rvrangecheck #( .CCM_SADR    (`RV_ICCM_SADR),\n', '                   .CCM_SIZE    (`RV_ICCM_SIZE) ) iccm_rangecheck (\n', ""                                                                     .addr     ({ifc_fetch_addr_f1[31:1],1'b0}) ,\n"", '                                                                     .in_range (iccm_acc_in_range_f1) ,\n', '                                                                     .in_region(iccm_acc_in_region_f1)\n', '                                                                     );\n', '\n', '   assign ifc_iccm_access_f1 = iccm_acc_in_range_f1 ;\n', '\n', '   assign ifc_dma_access_ok = ( (~ifc_iccm_access_f1 |\n', '                                 (fb_full_f1 & ~(ifu_fb_consume2 | ifu_fb_consume1)) |\n', '                                 wfm |\n', '                                 idle ) & ~exu_flush_final) |\n', '                              dma_iccm_stall_any_f;\n', '\n', '   assign ifc_region_acc_fault_f1 = ~iccm_acc_in_range_f1 & iccm_acc_in_region_f1 ;\n', ' `else\n', ""   assign ifc_iccm_access_f1 = 1'b0 ;\n"", ""   assign ifc_dma_access_ok  = 1'b0 ;\n"", ""   assign ifc_region_acc_fault_f1  = 1'b0 ;\n"", ' `endif\n', '\n', ""   assign cacheable_select[4:0]    =  {ifc_fetch_addr_f1[31:28] , 1'b0 } ;\n"", '   assign ifc_fetch_uncacheable_f1 =  ~dec_tlu_mrac_ff[cacheable_select]  ; // bit 0 of each region description is the cacheable bit\n', '\n', 'endmodule // ifu_ifc_ctl\n', '\n']"
"['//********************************************************************************\n', '// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '//********************************************************************************\n', '\n', '\n', '//********************************************************************************\n', '// Function: Icache , iccm  control\n', '// BFF -> F1 -> F2 -> A\n', '//********************************************************************************\n', '\n', 'module ifu_mem_ctl\n', '   import veer_types::*;\n', '(\n', '   input logic clk,\n', '   input logic free_clk,                                            // free clock always except during pause\n', '   input logic active_clk,                                          // Active always except during pause\n', '   input logic rst_l,\n', '\n', '   input logic                       exu_flush_final,               // Flush from the pipeline.\n', '   input logic                       dec_tlu_flush_err_wb,          // Flush from the pipeline due to perr.\n', '\n', '   input logic [31:1]                fetch_addr_f1,                 // Fetch Address byte aligned always.      F1 stage.\n', '   input logic                       ifc_fetch_uncacheable_f1,      // The fetch request is uncacheable space. F1 stage\n', '   input logic                       ifc_fetch_req_f1,              // Fetch request. Comes with the address.  F1 stage\n', '   input logic                       ifc_fetch_req_f1_raw,          // Fetch request without some qualifications. Used for clock-gating. F1 stage\n', '   input logic                       ifc_iccm_access_f1,            // This request is to the ICCM. Do not generate misses to the bus.\n', '   input logic                       ifc_region_acc_fault_f1,       // Access fault. in ICCM region but offset is outside defined ICCM.\n', '   input logic                       ifc_dma_access_ok,             // It is OK to give dma access to the ICCM. (ICCM is not busy this cycle).\n', '   input logic                       dec_tlu_fence_i_wb,            // Fence.i instruction is committing. Clear all Icache valids.\n', '\n', '\n', '   input logic [16:6]                ifu_icache_error_index,        //  Index with parity/ecc error\n', '   input logic                       ifu_icache_error_val,          //  Parity/Ecc  error\n', '   input logic                       ifu_icache_sb_error_val,       //  single bit iccm  error\n', '   input logic [7:1]                 ifu_bp_inst_mask_f2,           // tell ic which valids to kill because of a taken branch, right justified\n', '\n', '   output logic                      ifu_miss_state_idle,           // No icache misses are outstanding.\n', '   output logic                      ifu_ic_mb_empty,               // Continue with normal fetching. This does not mean that miss is finished.\n', '   output logic                      ic_dma_active  ,               // In the middle of servicing dma request to ICCM. Do not make any new requests.\n', '   output logic                      ic_write_stall,                // Stall fetch the cycle we are writing the cache.\n', '\n', '/// PMU signals\n', '   output logic                      ifu_pmu_ic_miss,               // IC miss event\n', '   output logic                      ifu_pmu_ic_hit,                // IC hit event\n', '   output logic                      ifu_pmu_bus_error,             // Bus error event\n', '   output logic                      ifu_pmu_bus_busy,              // Bus busy event\n', '   output logic                      ifu_pmu_bus_trxn,              // Bus transaction\n', '\n', '   // AXI Write Channels - IFU never writes. So, 0 out mostly\n', '   output logic                           ifu_axi_awvalid,\n', '   input  logic                           ifu_axi_awready,\n', '   output logic [`RV_IFU_BUS_TAG-1:0]     ifu_axi_awid,\n', '   output logic [31:0]                    ifu_axi_awaddr,\n', '   output logic [3:0]                     ifu_axi_awregion,\n', '   output logic [7:0]                     ifu_axi_awlen,\n', '   output logic [2:0]                     ifu_axi_awsize,\n', '   output logic [1:0]                     ifu_axi_awburst,\n', '   output logic                           ifu_axi_awlock,\n', '   output logic [3:0]                     ifu_axi_awcache,\n', '   output logic [2:0]                     ifu_axi_awprot,\n', '   output logic [3:0]                     ifu_axi_awqos,\n', '\n', '   output logic                           ifu_axi_wvalid,\n', '   input  logic                           ifu_axi_wready,\n', '   output logic [63:0]                    ifu_axi_wdata,\n', '   output logic [7:0]                     ifu_axi_wstrb,\n', '   output logic                           ifu_axi_wlast,\n', '\n', '   input  logic                           ifu_axi_bvalid,\n', '   output logic                           ifu_axi_bready,\n', '   input  logic [1:0]                     ifu_axi_bresp,\n', '   input  logic [`RV_IFU_BUS_TAG-1:0]     ifu_axi_bid,\n', '\n', '   // AXI Read Channels\n', '   output logic                           ifu_axi_arvalid,\n', '   input  logic                           ifu_axi_arready,\n', '   output logic [`RV_IFU_BUS_TAG-1:0]     ifu_axi_arid,\n', '   output logic [31:0]                    ifu_axi_araddr,\n', '   output logic [3:0]                     ifu_axi_arregion,\n', '   output logic [7:0]                     ifu_axi_arlen,\n', '   output logic [2:0]                     ifu_axi_arsize,\n', '   output logic [1:0]                     ifu_axi_arburst,\n', '   output logic                           ifu_axi_arlock,\n', '   output logic [3:0]                     ifu_axi_arcache,\n', '   output logic [2:0]                     ifu_axi_arprot,\n', '   output logic [3:0]                     ifu_axi_arqos,\n', '\n', '   input  logic                           ifu_axi_rvalid,\n', '   output logic                           ifu_axi_rready,\n', '   input  logic [`RV_IFU_BUS_TAG-1:0]     ifu_axi_rid,\n', '   input  logic [63:0]                    ifu_axi_rdata,\n', '   input  logic [1:0]                     ifu_axi_rresp,\n', '   input  logic                           ifu_axi_rlast,\n', '\n', '    /// SCVI Bus interface\n', '    input  logic                     ifu_bus_clk_en,\n', '\n', '\n', '   input  logic                      dma_iccm_req,      //  dma iccm command (read or write)\n', '   input  logic [31:0]               dma_mem_addr,      //  dma address\n', '   input  logic [2:0]                dma_mem_sz,        //  size\n', '   input  logic                      dma_mem_write,     //  write\n', '   input  logic [63:0]               dma_mem_wdata,     //  write data\n', '\n', '   output logic                      iccm_dma_ecc_error,//   Data read from iccm has an ecc error\n', '   output logic                      iccm_dma_rvalid,   //   Data read from iccm is valid\n', '   output logic [63:0]               iccm_dma_rdata,    //   dma data read from iccm\n', '   output logic                      iccm_ready,        //   iccm ready to accept new command.\n', '\n', '\n', '//   I$ & ITAG Ports\n', '   output logic [31:2]               ic_rw_addr,         // Read/Write addresss to the Icache.\n', '   output logic [3:0]                ic_wr_en,           // Icache write enable, when filling the Icache.\n', '   output logic                      ic_rd_en,           // Icache read  enable.\n', '\n', '`ifdef RV_ICACHE_ECC\n', '   output logic [83:0]               ic_wr_data,         // Data to fill to the Icache. With ECC\n', '   input  logic [167:0]              ic_rd_data ,        // Data read from Icache. 2x64bits + parity bits. F2 stage. With ECC\n', '   input  logic [24:0]               ictag_debug_rd_data,// Debug icache tag.\n', '   output logic [41:0]               ic_debug_wr_data,   // Debug wr cache.\n', '   output logic [41:0]               ifu_ic_debug_rd_data,       // debug data read\n', '`else\n', '   output logic [67:0]               ic_wr_data,         // Data to fill to the Icache. With Parity\n', '   input  logic [135:0]              ic_rd_data ,        // Data read from Icache. 2x64bits + parity bits. F2 stage. With Parity\n', '   input  logic [20:0]               ictag_debug_rd_data,// Debug icache tag.\n', '   output logic [33:0]               ic_debug_wr_data,   // Debug wr cache.\n', '   output logic [33:0]               ifu_ic_debug_rd_data,       // debug data read\n', '`endif\n', '\n', '   output logic [15:2]               ic_debug_addr,      // Read/Write addresss to the Icache.\n', '   output logic                      ic_debug_rd_en,     // Icache debug rd\n', '   output logic                      ic_debug_wr_en,     // Icache debug wr\n', '   output logic                      ic_debug_tag_array, // Debug tag array\n', '   output logic [3:0]                ic_debug_way,       // Debug way. Rd or Wr.\n', '\n', '\n', '   output logic [3:0]                ic_tag_valid,       // Valid bits when accessing the Icache. One valid bit per way. F2 stage\n', '\n', '   input  logic [3:0]                ic_rd_hit,          // Compare hits from Icache tags. Per way.  F2 stage\n', '   input  logic                      ic_tag_perr,        // Icache Tag parity error\n', '\n', '`ifdef RV_ICCM_ENABLE\n', '   // ICCM ports\n', '   output logic [`RV_ICCM_BITS-1:2]  iccm_rw_addr,       // ICCM read/write address.\n', '   output logic                      iccm_wren,          // ICCM write enable (through the DMA)\n', '   output logic                      iccm_rden,          // ICCM read enable.\n', '   output logic [77:0]               iccm_wr_data,       // ICCM write data.\n', '   output logic [2:0]                iccm_wr_size,       // ICCM write location within DW.\n', '\n', '   input  logic [155:0]              iccm_rd_data,       // Data read from ICCM.\n', '`endif\n', '\n', '\n', '   // IFU control signals\n', '   output logic                      ic_hit_f2,              // Hit in Icache(if Icache access) or ICCM access( ICCM always has ic_hit_f2)\n', '   output logic                      ic_crit_wd_rdy,         // Critical fetch is ready to be bypassed.\n', '   output logic  [7:0]               ic_access_fault_f2,     // Access fault (bus error or ICCM access in region but out of offset range).\n', '   output logic                      ic_rd_parity_final_err, // This fetch has an tag parity error.\n', '   output logic                      iccm_rd_ecc_single_err, // This fetch has a single ICCM ecc  error.\n', '   output logic  [7:0]               iccm_rd_ecc_double_err, // This fetch has a double ICCM ecc  error.\n', '   output logic                      iccm_dma_sb_error,      // Single Bit ECC error from a DMA access\n', '   output logic [7:0]                ic_fetch_val_f2,        // valid bytes for fetch. To the Aligner.\n', '   output logic [127:0]              ic_data_f2,             // Data read from Icache or ICCM. To the Aligner.\n', '   output icache_err_pkt_t           ic_error_f2 ,           // Parity or ECC bits for the Icache Data\n', '   output logic                      ifu_icache_fetch_f2  ,\n', '   output logic [127:0]              ic_premux_data,         // Premuxed data to be muxed with Icache data\n', '   output logic                      ic_sel_premux_data,     // Select premux data.\n', '\n', '/////  Debug\n', '   input  cache_debug_pkt_t          dec_tlu_ic_diag_pkt ,       // Icache/tag debug read/write packet\n', '   input  logic                      dec_tlu_core_ecc_disable,   // disable the ecc checking and flagging\n', '   output logic                      ifu_ic_debug_rd_data_valid, // debug data valid.\n', '\n', '\n', '   input  logic         scan_mode\n', '   );\n', '\n', '`include ""global.h""\n', '\n', '//  Create different defines for ICACHE and ICCM enable combinations\n', '`ifdef RV_ICCM_ENABLE\n', '     `ifdef RV_ICACHE_ENABLE\n', '        `define ICCM_AND_ICACHE\n', '      `else\n', '        `define ICCM_AND_NOT_ICACHE\n', '      `endif\n', '`else\n', '     `ifdef RV_ICACHE_ENABLE\n', '        `define NOT_ICCM_AND_ICACHE\n', '      `else\n', '        `define NOT_ICCM_AND_NOT_ICACHE\n', '      `endif\n', '`endif\n', '\n', '\n', ' localparam   NUM_OF_BEATS = 8 ;\n', '\n', '\n', '\n', '   logic [31:3]    ifu_ic_req_addr_f2;\n', '   logic           uncacheable_miss_in ;\n', '   logic           uncacheable_miss_ff;\n', '\n', '\n', '   logic           ifu_wr_en_new  ;\n', '   logic           ifu_wr_en_new_q  ;\n', '   logic [63:0]    ifu_wr_data_new ;\n', '\n', '   logic           axi_ifu_wr_en_new  ;\n', '   logic           axi_ifu_wr_en_new_q  ;\n', '   logic           axi_ifu_wr_en_new_wo_err  ;\n', '   logic [63:0]    axi_ifu_wr_data_new ;\n', '   logic [3:0]     axi_ic_wr_en ;\n', '\n', '   logic           reset_tag_valid_for_miss  ;\n', '\n', '\n', '   logic [2:0]     way_status;\n', '   logic [2:0]     way_status_mb_in;\n', '   logic [2:0]     way_status_rep_new;\n', '   logic [2:0]     way_status_mb_ff;\n', '   logic [2:0]     way_status_new;\n', '   logic [2:0]     way_status_hit_new;\n', '   logic [2:0]     way_status_new_w_debug;\n', '   logic [3:0]     tagv_mb_in;\n', '   logic [3:0]     tagv_mb_ff;\n', '\n', '\n', '   logic           ifu_wr_data_comb_err ;\n', '   logic           ifu_wr_data_error;\n', '   logic  [7:0]    ifu_byp_data_err;\n', '   logic           ifu_wr_cumulative_err_data;\n', '   logic           ifu_wr_cumulative_err;\n', '   logic           ifu_wr_data_comb_err_ff;\n', '   logic           write_even_beat;\n', '\n', '\n', '   logic           ifc_dma_access_q_ok;\n', '   logic           ifc_iccm_access_f2 ;\n', '   logic           ifc_region_acc_fault_f2;\n', '   logic  [7:0]    ifc_bus_acc_fault_f2;\n', '   logic           ic_act_miss_f2;\n', '   logic           ic_miss_under_miss_f2;\n', '   logic           ic_act_hit_f2;\n', '   logic           miss_pending;\n', '   logic [31:1]    imb_in , imb_ff  ;\n', '   logic           flush_final_f2;\n', '   logic           ifc_fetch_req_f2;\n', '   logic           ifc_fetch_req_f2_raw;\n', '   logic           fetch_req_f2_qual   ;\n', '   logic           ifc_fetch_req_qual_f1 ;\n', '   logic [3:0]     replace_way_mb_any;\n', '   logic           last_beat;\n', '   logic           reset_beat_cnt  ;\n', '   logic [2:0]     req_addr_count ;\n', '   logic [5:3]     ic_req_addr_bits_5_3 ;\n', '   logic [5:3]     ic_wr_addr_bits_5_3 ;\n', '   logic [31:1]    ifu_fetch_addr_int_f2 ;\n', '   logic [31:1]    ifu_ic_rw_int_addr ;\n', '   logic           ic_crit_wd_rdy_in ;\n', '   logic           crit_wd_byp_ok_ff ;\n', '   logic           ic_crit_wd_rdy_ff;\n', '   logic           ic_byp_hit_f2 ;\n', '   logic           ic_valid ;\n', '   logic           ic_valid_ff;\n', '   logic           reset_all_tags;\n', '   logic           ic_valid_w_debug;\n', '\n', '   logic [3:0]     ifu_tag_wren,ifu_tag_wren_ff;\n', '   logic [3:0]     ic_debug_tag_wr_en;\n', '   logic [3:0]     ifu_tag_wren_w_debug;\n', '   logic [3:0]     ic_debug_way_ff;\n', '   logic           ic_debug_rd_en_ff   ;\n', '   logic           write_bypass_data;\n', '   logic           fetch_f1_f2_c1_clken ;\n', '   logic           fetch_f1_f2_c1_clk;\n', '   logic           debug_c1_clken;\n', '   logic           debug_c1_clk;\n', '\n', '   logic           reset_ic_in ;\n', '   logic           reset_ic_ff ;\n', '   logic [3:1]     vaddr_f2 ;\n', '   logic [31:1]    ifu_status_wr_addr;\n', '   logic           sel_fetch_u_miss;\n', '   logic           sel_fetch_u_miss_ff;\n', '   logic           sel_mb_addr ;\n', '   logic           sel_mb_addr_ff ;\n', '   logic [127:0]   ic_final_data;\n', '\n', '   logic [ICACHE_TAG_HIGH-1:ICACHE_TAG_LOW] ifu_ic_rw_int_addr_ff ;\n', '   logic [ICACHE_TAG_HIGH-1:ICACHE_TAG_LOW] ifu_status_wr_addr_ff ;\n', '   logic [ICACHE_TAG_HIGH-1:ICACHE_TAG_LOW] ifu_ic_rw_int_addr_w_debug ;\n', '   logic [ICACHE_TAG_HIGH-1:ICACHE_TAG_LOW] ifu_status_wr_addr_w_debug ;\n', '\n', '   logic [2:0]                              way_status_new_ff ;\n', '   logic                                    way_status_wr_en_ff ;\n', '   logic [ICACHE_TAG_DEPTH-1:0][2:0]        way_status_out ;\n', '   logic [1:0]                              ic_debug_way_enc;\n', '   logic [127:0]                            ic_byp_data_only;\n', '   logic [127:0]                            ic_rd_data_only;\n', '\n', '   logic [`RV_IFU_BUS_TAG-1:0]             ifu_axi_rid_ff;\n', '\n', '   logic         fetch_req_icache_f2;\n', '   logic         fetch_req_iccm_f2;\n', '   logic         ic_iccm_hit_f2;\n', '   logic         fetch_uncacheable_ff;\n', '   logic         way_status_wr_en;\n', '   logic         sel_byp_data;\n', '   logic         sel_ic_data;\n', '   logic         sel_iccm_data;\n', '   logic         ic_rd_parity_final_err_ff;\n', '   logic         ic_act_miss_f2_delayed;\n', '   logic         axi_ifu_wr_data_error;\n', '   logic         way_status_wr_en_w_debug;\n', '   logic         ic_debug_tag_val_rd_out;\n', '   logic         ifu_pmu_ic_miss_in;\n', '   logic         ifu_pmu_ic_hit_in;\n', '   logic         ifu_pmu_bus_error_in;\n', '   logic         ifu_pmu_bus_trxn_in;\n', '   logic         ifu_pmu_bus_busy_in;\n', '   logic         ic_debug_ict_array_sel_in;\n', '   logic         ic_debug_ict_array_sel_ff;\n', '   logic         debug_data_clk;\n', '   logic         debug_data_clken;\n', '   logic                   ifc_region_acc_fault_final_f1, ifc_region_acc_fault_memory, ifc_region_acc_okay;\n', '\n', '\n', '`ifdef RV_ICACHE_ECC\n', '   logic [19:0]  ic_wr_ecc;\n', '   logic [3:0] [1:0] ic_wr_ecc0_unused;   // bit 6:5 are not used for a the 16bit sedded\n', '\n', '`else\n', '   logic [3:0]   ic_wr_parity;\n', '`endif\n', '\n', '\n', '\n', ""   assign ifu_axi_awvalid                        = '0;\n"", ""   assign ifu_axi_awid[`RV_IFU_BUS_TAG-1:0]      = '0;\n"", ""   assign ifu_axi_awaddr[31:0]                   = '0;\n"", ""   assign ifu_axi_awsize[2:0]                    = '0;\n"", ""   assign ifu_axi_awprot[2:0]                    = '0;\n"", ""   assign ifu_axi_awcache[3:0]                   = '0;\n"", ""   assign ifu_axi_awregion[3:0]                  = '0;\n"", ""   assign ifu_axi_awlen[7:0]                     = '0;\n"", ""   assign ifu_axi_awburst[1:0]                   = '0;\n"", ""   assign ifu_axi_awqos[3:0]                     = '0;\n"", ""   assign ifu_axi_awlock                         = '0;\n"", '   // AXI Write Data Channel\n', ""   assign ifu_axi_wvalid                         = '0;\n"", ""   assign ifu_axi_wdata[63:0]                    = '0;\n"", ""   assign ifu_axi_wstrb[7:0]                     = '0;\n"", ""   assign ifu_axi_wlast                          = '1;\n"", '   // AXI Write Response Channel\n', ""   assign ifu_axi_bready                         = '1;\n"", '\n', '\n', '// ---- Clock gating section -----\n', '// c1 clock enables\n', '\n', '\n', '   assign fetch_f1_f2_c1_clken  = ifc_fetch_req_f1_raw | ifc_fetch_req_f2 | miss_pending | exu_flush_final ;\n', '   assign debug_c1_clken        = ic_debug_rd_en | ic_debug_wr_en ;\n', '   // C1 - 1 clock pulse for data\n', '\n', '\n', '\n', '// ------ end clock gating section ------------------------\n', '\n', '\n', '   logic [ICCM_BITS-1:2]                iccm_ecc_corr_index_ff;\n', '   logic [38:0]                         iccm_ecc_corr_data_ff;\n', '   logic                                iccm_ecc_write_status     ;\n', '   logic                                iccm_correct_ecc     ;\n', '   logic                                iccm_rd_ecc_single_err_ff   ;\n', '   logic                                perr_state_en;\n', '   logic [7:0] fetch_mask, ic_fetch_mem_val, bp_mask, ic_bp_mem_mask, ic_fetch_val_mem_f2;\n', '   logic                                dma_iccm_rd_req_f1;\n', '   logic                                dma_iccm_rd_req_f2;\n', '   logic [3:0]                          iccm_single_ecc_error;\n', '\n', '   assign dma_iccm_rd_req_f1  = (dma_iccm_req & ~dma_mem_write) ;\n', '   rvdff #(1)  dma_iccm_req_ff (.*, .clk(free_clk), .din (dma_iccm_rd_req_f1), .dout(dma_iccm_rd_req_f2));\n', '\n', '   assign iccm_dma_sb_error  = (|iccm_single_ecc_error ) & dma_iccm_rd_req_f2;\n', '\n', '\n', ""   typedef enum logic [2:0] {ERR_IDLE=3'b000, PERR_WFF=3'b001 , ECC_WFF=3'b010 , ECC_CORR=3'b011, DMA_SB_ERR=3'b100} perr_state_t;\n"", '   perr_state_t perr_state, perr_nxtstate;\n', '\n', '\n', '   assign ic_dma_active =  iccm_correct_ecc | (perr_state == DMA_SB_ERR) | (dec_tlu_flush_err_wb & (perr_state == ECC_WFF));\n', '   //////////////////////////////////// Create Miss State Machine ///////////////////////\n', '   //                                   Create Miss State Machine                      //\n', '   //                                   Create Miss State Machine                      //\n', '   //                                   Create Miss State Machine                      //\n', '   //////////////////////////////////// Create Miss State Machine ///////////////////////\n', '   logic   miss_state_en;\n', '\n', ""   typedef enum logic [2:0] {IDLE=3'b000, CRIT_BYP_OK=3'b001, HIT_U_MISS=3'b010, MISS_WAIT=3'b011,CRIT_WRD_RDY=3'b100,SCND_MISS=3'b101} miss_state_t;\n"", '   miss_state_t miss_state, miss_nxtstate;\n', '\n', '   // FIFO state machine\n', '   always_comb begin : MISS_SM\n', '      miss_nxtstate   = IDLE;\n', ""      miss_state_en   = 1'b0;\n"", '      case (miss_state)\n', '         IDLE: begin : idle\n', '                  miss_nxtstate = (ic_act_miss_f2 & ~exu_flush_final) ? CRIT_BYP_OK : HIT_U_MISS ;\n', '                  miss_state_en = ic_act_miss_f2;\n', '         end\n', '         CRIT_BYP_OK: begin : crit_byp_ok\n', '                  miss_nxtstate = ( ic_byp_hit_f2 &  ~exu_flush_final & ~(ifu_wr_en_new & last_beat) & ~uncacheable_miss_ff) ? MISS_WAIT :\n', '                                  ( ic_byp_hit_f2                                                    &  uncacheable_miss_ff) ? IDLE :\n', '                                  (~ic_byp_hit_f2 &  ~exu_flush_final &  (ifu_wr_en_new & last_beat) &  uncacheable_miss_ff) ? CRIT_WRD_RDY :\n', '                                  (                                      (ifu_wr_en_new & last_beat) & ~uncacheable_miss_ff) ? IDLE :\n', '                                  (                   exu_flush_final & ~(ifu_wr_en_new & last_beat)                       ) ? HIT_U_MISS : IDLE;\n', '                  miss_state_en =  exu_flush_final | ic_byp_hit_f2 | (ifu_wr_en_new & last_beat)  ;\n', '         end\n', '         CRIT_WRD_RDY: begin : crit_wrd_rdy\n', '                  miss_nxtstate =  IDLE ;\n', '                  miss_state_en =  exu_flush_final | flush_final_f2 | ic_byp_hit_f2   ;\n', '         end\n', '         MISS_WAIT: begin : miss_wait\n', '                  miss_nxtstate =  (exu_flush_final & ~(ifu_wr_en_new & last_beat)) ? HIT_U_MISS  : IDLE ;\n', '                  miss_state_en =   exu_flush_final | (ifu_wr_en_new & last_beat)  ;\n', '         end\n', '         HIT_U_MISS: begin : hit_u_miss\n', '                  miss_nxtstate =  ic_miss_under_miss_f2 & ~(ifu_wr_en_new & last_beat) ? SCND_MISS :  IDLE  ;\n', '                  miss_state_en = (ifu_wr_en_new & last_beat) | ic_miss_under_miss_f2;\n', '         end\n', '         SCND_MISS: begin : scnd_miss\n', '                  miss_nxtstate =  IDLE  ;\n', '                  miss_state_en = (ifu_wr_en_new & last_beat)  ;\n', '         end\n', '         default: begin : def_case\n', '                  miss_nxtstate   = IDLE;\n', ""                  miss_state_en   = 1'b0;\n"", '         end\n', '      endcase\n', '   end\n', '   rvdffs #(($bits(miss_state_t))) miss_state_ff (.clk(free_clk), .din(miss_nxtstate), .dout({miss_state}), .en(miss_state_en),   .*);\n', '   logic    sel_hold_imb     ;\n', '\n', '   assign miss_pending       =  (miss_state != IDLE) ;\n', '   assign crit_wd_byp_ok_ff  =  (miss_state == CRIT_BYP_OK) | ((miss_state == CRIT_WRD_RDY) & ~flush_final_f2);\n', '   assign sel_hold_imb       =  (miss_pending & ~(ifu_wr_en_new & last_beat) & ~((miss_state == CRIT_WRD_RDY) & exu_flush_final)) | ic_act_miss_f2 |\n', '                                (miss_pending & (miss_nxtstate == CRIT_WRD_RDY)) ;\n', '\n', '\n', '\n', '\n', '   assign ic_req_addr_bits_5_3[5:3] = req_addr_count[2:0] ;\n', '   assign ic_wr_addr_bits_5_3[5:3]  = ifu_axi_rid_ff[2:0] ;\n', '   // NOTE: Cacheline size is 16 bytes in this example.\n', '   // Tag     Index  Bank Offset\n', '   // [31:16] [15:5] [4]  [3:0]\n', '\n', '\n', '   assign fetch_req_icache_f2   = ifc_fetch_req_f2 & ~ifc_iccm_access_f2 & ~ifc_region_acc_fault_f2;\n', '   assign fetch_req_iccm_f2     = ifc_fetch_req_f2 &  ifc_iccm_access_f2;\n', '\n', '   assign ic_iccm_hit_f2        = fetch_req_iccm_f2  &  (~miss_pending | (miss_state==HIT_U_MISS));\n', '   assign ic_byp_hit_f2         = ic_crit_wd_rdy  & fetch_req_icache_f2 &  miss_pending ;\n', '   assign ic_act_hit_f2         = (|ic_rd_hit[3:0]) & fetch_req_icache_f2 & ~reset_all_tags & (~miss_pending | (miss_state==HIT_U_MISS)) & ~sel_mb_addr_ff;\n', '   assign ic_act_miss_f2        = (~(|ic_rd_hit[3:0]) | reset_all_tags) & fetch_req_icache_f2 & ~miss_pending & ~ifc_region_acc_fault_f2;\n', '   assign ic_miss_under_miss_f2 = (~(|ic_rd_hit[3:0]) | reset_all_tags) & fetch_req_icache_f2 & (miss_state == HIT_U_MISS) ;\n', '   assign ic_hit_f2             =  ic_act_hit_f2 | ic_byp_hit_f2 | ic_iccm_hit_f2 | (ifc_region_acc_fault_f2 & ifc_fetch_req_f2 & ~((miss_state == CRIT_BYP_OK) | (miss_state == SCND_MISS)));\n', '\n', '   assign uncacheable_miss_in   = sel_hold_imb ? uncacheable_miss_ff : ifc_fetch_uncacheable_f1 ;\n', '   assign imb_in[31:1]          = sel_hold_imb ? imb_ff[31:1] : {fetch_addr_f1[31:1]} ;\n', '   assign way_status_mb_in[2:0] = ( miss_pending) ? way_status_mb_ff[2:0] : {way_status[2:0]} ;\n', '   assign tagv_mb_in[3:0]       = ( miss_pending) ? tagv_mb_ff[3:0]       : {ic_tag_valid[3:0]} ;\n', '\n', '   assign reset_ic_in           = miss_pending  &  (reset_all_tags |  reset_ic_ff) ;\n', '\n', '   rvdff #(1)  reset_ic_f (.*, .clk(free_clk), .din (reset_ic_in), .dout(reset_ic_ff));\n', '   rvdff #(1)  uncache_ff (.*, .clk(active_clk), .din (ifc_fetch_uncacheable_f1), .dout(fetch_uncacheable_ff));\n', '\n', '\n', '\n', '   rvdffe #(31) ifu_fetch_addr_f2_ff (.*,\n', '                    .en (fetch_f1_f2_c1_clken),\n', '                    .din ({fetch_addr_f1[31:1]}),\n', '                    .dout({ifu_fetch_addr_int_f2[31:1]}));\n', '\n', '   assign vaddr_f2[3:1] = ifu_fetch_addr_int_f2[3:1] ;\n', '\n', '\n', '   rvdff_fpga #(1)  unc_miss_ff        (.*, .clk(fetch_f1_f2_c1_clk), .clken(fetch_f1_f2_c1_clken), .rawclk(clk), .din (uncacheable_miss_in),     .dout(uncacheable_miss_ff));\n', '   rvdff_fpga #(3)  mb_rep_wayf2_ff    (.*, .clk(fetch_f1_f2_c1_clk), .clken(fetch_f1_f2_c1_clken), .rawclk(clk), .din ({way_status_mb_in[2:0]}), .dout({way_status_mb_ff[2:0]}));\n', '   rvdff_fpga #(4)  mb_tagv_ff         (.*, .clk(fetch_f1_f2_c1_clk), .clken(fetch_f1_f2_c1_clken), .rawclk(clk), .din ({tagv_mb_in[3:0]}),       .dout({tagv_mb_ff[3:0]}));\n', '   rvdff_fpga #(1) ifu_iccm_acc_ff     (.*, .clk(fetch_f1_f2_c1_clk), .clken(fetch_f1_f2_c1_clken), .rawclk(clk), .din(ifc_iccm_access_f1),       .dout(ifc_iccm_access_f2));\n', '   rvdff_fpga #(1) ifu_iccm_reg_acc_ff (.*, .clk(fetch_f1_f2_c1_clk), .clken(fetch_f1_f2_c1_clken), .rawclk(clk), .din(ifc_region_acc_fault_final_f1), .dout(ifc_region_acc_fault_f2));\n', '\n', '   rvdffe #(31) imb_f2_ff       (.*, .en(fetch_f1_f2_c1_clken), .din ({imb_in[31:1]}), .dout({imb_ff[31:1]}));\n', '\n', '   assign ifc_fetch_req_qual_f1  = ifc_fetch_req_f1  & ~((miss_state == CRIT_WRD_RDY) & flush_final_f2) ;// & ~exu_flush_final ;\n', '   rvdff #(1) fetch_req_f2_ff  (.*, .clk(active_clk),  .din(ifc_fetch_req_qual_f1), .dout(ifc_fetch_req_f2_raw));\n', '\n', '   assign ifc_fetch_req_f2       = ifc_fetch_req_f2_raw & ~exu_flush_final ;\n', '\n', '\n', '   assign ifu_ic_req_addr_f2[31:3] = {imb_ff[31:6] , ic_req_addr_bits_5_3[5:3] };\n', '   assign ifu_ic_mb_empty          = ((miss_state == HIT_U_MISS) & ~(ifu_wr_en_new & last_beat)) |  ~miss_pending ;\n', '   assign ifu_miss_state_idle      = (miss_state == IDLE) ;\n', '\n', '//   four-way set associative - three bits\n', '//   each bit represents one branch point in a binary decision tree; let 1\n', '//   represent that the left side has been referenced more recently than the\n', '//   right side, and 0 vice-versa\n', '//\n', '//              are all 4 ways valid?\n', '//                   /       \\\n', '//                  |        no, use an invalid way.\n', '//                  |\n', '//                  |\n', '//             bit_0 == 0?             state | replace      ref to | next state\n', '//               /       \\             ------+--------      -------+-----------\n', '//              y         n             x00  |  way_0      way_0 |    _11\n', '//             /           \\            x10  |  way_1      way_1 |    _01\n', '//      bit_1 == 0?    bit_2 == 0?      0x1  |  way_2      way_2 |    1_0\n', '//        /    \\          /    \\        1x1  |  way_3      way_3 |    0_0\n', '//       y      n        y      n\n', ""//      /        \\      /        \\        ('x' means don't care       ('_' means unchanged)\n"", ""//    way_0    way_1  way_2     way_3      don't care)\n"", '\n', '\n', '\n', '\n', '   assign replace_way_mb_any[3] = ( way_status_mb_ff[2]  & way_status_mb_ff[0] & (&tagv_mb_ff[3:0])) |\n', '                                  (~tagv_mb_ff[3]& tagv_mb_ff[2] &  tagv_mb_ff[1] &  tagv_mb_ff[0]) ;\n', '   assign replace_way_mb_any[2] = (~way_status_mb_ff[2]  & way_status_mb_ff[0] & (&tagv_mb_ff[3:0])) |\n', '                                  (~tagv_mb_ff[2]& tagv_mb_ff[1] &  tagv_mb_ff[0]) ;\n', '   assign replace_way_mb_any[1] = ( way_status_mb_ff[1] & ~way_status_mb_ff[0] & (&tagv_mb_ff[3:0])) |\n', '                                  (~tagv_mb_ff[1]& tagv_mb_ff[0] ) ;\n', '   assign replace_way_mb_any[0] = (~way_status_mb_ff[1] & ~way_status_mb_ff[0] & (&tagv_mb_ff[3:0])) |\n', '                                  (~tagv_mb_ff[0] ) ;\n', '\n', ""  assign way_status_hit_new[2:0] = ({3{ic_rd_hit[0]}} & {way_status[2] , 1'b1 , 1'b1}) |\n"", ""                                   ({3{ic_rd_hit[1]}} & {way_status[2] , 1'b0 , 1'b1}) |\n"", ""                                   ({3{ic_rd_hit[2]}} & {1'b1 ,way_status[1]  , 1'b0}) |\n"", ""                                   ({3{ic_rd_hit[3]}} & {1'b0 ,way_status[1]  , 1'b0}) ;\n"", '\n', ""  assign way_status_rep_new[2:0] = ({3{replace_way_mb_any[0]}} & {way_status_mb_ff[2] , 1'b1 , 1'b1}) |\n"", ""                                   ({3{replace_way_mb_any[1]}} & {way_status_mb_ff[2] , 1'b0 , 1'b1}) |\n"", ""                                   ({3{replace_way_mb_any[2]}} & {1'b1 ,way_status_mb_ff[1]  , 1'b0}) |\n"", ""                                   ({3{replace_way_mb_any[3]}} & {1'b0 ,way_status_mb_ff[1]  , 1'b0}) ;\n"", '\n', '  // Make sure to select the way_status_hit_new even when in hit_under_miss.\n', '  assign way_status_new[2:0]     = (ifu_wr_en_new_q  )  ? way_status_rep_new[2:0] :\n', '                                                          way_status_hit_new[2:0] ;\n', '\n', '\n', '  assign way_status_wr_en  = (ifu_wr_en_new_q  ) | ic_act_hit_f2;\n', '\n', '\n', '\n', '   assign sel_fetch_u_miss  =  ((miss_state == HIT_U_MISS) & ifc_fetch_req_f1 ) ;\n', '   rvdff #(1) sel_f_u_m_ff (.*, .clk(free_clk), .din (sel_fetch_u_miss), .dout(sel_fetch_u_miss_ff));\n', '\n', '\n', '   assign sel_mb_addr  = ((miss_pending & ifu_wr_en_new ) | reset_tag_valid_for_miss) ;\n', '   assign ifu_ic_rw_int_addr[31:1] = ({31{ sel_mb_addr}}  &  {imb_ff[31:6] , ic_wr_addr_bits_5_3[5:3] , imb_ff[2:1]})  |\n', '                                     ({31{~sel_mb_addr}}  &  fetch_addr_f1[31:1] )   ;\n', '\n', '   assign ifu_status_wr_addr[31:1] = ({31{ sel_mb_addr}}  &  {imb_ff[31:6] , ic_wr_addr_bits_5_3[5:3] , imb_ff[2:1]})  |\n', '                                     ({31{~sel_mb_addr}}  &  ifu_fetch_addr_int_f2[31:1] )   ;\n', '\n', '   rvdff #(1) sel_mb_addr_flop (.*, .clk(free_clk), .din({sel_mb_addr}), .dout({sel_mb_addr_ff}));\n', '\n', '  assign ic_rw_addr[31:2]      = ifu_ic_rw_int_addr[31:2] ;\n', '\n', '\n', 'genvar i ;\n', 'for (i=0 ; i < 4 ; i++) begin : DATA_PGEN\n', ' `ifdef RV_ICACHE_ECC\n', '                rvecc_encode  ic_ecc_encode0 (\n', ""                           .din    ({16'b0, ifu_wr_data_new[((16*i)+15):(16*i)]}),\n"", '                           .ecc_out({ ic_wr_ecc0_unused[i],ic_wr_ecc[i*5+4:i*5]}));\n', '\n', '  `else\n', '       rveven_paritygen #(16) parlo  (.data_in   (ifu_wr_data_new[((16*i)+15):(16*i)]),\n', '                                      .parity_out(ic_wr_parity[i]));\n', '\n', '  `endif\n', 'end\n', '\n', '  assign ifu_wr_data_comb_err       =  ifu_wr_data_error ;\n', '  assign ifu_wr_cumulative_err      = (ifu_wr_data_comb_err | ifu_wr_data_comb_err_ff) & ~reset_beat_cnt;\n', '  assign ifu_wr_cumulative_err_data =  ifu_wr_data_comb_err | ifu_wr_data_comb_err_ff ;\n', '\n', '  rvdff #(1) cumul_err_ff (.*, .clk(free_clk),  .din (ifu_wr_cumulative_err), .dout(ifu_wr_data_comb_err_ff));\n', '\n', '`ifdef RV_ICACHE_ECC\n', '   assign ic_rd_data_only[127:0]   = {ic_rd_data [157:126], ic_rd_data [115:84] , ic_rd_data [73:42],ic_rd_data [31:0]} ;\n', '   assign ic_error_f2.ecc[39:0]    = {ic_rd_data[167:158], ic_rd_data[125:116], ic_rd_data[83:74] ,ic_rd_data[41:32]};\n', '   assign ic_wr_data[83:0] = {ic_wr_ecc[19:10],\n', '                              ifu_wr_data_new[63:32],\n', '                              ic_wr_ecc[9:0],\n', '                              ifu_wr_data_new[31:0]} ;\n', '\n', '`else\n', '   assign ic_rd_data_only[127:0]  = {ic_rd_data [133:102], ic_rd_data [99:68] , ic_rd_data [65:34] ,ic_rd_data [31:0]} ;\n', '   assign ic_error_f2.parity[7:0] = {ic_rd_data[135:134] , ic_rd_data[101:100], ic_rd_data [67:66] ,ic_rd_data [33:32]};\n', '   assign ic_wr_data[67:0] = {ic_wr_parity[3:2],\n', '                              ifu_wr_data_new[63:32],\n', '                              ic_wr_parity[1:0],\n', '                              ifu_wr_data_new[31:0]} ;\n', '\n', '\n', '`endif\n', '\n', '\n', '  assign sel_byp_data     =  ic_crit_wd_rdy  ;//& ~ifu_byp_data_err;\n', '  assign sel_ic_data      = ~ic_crit_wd_rdy & ~fetch_req_iccm_f2 ;\n', '`ifdef ICCM_AND_ICACHE\n', '  assign sel_iccm_data    =  fetch_req_iccm_f2  ;\n', '\n', '  assign ic_final_data  = ({128{sel_byp_data | sel_iccm_data | sel_ic_data}} & {ic_rd_data_only[127:0]} ) ;\n', '\n', '  assign ic_premux_data = ({128{sel_byp_data }} & {ic_byp_data_only[127:0]} ) |\n', '                          ({128{sel_iccm_data}} & {iccm_rd_data[148:117],iccm_rd_data[109:78] , iccm_rd_data[70:39],iccm_rd_data[31:0]});\n', '\n', '  assign ic_sel_premux_data = sel_iccm_data | sel_byp_data ;\n', '\n', '`endif\n', '\n', '`ifdef ICCM_AND_NOT_ICACHE\n', '  assign sel_iccm_data    =  fetch_req_iccm_f2  ;\n', '  assign ic_final_data  = ({128{sel_byp_data }} & {ic_byp_data_only[127:0]} ) |\n', '                          ({128{sel_iccm_data}} & {iccm_rd_data[148:117],iccm_rd_data[109:78] , iccm_rd_data[70:39],iccm_rd_data[31:0]});\n', ""  assign ic_premux_data = '0 ;\n"", ""  assign ic_sel_premux_data = '0 ;\n"", '`endif\n', '\n', '`ifdef NOT_ICCM_AND_ICACHE\n', '\n', '    assign ic_final_data  = ({128{sel_byp_data | sel_ic_data}} & {ic_rd_data_only[127:0]} ) ;\n', '\n', '  assign ic_premux_data = ({128{sel_byp_data }} & {ic_byp_data_only[127:0]} ) ;\n', '  assign ic_sel_premux_data =  sel_byp_data ;\n', '`endif\n', '\n', '`ifdef NOT_ICCM_AND_NOT_ICACHE\n', '  assign ic_final_data  = ({128{sel_byp_data }} & {ic_byp_data_only[127:0]} ) ;\n', '  assign ic_premux_data = 0 ;\n', ""  assign ic_sel_premux_data = '0 ;\n"", '`endif\n', '\n', ' assign ifu_icache_fetch_f2   =  sel_ic_data ;\n', '\n', '  assign ifc_bus_acc_fault_f2[7:0]   =  {8{ic_byp_hit_f2}} & ifu_byp_data_err[7:0] ;\n', '  assign ic_data_f2[127:0]      =  ic_final_data[127:0];\n', '\n', '\n', 'rvdff #(1) flush_final_ff (.*, .clk(free_clk), .din({exu_flush_final}), .dout({flush_final_f2}));\n', 'assign fetch_req_f2_qual       = ic_hit_f2 & ~exu_flush_final;\n', 'assign ic_access_fault_f2[7:0]  = ({8{ifc_region_acc_fault_f2}} | ifc_bus_acc_fault_f2[7:0])  & {8{~exu_flush_final}};\n', '\n', '  // right justified\n', 'assign ic_fetch_val_f2[7] = fetch_req_f2_qual & ifu_bp_inst_mask_f2[7] & ((!vaddr_f2[3]&!vaddr_f2[2]&!vaddr_f2[1]));\n', 'assign ic_fetch_val_f2[6] = fetch_req_f2_qual & ifu_bp_inst_mask_f2[6] & ((!vaddr_f2[3]&!vaddr_f2[2]));\n', 'assign ic_fetch_val_f2[5] = fetch_req_f2_qual & ifu_bp_inst_mask_f2[5] & ((!vaddr_f2[3]&!vaddr_f2[1]) | (!vaddr_f2[3]&!vaddr_f2[2]));\n', 'assign ic_fetch_val_f2[4] = fetch_req_f2_qual & ifu_bp_inst_mask_f2[4] & ((!vaddr_f2[3]));\n', 'assign ic_fetch_val_f2[3] = fetch_req_f2_qual & ifu_bp_inst_mask_f2[3] & ((!vaddr_f2[2]&!vaddr_f2[1]) | (!vaddr_f2[3]));\n', 'assign ic_fetch_val_f2[2] = fetch_req_f2_qual & ifu_bp_inst_mask_f2[2] & ((!vaddr_f2[2]) | (!vaddr_f2[3]));\n', 'assign ic_fetch_val_f2[1] = fetch_req_f2_qual & ifu_bp_inst_mask_f2[1] & ((!vaddr_f2[1]) | (!vaddr_f2[2]) | (!vaddr_f2[3])) ;\n', 'assign ic_fetch_val_f2[0] = fetch_req_f2_qual ;\n', '\n', ""   assign fetch_mask[7:0] = {vaddr_f2[3:1]==3'b111,vaddr_f2[3:1]==3'b110,vaddr_f2[3:1]==3'b101,vaddr_f2[3:1]==3'b100,vaddr_f2[3:1]==3'b011,vaddr_f2[3:1]==3'b010,vaddr_f2[3:1]==3'b001,vaddr_f2[3:1]==3'b000};\n"", '\n', ""   assign ic_fetch_mem_val[7:0] = { 1'b1, |fetch_mask[6:0], |fetch_mask[5:0], |fetch_mask[4:0], |fetch_mask[3:0], |fetch_mask[2:0], |fetch_mask[1:0], fetch_mask[0] };\n"", '\n', ""   assign bp_mask[7:0] = {ifu_bp_inst_mask_f2[7:1], 1'b1};\n"", '\n', '   assign ic_bp_mem_mask[7:0] = ({8{fetch_mask[0]}} &  bp_mask[7:0]) |            // unrotate the bpmask\n', ""                                ({8{fetch_mask[1]}} & {bp_mask[6:0],1'b0}) |\n"", ""                                ({8{fetch_mask[2]}} & {bp_mask[5:0],2'b0}) |\n"", ""                                ({8{fetch_mask[3]}} & {bp_mask[4:0],3'b0}) |\n"", ""                                ({8{fetch_mask[4]}} & {bp_mask[3:0],4'b0}) |\n"", ""                                ({8{fetch_mask[5]}} & {bp_mask[2:0],5'b0}) |\n"", ""                                ({8{fetch_mask[6]}} & {bp_mask[1:0],6'b0}) |\n"", ""                                ({8{fetch_mask[7]}} & {bp_mask[0]  ,7'b0});\n"", '\n', '   assign ic_fetch_val_mem_f2[7:0] = {8{fetch_req_f2_qual}} & ic_bp_mem_mask[7:0] & ic_fetch_mem_val[7:0];\n', '\n', '\n', '\n', '/////////////////////////////////////////////////////////////////////////////////////\n', '//   New logic for bypass\n', '/////////////////////////////////////////////////////////////////////////////////////\n', '\n', '  logic                   write_byp_first_data ;\n', '  logic                   write_byp_second_data ;\n', '\n', '  logic [63:0]            ifu_byp_data_first_half;\n', '  logic [63:0]            ifu_byp_data_second_half;\n', '  logic                   ifu_byp_data_error_first_half_in;\n', '  logic                   ifu_byp_data_error_first_half;\n', '  logic                   ifu_byp_data_error_second_half_in;\n', '  logic                   ifu_byp_data_error_second_half;\n', '  logic                   ifu_byp_data_first_half_valid_in ;\n', '  logic                   ifu_byp_data_first_half_valid    ;\n', '  logic                   ifu_byp_data_second_half_valid_in ;\n', '  logic                   ifu_byp_data_second_half_valid    ;\n', '  logic                   ic_crit_wd_complete    ;\n', '\n', '  logic [IFU_BUS_TAG-1:0] byp_tag_ff;\n', '  logic                   byp_data_first_c1_clken ;\n', '  logic                   byp_data_first_c1_clk;\n', '  logic                   byp_data_second_c1_clken ;\n', '  logic                   byp_data_second_c1_clk;\n', '\n', '  assign   byp_data_first_c1_clken  = write_byp_first_data;\n', '  assign   byp_data_second_c1_clken = write_byp_second_data;\n', '\n', ""  assign byp_tag_ff[IFU_BUS_TAG-1:0]  =  IFU_BUS_TAG'({imb_ff[5:4] , 1'b0});\n"", ""  assign write_byp_first_data         =   axi_ifu_wr_en_new & ({byp_tag_ff[IFU_BUS_TAG-1:1],1'b0}  == ifu_axi_rid_ff[IFU_BUS_TAG-1:0]);\n"", ""  assign write_byp_second_data        =   axi_ifu_wr_en_new & ({byp_tag_ff[IFU_BUS_TAG-1:1],1'b1}  == ifu_axi_rid_ff[IFU_BUS_TAG-1:0]);\n"", '\n', ' // First Half flops\n', '  rvdffe #(64) byp_data_first_half (.*,\n', '            .en(byp_data_first_c1_clken),\n', '            .din (ifu_wr_data_new[63:0]),\n', '            .dout(ifu_byp_data_first_half[63:0]));\n', '\n', '  assign ifu_byp_data_error_first_half_in = write_byp_first_data ? ifu_wr_data_error : (ifu_byp_data_error_first_half  & ~ic_act_miss_f2) ;\n', '\n', '  rvdff #(1) byp_data_first_half_err (.*,\n', '            .clk(free_clk),\n', '            .din (ifu_byp_data_error_first_half_in),\n', '            .dout(ifu_byp_data_error_first_half));\n', '\n', ""  assign ifu_byp_data_first_half_valid_in = write_byp_first_data ? 1'b1  : (ifu_byp_data_first_half_valid  & ~ic_act_miss_f2) ;\n"", '  rvdff #(1) byp_data_first_half_val (.*,\n', '            .clk(free_clk),\n', '            .din (ifu_byp_data_first_half_valid_in),\n', '            .dout(ifu_byp_data_first_half_valid));\n', '\n', '\n', ' // Second Half flops\n', '  rvdffe #(64) byp_data_second_half (.*,\n', '            .en(byp_data_second_c1_clken),\n', '            .din (ifu_wr_data_new[63:0]),\n', '            .dout(ifu_byp_data_second_half[63:0]));\n', '\n', '  assign ifu_byp_data_error_second_half_in = write_byp_second_data ? ifu_wr_data_error : (ifu_byp_data_error_second_half  & ~ic_act_miss_f2) ;\n', '  rvdff #(1) byp_data_second_half_err (.*,\n', '                   .clk(free_clk),\n', '                   .din (ifu_byp_data_error_second_half_in),\n', '                   .dout(ifu_byp_data_error_second_half));\n', '\n', ""  assign ifu_byp_data_second_half_valid_in = write_byp_second_data ? 1'b1  : (ifu_byp_data_second_half_valid  & ~ic_act_miss_f2) ;\n"", '  rvdff #(1) byp_data_second_half_val (.*,\n', '                   .clk(free_clk),\n', '                    .din (ifu_byp_data_second_half_valid_in),\n', '                    .dout(ifu_byp_data_second_half_valid));\n', '\n', '  assign ic_byp_data_only[127:0] = { ifu_byp_data_second_half[63:0] , ifu_byp_data_first_half[63:0] } ;\n', '\n', '  assign ifu_byp_data_err[7:0]  =  {{4{ ifu_byp_data_error_second_half}} , {4{ifu_byp_data_error_first_half}}} ;\n', '\n', '// Critical word ready.\n', '   assign    ic_crit_wd_complete = (write_byp_first_data  & ifu_byp_data_second_half_valid) |\n', '                                   (write_byp_second_data & ifu_byp_data_first_half_valid)  ;\n', '\n', '   assign    ic_crit_wd_rdy_in = (ic_crit_wd_complete & crit_wd_byp_ok_ff & ~exu_flush_final ) |\n', '                                 (ic_crit_wd_rdy_ff & ~fetch_req_icache_f2 & crit_wd_byp_ok_ff & ~exu_flush_final) ;\n', '\n', '   rvdff #(1)           crit_wd_ff      (.*, .clk(free_clk),  .din(ic_crit_wd_rdy_in),   .dout(ic_crit_wd_rdy_ff));\n', '/////////////////////////////////////////////////////////////////////////////////////\n', '// Parity checking logic for Icache logic.                                         //\n', '/////////////////////////////////////////////////////////////////////////////////////\n', '\n', '\n', 'assign ic_rd_parity_final_err = ic_tag_perr & ifu_icache_fetch_f2  ;\n', '\n', 'logic [16:6]                                  ifu_ic_rw_int_addr_f2_Q ;\n', 'logic [3:0]                                   perr_err_inv_way;\n', 'logic [16:6]                                  perr_ic_index_ff;\n', 'logic                                         perr_sel_invalidate;\n', 'logic                                         perr_sb_write_status   ;\n', 'logic                                         ifu_icache_sb_error_val_ff   ;\n', '\n', '         rvdff #(11) ic_index_q (.*,\n', '                   .clk(active_clk),\n', '                   .din(ifu_icache_error_index[16:6]),\n', '                   .dout(ifu_ic_rw_int_addr_f2_Q[16:6]));\n', '\n', '\n', '\n', '\n', '   rvdff  #((1))  perr_err_ff    (.clk(active_clk), .din(ifu_icache_error_val),   .dout(ic_rd_parity_final_err_ff),   .*);\n', '   rvdff  #((1))  sbiccm_err_ff  (.clk(active_clk), .din(ifu_icache_sb_error_val),       .dout(ifu_icache_sb_error_val_ff),   .*);\n', '   rvdffs #((11)) perr_dat_ff    (.clk(active_clk), .din(ifu_ic_rw_int_addr_f2_Q[16:6]), .dout(perr_ic_index_ff), .en(perr_sb_write_status),  .*);\n', '\n', '   assign perr_err_inv_way[3:0]   =  {4{perr_sel_invalidate}} ;\n', '\n', '   //////////////////////////////////// Create Parity Error State Machine ///////////////////////\n', '   //                                   Create Parity Error State Machine                      //\n', '   //                                   Create Parity Error State Machine                      //\n', '   //                                   Create Parity Error State Machine                      //\n', '   //////////////////////////////////// Create Parity Error State Machine ///////////////////////\n', '\n', '   assign iccm_correct_ecc = (perr_state == ECC_CORR);\n', '\n', '   // FIFO state machine\n', '   always_comb begin  : ERROR_SM\n', '      perr_nxtstate            = ERR_IDLE;\n', ""      perr_state_en            = 1'b0;\n"", ""      perr_sb_write_status     = 1'b0;\n"", ""      perr_sel_invalidate      = 1'b0;\n"", ""      //iccm_correct_ecc         = 1'b0;\n"", '\n', '      case (perr_state)\n', '         ERR_IDLE: begin : err_idle\n', '                  perr_nxtstate         =  iccm_dma_sb_error ? DMA_SB_ERR : (ic_rd_parity_final_err_ff & ~exu_flush_final) ? PERR_WFF : ECC_WFF;\n', '                  perr_state_en         =  ((ic_rd_parity_final_err_ff | ifu_icache_sb_error_val_ff) & ~exu_flush_final) | iccm_dma_sb_error;\n', '                  perr_sb_write_status  =  perr_state_en;\n', '         end\n', '         PERR_WFF: begin : perr_wff\n', '                  perr_nxtstate       =  ERR_IDLE ;\n', '                  perr_state_en       =   exu_flush_final  ;\n', '                  perr_sel_invalidate =  (dec_tlu_flush_err_wb &  exu_flush_final);\n', '         end\n', '         ECC_WFF: begin : ecc_wff\n', '                  perr_nxtstate       =  (~dec_tlu_flush_err_wb &  exu_flush_final ) ? ERR_IDLE : ECC_CORR ;\n', '                  perr_state_en       =   exu_flush_final   ;\n', '         end\n', '         DMA_SB_ERR : begin : dma_sb_ecc\n', '                 perr_nxtstate       = ECC_CORR;\n', ""                 perr_state_en       = 1'b1;\n"", '         end\n', '         ECC_CORR: begin : ecc_corr\n', '                  perr_nxtstate       =  ERR_IDLE  ;\n', ""                  perr_state_en       =   1'b1   ;\n"", '         end\n', '         default: begin : def_case\n', '                  perr_nxtstate            = ERR_IDLE;\n', ""                  perr_state_en            = 1'b0;\n"", ""                  perr_sb_write_status     = 1'b0;\n"", ""                  perr_sel_invalidate      = 1'b0;\n"", ""                 // iccm_correct_ecc         = 1'b0;\n"", '         end\n', '      endcase\n', '   end\n', '   rvdffs #(($bits(perr_state_t))) perr_state_ff (.clk(free_clk), .din(perr_nxtstate), .dout({perr_state}), .en(perr_state_en),   .*);\n', '\n', '`ifdef RV_ICCM_ENABLE\n', '/////////////////////////////////////////////////////////////////////////////////////\n', '// ECC checking logic for ICCM data.                                               //\n', '/////////////////////////////////////////////////////////////////////////////////////\n', '\n', 'logic [3:0] [31:0] iccm_corrected_data;\n', 'logic [3:0] [06:0] iccm_corrected_ecc;\n', 'logic [3:0]        iccm_double_ecc_error;\n', 'logic [3:0]        iccm_ecc_word_enable;\n', '\n', '\n', 'logic [ICCM_BITS-1:4]       iccm_rw_addr_f2;\n', '\n', 'logic [31:0]       iccm_corrected_data_f2_mux;\n', 'logic [06:0]       iccm_corrected_ecc_f2_mux;\n', 'logic [3:0]        iccm_rd_err_f2_mux;\n', 'logic              iccm_dma_rvalid_in;\n', '\n', 'for (i=0; i < 4 ; i++) begin : ICCM_ECC_CHECK\n', 'assign iccm_ecc_word_enable[i] = ((|ic_fetch_val_mem_f2[(2*i+1):(2*i)] & ~exu_flush_final & sel_iccm_data) | iccm_dma_rvalid_in) & ~dec_tlu_core_ecc_disable;\n', 'rvecc_decode  ecc_decode (\n', '                           .en(iccm_ecc_word_enable[i]),\n', ""                           .sed_ded ( 1'b0 ),    // 1 : means only detection\n"", '                           .din(iccm_rd_data[(39*i+31):(39*i)]),\n', '                           .ecc_in(iccm_rd_data[(39*i+38):(39*i+32)]),\n', '                           .dout(iccm_corrected_data[i][31:0]),\n', '                           .ecc_out(iccm_corrected_ecc[i][6:0]),\n', '                           .single_ecc_error(iccm_single_ecc_error[i]),\n', '                           .double_ecc_error(iccm_double_ecc_error[i]));\n', 'end\n', '\n', 'assign iccm_rd_ecc_single_err  = (|iccm_single_ecc_error ) & ifc_iccm_access_f2;\n', 'assign iccm_rd_ecc_double_err[7:0]  = ({{2{iccm_double_ecc_error[3]}}, {2{iccm_double_ecc_error[2]}} , {2{iccm_double_ecc_error[1]}} , {2{iccm_double_ecc_error[0]}}} ) & {8{ifc_iccm_access_f2}};\n', '\n', 'assign iccm_corrected_data_f2_mux[31:0] = iccm_single_ecc_error[0] ? iccm_corrected_data[0] :\n', '                                          iccm_single_ecc_error[1] ? iccm_corrected_data[1] :\n', '                                          iccm_single_ecc_error[2] ? iccm_corrected_data[2] :\n', '                                                                     iccm_corrected_data[3] ;\n', '\n', 'assign iccm_corrected_ecc_f2_mux[06:0]  = iccm_single_ecc_error[0] ? iccm_corrected_ecc[0] :\n', '                                          iccm_single_ecc_error[1] ? iccm_corrected_ecc[1] :\n', '                                          iccm_single_ecc_error[2] ? iccm_corrected_ecc[2] :\n', '                                                                     iccm_corrected_ecc[3] ;\n', '\n', '\n', '  rvdff #(ICCM_BITS-4) iccm_index_f2 (.*, .clk(free_clk),   .din(iccm_rw_addr[ICCM_BITS-1:4]), .dout(iccm_rw_addr_f2[ICCM_BITS-1:4]));\n', '\n', ""  assign iccm_rd_err_f2_mux[1:0] =  iccm_single_ecc_error[0] ? 2'b00:\n"", ""                                     iccm_single_ecc_error[1] ? 2'b01:\n"", ""                                     iccm_single_ecc_error[2] ? 2'b10: 2'b11 ;\n"", '\n', '\n', '   logic  iccm_rd_ecc_single_err_hold_in ;\n', '\n', '   assign iccm_ecc_write_status          =  ((iccm_rd_ecc_single_err & ~iccm_rd_ecc_single_err_ff)  & ~exu_flush_final) | iccm_dma_sb_error;\n', '   assign iccm_rd_ecc_single_err_hold_in =  (iccm_rd_ecc_single_err | iccm_rd_ecc_single_err_ff) & ~exu_flush_final;\n', '\n', '   rvdff  #((1))          ecc_rr_ff    (.clk(free_clk), .din(iccm_rd_ecc_single_err_hold_in),   .dout(iccm_rd_ecc_single_err_ff),            .*);\n', '   rvdffs #((32))         ecc_dat0_ff  (.clk(free_clk), .din(iccm_corrected_data_f2_mux[31:0]), .dout(iccm_ecc_corr_data_ff[31:0]),          .en(iccm_ecc_write_status),  .*);\n', '   rvdffs #((7))          ecc_dat1_ff  (.clk(free_clk), .din(iccm_corrected_ecc_f2_mux[6:0]),   .dout(iccm_ecc_corr_data_ff[38:32]),         .en(iccm_ecc_write_status),  .*);\n', '   rvdffs #((ICCM_BITS-4))ecc_ind0_ff  (.clk(free_clk), .din(iccm_rw_addr_f2[ICCM_BITS-1:4]),   .dout(iccm_ecc_corr_index_ff[ICCM_BITS-1:4]),.en(iccm_ecc_write_status),  .*);\n', '   rvdffs #((2))          ecc_ind1_ff  (.clk(free_clk), .din(iccm_rd_err_f2_mux[1:0]),          .dout(iccm_ecc_corr_index_ff[3:2]),          .en(iccm_ecc_write_status),  .*);\n', '\n', '`else\n', ""assign iccm_rd_ecc_single_err     = 1'b0 ;\n"", ""assign iccm_rd_ecc_double_err     = '0 ;\n"", ""assign iccm_rd_ecc_single_err_ff  = 1'b0 ;\n"", '\n', ""assign iccm_ecc_corr_index_ff[ICCM_BITS-1:2]  =  '0;\n"", ""assign iccm_ecc_corr_data_ff[38:0]            =  '0;\n"", ""assign iccm_ecc_write_status                  =  '0;\n"", ""assign iccm_single_ecc_error                  =  '0;\n"", '\n', '\n', '`endif\n', '\n', '   logic        axiclk;\n', '   logic        axiclk_reset;\n', '   logic        axi_ifu_bus_clk_en_ff;\n', '   logic        axi_ifu_bus_clk_en ;\n', '\n', '   logic        ifc_axi_ic_req_ff_in;\n', '   logic        ifc_axi_ic_req_ff2 ;\n', '\n', '   logic        axi_inc_data_beat_cnt     ;\n', '   logic        axi_reset_data_beat_cnt   ;\n', '   logic        axi_hold_data_beat_cnt    ;\n', '\n', '   logic        axi_inc_cmd_beat_cnt     ;\n', '   logic        axi_reset_cmd_beat_cnt_0   ;\n', '   logic        axi_reset_cmd_beat_cnt_6   ;\n', '   logic        axi_hold_cmd_beat_cnt    ;\n', '\n', '   logic [2:0]  axi_new_data_beat_count  ;\n', '   logic [2:0]  axi_data_beat_count      ;\n', '\n', '   logic [2:0]  axi_new_cmd_beat_count  ;\n', '   logic [2:0]  axi_cmd_beat_count      ;\n', '\n', '   logic        axi_inc_rd_addr_cnt  ;\n', '   logic        axi_set_rd_addr_cnt  ;\n', '   logic        axi_reset_rd_addr_cnt;\n', '   logic        axi_hold_rd_addr_cnt ;\n', '\n', '   logic [2:0]  axi_new_rd_addr_count;\n', '   logic [2:0]  axi_rd_addr_count;\n', '\n', '\n', '   logic        axi_cmd_sent           ;\n', '   logic        axi_last_data_beat     ;\n', '   logic        axi_wrap_addr          ;\n', '\n', '\n', '   logic        ifu_axi_rvalid_ff        ;\n', '   logic        ifu_axi_rvalid_unq_ff    ;\n', '   logic        ifu_axi_arready_unq_ff    ;\n', '   logic        ifu_axi_arvalid_ff        ;\n', '   logic        ifu_axi_arready_ff        ;\n', '   logic [63:0] ifu_axi_rdata_ff        ;\n', '   logic [1:0]  ifu_axi_rresp_ff          ;\n', '\n', '   logic        axi_w0_wren            ;\n', '   logic        axi_w1_wren            ;\n', '   logic        axi_w2_wren            ;\n', '   logic        axi_w3_wren            ;\n', '\n', '   logic        axi_w0_wren_last       ;\n', '   logic        axi_w1_wren_last       ;\n', '   logic        axi_w2_wren_last       ;\n', '   logic        axi_w3_wren_last       ;\n', '\n', '   logic        w0_wren_reset_miss      ;\n', '   logic        w1_wren_reset_miss      ;\n', '   logic        w2_wren_reset_miss      ;\n', '   logic        w3_wren_reset_miss      ;\n', '\n', '   logic        ifc_dma_access_ok_d;\n', '   logic        ifc_dma_access_ok_prev;\n', '\n', 'assign axi_ifu_bus_clk_en =  ifu_bus_clk_en ;\n', '\n', '\n', '\n', '   rvdff #(1)           axi_clken_ff  (.*, .clk(free_clk), .din(axi_ifu_bus_clk_en), .dout(axi_ifu_bus_clk_en_ff));\n', '\n', '   logic   axi_cmd_req_in ;\n', '   logic   axi_cmd_req_hold ;\n', '\n', '\n', ""   assign  ifc_axi_ic_req_ff_in  = (ic_act_miss_f2 | axi_cmd_req_hold | ifc_axi_ic_req_ff2) & ~((axi_cmd_beat_count==3'b111) & ifu_axi_arvalid & ifu_axi_arready & miss_pending);\n"", '\n', '   assign    axi_cmd_req_in  = (ic_act_miss_f2 | axi_cmd_req_hold) & ~axi_cmd_sent  ; // hold until first command sent\n', '   // changes for making the axi blocking\n', '   rvdff #(1)  axi_cmd_req_ff  (.*,  .clk(free_clk), .din(axi_cmd_req_in), .dout(axi_cmd_req_hold));\n', '\n', '`ifndef RV_FPGA_OPTIMIZE\n', '   rvclkhdr fetch_f1_f2_c1_cgc   ( .en(fetch_f1_f2_c1_clken),     .l1clk(fetch_f1_f2_c1_clk), .* );  // ifndef FPGA_OPTIMIZE\n', '   rvclkhdr axi_clk(.en(axi_ifu_bus_clk_en),.l1clk(axiclk), .*);                                     // ifndef FPGA_OPTIMIZE\n', '   rvclkhdr axi_clk_reset(.en(axi_ifu_bus_clk_en | ic_act_miss_f2),   .l1clk(axiclk_reset), .*);     // ifndef FPGA_OPTIMIZE\n', '`endif\n', '\n', '\n', '///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '//  logic   axi_cmd_rsp_pend;\n', '// `ifdef RV_BUILD_SVC\n', '//     rvdffsc  axi_cmd_rsp_pend_ff  ( .din(ifu_axi_arready), .dout(axi_cmd_rsp_pend), .en(ifu_axi_arvalid), .clear(ifu_axi_rvalid & ifu_axi_rready), .clk(axiclk), .*);\n', '// `elsif RV_BUILD_AXI4\n', '//     rvdffsc  axi_cmd_rsp_pend_ff  ( .din(ifu_axi_arready), .dout(axi_cmd_rsp_pend), .en(ifu_axi_arvalid), .clear(ifu_axi_rvalid & ifu_axi_rready), .clk(axiclk), .*);\n', '// `else\n', ""//     assign    axi_cmd_rsp_pend      = 1'b0;\n"", '// `endif\n', '//   assign    ifu_axi_arvalid                 = ifc_axi_ic_req_ff2 & ~axi_cmd_rsp_pend;\n', '///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '   assign    ifu_axi_arvalid                 = ifc_axi_ic_req_ff2 ;\n', ""   assign    ifu_axi_arid[IFU_BUS_TAG-1:0]   = IFU_BUS_TAG'(axi_rd_addr_count[2:0]);\n"", ""   assign    ifu_axi_araddr[31:0]            = {ifu_ic_req_addr_f2[31:3],3'b0} ;\n"", ""   assign    ifu_axi_rready                  = 1'b1;\n"", ""   assign    ifu_axi_arsize[2:0]             = 3'b011;\n"", ""   assign    ifu_axi_arcache[3:0]            = 4'b1111;\n"", ""   assign    ifu_axi_arprot[2:0]             = 3'b100;\n"", '   assign    ifu_axi_arregion[3:0]           = ifu_axi_araddr[31:28];\n', ""   assign    ifu_axi_arlen[7:0]              = '0;\n"", ""   assign    ifu_axi_arburst[1:0]            = 2'b01;\n"", ""   assign    ifu_axi_arqos[3:0]              = '0;\n"", ""   assign    ifu_axi_arlock                  = '0;\n"", '\n', '   // IFU Write channels - not needed, so 00 out\n', '   rvdff_fpga #(1)            axi_ic_req_ff2   (.*, .clk(axiclk), .clken(axi_ifu_bus_clk_en), .rawclk(clk), .din(ifc_axi_ic_req_ff_in),          .dout(ifc_axi_ic_req_ff2));\n', '   rvdff_fpga #(1)            axi_rdy_ff       (.*, .clk(axiclk), .clken(axi_ifu_bus_clk_en), .rawclk(clk), .din(ifu_axi_arready),               .dout(ifu_axi_arready_unq_ff));\n', '   rvdff_fpga #(1)            axi_rsp_vld_ff   (.*, .clk(axiclk), .clken(axi_ifu_bus_clk_en), .rawclk(clk), .din(ifu_axi_rvalid),                .dout(ifu_axi_rvalid_unq_ff));\n', '   rvdff_fpga #(1)            axi_cmd_ff       (.*, .clk(axiclk), .clken(axi_ifu_bus_clk_en), .rawclk(clk), .din(ifu_axi_arvalid),               .dout(ifu_axi_arvalid_ff));\n', '   rvdff_fpga #(2)            scvi_rsp_cmd_ff  (.*, .clk(axiclk), .clken(axi_ifu_bus_clk_en), .rawclk(clk), .din(ifu_axi_rresp[1:0]),            .dout(ifu_axi_rresp_ff[1:0]));\n', '   rvdff_fpga #(IFU_BUS_TAG)  scvi_rsp_tag_ff  (.*, .clk(axiclk), .clken(axi_ifu_bus_clk_en), .rawclk(clk), .din(ifu_axi_rid[IFU_BUS_TAG-1:0]),  .dout(ifu_axi_rid_ff[IFU_BUS_TAG-1:0]));\n', '   rvdff_fpga #(64)           axi_data_ff      (.*, .clk(axiclk), .clken(axi_ifu_bus_clk_en), .rawclk(clk), .din(ifu_axi_rdata[63:0]),           .dout(ifu_axi_rdata_ff[63:0]));\n', '\n', '\n', '\n', '   assign    ifu_axi_arready_ff   =  ifu_axi_arready_unq_ff & axi_ifu_bus_clk_en_ff ;\n', '   assign    ifu_axi_rvalid_ff   =  ifu_axi_rvalid_unq_ff & axi_ifu_bus_clk_en_ff ;\n', '   assign    axi_cmd_sent        =  ifu_axi_arvalid & ifu_axi_arready & miss_pending & axi_ifu_bus_clk_en;\n', '   assign axi_inc_data_beat_cnt         = (axi_ifu_wr_en_new & ~axi_last_data_beat) ;\n', '   assign axi_reset_data_beat_cnt       =  ic_act_miss_f2 | (axi_ifu_wr_en_new &  axi_last_data_beat) ;\n', '   assign axi_hold_data_beat_cnt        = ~axi_inc_data_beat_cnt & ~axi_reset_data_beat_cnt ;\n', '\n', ""   assign axi_new_data_beat_count[2:0] = ({3{axi_reset_data_beat_cnt}} & 3'b000 ) |\n"", ""                                     ({3{axi_inc_data_beat_cnt}}   & (axi_data_beat_count[2:0] + 3'b001)) |\n"", '                                     ({3{axi_hold_data_beat_cnt}}  &  axi_data_beat_count[2:0]) ;\n', '\n', '   rvdff #(3)  axi_mb_beat_count_ff (.*, .clk(free_clk), .din ({axi_new_data_beat_count[2:0]}), .dout({axi_data_beat_count[2:0]}));\n', '\n', '// Request Address Count\n', '   assign axi_inc_rd_addr_cnt     = axi_cmd_sent;\n', '   assign axi_set_rd_addr_cnt     = ic_act_miss_f2  ;\n', '   assign axi_hold_rd_addr_cnt    = ~axi_inc_rd_addr_cnt & ~axi_set_rd_addr_cnt;\n', '\n', ""   assign axi_new_rd_addr_count[2:0] = ~miss_pending ? {imb_ff[5:4],1'b0} :  axi_inc_rd_addr_cnt ? (axi_rd_addr_count[2:0] + 3'b001) : axi_rd_addr_count[2:0];\n"", '\n', '\n', '   rvdff_fpga  #(3)  axi_cmd_beat_ff (.*,           .clk(axiclk_reset), .clken(axi_ifu_bus_clk_en | ic_act_miss_f2), .rawclk(clk), .din ({axi_new_cmd_beat_count[2:0]}), .dout({axi_cmd_beat_count[2:0]}));\n', ""   rvdffs_fpga #(3)  axi_rd_addr_ff (.*, .en(1'b1), .clk(axiclk_reset), .clken(axi_ifu_bus_clk_en | ic_act_miss_f2), .rawclk(clk), .din ({axi_new_rd_addr_count[2:0]}), .dout({axi_rd_addr_count[2:0]}));\n"", '\n', '// command beat Count\n', '   assign axi_inc_cmd_beat_cnt     =  ifu_axi_arvalid         &  ifu_axi_arready & miss_pending;\n', '   assign axi_reset_cmd_beat_cnt_0 =  ic_act_miss_f2        & ~uncacheable_miss_in ;\n', '   assign axi_reset_cmd_beat_cnt_6 =  ic_act_miss_f2        &  uncacheable_miss_in ;\n', '   assign axi_hold_cmd_beat_cnt    = ~axi_inc_cmd_beat_cnt & ~ic_act_miss_f2 ;\n', '\n', ""   assign axi_new_cmd_beat_count[2:0] =  ({3{axi_reset_cmd_beat_cnt_0}} & 3'b000 ) |\n"", ""                                          ({3{axi_reset_cmd_beat_cnt_6}} & 3'b110 ) |\n"", ""                                          ({3{axi_inc_cmd_beat_cnt}}   & (axi_cmd_beat_count[2:0] + 3'b001)) |\n"", '                                          ({3{axi_hold_cmd_beat_cnt}}  &  axi_cmd_beat_count[2:0]) ;\n', '\n', '\n', '   assign    req_addr_count[2:0]    = axi_rd_addr_count[2:0] ;\n', '\n', '\n', '\n', ""    assign axi_last_data_beat     =  uncacheable_miss_ff ? (axi_data_beat_count[2:0] == 3'b001) : (axi_data_beat_count[2:0] == 3'b111);\n"", ""    assign axi_wrap_addr          =  (axi_rd_addr_count[2:0] == 3'b111);\n"", '\n', '   assign  axi_ifu_wr_en_new         =  ifu_axi_rvalid_ff  & miss_pending ;\n', '   assign  axi_ifu_wr_en_new_q       =  ifu_axi_rvalid_ff  & miss_pending & ~uncacheable_miss_ff & ~(|ifu_axi_rresp_ff[1:0]); // qualify with no-error conditions ;\n', '   assign  axi_ifu_wr_en_new_wo_err  =  ifu_axi_rvalid_ff & miss_pending &  ~uncacheable_miss_ff;\n', '   assign  axi_ifu_wr_data_new[63:0] =  ifu_axi_rdata_ff[63:0] ;\n', '\n', ""   assign axi_w0_wren = axi_ifu_wr_en_new_q & (replace_way_mb_any[3:0] == 4'b0001) & miss_pending ;\n"", ""   assign axi_w1_wren = axi_ifu_wr_en_new_q & (replace_way_mb_any[3:0] == 4'b0010) & miss_pending ;\n"", ""   assign axi_w2_wren = axi_ifu_wr_en_new_q & (replace_way_mb_any[3:0] == 4'b0100) & miss_pending ;\n"", ""   assign axi_w3_wren = axi_ifu_wr_en_new_q & (replace_way_mb_any[3:0] == 4'b1000) & miss_pending ;\n"", '\n', '   assign axi_ic_wr_en[3:0] = {axi_w3_wren , axi_w2_wren , axi_w1_wren , axi_w0_wren} ;\n', '\n', ""   assign axi_w0_wren_last = axi_ifu_wr_en_new_wo_err & (replace_way_mb_any[3:0] == 4'b0001) & miss_pending & axi_last_data_beat;\n"", ""   assign axi_w1_wren_last = axi_ifu_wr_en_new_wo_err & (replace_way_mb_any[3:0] == 4'b0010) & miss_pending & axi_last_data_beat;\n"", ""   assign axi_w2_wren_last = axi_ifu_wr_en_new_wo_err & (replace_way_mb_any[3:0] == 4'b0100) & miss_pending & axi_last_data_beat;\n"", ""   assign axi_w3_wren_last = axi_ifu_wr_en_new_wo_err & (replace_way_mb_any[3:0] == 4'b1000) & miss_pending & axi_last_data_beat;\n"", '\n', '   rvdff #(1)  act_miss_ff (.*, .clk(free_clk), .din (ic_act_miss_f2), .dout(ic_act_miss_f2_delayed));\n', '   assign reset_tag_valid_for_miss = ic_act_miss_f2_delayed & (miss_state == CRIT_BYP_OK) ;\n', '\n', ""   assign w0_wren_reset_miss    = (replace_way_mb_any[3:0] == 4'b0001) & reset_tag_valid_for_miss ;\n"", ""   assign w1_wren_reset_miss    = (replace_way_mb_any[3:0] == 4'b0010) & reset_tag_valid_for_miss ;\n"", ""   assign w2_wren_reset_miss    = (replace_way_mb_any[3:0] == 4'b0100) & reset_tag_valid_for_miss ;\n"", ""   assign w3_wren_reset_miss    = (replace_way_mb_any[3:0] == 4'b1000) & reset_tag_valid_for_miss ;\n"", '\n', '   assign    axi_ifu_wr_data_error = |ifu_axi_rresp_ff[1:0] &  ifu_axi_rvalid_ff  & miss_pending;\n', '\n', '   rvdff #(1)           dma_ok_prev_ff  (.*, .clk(free_clk),  .din(ifc_dma_access_ok_d), .dout(ifc_dma_access_ok_prev));\n', '\n', '   assign ic_crit_wd_rdy   = ic_crit_wd_rdy_ff ;\n', '   assign last_beat        =  axi_last_data_beat ;\n', '   assign ifu_wr_data_error = axi_ifu_wr_data_error ;\n', '   assign reset_beat_cnt    = axi_reset_data_beat_cnt ;\n', '\n', '// DMA\n', '   // Making sure that the dma_access is allowed when we have 2 back to back dma_access_ok. Also gating with current state == idle\n', '   assign ifc_dma_access_ok_d  = ifc_dma_access_ok &  ~iccm_correct_ecc;\n', '   assign ifc_dma_access_q_ok  = ifc_dma_access_ok &  ~iccm_correct_ecc & ifc_dma_access_ok_prev &  (perr_state == ERR_IDLE) ;\n', '   assign iccm_ready           = ifc_dma_access_q_ok ;\n', '\n', '    `ifdef RV_ICCM_ENABLE\n', '         logic  dma_select_upper  ;\n', '         logic  iccm_dma_rden    ;\n', '\n', '//         logic  ic_dma_active_in;\n', '         logic  iccm_dma_ecc_error_in;\n', '         logic  [13:0] dma_mem_ecc;\n', '         logic  [63:0] iccm_dma_rdata_in;\n', '\n', '//         assign ic_dma_active_in   =  ifc_dma_access_q_ok & dma_iccm_req ;\n', '         assign iccm_wren          =  (ifc_dma_access_q_ok & dma_iccm_req &  dma_mem_write) | iccm_correct_ecc;\n', '         assign iccm_rden          =  (ifc_dma_access_q_ok & dma_iccm_req & ~dma_mem_write) | (ifc_iccm_access_f1 & ifc_fetch_req_f1);\n', '         assign iccm_dma_rden      =  (ifc_dma_access_q_ok & dma_iccm_req & ~dma_mem_write)                     ;\n', '         assign iccm_wr_size[2:0]  =   {3{dma_iccm_req  & dma_mem_write}} &  dma_mem_sz[2:0] ;\n', '\n', '         rvecc_encode  iccm_ecc_encode0 (\n', '                           .din(dma_mem_wdata[31:0]),\n', '                           .ecc_out(dma_mem_ecc[6:0]));\n', '\n', '         rvecc_encode  iccm_ecc_encode1 (\n', '                           .din(dma_mem_wdata[63:32]),\n', '                           .ecc_out(dma_mem_ecc[13:7]));\n', '\n', '         assign iccm_wr_data[38:0]  =  (iccm_correct_ecc & ~(ifc_dma_access_q_ok & dma_iccm_req)) ?  iccm_ecc_corr_data_ff[38:0] :\n', '                                       {dma_mem_ecc[ 6:0],dma_mem_wdata[31:0]};\n', '         assign iccm_wr_data[77:39] =  (iccm_correct_ecc & ~(ifc_dma_access_q_ok & dma_iccm_req)) ?  iccm_ecc_corr_data_ff[38:0] :\n', '                                       {dma_mem_ecc[13:7],dma_mem_wdata[63:32]};\n', '\n', '         assign iccm_dma_rdata_in[63:0] =  iccm_dma_ecc_error_in ? {2{dma_mem_addr[31:0]}} : dma_select_upper ? {iccm_corrected_data[3], iccm_corrected_data[2]} : {iccm_corrected_data[1],iccm_corrected_data[0]};\n', '         assign iccm_dma_ecc_error_in   =  dma_select_upper ? |(iccm_double_ecc_error[3:2]) : |(iccm_double_ecc_error[1:0]);\n', '\n', '         rvdff #(1)           dma_addr_bt3_ff  (.*, .clk(free_clk), .din(dma_mem_addr[3]),         .dout(dma_select_upper));\n', '         rvdff #(1)           ccm_rdy_in_ff    (.*, .clk(free_clk), .din(iccm_dma_rden),           .dout(iccm_dma_rvalid_in));\n', '         rvdff #(1)           ccm_rdy_ff       (.*, .clk(free_clk), .din(iccm_dma_rvalid_in),      .dout(iccm_dma_rvalid));\n', '         rvdff #(1)           ccm_err_ff       (.*, .clk(free_clk), .din(iccm_dma_ecc_error_in),   .dout(iccm_dma_ecc_error));\n', '         rvdff #(64)          dma_data_ff      (.*, .clk(free_clk), .din(iccm_dma_rdata_in[63:0]), .dout(iccm_dma_rdata[63:0]));\n', '\n', '         assign iccm_rw_addr[ICCM_BITS-1:2]    = (  ifc_dma_access_q_ok & dma_iccm_req  & ~iccm_correct_ecc) ? dma_mem_addr[ICCM_BITS-1:2] :\n', '                                                 (~(ifc_dma_access_q_ok & dma_iccm_req) &  iccm_correct_ecc) ? iccm_ecc_corr_index_ff[ICCM_BITS-1:2] : fetch_addr_f1[ICCM_BITS-1:2] ;\n', '    `else\n', ""         assign iccm_dma_rvalid = 1'b0 ;\n"", ""         assign iccm_dma_ecc_error = 1'b0 ;\n"", ""         assign iccm_dma_rdata[63:0] = '0 ;\n"", '    `endif\n', '\n', '\n', '////// ICCM signals\n', '\n', 'assign   ic_rd_en    = ifc_fetch_req_f1 & ~ifc_fetch_uncacheable_f1;\n', '\n', 'assign ifu_tag_wren[0] = axi_w0_wren_last | w0_wren_reset_miss;\n', 'assign ifu_tag_wren[1] = axi_w1_wren_last | w1_wren_reset_miss;\n', 'assign ifu_tag_wren[2] = axi_w2_wren_last | w2_wren_reset_miss;\n', 'assign ifu_tag_wren[3] = axi_w3_wren_last | w3_wren_reset_miss;\n', 'assign ifu_wr_en_new   = axi_ifu_wr_en_new;\n', 'assign ifu_wr_en_new_q = axi_ifu_wr_en_new_q;\n', 'assign ifu_wr_data_new[63:0]=  axi_ifu_wr_data_new[63:0];\n', 'assign ic_wr_en[3:0]   =  axi_ic_wr_en[3:0];\n', 'assign ic_write_stall  = ifu_wr_en_new &  ~(((miss_state== CRIT_BYP_OK) & ~(ifu_wr_en_new & last_beat)));\n', '\n', '   rvdff #(1) reset_all_tag_ff (.*, .clk(active_clk),  .din(dec_tlu_fence_i_wb), .dout(reset_all_tags));\n', '\n', '\n', '\n', '///////////////////////////////////////////////////////////////\n', '// Icache status and LRU\n', '///////////////////////////////////////////////////////////////\n', '`ifdef RV_ICACHE_ENABLE\n', '   assign  ic_valid  = ~ifu_wr_cumulative_err_data & ~(reset_ic_in | reset_ic_ff) & ~reset_tag_valid_for_miss;\n', '\n', '   assign ifu_status_wr_addr_w_debug[ICACHE_TAG_HIGH-1:ICACHE_TAG_LOW] = ((ic_debug_rd_en | ic_debug_wr_en ) & ic_debug_tag_array) ?\n', '                                                                           ic_debug_addr[ICACHE_TAG_HIGH-1:ICACHE_TAG_LOW] :\n', '                                                                           ifu_status_wr_addr[ICACHE_TAG_HIGH-1:ICACHE_TAG_LOW];\n', '\n', '   // status\n', '         rvdff #(ICACHE_TAG_HIGH-ICACHE_TAG_LOW) status_wr_addr_ff (.*,  .clk(free_clk), .din(ifu_status_wr_addr_w_debug[ICACHE_TAG_HIGH-1:ICACHE_TAG_LOW]),\n', '                   .dout(ifu_status_wr_addr_ff[ICACHE_TAG_HIGH-1:ICACHE_TAG_LOW]));\n', '\n', '         assign way_status_wr_en_w_debug = way_status_wr_en | (ic_debug_wr_en  & ic_debug_tag_array);\n', '         rvdff #(1) status_wren_ff (.*, .clk(free_clk),  .din(way_status_wr_en_w_debug), .dout(way_status_wr_en_ff));\n', '\n', '         assign way_status_new_w_debug[2:0]  = (ic_debug_wr_en  & ic_debug_tag_array) ? ic_debug_wr_data[6:4] :\n', '                                                way_status_new[2:0] ;\n', '         rvdff #(3) status_data_ff (.*,  .clk(free_clk), .din(way_status_new_w_debug[2:0]), .dout(way_status_new_ff[2:0]));\n', '\n', '   logic [(ICACHE_TAG_DEPTH/8)-1 : 0] way_status_clken;\n', '   logic [(ICACHE_TAG_DEPTH/8)-1 : 0] way_status_clk;\n', '\n', '   genvar  j;\n', '   for (i=0 ; i<ICACHE_TAG_DEPTH/8 ; i++) begin : CLK_GRP_WAY_STATUS\n', '      assign way_status_clken[i] = (ifu_status_wr_addr_ff[ICACHE_TAG_HIGH-1:ICACHE_TAG_LOW+3] == i );\n', '\n', '\n', '`ifndef RV_FPGA_OPTIMIZE\n', '   rvclkhdr way_status_cgc ( .en(way_status_clken[i]),   .l1clk(way_status_clk[i]), .* );            // ifndef FPGA_OPTIMIZE\n', '`endif\n', '\n', '      for (j=0 ; j<8 ; j++) begin : WAY_STATUS\n', '\n', '         rvdffs_fpga #(3) ic_way_status (.*,\n', '                   .clk(way_status_clk[i]),\n', '                   .clken(way_status_clken[i]),\n', '                   .rawclk(clk),\n', '                   .en(((ifu_status_wr_addr_ff[ICACHE_TAG_LOW+2:ICACHE_TAG_LOW] == j) & way_status_wr_en_ff)),\n', '                   .din(way_status_new_ff[2:0]),\n', '                   .dout(way_status_out[8*i+j]));\n', '\n', '      end  // WAY_STATUS\n', '   end  // CLK_GRP_WAY_STATUS\n', '\n', '  always_comb begin : way_status_out_mux\n', ""      way_status[2:0] = 3'b0 ;\n"", '      for (int j=0; j< ICACHE_TAG_DEPTH; j++) begin : status_mux_loop\n', ""        if (ifu_ic_rw_int_addr_ff[ICACHE_TAG_HIGH-1:ICACHE_TAG_LOW] == (ICACHE_TAG_HIGH-ICACHE_TAG_LOW)'(j)) begin : mux_out\n"", '         way_status[2:0] =  way_status_out[j];\n', '        end\n', '      end\n', '  end\n', '\n', 'assign ifu_ic_rw_int_addr_w_debug[ICACHE_TAG_HIGH-1:ICACHE_TAG_LOW] = ((ic_debug_rd_en | ic_debug_wr_en ) & ic_debug_tag_array) ?\n', '                                                                        ic_debug_addr[ICACHE_TAG_HIGH-1:ICACHE_TAG_LOW] :\n', '                                                                        ifu_ic_rw_int_addr[ICACHE_TAG_HIGH-1:ICACHE_TAG_LOW];\n', '\n', '         rvdff #(ICACHE_TAG_HIGH-ICACHE_TAG_LOW) tag_addr_ff (.*, .clk(free_clk),\n', '                   .din(ifu_ic_rw_int_addr_w_debug[ICACHE_TAG_HIGH-1:ICACHE_TAG_LOW]),\n', '                   .dout(ifu_ic_rw_int_addr_ff[ICACHE_TAG_HIGH-1:ICACHE_TAG_LOW]));\n', '\n', '         assign ifu_tag_wren_w_debug[3:0] = ifu_tag_wren[3:0] | ic_debug_tag_wr_en[3:0] ;\n', '         rvdff #(4) tag_v_we_ff (.*, .clk(free_clk),\n', '                   .din(ifu_tag_wren_w_debug[3:0]),\n', '                   .dout(ifu_tag_wren_ff[3:0]));\n', '\n', '         assign ic_valid_w_debug = (ic_debug_wr_en & ic_debug_tag_array) ? ic_debug_wr_data[0] : ic_valid;\n', '         rvdff #(1) tag_v_ff (.*, .clk(free_clk),\n', '                   .din(ic_valid_w_debug),\n', '                   .dout(ic_valid_ff));\n', '\n', '   logic [3:0] [ICACHE_TAG_DEPTH-1:0] ic_tag_valid_out ;\n', '\n', '   logic [(ICACHE_TAG_DEPTH/32)-1:0]  tag_valid_w0_clken ;\n', '   logic [(ICACHE_TAG_DEPTH/32)-1:0]  tag_valid_w1_clken ;\n', '   logic [(ICACHE_TAG_DEPTH/32)-1:0]  tag_valid_w2_clken ;\n', '   logic [(ICACHE_TAG_DEPTH/32)-1:0]  tag_valid_w3_clken ;\n', '\n', '   logic [(ICACHE_TAG_DEPTH/32)-1:0]  tag_valid_w0_clk   ;\n', '   logic [(ICACHE_TAG_DEPTH/32)-1:0]  tag_valid_w1_clk   ;\n', '   logic [(ICACHE_TAG_DEPTH/32)-1:0]  tag_valid_w2_clk   ;\n', '   logic [(ICACHE_TAG_DEPTH/32)-1:0]  tag_valid_w3_clk   ;\n', '\n', '\n', '\n', '   for (i=0 ; i<ICACHE_TAG_DEPTH/32 ; i++) begin : CLK_GRP_TAG_VALID\n', '      assign tag_valid_w0_clken[i] = (((ifu_ic_rw_int_addr_ff[ICACHE_TAG_HIGH-1:ICACHE_TAG_LOW+5] == i ) &  ifu_tag_wren_ff[0] ) |\n', '                                      ((perr_ic_index_ff     [ICACHE_TAG_HIGH-1:ICACHE_TAG_LOW+5] == i ) &  perr_err_inv_way[0]) | reset_all_tags);\n', '      assign tag_valid_w1_clken[i] = (((ifu_ic_rw_int_addr_ff[ICACHE_TAG_HIGH-1:ICACHE_TAG_LOW+5] == i ) &  ifu_tag_wren_ff[1] ) |\n', '                                      ((perr_ic_index_ff     [ICACHE_TAG_HIGH-1:ICACHE_TAG_LOW+5] == i ) &  perr_err_inv_way[1]) | reset_all_tags);\n', '      assign tag_valid_w2_clken[i] = (((ifu_ic_rw_int_addr_ff[ICACHE_TAG_HIGH-1:ICACHE_TAG_LOW+5] == i ) &  ifu_tag_wren_ff[2] ) |\n', '                                      ((perr_ic_index_ff     [ICACHE_TAG_HIGH-1:ICACHE_TAG_LOW+5] == i ) &  perr_err_inv_way[2]) | reset_all_tags);\n', '      assign tag_valid_w3_clken[i] = (((ifu_ic_rw_int_addr_ff[ICACHE_TAG_HIGH-1:ICACHE_TAG_LOW+5] == i ) &  ifu_tag_wren_ff[3] ) |\n', '                                      ((perr_ic_index_ff     [ICACHE_TAG_HIGH-1:ICACHE_TAG_LOW+5] == i ) &  perr_err_inv_way[3]) | reset_all_tags);\n', '\n', '`ifndef RV_FPGA_OPTIMIZE\n', '      rvclkhdr way0_status_cgc ( .en(tag_valid_w0_clken[i]),   .l1clk(tag_valid_w0_clk[i]), .* );  // ifndef FPGA_OPTIMIZE\n', '      rvclkhdr way1_status_cgc ( .en(tag_valid_w1_clken[i]),   .l1clk(tag_valid_w1_clk[i]), .* );  // ifndef FPGA_OPTIMIZE\n', '      rvclkhdr way2_status_cgc ( .en(tag_valid_w2_clken[i]),   .l1clk(tag_valid_w2_clk[i]), .* );  // ifndef FPGA_OPTIMIZE\n', '      rvclkhdr way3_status_cgc ( .en(tag_valid_w3_clken[i]),   .l1clk(tag_valid_w3_clk[i]), .* );  // ifndef FPGA_OPTIMIZE\n', '`endif\n', '\n', '    for (j=0 ; j<32 ; j++) begin : TAG_VALID\n', '         rvdffs_fpga #(1) ic_way0_tagvalid_dup (.*,\n', '                   .clk(tag_valid_w0_clk[i]),\n', '                   .clken(tag_valid_w0_clken[i]),\n', '                   .rawclk(clk),\n', '                   .en(((ifu_ic_rw_int_addr_ff[ICACHE_TAG_LOW+4:ICACHE_TAG_LOW] == j) & ifu_tag_wren_ff[0] ) |\n', '                        ((perr_ic_index_ff     [ICACHE_TAG_LOW+4:ICACHE_TAG_LOW] == j) & perr_err_inv_way[0]) | reset_all_tags),\n', '                   .din(ic_valid_ff & ~reset_all_tags & ~perr_sel_invalidate),\n', '                   .dout(ic_tag_valid_out[0][32*i+j]));\n', '\n', '         rvdffs_fpga #(1) ic_way1_tagvalid_dup (.*,\n', '                   .clk(tag_valid_w1_clk[i]),\n', '                   .clken(tag_valid_w1_clken[i]),\n', '                   .rawclk(clk),\n', '                   .en(((ifu_ic_rw_int_addr_ff[ICACHE_TAG_LOW+4:ICACHE_TAG_LOW] == j) & ifu_tag_wren_ff[1] ) |\n', '                        ((perr_ic_index_ff     [ICACHE_TAG_LOW+4:ICACHE_TAG_LOW] == j) & perr_err_inv_way[1]) | reset_all_tags),\n', '                   .din(ic_valid_ff & ~reset_all_tags & ~perr_sel_invalidate),\n', '                   .dout(ic_tag_valid_out[1][32*i+j]));\n', '\n', '         rvdffs_fpga #(1) ic_way2_tagvalid_dup (.*,\n', '                   .clk(tag_valid_w2_clk[i]),\n', '                   .clken(tag_valid_w2_clken[i]),\n', '                   .rawclk(clk),\n', '                   .en(((ifu_ic_rw_int_addr_ff[ICACHE_TAG_LOW+4:ICACHE_TAG_LOW] == j) & ifu_tag_wren_ff[2] ) |\n', '                        ((perr_ic_index_ff     [ICACHE_TAG_LOW+4:ICACHE_TAG_LOW] == j) & perr_err_inv_way[2]) | reset_all_tags),\n', '                   .din(ic_valid_ff & ~reset_all_tags & ~perr_sel_invalidate),\n', '                   .dout(ic_tag_valid_out[2][32*i+j]));\n', '         rvdffs_fpga #(1) ic_way3_tagvalid_dup (.*,\n', '                   .clk(tag_valid_w3_clk[i]),\n', '                   .clken(tag_valid_w3_clken[i]),\n', '                   .rawclk(clk),\n', '                   .en(((ifu_ic_rw_int_addr_ff[ICACHE_TAG_LOW+4:ICACHE_TAG_LOW] == j) & ifu_tag_wren_ff[3] ) |\n', '                        ((perr_ic_index_ff     [ICACHE_TAG_LOW+4:ICACHE_TAG_LOW] == j) & perr_err_inv_way[3]) | reset_all_tags),\n', '                   .din(ic_valid_ff & ~reset_all_tags & ~perr_sel_invalidate),\n', '                   .dout(ic_tag_valid_out[3][32*i+j]));\n', '    end //TAG_VALID\n', '   end  // CLK_GRP_TAG_VALID\n', '  logic [3:0] ic_tag_valid_unq;\n', '  always_comb begin : tag_valid_out_mux\n', ""      ic_tag_valid_unq[3:0] = 4'b0 ;\n"", '      for (int j=0; j< ICACHE_TAG_DEPTH; j++) begin : tag_valid_loop\n', ""        if (ifu_ic_rw_int_addr_ff[ICACHE_TAG_HIGH-1:ICACHE_TAG_LOW] == (ICACHE_TAG_HIGH-ICACHE_TAG_LOW)'(j)) begin : valid_out\n"", '         ic_tag_valid_unq[3:0] =  {ic_tag_valid_out[3][j] , ic_tag_valid_out[2][j] , ic_tag_valid_out[1][j], ic_tag_valid_out[0][j]};\n', '        end\n', '      end\n', '  end\n', '\n', '`else\n', '  logic [3:0] ic_tag_valid_unq;\n', ""  assign ic_tag_valid_unq[3:0] = '0 ;\n"", ""  assign way_status[2:0]       = '0 ;\n"", '`endif\n', '\n', '   assign ic_tag_valid[3:0] = ic_tag_valid_unq[3:0] & {4{(~fetch_uncacheable_ff & ifc_fetch_req_f2) }} ;\n', '   assign ic_debug_tag_val_rd_out = |(ic_tag_valid_unq[3:0] &  ic_debug_way_ff[3:00] & {4{ic_debug_rd_en_ff}}) ;\n', '///////////////////////////////////////////\n', '// PMU signals\n', '///////////////////////////////////////////\n', '\n', ' assign ifu_pmu_ic_miss_in   = ic_act_miss_f2 ;\n', ' assign ifu_pmu_ic_hit_in    = ic_act_hit_f2  ;\n', ' assign ifu_pmu_bus_error_in = |ifc_bus_acc_fault_f2;\n', ' assign ifu_pmu_bus_trxn_in  = axi_cmd_sent ;\n', ' assign ifu_pmu_bus_busy_in  = ifu_axi_arvalid_ff & ~ifu_axi_arready_ff & miss_pending ;\n', '\n', '   rvdff #(5) ifu_pmu_sigs_ff (.*,\n', '                    .clk (active_clk),\n', '                    .din ({ifu_pmu_ic_miss_in,\n', '                           ifu_pmu_ic_hit_in,\n', '                           ifu_pmu_bus_error_in,\n', '                           ifu_pmu_bus_busy_in,\n', '                           ifu_pmu_bus_trxn_in\n', '                          }),\n', '                    .dout({ifu_pmu_ic_miss,\n', '                           ifu_pmu_ic_hit,\n', '                           ifu_pmu_bus_error,\n', '                           ifu_pmu_bus_busy,\n', '                           ifu_pmu_bus_trxn\n', '                           }));\n', '\n', '\n', '///////////////////////////////////////////////////////\n', '// Cache debug logic                                 //\n', '///////////////////////////////////////////////////////\n', 'logic ic_debug_ic_array_sel_word0_in;\n', 'logic ic_debug_ic_array_sel_word1_in;\n', 'logic ic_debug_ic_array_sel_word2_in;\n', 'logic ic_debug_ic_array_sel_word3_in;\n', '\n', 'logic ic_debug_ic_array_sel_word0   ;\n', 'logic ic_debug_ic_array_sel_word1   ;\n', 'logic ic_debug_ic_array_sel_word2   ;\n', 'logic ic_debug_ic_array_sel_word3   ;\n', '\n', '\n', '\n', 'assign ic_debug_addr[15:02]     = dec_tlu_ic_diag_pkt.icache_dicawics[15:2] ;\n', 'assign ic_debug_way_enc[01:00]  = dec_tlu_ic_diag_pkt.icache_dicawics[17:16] ;\n', '\n', '`ifdef RV_ICACHE_ECC\n', 'assign ic_debug_wr_data[41:0]   = dec_tlu_ic_diag_pkt.icache_wrdata[41:0] ;\n', '`else\n', 'assign ic_debug_wr_data[33:0]   = dec_tlu_ic_diag_pkt.icache_wrdata[33:0] ;\n', '`endif\n', '\n', 'assign ic_debug_tag_array       = dec_tlu_ic_diag_pkt.icache_dicawics[18] ;\n', 'assign ic_debug_rd_en           = dec_tlu_ic_diag_pkt.icache_rd_valid ;\n', 'assign ic_debug_wr_en           = dec_tlu_ic_diag_pkt.icache_wr_valid ;\n', '\n', '\n', ""assign ic_debug_way[3:0]        = {(ic_debug_way_enc[1:0] == 2'b11),\n"", ""                                   (ic_debug_way_enc[1:0] == 2'b10),\n"", ""                                   (ic_debug_way_enc[1:0] == 2'b01),\n"", ""                                   (ic_debug_way_enc[1:0] == 2'b00) };\n"", '\n', 'assign ic_debug_tag_wr_en[3:0] = {4{ic_debug_wr_en & ic_debug_tag_array}} & ic_debug_way[3:0] ;\n', '\n', ""assign ic_debug_ic_array_sel_word0_in = (ic_debug_addr[3:2] == 2'b00) & ic_debug_rd_en & ~ic_debug_tag_array ;\n"", ""assign ic_debug_ic_array_sel_word1_in = (ic_debug_addr[3:2] == 2'b01) & ic_debug_rd_en & ~ic_debug_tag_array ;\n"", ""assign ic_debug_ic_array_sel_word2_in = (ic_debug_addr[3:2] == 2'b10) & ic_debug_rd_en & ~ic_debug_tag_array ;\n"", ""assign ic_debug_ic_array_sel_word3_in = (ic_debug_addr[3:2] == 2'b11) & ic_debug_rd_en & ~ic_debug_tag_array ;\n"", 'assign ic_debug_ict_array_sel_in      =  ic_debug_rd_en & ic_debug_tag_array ;\n', '\n', 'rvdffe #(09) ifu_debug_sel_ff (.*,\n', '                    .en (debug_c1_clken),\n', '                    .din ({ic_debug_ic_array_sel_word0_in,\n', '                           ic_debug_ic_array_sel_word1_in,\n', '                           ic_debug_ic_array_sel_word2_in,\n', '                           ic_debug_ic_array_sel_word3_in,\n', '                           ic_debug_ict_array_sel_in,\n', '                           ic_debug_way[3:0]\n', '                          }),\n', '                    .dout({ic_debug_ic_array_sel_word0,\n', '                           ic_debug_ic_array_sel_word1,\n', '                           ic_debug_ic_array_sel_word2,\n', '                           ic_debug_ic_array_sel_word3,\n', '                           ic_debug_ict_array_sel_ff,\n', '                           ic_debug_way_ff[3:0]\n', '                           }));\n', '\n', '\n', 'rvdff #(1) ifu_debug_rd_en_ff (.*,.clk(free_clk),\n', '                    .din ({\n', '                           ic_debug_rd_en\n', '                          }),\n', '                    .dout({\n', '                           ic_debug_rd_en_ff\n', '                           }));\n', '\n', '\n', '`ifdef RV_ICACHE_ECC\n', 'logic [41:0] ifu_ic_debug_rd_data_in   ;\n', ""assign ifu_ic_debug_rd_data_in[41:0] = ( {42{ic_debug_ict_array_sel_ff   }} &  {5'b0,ictag_debug_rd_data[24:20], ictag_debug_rd_data[19:0] ,5'b0, way_status[2:0], 3'b0, ic_debug_tag_val_rd_out} ) |\n"", '                                       ( {42{ic_debug_ic_array_sel_word0 }} &  {ic_rd_data [41:0]}  )  |\n', '                                       ( {42{ic_debug_ic_array_sel_word1 }} &  {ic_rd_data [83:42]} )  |\n', '                                       ( {42{ic_debug_ic_array_sel_word2 }} &  {ic_rd_data [125:84]})  |\n', '                                       ( {42{ic_debug_ic_array_sel_word3 }} &  {ic_rd_data [167:126]}) ;\n', '\n', 'rvdffe #(42) ifu_debug_data_ff (.*,\n', '                    .en (debug_data_clken),\n', '                    .din ({\n', '                           ifu_ic_debug_rd_data_in[41:0]\n', '                          }),\n', '                    .dout({\n', '                           ifu_ic_debug_rd_data\n', '                           }));\n', '\n', '`else\n', 'logic [33:0] ifu_ic_debug_rd_data_in   ;\n', ""assign ifu_ic_debug_rd_data_in[33:0] = ( {34{ic_debug_ict_array_sel_ff   }} &  {1'b0,ictag_debug_rd_data[20], ictag_debug_rd_data[19:0] ,5'b0, way_status[2:0], 3'b0, ic_debug_tag_val_rd_out} ) |\n"", '                                       ( {34{ic_debug_ic_array_sel_word0 }} &  {ic_rd_data [33:0]}  )  |\n', '                                       ( {34{ic_debug_ic_array_sel_word1 }} &  {ic_rd_data [67:34]} )  |\n', '                                       ( {34{ic_debug_ic_array_sel_word2 }} &  {ic_rd_data [101:68]})  |\n', '                                       ( {34{ic_debug_ic_array_sel_word3 }} &  {ic_rd_data [135:102]}) ;\n', '\n', 'rvdffe #(34) ifu_debug_data_ff (.*,\n', '                    .en (debug_data_clken),\n', '                    .din ({\n', '                           ifu_ic_debug_rd_data_in[33:0]\n', '                          }),\n', '                    .dout({\n', '                           ifu_ic_debug_rd_data\n', '                           }));\n', '\n', '`endif\n', '\n', 'assign debug_data_clken  =  ic_debug_rd_en_ff;\n', '\n', 'rvdff #(1) ifu_debug_valid_ff (.*, .clk(free_clk),\n', '                    .din ({\n', '                           ic_debug_rd_en_ff\n', '                          }),\n', '                    .dout({\n', '                           ifu_ic_debug_rd_data_valid\n', '                           }));\n', '\n', '// memory protection\n', '   assign ifc_region_acc_okay           =  (~(|{`RV_INST_ACCESS_ENABLE0,`RV_INST_ACCESS_ENABLE1,`RV_INST_ACCESS_ENABLE2,`RV_INST_ACCESS_ENABLE3,`RV_INST_ACCESS_ENABLE4,`RV_INST_ACCESS_ENABLE5,`RV_INST_ACCESS_ENABLE6,`RV_INST_ACCESS_ENABLE7})) |\n', ""                                           (`RV_INST_ACCESS_ENABLE0 & (({fetch_addr_f1[31:1],1'b0} | `RV_INST_ACCESS_MASK0) == (`RV_INST_ACCESS_ADDR0 | `RV_INST_ACCESS_MASK0))) |\n"", ""                                           (`RV_INST_ACCESS_ENABLE1 & (({fetch_addr_f1[31:1],1'b0} | `RV_INST_ACCESS_MASK1) == (`RV_INST_ACCESS_ADDR1 | `RV_INST_ACCESS_MASK1))) |\n"", ""                                           (`RV_INST_ACCESS_ENABLE2 & (({fetch_addr_f1[31:1],1'b0} | `RV_INST_ACCESS_MASK2) == (`RV_INST_ACCESS_ADDR2 | `RV_INST_ACCESS_MASK2))) |\n"", ""                                           (`RV_INST_ACCESS_ENABLE3 & (({fetch_addr_f1[31:1],1'b0} | `RV_INST_ACCESS_MASK3) == (`RV_INST_ACCESS_ADDR3 | `RV_INST_ACCESS_MASK3))) |\n"", ""                                           (`RV_INST_ACCESS_ENABLE4 & (({fetch_addr_f1[31:1],1'b0} | `RV_INST_ACCESS_MASK4) == (`RV_INST_ACCESS_ADDR4 | `RV_INST_ACCESS_MASK4))) |\n"", ""                                           (`RV_INST_ACCESS_ENABLE5 & (({fetch_addr_f1[31:1],1'b0} | `RV_INST_ACCESS_MASK5) == (`RV_INST_ACCESS_ADDR5 | `RV_INST_ACCESS_MASK5))) |\n"", ""                                           (`RV_INST_ACCESS_ENABLE6 & (({fetch_addr_f1[31:1],1'b0} | `RV_INST_ACCESS_MASK6) == (`RV_INST_ACCESS_ADDR6 | `RV_INST_ACCESS_MASK6))) |\n"", ""                                           (`RV_INST_ACCESS_ENABLE7 & (({fetch_addr_f1[31:1],1'b0} | `RV_INST_ACCESS_MASK7) == (`RV_INST_ACCESS_ADDR7 | `RV_INST_ACCESS_MASK7)));\n"", '\n', '   assign ifc_region_acc_fault_memory   =  ~ifc_iccm_access_f1 & ~ifc_region_acc_okay & ifc_fetch_req_f1;\n', '\n', '   assign ifc_region_acc_fault_final_f1 = ifc_region_acc_fault_f1 | ifc_region_acc_fault_memory;\n', '\n', '\n', '\n', '\n', '\n', '////////////////////////////////////////////////////////////////////////////////////\n', '////////////////////////////////////////////////////////////////////////////////////\n', '///  Assertions , Assertions , Assertions , Assertions , Assertions , Assertions ///\n', '////////////////////////////////////////////////////////////////////////////////////\n', '////////////////////////////////////////////////////////////////////////////////////\n', '`ifdef ASSERT_ON\n', '   assert_hit_miss_one_z_hot: assert #0 ($onehot0({ic_iccm_hit_f2,ic_byp_hit_f2,ic_act_hit_f2,ic_act_miss_f2,ic_miss_under_miss_f2}));\n', '\n', '   property fetch_stall;\n', '     @(posedge clk) disable iff(~rst_l) (ic_debug_rd_en | ic_debug_wr_en | ic_dma_active | ic_write_stall)  |->  ~ifc_fetch_req_f1;\n', '   endproperty\n', '   assert_fetch_stall: assert property (fetch_stall) else\n', '     $display(""Assertion fetch_stall: ic_debug_rd_en=1\'b%b, ic_debug_wr_en=1\'b%b,  ic_dma_active=1\'b%b,  ic_write_stall=1\'b%b"",ic_debug_rd_en,ic_debug_wr_en, ic_dma_active, ic_write_stall);\n', '\n', '\n', '   assert_perr_one_z_hot: assert #0 ($onehot0({ifu_icache_error_val,ifu_icache_sb_error_val}));\n', '\n', '`endif\n', '\n', 'endmodule  // ifu_mem_ctl\n']"
"['// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '\n', '//********************************************************************************\n', '// $Id$\n', '//\n', '//\n', '// Function: Top level file for load store unit\n', '// Comments:\n', '//\n', '//\n', '// DC1 -> DC2 -> DC3 -> DC4 (Commit)\n', '//\n', '//********************************************************************************\n', '\n', 'module lsu\n', '   import veer_types::*;\n', '(\n', '\n', '   input logic [31:0]                      i0_result_e4_eff, // I0 e4 result for e4 -> dc3 store forwarding\n', '   input logic [31:0]                      i1_result_e4_eff, // I1 e4 result for e4 -> dc3 store forwarding\n', '   input logic [31:0]                      i0_result_e2,     // I0 e2 result for e2 -> dc2 store forwarding\n', '\n', '   input logic                             flush_final_e3,    // I0/I1 flush in e3\n', '   input logic                             i0_flush_final_e3, // I0 flush in e3\n', '   input logic                             dec_tlu_flush_lower_wb,    // I0/I1 writeback flush. This is used to flush the old packets only\n', ""   input logic                             dec_tlu_i0_kill_writeb_wb, // I0 is flushed, don't writeback any results to arch state\n"", ""   input logic                             dec_tlu_i1_kill_writeb_wb, // I1 is flushed, don't writeback any results to arch state\n"", '   input logic                             dec_tlu_cancel_e4,         // cancel the bus load in dc4 and reset the freeze\n', '\n', '   // chicken signals\n', '   input logic                             dec_tlu_dccm_nonblock_dma_disable, // disable dma nonblock\n', '   input logic                             dec_tlu_wb_coalescing_disable,   // disable the write buffer coalesce\n', '   input logic                             dec_tlu_ld_miss_byp_wb_disable,  // disable the miss bypass in the write buffer\n', '   input logic                             dec_tlu_sideeffect_posted_disable,  // disable posted writes to sideeffect addr to the bus\n', '   input logic                             dec_tlu_core_ecc_disable,        // disable the generation of the ecc\n', '\n', '   input logic [31:0]                      exu_lsu_rs1_d,      // address rs operand\n', '   input logic [31:0]                      exu_lsu_rs2_d,      // store data\n', '   input logic [11:0]                      dec_lsu_offset_d,   // address offset operand\n', '\n', '   input                                   lsu_pkt_t lsu_p,     // lsu control packet\n', '   input logic                             dec_i0_lsu_decode_d, // lsu is in i0\n', '   input logic [31:0]                      dec_tlu_mrac_ff,     // CSR for memory region control\n', '\n', '   output logic [31:0]                     lsu_result_dc3,      // lsu load data\n', '   output logic                            lsu_single_ecc_error_incr,     // Increment the counter for Single ECC error\n', '   output logic [31:0]                     lsu_result_corr_dc4, // This is the ECC corrected data going to RF\n', '   output logic                            lsu_freeze_dc3,      // lsu freeze due to load to external\n', '   output logic                            lsu_load_stall_any, // This is for blocking loads in the decode\n', '   output logic                            lsu_store_stall_any, // This is for blocking stores in the decode\n', ""   output logic                            lsu_load_ecc_stbuf_full_dc3, // Load with ecc error can't allocate to stbuf\n"", '   output logic                            lsu_idle_any,        // lsu buffers are empty and no instruction in the pipeline\n', '   output logic                            lsu_halt_idle_any,   // This is used to enter halt mode. Exclude DMA\n', '\n', '   output lsu_error_pkt_t                  lsu_error_pkt_dc3,             // lsu exception packet\n', '   output logic                            lsu_freeze_external_ints_dc3,  // freeze due to sideeffects loads need to suppress external interrupt\n', '   output logic                            lsu_imprecise_error_load_any,  // bus load imprecise error\n', '   output logic                            lsu_imprecise_error_store_any, // bus store imprecise error\n', '   output logic [31:0]                     lsu_imprecise_error_addr_any,  // bus store imprecise error address\n', '\n', '   // Non-blocking loads\n', '   input  logic                                 dec_nonblock_load_freeze_dc2,   //\n', '   output logic                                 lsu_nonblock_load_valid_dc3,    // there is an external load -> put in the cam\n', '   output logic [`RV_LSU_NUM_NBLOAD_WIDTH-1:0]  lsu_nonblock_load_tag_dc3,      // the tag of the external non block load\n', '   output logic                                 lsu_nonblock_load_inv_dc5,      // invalidate signal for the cam entry for non block loads\n', '   output logic [`RV_LSU_NUM_NBLOAD_WIDTH-1:0]  lsu_nonblock_load_inv_tag_dc5,  // tag of the enrty which needs to be invalidated\n', '   output logic                                 lsu_nonblock_load_data_valid,   // the non block is valid - sending information back to the cam\n', '   output logic                                 lsu_nonblock_load_data_error,   // non block load has an error\n', '   output logic [`RV_LSU_NUM_NBLOAD_WIDTH-1:0]  lsu_nonblock_load_data_tag,     // the tag of the non block load sending the data/error\n', '   output logic [31:0]                          lsu_nonblock_load_data,         // Data of the non block load\n', '\n', '   output logic                            lsu_pmu_misaligned_dc3,         // PMU : misaligned\n', '   output logic                            lsu_pmu_bus_trxn,               // PMU : bus transaction\n', '   output logic                            lsu_pmu_bus_misaligned,         // PMU : misaligned access going to the bus\n', '   output logic                            lsu_pmu_bus_error,              // PMU : bus sending error back\n', '   output logic                            lsu_pmu_bus_busy,               // PMU : bus is not ready\n', '\n', '   // Trigger signals\n', '   input                                   trigger_pkt_t [3:0] trigger_pkt_any, // Trigger info from the decode\n', '   output logic [3:0]                      lsu_trigger_match_dc3,               // lsu trigger hit (one bit per trigger)\n', '\n', '   // DCCM ports\n', '   output logic                            dccm_wren,       // DCCM write enable\n', '   output logic                            dccm_rden,       // DCCM read enable\n', '   output logic [`RV_DCCM_BITS-1:0]        dccm_wr_addr,    // DCCM write address (write can happen to one bank only)\n', '   output logic [`RV_DCCM_BITS-1:0]        dccm_rd_addr_lo, // DCCM read address low bank\n', '   output logic [`RV_DCCM_BITS-1:0]        dccm_rd_addr_hi, // DCCM read address hi bank (hi and low same if aligned read)\n', '   output logic [`RV_DCCM_FDATA_WIDTH-1:0] dccm_wr_data,    // DCCM write data (this is always aligned)\n', '\n', '   input logic [`RV_DCCM_FDATA_WIDTH-1:0]  dccm_rd_data_lo, // DCCM read data low bank\n', '   input logic [`RV_DCCM_FDATA_WIDTH-1:0]  dccm_rd_data_hi, // DCCM read data hi bank\n', '\n', '   // PIC ports\n', '   output logic                            picm_wren,    // PIC memory write enable\n', '   output logic                            picm_rden,    // PIC memory read enable\n', '   output logic                            picm_mken,    // Need to read the mask for stores to determine which bits to write/forward\n', '   output logic [31:0]                     picm_addr,    // PIC memory address\n', '   output logic [31:0]                     picm_wr_data, // PIC memory write data\n', '   input logic [31:0]                      picm_rd_data, // PIC memory read/mask data\n', '\n', '   // AXI Write Channels\n', '   output logic                            lsu_axi_awvalid,\n', '   input  logic                            lsu_axi_awready,\n', '   output logic [`RV_LSU_BUS_TAG-1:0]      lsu_axi_awid,\n', '   output logic [31:0]                     lsu_axi_awaddr,\n', '   output logic [3:0]                      lsu_axi_awregion,\n', '   output logic [7:0]                      lsu_axi_awlen,\n', '   output logic [2:0]                      lsu_axi_awsize,\n', '   output logic [1:0]                      lsu_axi_awburst,\n', '   output logic                            lsu_axi_awlock,\n', '   output logic [3:0]                      lsu_axi_awcache,\n', '   output logic [2:0]                      lsu_axi_awprot,\n', '   output logic [3:0]                      lsu_axi_awqos,\n', '\n', '   output logic                            lsu_axi_wvalid,\n', '   input  logic                            lsu_axi_wready,\n', '   output logic [63:0]                     lsu_axi_wdata,\n', '   output logic [7:0]                      lsu_axi_wstrb,\n', '   output logic                            lsu_axi_wlast,\n', '\n', '   input  logic                            lsu_axi_bvalid,\n', '   output logic                            lsu_axi_bready,\n', '   input  logic [1:0]                      lsu_axi_bresp,\n', '   input  logic [`RV_LSU_BUS_TAG-1:0]      lsu_axi_bid,\n', '\n', '   // AXI Read Channels\n', '   output logic                            lsu_axi_arvalid,\n', '   input  logic                            lsu_axi_arready,\n', '   output logic [`RV_LSU_BUS_TAG-1:0]      lsu_axi_arid,\n', '   output logic [31:0]                     lsu_axi_araddr,\n', '   output logic [3:0]                      lsu_axi_arregion,\n', '   output logic [7:0]                      lsu_axi_arlen,\n', '   output logic [2:0]                      lsu_axi_arsize,\n', '   output logic [1:0]                      lsu_axi_arburst,\n', '   output logic                            lsu_axi_arlock,\n', '   output logic [3:0]                      lsu_axi_arcache,\n', '   output logic [2:0]                      lsu_axi_arprot,\n', '   output logic [3:0]                      lsu_axi_arqos,\n', '\n', '   input  logic                            lsu_axi_rvalid,\n', '   output logic                            lsu_axi_rready,\n', '   input  logic [`RV_LSU_BUS_TAG-1:0]      lsu_axi_rid,\n', '   input  logic [63:0]                     lsu_axi_rdata,\n', '   input  logic [1:0]                      lsu_axi_rresp,\n', '   input  logic                            lsu_axi_rlast,\n', '\n', '   input logic                             lsu_bus_clk_en,    // external drives a clock_en to control bus ratio\n', '\n', '   // DMA slave\n', '   input logic                             dma_dccm_req,       // DMA read/write to dccm\n', '   input logic [31:0]                      dma_mem_addr,       // DMA address\n', '   input logic [2:0]                       dma_mem_sz,         // DMA access size\n', '   input logic                             dma_mem_write,      // DMA access is a write\n', '   input logic [63:0]                      dma_mem_wdata,      // DMA write data\n', '\n', '   output logic                            dccm_dma_rvalid,     // lsu data valid for DMA dccm read\n', '   output logic                            dccm_dma_ecc_error,  // DMA load had ecc error\n', '   output logic [63:0]                     dccm_dma_rdata,      // lsu data for DMA dccm read\n', '   output logic                            dccm_ready,          // lsu ready for DMA access\n', '\n', '   input logic                             clk_override,        // Disable clock gating\n', '   input logic                             scan_mode,           // scan\n', '   input logic                             clk,\n', '   input logic                             free_clk,\n', '   input logic                             rst_l\n', '\n', '   );\n', '\n', '\n', '`include ""global.h""\n', '\n', '   logic        lsu_dccm_rden_dc3;\n', '   logic [63:0] store_data_dc2;\n', '   logic [63:0] store_data_dc3;\n', '   logic [31:0] store_data_dc4;\n', '   logic [31:0] store_data_dc5;\n', '   logic [31:0] store_ecc_datafn_hi_dc3;\n', '   logic [31:0] store_ecc_datafn_lo_dc3;\n', '\n', '   logic        single_ecc_error_hi_dc3, single_ecc_error_lo_dc3;\n', '   logic        lsu_single_ecc_error_dc3, lsu_single_ecc_error_dc4, lsu_single_ecc_error_dc5;\n', '   logic        lsu_double_ecc_error_dc3;\n', '\n', '   logic [31:0] dccm_data_hi_dc3;\n', '   logic [31:0] dccm_data_lo_dc3;\n', '   logic [6:0]  dccm_data_ecc_hi_dc3;\n', '   logic [6:0]  dccm_data_ecc_lo_dc3;\n', '\n', '   logic [31:0] lsu_ld_data_dc3;\n', '   logic [31:0] lsu_ld_data_corr_dc3;\n', '   logic [31:0] picm_mask_data_dc3;\n', '\n', '   logic [31:0] lsu_addr_dc1, lsu_addr_dc2, lsu_addr_dc3, lsu_addr_dc4, lsu_addr_dc5;\n', '   logic [31:0] end_addr_dc1, end_addr_dc2, end_addr_dc3, end_addr_dc4, end_addr_dc5;\n', '\n', '   lsu_pkt_t    lsu_pkt_dc1, lsu_pkt_dc2, lsu_pkt_dc3, lsu_pkt_dc4, lsu_pkt_dc5;\n', '   logic        lsu_i0_valid_dc1, lsu_i0_valid_dc2, lsu_i0_valid_dc3, lsu_i0_valid_dc4, lsu_i0_valid_dc5;\n', '\n', '   // Store Buffer signals\n', '   logic        isldst_dc1, dccm_ldst_dc2, dccm_ldst_dc3;\n', '   logic        store_stbuf_reqvld_dc3;\n', '   logic        load_stbuf_reqvld_dc3;\n', '   logic        ldst_stbuf_reqvld_dc3;\n', '   logic        lsu_commit_dc5;\n', '   logic        lsu_exc_dc2;\n', '\n', '   logic        addr_in_dccm_dc1, addr_in_dccm_dc2, addr_in_dccm_dc3;\n', '   logic        addr_in_pic_dc1, addr_in_pic_dc2, addr_in_pic_dc3;\n', '   logic        addr_external_dc2, addr_external_dc3, addr_external_dc4, addr_external_dc5;\n', '\n', '   logic                       stbuf_reqvld_any;\n', '   logic                       stbuf_reqvld_flushed_any;\n', '   logic                       stbuf_addr_in_pic_any;\n', '   logic [DCCM_BYTE_WIDTH-1:0] stbuf_byteen_any;\n', '   logic [LSU_SB_BITS-1:0]     stbuf_addr_any;\n', '   logic [DCCM_DATA_WIDTH-1:0] stbuf_data_any;\n', '   logic [(DCCM_FDATA_WIDTH-DCCM_DATA_WIDTH-1):0] stbuf_ecc_any;\n', '\n', '   logic                       lsu_cmpen_dc2;\n', '   logic [DCCM_DATA_WIDTH-1:0] stbuf_fwddata_hi_dc3;\n', '   logic [DCCM_DATA_WIDTH-1:0] stbuf_fwddata_lo_dc3;\n', '   logic [DCCM_BYTE_WIDTH-1:0] stbuf_fwdbyteen_hi_dc3;\n', '   logic [DCCM_BYTE_WIDTH-1:0] stbuf_fwdbyteen_lo_dc3;\n', '\n', '   logic        lsu_stbuf_commit_any;\n', '   logic        lsu_stbuf_empty_any;\n', '   logic        lsu_stbuf_nodma_empty_any;   // Store Buffer is empty except dma writes\n', '   logic        lsu_stbuf_full_any;\n', '\n', '    // Bus signals\n', '   logic        lsu_busreq_dc5;\n', '   logic        lsu_bus_buffer_pend_any;\n', '   logic        lsu_bus_buffer_empty_any;\n', '   logic        lsu_bus_buffer_full_any;\n', '   logic        lsu_busreq_dc2;\n', '   logic [31:0] bus_read_data_dc3;\n', '   logic        ld_bus_error_dc3;\n', '   logic [31:0] ld_bus_error_addr_dc3;\n', '\n', '   logic        flush_dc2_up, flush_dc3, flush_dc4, flush_dc5, flush_prior_dc5;\n', '   logic        is_sideeffects_dc2, is_sideeffects_dc3;\n', '   logic        ldst_nodma_dc1todc3;\n', '\n', '\n', '   // Clocks\n', '   logic        lsu_c1_dc3_clk, lsu_c1_dc4_clk, lsu_c1_dc5_clk;\n', '   logic        lsu_c2_dc3_clk, lsu_c2_dc4_clk, lsu_c2_dc5_clk;\n', '   logic        lsu_freeze_c1_dc2_clk, lsu_freeze_c1_dc3_clk;\n', '   logic        lsu_freeze_c1_dc1_clken, lsu_freeze_c1_dc2_clken, lsu_freeze_c1_dc3_clken;\n', '   logic        lsu_freeze_c2_dc1_clken, lsu_freeze_c2_dc2_clken, lsu_freeze_c2_dc3_clken, lsu_freeze_c2_dc4_clken;\n', '   logic        lsu_store_c1_dc1_clken, lsu_store_c1_dc2_clken, lsu_store_c1_dc3_clken, lsu_store_c1_dc4_clk, lsu_store_c1_dc5_clk;\n', '\n', '   logic        lsu_freeze_c2_dc1_clk, lsu_freeze_c2_dc2_clk, lsu_freeze_c2_dc3_clk, lsu_freeze_c2_dc4_clk;\n', '   logic        lsu_stbuf_c1_clk;\n', '   logic        lsu_bus_ibuf_c1_clk, lsu_bus_obuf_c1_clk, lsu_bus_buf_c1_clk;\n', '   logic        lsu_dccm_c1_dc3_clk, lsu_dccm_c1_dc3_clken, lsu_pic_c1_dc3_clken;\n', '   logic        lsu_busm_clk;\n', '   logic        lsu_free_c2_clk;\n', '\n', '\n', '   lsu_lsc_ctl lsu_lsc_ctl(.*);\n', '\n', '   // block stores in decode  - for either bus or stbuf reasons\n', '   assign lsu_store_stall_any = lsu_stbuf_full_any | lsu_bus_buffer_full_any;\n', '   assign lsu_load_stall_any  = lsu_bus_buffer_full_any;\n', '\n', '   // Ready to accept dma trxns\n', ""   // There can't be any inpipe forwarding from non-dma packet to dma packet since they can be flushed so we can't have ld/st in dc3-dc5 when dma is in dc2\n"", '   assign ldst_nodma_dc1todc3 = (lsu_pkt_dc1.valid & ~lsu_pkt_dc1.dma) | (lsu_pkt_dc2.valid & ~lsu_pkt_dc2.dma) | (lsu_pkt_dc3.valid & ~lsu_pkt_dc3.dma);\n', '   assign dccm_ready = ~(lsu_p.valid | lsu_stbuf_full_any | lsu_freeze_dc3 | ldst_nodma_dc1todc3);\n', '\n', '   // Generate per cycle flush signals\n', '   assign flush_dc2_up = flush_final_e3 | i0_flush_final_e3 | dec_tlu_flush_lower_wb;\n', '   assign flush_dc3    = (flush_final_e3 & i0_flush_final_e3) | dec_tlu_flush_lower_wb;\n', '   assign flush_dc4    = dec_tlu_flush_lower_wb;\n', '   assign flush_dc5    = (dec_tlu_i0_kill_writeb_wb | (dec_tlu_i1_kill_writeb_wb & ~lsu_i0_valid_dc5));\n', '   assign flush_prior_dc5 = dec_tlu_i0_kill_writeb_wb & ~lsu_i0_valid_dc5;    // Flush is due to i0 instruction and ld/st is in i1\n', '\n', '   // lsu idle\n', '   assign lsu_idle_any = ~(lsu_pkt_dc1.valid | lsu_pkt_dc2.valid | lsu_pkt_dc3.valid | lsu_pkt_dc4.valid | lsu_pkt_dc5.valid) &\n', '                         lsu_bus_buffer_empty_any & lsu_stbuf_empty_any;\n', '\n', '   // lsu halt idle. This is used for entering the halt mode\n', '   // Indicates non-idle if there is a instruction valid in dc1-dc5 or read/write buffers are non-empty since they can come with error\n', '   // Need to make sure bus trxns are done and there are no non-dma writes in store buffer\n', '   assign lsu_halt_idle_any = ~((lsu_pkt_dc1.valid & ~lsu_pkt_dc1.dma) |\n', '                                (lsu_pkt_dc2.valid & ~lsu_pkt_dc2.dma) |\n', '                                (lsu_pkt_dc3.valid & ~lsu_pkt_dc3.dma) |\n', '                                (lsu_pkt_dc4.valid & ~lsu_pkt_dc4.dma) |\n', '                                (lsu_pkt_dc5.valid & ~lsu_pkt_dc5.dma)) &\n', '                               lsu_bus_buffer_empty_any & lsu_stbuf_nodma_empty_any;\n', '\n', '   // Instantiate the store buffer\n', '   //assign ldst_stbuf_reqvld_dc3  = store_stbuf_reqvld_dc3 | load_stbuf_reqvld_dc3;\n', '   assign store_stbuf_reqvld_dc3 = lsu_pkt_dc3.valid & lsu_pkt_dc3.store & (addr_in_dccm_dc3 | addr_in_pic_dc3) & (~flush_dc3 | lsu_pkt_dc3.dma) & ~lsu_freeze_dc3;\n', '   assign load_stbuf_reqvld_dc3  = lsu_pkt_dc3.valid & lsu_pkt_dc3.load  & (addr_in_dccm_dc3 | addr_in_pic_dc3) & lsu_single_ecc_error_dc3 & (~flush_dc3 | lsu_pkt_dc3.dma) & ~lsu_freeze_dc3;\n', '\n', '   // These go to store buffer to detect full\n', '   assign isldst_dc1 = lsu_pkt_dc1.valid & (lsu_pkt_dc1.load | lsu_pkt_dc1.store);\n', '   assign dccm_ldst_dc2 = lsu_pkt_dc2.valid & (lsu_pkt_dc2.load | lsu_pkt_dc2.store) & (addr_in_dccm_dc2 | addr_in_pic_dc2);\n', '   assign dccm_ldst_dc3 = lsu_pkt_dc3.valid & (lsu_pkt_dc3.load | lsu_pkt_dc3.store) & (addr_in_dccm_dc3 | addr_in_pic_dc3);\n', '\n', '   // Disable Forwarding for now\n', '   assign lsu_cmpen_dc2 = lsu_pkt_dc2.valid & (lsu_pkt_dc2.load | lsu_pkt_dc2.store) & (addr_in_dccm_dc2 | addr_in_pic_dc2);\n', '\n', '   // Bus signals\n', '   assign lsu_busreq_dc2 = lsu_pkt_dc2.valid & (lsu_pkt_dc2.load | lsu_pkt_dc2.store) & addr_external_dc2 & ~flush_dc2_up & ~lsu_exc_dc2;\n', '\n', '   // PMU signals\n', '   assign lsu_pmu_misaligned_dc3 = lsu_pkt_dc3.valid & ((lsu_pkt_dc3.half & lsu_addr_dc3[0]) | (lsu_pkt_dc3.word & (|lsu_addr_dc3[1:0])));\n', '\n', '\n', '   lsu_dccm_ctl dccm_ctl (\n', '      .lsu_addr_dc1(lsu_addr_dc1[31:0]),\n', '      .end_addr_dc1(end_addr_dc1[DCCM_BITS-1:0]),\n', '      .lsu_addr_dc3(lsu_addr_dc3[DCCM_BITS-1:0]),\n', '      .*\n', '   );\n', '\n', '   lsu_stbuf stbuf(\n', '      .lsu_addr_dc1(lsu_addr_dc1[LSU_SB_BITS-1:0]),\n', '      .end_addr_dc1(end_addr_dc1[LSU_SB_BITS-1:0]),\n', '      .lsu_addr_dc2(lsu_addr_dc2[LSU_SB_BITS-1:0]),\n', '      .end_addr_dc2(end_addr_dc2[LSU_SB_BITS-1:0]),\n', '      .lsu_addr_dc3(lsu_addr_dc3[LSU_SB_BITS-1:0]),\n', '      .end_addr_dc3(end_addr_dc3[LSU_SB_BITS-1:0]),\n', '      .*\n', '\n', '   );\n', '\n', '   lsu_ecc ecc (\n', '      .lsu_addr_dc3(lsu_addr_dc3[DCCM_BITS-1:0]),\n', '      .end_addr_dc3(end_addr_dc3[DCCM_BITS-1:0]),\n', '      .*\n', '   );\n', '\n', '   lsu_trigger trigger (\n', '      .store_data_dc3(store_data_dc3[31:0]),\n', '      .*\n', '   );\n', '\n', '   // Clk domain\n', '   lsu_clkdomain clkdomain (.*);\n', '\n', '   // Bus interface\n', '   lsu_bus_intf bus_intf (.*);\n', '\n', '   //Flops\n', '   //rvdffs #(1) lsu_i0_valid_dc1ff (.*, .din(dec_i0_lsu_decode_d), .dout(lsu_i0_valid_dc1), .en(~lsu_freeze_dc3));\n', '   rvdff_fpga #(1) lsu_i0_valid_dc1ff    (.*, .din(dec_i0_lsu_decode_d), .dout(lsu_i0_valid_dc1), .clk(lsu_freeze_c2_dc1_clk), .clken(lsu_freeze_c2_dc1_clken), .rawclk(clk));\n', '   rvdff_fpga #(1) lsu_i0_valid_dc2ff    (.*, .din(lsu_i0_valid_dc1),    .dout(lsu_i0_valid_dc2), .clk(lsu_freeze_c2_dc2_clk), .clken(lsu_freeze_c2_dc2_clken), .rawclk(clk));\n', '   rvdff_fpga #(1) lsu_i0_valid_dc3ff    (.*, .din(lsu_i0_valid_dc2),    .dout(lsu_i0_valid_dc3), .clk(lsu_freeze_c2_dc3_clk), .clken(lsu_freeze_c2_dc3_clken), .rawclk(clk));\n', '   rvdff_fpga #(1) lsu_i0_valid_dc4ff    (.*, .din(lsu_i0_valid_dc3),    .dout(lsu_i0_valid_dc4), .clk(lsu_freeze_c2_dc4_clk), .clken(lsu_freeze_c2_dc4_clken), .rawclk(clk));\n', '\n', '   rvdff #(1) lsu_i0_valid_dc5ff    (.*, .din(lsu_i0_valid_dc4),    .dout(lsu_i0_valid_dc5), .clk(lsu_c2_dc5_clk));\n', '   rvdff #(1) lsu_single_ecc_err_dc4(.*, .din(lsu_single_ecc_error_dc3), .dout(lsu_single_ecc_error_dc4), .clk(lsu_c2_dc4_clk));\n', '   rvdff #(1) lsu_single_ecc_err_dc5(.*, .din(lsu_single_ecc_error_dc4), .dout(lsu_single_ecc_error_dc5), .clk(lsu_c2_dc5_clk));\n', '\n', '`ifdef ASSERT_ON\n', '   logic [8:0] store_data_bypass_sel;\n', '   assign store_data_bypass_sel[8:0] =  {lsu_p.store_data_bypass_c1,\n', '                                    lsu_p.store_data_bypass_c2,\n', '                                    lsu_p.store_data_bypass_i0_e2_c2,\n', '                                    lsu_p.store_data_bypass_e4_c1[1:0],\n', '                                    lsu_p.store_data_bypass_e4_c2[1:0],\n', '                                    lsu_p.store_data_bypass_e4_c3[1:0]};\n', '   assert_store_data_bypass_onehot: assert #0 ($onehot0(store_data_bypass_sel[8:0]));\n', '\n', '   assert_picm_rden_and_wren:   assert #0 ($onehot0({(picm_rden | picm_mken),picm_wren}));\n', '   assert_picm_rden_and_dccmen: assert #0 ($onehot0({(picm_rden | picm_mken),dccm_rden}));\n', '   assert_picm_wren_and_dccmen: assert #0 ($onehot0({picm_wren,   dccm_wren}));\n', '\n', ""   //assert_no_exceptions: assert #0 (lsu_exc_pkt_dc3.exc_valid == 1'b0);\n"", '   property exception_no_lsu_flush;\n', '      @(posedge clk)  disable iff(~rst_l) lsu_error_pkt_dc3.exc_valid |-> ##[1:2] (flush_dc4 | flush_dc5);\n', '   endproperty\n', '   assert_exception_no_lsu_flush: assert property (exception_no_lsu_flush) else\n', '      $display(""No flush within 2 cycles of exception"");\n', '`endif\n', '\n', 'endmodule // lsu\n']"
"['// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '\n', '//********************************************************************************\n', '// $Id$\n', '//\n', '//\n', '// Owner:\n', '// Function: Checks the memory map for the address\n', '// Comments:\n', '//\n', '//********************************************************************************\n', 'module lsu_addrcheck\n', '   import veer_types::*;\n', '(\n', '   input logic         lsu_freeze_c2_dc2_clk,       // clock\n', '   input logic         lsu_freeze_c2_dc3_clk,\n', '   input logic         lsu_freeze_c2_dc2_clken,\n', '   input logic         lsu_freeze_c2_dc3_clken,\n', '   input logic         rst_l,                       // reset\n', '   input logic         clk,\n', '\n', '   input logic [31:0]  start_addr_dc1,              // start address for lsu\n', '   input logic [31:0]  end_addr_dc1,                // end address for lsu\n', '   input lsu_pkt_t     lsu_pkt_dc1,                 // packet in dc1\n', '   input logic [31:0]  dec_tlu_mrac_ff,             // CSR read\n', '\n', '\n', '   output logic        is_sideeffects_dc2,          // is sideffects space\n', '   output logic        is_sideeffects_dc3,\n', '   output logic        addr_in_dccm_dc1,            // address in dccm\n', '   output logic        addr_in_pic_dc1,             // address in pic\n', '   output logic        addr_external_dc1,           // address in external\n', '\n', '   output logic        access_fault_dc1,            // access fault\n', '   output logic        misaligned_fault_dc1,        // misaligned\n', '\n', '   input  logic        scan_mode\n', ');\n', '\n', '`include ""global.h""\n', '\n', '   localparam DCCM_REGION = `RV_DCCM_REGION;\n', '   localparam PIC_REGION  = `RV_PIC_REGION;\n', '   localparam ICCM_REGION = `RV_ICCM_REGION;\n', '\n', '   `ifdef RV_ICCM_ENABLE\n', ""      localparam ICCM_ENABLE = 1'b1;\n"", '   `else\n', ""       localparam ICCM_ENABLE = 1'b0;\n"", '   `endif\n', '\n', '   `ifdef RV_DCCM_ENABLE\n', ""      localparam DCCM_ENABLE = 1'b1;\n"", '   `else\n', ""       localparam DCCM_ENABLE = 1'b0;\n"", '   `endif\n', '\n', '   logic        is_sideeffects_dc1, is_aligned_dc1;\n', '   logic        start_addr_in_dccm_dc1, end_addr_in_dccm_dc1;\n', '   logic        start_addr_in_dccm_region_dc1, end_addr_in_dccm_region_dc1;\n', '   logic        start_addr_in_pic_dc1, end_addr_in_pic_dc1;\n', '   logic        start_addr_in_pic_region_dc1, end_addr_in_pic_region_dc1;\n', '   logic [4:0]  csr_idx;\n', '   logic        addr_in_iccm;\n', '   logic        non_dccm_access_ok;\n', '\n', '   if (DCCM_ENABLE == 1) begin: Gen_dccm_enable\n', '      // Start address check\n', '      rvrangecheck #(.CCM_SADR(`RV_DCCM_SADR),\n', '                     .CCM_SIZE(`RV_DCCM_SIZE)) start_addr_dccm_rangecheck (\n', '         .addr(start_addr_dc1[31:0]),\n', '         .in_range(start_addr_in_dccm_dc1),\n', '         .in_region(start_addr_in_dccm_region_dc1)\n', '      );\n', '\n', '      // End address check\n', '      rvrangecheck #(.CCM_SADR(`RV_DCCM_SADR),\n', '                     .CCM_SIZE(`RV_DCCM_SIZE)) end_addr_dccm_rangecheck (\n', '         .addr(end_addr_dc1[31:0]),\n', '         .in_range(end_addr_in_dccm_dc1),\n', '         .in_region(end_addr_in_dccm_region_dc1)\n', '      );\n', '   end else begin: Gen_dccm_disable // block: Gen_dccm_enable\n', ""      assign start_addr_in_dccm_dc1 = '0;\n"", ""      assign start_addr_in_dccm_region_dc1 = '0;\n"", ""      assign end_addr_in_dccm_dc1 = '0;\n"", ""      assign end_addr_in_dccm_region_dc1 = '0;\n"", '   end\n', '    if (ICCM_ENABLE == 1) begin : check_iccm\n', '     assign addr_in_iccm =  (start_addr_dc1[31:28] == ICCM_REGION);\n', '  end\n', '  else begin\n', ""     assign addr_in_iccm = 1'b0;\n"", '  end\n', '   // PIC memory check\n', '   // Start address check\n', '   rvrangecheck #(.CCM_SADR(`RV_PIC_BASE_ADDR),\n', '                  .CCM_SIZE(`RV_PIC_SIZE)) start_addr_pic_rangecheck (\n', '      .addr(start_addr_dc1[31:0]),\n', '      .in_range(start_addr_in_pic_dc1),\n', '      .in_region(start_addr_in_pic_region_dc1)\n', '   );\n', '\n', '   // End address check\n', '   rvrangecheck #(.CCM_SADR(`RV_PIC_BASE_ADDR),\n', '                  .CCM_SIZE(`RV_PIC_SIZE)) end_addr_pic_rangecheck (\n', '      .addr(end_addr_dc1[31:0]),\n', '      .in_range(end_addr_in_pic_dc1),\n', '      .in_region(end_addr_in_pic_region_dc1)\n', '   );\n', '\n', '   assign addr_in_dccm_dc1        = (start_addr_in_dccm_dc1 & end_addr_in_dccm_dc1);\n', '   assign addr_in_pic_dc1         = (start_addr_in_pic_dc1 & end_addr_in_pic_dc1);\n', '\n', '   assign addr_external_dc1   = ~(addr_in_dccm_dc1 | addr_in_pic_dc1);  //~addr_in_dccm_region_dc1;\n', ""   assign csr_idx[4:0]       = {start_addr_dc1[31:28], 1'b1};\n"", '   assign is_sideeffects_dc1 = dec_tlu_mrac_ff[csr_idx] & ~(start_addr_in_dccm_region_dc1 | start_addr_in_pic_region_dc1 | addr_in_iccm);  //every region has the 2 LSB indicating ( 1: sideeffects/no_side effects, and 0: cacheable ). Ignored in internal regions\n', ""   assign is_aligned_dc1    = (lsu_pkt_dc1.word & (start_addr_dc1[1:0] == 2'b0)) |\n"", ""                              (lsu_pkt_dc1.half & (start_addr_dc1[0] == 1'b0)) |\n"", '                              lsu_pkt_dc1.by;\n', '\n', '    assign non_dccm_access_ok = (~(|{`RV_DATA_ACCESS_ENABLE0,`RV_DATA_ACCESS_ENABLE1,`RV_DATA_ACCESS_ENABLE2,`RV_DATA_ACCESS_ENABLE3,`RV_DATA_ACCESS_ENABLE4,`RV_DATA_ACCESS_ENABLE5,`RV_DATA_ACCESS_ENABLE6,`RV_DATA_ACCESS_ENABLE7})) |\n', '\n', '                             (((`RV_DATA_ACCESS_ENABLE0 & ((start_addr_dc1[31:0] | `RV_DATA_ACCESS_MASK0)) == (`RV_DATA_ACCESS_ADDR0 | `RV_DATA_ACCESS_MASK0)) |\n', '                               (`RV_DATA_ACCESS_ENABLE1 & ((start_addr_dc1[31:0] | `RV_DATA_ACCESS_MASK1)) == (`RV_DATA_ACCESS_ADDR1 | `RV_DATA_ACCESS_MASK1)) |\n', '                               (`RV_DATA_ACCESS_ENABLE2 & ((start_addr_dc1[31:0] | `RV_DATA_ACCESS_MASK2)) == (`RV_DATA_ACCESS_ADDR2 | `RV_DATA_ACCESS_MASK2)) |\n', '                               (`RV_DATA_ACCESS_ENABLE3 & ((start_addr_dc1[31:0] | `RV_DATA_ACCESS_MASK3)) == (`RV_DATA_ACCESS_ADDR3 | `RV_DATA_ACCESS_MASK3)) |\n', '                               (`RV_DATA_ACCESS_ENABLE4 & ((start_addr_dc1[31:0] | `RV_DATA_ACCESS_MASK4)) == (`RV_DATA_ACCESS_ADDR4 | `RV_DATA_ACCESS_MASK4)) |\n', '                               (`RV_DATA_ACCESS_ENABLE5 & ((start_addr_dc1[31:0] | `RV_DATA_ACCESS_MASK5)) == (`RV_DATA_ACCESS_ADDR5 | `RV_DATA_ACCESS_MASK5)) |\n', '                               (`RV_DATA_ACCESS_ENABLE6 & ((start_addr_dc1[31:0] | `RV_DATA_ACCESS_MASK6)) == (`RV_DATA_ACCESS_ADDR6 | `RV_DATA_ACCESS_MASK6)) |\n', '                               (`RV_DATA_ACCESS_ENABLE7 & ((start_addr_dc1[31:0] | `RV_DATA_ACCESS_MASK7)) == (`RV_DATA_ACCESS_ADDR7 | `RV_DATA_ACCESS_MASK7)))        &\n', '\n', '                              ((`RV_DATA_ACCESS_ENABLE0 & ((end_addr_dc1[31:0]   | `RV_DATA_ACCESS_MASK0)) == (`RV_DATA_ACCESS_ADDR0 | `RV_DATA_ACCESS_MASK0)) |\n', '                               (`RV_DATA_ACCESS_ENABLE1 & ((end_addr_dc1[31:0]   | `RV_DATA_ACCESS_MASK1)) == (`RV_DATA_ACCESS_ADDR1 | `RV_DATA_ACCESS_MASK1)) |\n', '                               (`RV_DATA_ACCESS_ENABLE2 & ((end_addr_dc1[31:0]   | `RV_DATA_ACCESS_MASK2)) == (`RV_DATA_ACCESS_ADDR2 | `RV_DATA_ACCESS_MASK2)) |\n', '                               (`RV_DATA_ACCESS_ENABLE3 & ((end_addr_dc1[31:0]   | `RV_DATA_ACCESS_MASK3)) == (`RV_DATA_ACCESS_ADDR3 | `RV_DATA_ACCESS_MASK3)) |\n', '                               (`RV_DATA_ACCESS_ENABLE4 & ((end_addr_dc1[31:0]   | `RV_DATA_ACCESS_MASK4)) == (`RV_DATA_ACCESS_ADDR4 | `RV_DATA_ACCESS_MASK4)) |\n', '                               (`RV_DATA_ACCESS_ENABLE5 & ((end_addr_dc1[31:0]   | `RV_DATA_ACCESS_MASK5)) == (`RV_DATA_ACCESS_ADDR5 | `RV_DATA_ACCESS_MASK5)) |\n', '                               (`RV_DATA_ACCESS_ENABLE6 & ((end_addr_dc1[31:0]   | `RV_DATA_ACCESS_MASK6)) == (`RV_DATA_ACCESS_ADDR6 | `RV_DATA_ACCESS_MASK6)) |\n', '                               (`RV_DATA_ACCESS_ENABLE7 & ((end_addr_dc1[31:0]   | `RV_DATA_ACCESS_MASK7)) == (`RV_DATA_ACCESS_ADDR7 | `RV_DATA_ACCESS_MASK7))));\n', '\n', '   // Access fault logic\n', '   // 1. Addr in dccm region but not in dccm offset\n', '   // 2. Addr in picm region but not in picm offset\n', '   // 3. DCCM -> PIC offset cross when DCCM/PIC in same region (PIC access are always word aligned so no cross possible from PIC->DCCM)\n', '   // 4. Ld/St access to picm are not word aligned\n', '   // 5. Address not in protected space or dccm/pic region\n', '   if (DCCM_ENABLE & (DCCM_REGION == PIC_REGION)) begin\n', '      assign access_fault_dc1  = ((start_addr_in_dccm_region_dc1 & ~(start_addr_in_dccm_dc1 | start_addr_in_pic_dc1)) |\n', '                                  (end_addr_in_dccm_region_dc1 & ~(end_addr_in_dccm_dc1 | end_addr_in_pic_dc1))       |\n', '                                  (start_addr_in_dccm_dc1 & end_addr_in_pic_dc1)                                      |\n', '                                  (start_addr_in_pic_dc1  & end_addr_in_dccm_dc1)                                     |\n', ""                                  ((addr_in_pic_dc1 & ((start_addr_dc1[1:0] != 2'b0) | ~lsu_pkt_dc1.word))) |\n"", '                                  (~start_addr_in_dccm_region_dc1 & ~non_dccm_access_ok)) & lsu_pkt_dc1.valid & ~lsu_pkt_dc1.dma;\n', '   end else begin\n', '      assign access_fault_dc1  = ((start_addr_in_dccm_region_dc1 & ~start_addr_in_dccm_dc1) |\n', '                                  (end_addr_in_dccm_region_dc1 & ~end_addr_in_dccm_dc1)     |\n', '                                  (start_addr_in_pic_region_dc1 & ~start_addr_in_pic_dc1)   |\n', '                                  (end_addr_in_pic_region_dc1 & ~end_addr_in_pic_dc1)       |\n', ""                                  ((addr_in_pic_dc1 & ((start_addr_dc1[1:0] != 2'b0) | ~lsu_pkt_dc1.word))) |\n"", '                                  (~start_addr_in_pic_region_dc1 & ~start_addr_in_dccm_region_dc1 & ~non_dccm_access_ok)) & lsu_pkt_dc1.valid & ~lsu_pkt_dc1.dma;\n', '   end\n', '\n', '   // Misaligned happens due to 2 reasons\n', '   // 1. Region cross\n', '   // 2. sideeffects access which are not aligned\n', '   assign misaligned_fault_dc1 = ((start_addr_dc1[31:28] != end_addr_dc1[31:28]) |\n', '                                  (is_sideeffects_dc1 & ~is_aligned_dc1)) & addr_external_dc1 & lsu_pkt_dc1.valid & ~lsu_pkt_dc1.dma;\n', '\n', '   rvdff_fpga #(.WIDTH(1)) is_sideeffects_dc2ff (.din(is_sideeffects_dc1), .dout(is_sideeffects_dc2), .clk(lsu_freeze_c2_dc2_clk), .clken(lsu_freeze_c2_dc2_clken), .rawclk(clk), .*);\n', '   rvdff_fpga #(.WIDTH(1)) is_sideeffects_dc3ff (.din(is_sideeffects_dc2), .dout(is_sideeffects_dc3), .clk(lsu_freeze_c2_dc3_clk), .clken(lsu_freeze_c2_dc3_clken), .rawclk(clk), .*);\n', '\n', '\n', 'endmodule // lsu_addrcheck\n', '\n']"
"['// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '\n', '//********************************************************************************\n', '// $Id$\n', '//\n', '//\n', '// Owner:\n', '// Function: lsu interface with interface queue\n', '// Comments:\n', '//\n', '//********************************************************************************\n', '\n', '// Function to do 8 to 3 bit encoding\n', 'function automatic logic [2:0] f_Enc8to3;\n', '   input logic [7:0] Dec_value;\n', '\n', '   logic [2:0]       Enc_value;\n', '   Enc_value[0] = Dec_value[1] | Dec_value[3] | Dec_value[5] | Dec_value[7];\n', '   Enc_value[1] = Dec_value[2] | Dec_value[3] | Dec_value[6] | Dec_value[7];\n', '   Enc_value[2] = Dec_value[4] | Dec_value[5] | Dec_value[6] | Dec_value[7];\n', '\n', '   return Enc_value[2:0];\n', 'endfunction // f_Enc8to3\n', '\n', '\n', 'module lsu_bus_buffer\n', '   import veer_types::*;\n', '(\n', '   input logic                          clk,\n', '   input logic                          rst_l,\n', '   input logic                          scan_mode,\n', '   input logic                          dec_tlu_dccm_nonblock_dma_disable, // disable dma nonblock\n', '   input logic                          dec_tlu_wb_coalescing_disable,    // disable write buffer coalescing\n', '   input logic                          dec_tlu_ld_miss_byp_wb_disable,   // disable ld miss bypass of the write buffer\n', '   input logic                          dec_tlu_sideeffect_posted_disable,  // disable posted writes to sideeffect addr to the bus\n', '\n', '   // various clocks needed for the bus reads and writes\n', '   input logic                          lsu_c1_dc3_clk,\n', '   input logic                          lsu_c1_dc4_clk,\n', '   input logic                          lsu_c1_dc5_clk,\n', '   input logic                          lsu_c2_dc3_clk,\n', '   input logic                          lsu_c2_dc4_clk,\n', '   input logic                          lsu_c2_dc5_clk,\n', '   input logic                          lsu_freeze_c1_dc2_clk,\n', '   input logic                          lsu_freeze_c1_dc3_clk,\n', '   input logic                          lsu_freeze_c2_dc2_clk,\n', '   input logic                          lsu_freeze_c2_dc3_clk,\n', '   input logic                          lsu_freeze_c2_dc3_clken,\n', '   input logic                          lsu_bus_ibuf_c1_clk,\n', '   input logic                          lsu_bus_obuf_c1_clk,\n', '   input logic                          lsu_bus_buf_c1_clk,\n', '   input logic                          lsu_free_c2_clk,\n', '   input logic                          lsu_busm_clk,\n', '\n', '\n', '   input                                lsu_pkt_t lsu_pkt_dc1,            // lsu packet flowing down the pipe\n', '   input                                lsu_pkt_t lsu_pkt_dc2,            // lsu packet flowing down the pipe\n', '   input                                lsu_pkt_t lsu_pkt_dc3,            // lsu packet flowing down the pipe\n', '   input                                lsu_pkt_t lsu_pkt_dc4,            // lsu packet flowing down the pipe\n', '   input                                lsu_pkt_t lsu_pkt_dc5,            // lsu packet flowing down the pipe\n', '\n', '   input logic [31:0]                   lsu_addr_dc2,                     // lsu address flowing down the pipe\n', '   input logic [31:0]                   end_addr_dc2,                     // lsu address flowing down the pipe\n', '   input logic [31:0]                   lsu_addr_dc5,                     // lsu address flowing down the pipe\n', '   input logic [31:0]                   end_addr_dc5,                     // lsu address flowing down the pipe\n', '   input logic [31:0]                   store_data_dc5,                   // store data flowing down the pipe\n', '\n', ""   input logic                          no_word_merge_dc5,                // dc5 store doesn't need to wait in ibuf since it will not coalesce\n"", ""   input logic                          no_dword_merge_dc5,               // dc5 store doesn't need to wait in ibuf since it will not coalesce\n"", '   input logic                          lsu_busreq_dc2,                   // bus request is in dc2\n', '   output logic                         lsu_busreq_dc3,                   // bus request is in dc2\n', '   output logic                         lsu_busreq_dc4,                   // bus request is in dc4\n', '   output logic                         lsu_busreq_dc5,                   // bus request is in dc5\n', '   input logic                          ld_full_hit_dc2,                  // load can get all its byte from a write buffer entry\n', '   input logic                          flush_dc2_up,                     // flush\n', '   input logic                          flush_dc3,                        // flush\n', '   input logic                          flush_dc4,                        // flush\n', '   input logic                          flush_dc5,                        // flush\n', '   input logic                          lsu_freeze_dc3,\n', '   input logic                          dec_tlu_cancel_e4,                // cancel the bus load in dc4 and reset the freeze\n', '   input logic                          lsu_commit_dc5,                   // lsu instruction in dc5 commits\n', '   input logic                          is_sideeffects_dc2,               // lsu attribute is side_effects\n', '   input logic                          is_sideeffects_dc5,               // lsu attribute is side_effects\n', '   input logic                          ldst_dual_dc1,                    // load/store is unaligned at 32 bit boundary\n', '   input logic                          ldst_dual_dc2,                    // load/store is unaligned at 32 bit boundary\n', '   input logic                          ldst_dual_dc3,                    // load/store is unaligned at 32 bit boundary\n', '   input logic                          ldst_dual_dc4,                    // load/store is unaligned at 32 bit boundary\n', '   input logic                          ldst_dual_dc5,                    // load/store is unaligned at 32 bit boundary\n', '\n', '   input logic [7:0]                   ldst_byteen_ext_dc2,\n', '\n', '   output logic                         ld_freeze_dc3,                    // load goes to external and asserts freeze\n', '   output logic                         lsu_bus_buffer_pend_any,          // bus buffer has a pending bus entry\n', '   output logic                         lsu_bus_buffer_full_any,          // bus buffer is full\n', '   output logic                         lsu_bus_buffer_empty_any,         // bus buffer is empty\n', '\n', '   output logic                         ld_bus_error_dc3,                 // bus error in dc3\n', '   output logic [31:0]                  ld_bus_error_addr_dc3,            // address of the bus error\n', '   output logic [31:0]                  ld_bus_data_dc3,                 // the Dc3 load data from bus\n', '\n', '   output logic [3:0]                   ld_byte_hit_buf_lo, ld_byte_hit_buf_hi,    // Byte enables for forwarding data\n', '   output logic [31:0]                  ld_fwddata_buf_lo, ld_fwddata_buf_hi,      // load forwarding data\n', '\n', '   output logic                         lsu_imprecise_error_load_any,     // imprecise load bus error\n', '   output logic                         lsu_imprecise_error_store_any,    // imprecise store bus error\n', '   output logic [31:0]                  lsu_imprecise_error_addr_any,     // address of the imprecise error\n', '\n', '   // Non-blocking loads\n', '   input  logic                                dec_nonblock_load_freeze_dc2,\n', '   output logic                                lsu_nonblock_load_valid_dc3,     // there is an external load -> put in the cam\n', '   output logic [`RV_LSU_NUM_NBLOAD_WIDTH-1:0] lsu_nonblock_load_tag_dc3,       // the tag of the external non block load\n', '   output logic                                lsu_nonblock_load_inv_dc5,       // invalidate signal for the cam entry for non block loads\n', '   output logic [`RV_LSU_NUM_NBLOAD_WIDTH-1:0] lsu_nonblock_load_inv_tag_dc5,   // tag of the enrty which needs to be invalidated\n', '   output logic                                lsu_nonblock_load_data_valid,    // the non block is valid - sending information back to the cam\n', '   output logic                                lsu_nonblock_load_data_error,    // non block load has an error\n', '   output logic [`RV_LSU_NUM_NBLOAD_WIDTH-1:0] lsu_nonblock_load_data_tag,      // the tag of the non block load sending the data/error\n', '   output logic [31:0]                         lsu_nonblock_load_data,          // Data of the non block load\n', '\n', '   // PMU events\n', '   output logic                         lsu_pmu_bus_trxn,\n', '   output logic                         lsu_pmu_bus_misaligned,\n', '   output logic                         lsu_pmu_bus_error,\n', '   output logic                         lsu_pmu_bus_busy,\n', '\n', '   // AXI Write Channels\n', '   output logic                            lsu_axi_awvalid,\n', '   input  logic                            lsu_axi_awready,\n', '   output logic [`RV_LSU_BUS_TAG-1:0]      lsu_axi_awid,\n', '   output logic [31:0]                     lsu_axi_awaddr,\n', '   output logic [3:0]                      lsu_axi_awregion,\n', '   output logic [7:0]                      lsu_axi_awlen,\n', '   output logic [2:0]                      lsu_axi_awsize,\n', '   output logic [1:0]                      lsu_axi_awburst,\n', '   output logic                            lsu_axi_awlock,\n', '   output logic [3:0]                      lsu_axi_awcache,\n', '   output logic [2:0]                      lsu_axi_awprot,\n', '   output logic [3:0]                      lsu_axi_awqos,\n', '\n', '   output logic                            lsu_axi_wvalid,\n', '   input  logic                            lsu_axi_wready,\n', '   output logic [63:0]                     lsu_axi_wdata,\n', '   output logic [7:0]                      lsu_axi_wstrb,\n', '   output logic                            lsu_axi_wlast,\n', '\n', '   input  logic                            lsu_axi_bvalid,\n', '   output logic                            lsu_axi_bready,\n', '   input  logic [1:0]                      lsu_axi_bresp,\n', '   input  logic [`RV_LSU_BUS_TAG-1:0]      lsu_axi_bid,\n', '\n', '   // AXI Read Channels\n', '   output logic                            lsu_axi_arvalid,\n', '   input  logic                            lsu_axi_arready,\n', '   output logic [`RV_LSU_BUS_TAG-1:0]      lsu_axi_arid,\n', '   output logic [31:0]                     lsu_axi_araddr,\n', '   output logic [3:0]                      lsu_axi_arregion,\n', '   output logic [7:0]                      lsu_axi_arlen,\n', '   output logic [2:0]                      lsu_axi_arsize,\n', '   output logic [1:0]                      lsu_axi_arburst,\n', '   output logic                            lsu_axi_arlock,\n', '   output logic [3:0]                      lsu_axi_arcache,\n', '   output logic [2:0]                      lsu_axi_arprot,\n', '   output logic [3:0]                      lsu_axi_arqos,\n', '\n', '   input  logic                            lsu_axi_rvalid,\n', '   output logic                            lsu_axi_rready,\n', '   input  logic [`RV_LSU_BUS_TAG-1:0]      lsu_axi_rid,\n', '   input  logic [63:0]                     lsu_axi_rdata,\n', '   input  logic [1:0]                      lsu_axi_rresp,\n', '   input  logic                            lsu_axi_rlast,\n', '\n', '   input logic                          lsu_bus_clk_en,\n', '   input logic                          lsu_bus_clk_en_q\n', '\n', ');\n', '\n', '`include ""global.h""\n', '\n', '   // For Ld: IDLE -> WAIT -> CMD -> RESP -> DONE -> IDLE\n', '   // For St: IDLE -> WAIT -> CMD -> RESP(?) -> IDLE\n', ""   typedef enum logic [2:0] {IDLE=3'b000, WAIT=3'b001, CMD=3'b010, RESP=3'b011, DONE=3'b100} state_t;\n"", '\n', '   localparam DEPTH     = `RV_LSU_NUM_NBLOAD;\n', '   localparam DEPTH_LOG2 = `RV_LSU_NUM_NBLOAD_WIDTH;\n', '   localparam TIMER     = 8;   // This can be only power of 2\n', '   localparam TIMER_LOG2 = (TIMER < 2) ? 1 : $clog2(TIMER);\n', ""   localparam TIMER_MAX = (TIMER == 0) ? TIMER_LOG2'(0) : TIMER_LOG2'(TIMER - 1);  // Maximum value of timer\n"", '\n', '   logic [3:0]                          ldst_byteen_hi_dc2, ldst_byteen_lo_dc2;\n', '   logic [DEPTH-1:0]                    ld_addr_hitvec_lo, ld_addr_hitvec_hi;\n', '   logic [3:0][DEPTH-1:0]               ld_byte_hitvec_lo, ld_byte_hitvec_hi;\n', '   logic [3:0][DEPTH-1:0]               ld_byte_hitvecfn_lo, ld_byte_hitvecfn_hi;\n', '\n', '   logic                                ld_addr_ibuf_hit_lo, ld_addr_ibuf_hit_hi;\n', '   logic [3:0]                          ld_byte_ibuf_hit_lo, ld_byte_ibuf_hit_hi;\n', '\n', '   logic [3:0]                          ldst_byteen_dc5;\n', '   logic [7:0]                          ldst_byteen_ext_dc5;\n', '   logic [3:0]                          ldst_byteen_hi_dc5, ldst_byteen_lo_dc5;\n', '   logic [31:0]                         store_data_hi_dc5, store_data_lo_dc5;\n', '   logic                                ldst_samedw_dc5;\n', '\n', '   logic                                lsu_nonblock_load_valid_dc4,lsu_nonblock_load_valid_dc5;\n', '   logic [31:0]                         lsu_nonblock_load_data_hi, lsu_nonblock_load_data_lo, lsu_nonblock_data_unalgn;\n', '   logic [1:0]                          lsu_nonblock_addr_offset;\n', '   logic [1:0]                          lsu_nonblock_sz;\n', '   logic                                lsu_nonblock_load_data_valid_hi, lsu_nonblock_load_data_valid_lo;\n', '   logic                                lsu_nonblock_load_data_error_hi, lsu_nonblock_load_data_error_lo;\n', '   logic                                lsu_nonblock_unsign, lsu_nonblock_dual;\n', '   logic                                dec_nonblock_load_freeze_dc3;\n', '   logic                                ld_precise_bus_error;\n', '   logic [DEPTH_LOG2-1:0]               lsu_imprecise_error_load_tag;\n', '   logic [31:0]                         ld_block_bus_data;\n', '\n', '   logic [DEPTH-1:0]                    CmdPtr0Dec, CmdPtr1Dec;\n', '   logic [DEPTH_LOG2-1:0]               CmdPtr0, CmdPtr1;\n', '   logic [DEPTH_LOG2-1:0]               WrPtr0_dc3, WrPtr0_dc4, WrPtr0_dc5;\n', '   logic [DEPTH_LOG2-1:0]               WrPtr1_dc3, WrPtr1_dc4, WrPtr1_dc5;\n', '   logic                                found_wrptr0, found_wrptr1, found_cmdptr0, found_cmdptr1;\n', '   logic [3:0]                          buf_numvld_any, buf_numvld_wrcmd_any, buf_numvld_pend_any, buf_numvld_cmd_any;\n', '   logic                                bus_sideeffect_pend;\n', '   logic                                bus_coalescing_disable;\n', '\n', '   logic                                ld_freeze_en, ld_freeze_rst;\n', '   logic                                FreezePtrEn;\n', '   logic [DEPTH_LOG2-1:0]               FreezePtr;\n', '\n', '   logic [DEPTH_LOG2-1:0]               lsu_imprecise_error_store_tag;\n', '\n', '   logic                                bus_addr_match_pending;\n', '   logic                                bus_cmd_sent, bus_cmd_ready;\n', '   logic                                bus_wcmd_sent, bus_wdata_sent;\n', '   logic                                bus_rsp_read, bus_rsp_write;\n', '   logic [LSU_BUS_TAG-1:0]              bus_rsp_read_tag, bus_rsp_write_tag;\n', '   logic                                bus_rsp_read_error, bus_rsp_write_error;\n', '   logic [63:0]                         bus_rsp_rdata;\n', '\n', '   // Bus buffer signals\n', '   state_t [DEPTH-1:0]                  buf_state;\n', '   logic   [DEPTH-1:0][2:0]             buf_state_out;\n', '   logic   [DEPTH-1:0][1:0]             buf_sz;\n', '   logic   [DEPTH-1:0][31:0]            buf_addr;\n', '   logic   [DEPTH-1:0][3:0]             buf_byteen;\n', '   logic   [DEPTH-1:0]                  buf_sideeffect;\n', '   logic   [DEPTH-1:0]                  buf_write;\n', '   logic   [DEPTH-1:0]                  buf_unsign;\n', '   logic   [DEPTH-1:0]                  buf_dual;\n', '   logic   [DEPTH-1:0]                  buf_samedw;\n', '   logic   [DEPTH-1:0]                  buf_nomerge;\n', '   logic   [DEPTH-1:0]                  buf_dualhi;\n', '   logic   [DEPTH-1:0][DEPTH_LOG2-1:0]  buf_dualtag;\n', '   logic   [DEPTH-1:0]                  buf_nb;\n', '   logic   [DEPTH-1:0]                  buf_error;\n', '   logic   [DEPTH-1:0][31:0]            buf_data;\n', '   logic   [DEPTH-1:0][DEPTH-1:0]       buf_age, buf_age_younger, buf_age_temp;\n', '\n', '   state_t [DEPTH-1:0]                  buf_nxtstate;\n', '   logic   [DEPTH-1:0]                  buf_rst;\n', '   logic   [DEPTH-1:0]                  buf_state_en;\n', '   logic   [DEPTH-1:0]                  buf_cmd_state_bus_en;\n', '   logic   [DEPTH-1:0]                  buf_resp_state_bus_en;\n', '   logic   [DEPTH-1:0]                  buf_state_bus_en;\n', '   logic   [DEPTH-1:0]                  buf_dual_in;\n', '   logic   [DEPTH-1:0]                  buf_samedw_in;\n', '   logic   [DEPTH-1:0]                  buf_nomerge_in;\n', '   logic   [DEPTH-1:0]                  buf_nb_in;\n', '   logic   [DEPTH-1:0]                  buf_sideeffect_in;\n', '   logic   [DEPTH-1:0]                  buf_unsign_in;\n', '   logic   [DEPTH-1:0][1:0]             buf_sz_in;\n', '   logic   [DEPTH-1:0]                  buf_write_in;\n', '   logic   [DEPTH-1:0]                  buf_wr_en;\n', '   logic   [DEPTH-1:0]                  buf_dualhi_in;\n', '   logic   [DEPTH-1:0][DEPTH_LOG2-1:0]  buf_dualtag_in;\n', '   logic   [DEPTH-1:0][3:0]             buf_byteen_in;\n', '   logic   [DEPTH-1:0][31:0]            buf_addr_in;\n', '   logic   [DEPTH-1:0][31:0]            buf_data_in;\n', '   logic   [DEPTH-1:0]                  buf_error_en;\n', '   logic   [DEPTH-1:0]                  buf_data_en;\n', '   logic   [DEPTH-1:0][DEPTH-1:0]       buf_age_in;\n', '   logic   [DEPTH-1:0][DEPTH-1:0]       buf_ageQ;\n', '\n', '   // Input buffer signals\n', '   logic                               ibuf_valid;\n', '   logic                               ibuf_dual;\n', '   logic                               ibuf_samedw;\n', '   logic                               ibuf_nomerge;\n', '   logic [DEPTH_LOG2-1:0]              ibuf_tag;\n', '   logic [DEPTH_LOG2-1:0]              ibuf_dualtag;\n', '   logic                               ibuf_nb;\n', '   logic                               ibuf_sideeffect;\n', '   logic                               ibuf_unsign;\n', '   logic                               ibuf_write;\n', '   logic [1:0]                         ibuf_sz;\n', '   logic [3:0]                         ibuf_byteen;\n', '   logic [31:0]                        ibuf_addr;\n', '   logic [31:0]                        ibuf_data;\n', '   logic [TIMER_LOG2-1:0]              ibuf_timer;\n', '\n', '   logic                               ibuf_byp;\n', '   logic                               ibuf_wr_en;\n', '   logic                               ibuf_rst;\n', '   logic                               ibuf_force_drain;\n', '   logic                               ibuf_drain_vld;\n', '   logic [DEPTH-1:0]                   ibuf_drainvec_vld;\n', '   logic [DEPTH_LOG2-1:0]              ibuf_tag_in;\n', '   logic [DEPTH_LOG2-1:0]              ibuf_dualtag_in;\n', '   logic [1:0]                         ibuf_sz_in;\n', '   logic [31:0]                        ibuf_addr_in;\n', '   logic [3:0]                         ibuf_byteen_in;\n', '   logic [31:0]                        ibuf_data_in;\n', '   logic [TIMER_LOG2-1:0]              ibuf_timer_in;\n', '   logic [3:0]                         ibuf_byteen_out;\n', '   logic [31:0]                        ibuf_data_out;\n', '   logic                               ibuf_merge_en, ibuf_merge_in;\n', '\n', '   // Output buffer signals\n', '   logic                               obuf_valid;\n', '   logic                               obuf_write;\n', '   logic                               obuf_sideeffect;\n', '   logic [31:0]                        obuf_addr;\n', '   logic [63:0]                        obuf_data;\n', '   logic [1:0]                         obuf_sz;\n', '   logic [7:0]                         obuf_byteen;\n', '   logic                               obuf_merge;\n', '   logic                               obuf_cmd_done, obuf_data_done;\n', '   logic [LSU_BUS_TAG-1:0]             obuf_tag0;\n', '   logic [LSU_BUS_TAG-1:0]             obuf_tag1;\n', '\n', '   logic                               ibuf_buf_byp;\n', '   logic                               obuf_force_wr_en;\n', '   logic                               obuf_wr_wait;\n', '   logic                               obuf_wr_en, obuf_wr_enQ;\n', '   logic                               obuf_rst;\n', '   logic                               obuf_write_in;\n', '   logic                               obuf_sideeffect_in;\n', '   logic [31:0]                        obuf_addr_in;\n', '   logic [63:0]                        obuf_data_in;\n', '   logic [1:0]                         obuf_sz_in;\n', '   logic [7:0]                         obuf_byteen_in;\n', '   logic                               obuf_merge_in;\n', '   logic                               obuf_cmd_done_in, obuf_data_done_in;\n', '   logic [LSU_BUS_TAG-1:0]             obuf_tag0_in;\n', '   logic [LSU_BUS_TAG-1:0]             obuf_tag1_in;\n', '\n', '   logic                               obuf_merge_en;\n', '   logic [TIMER_LOG2-1:0]              obuf_wr_timer, obuf_wr_timer_in;\n', '   logic [7:0]                         obuf_byteen0_in, obuf_byteen1_in;\n', '   logic [63:0]                        obuf_data0_in, obuf_data1_in;\n', '\n', '   logic                   lsu_axi_awvalid_q, lsu_axi_awready_q;\n', '   logic                   lsu_axi_wvalid_q, lsu_axi_wready_q;\n', '   logic                   lsu_axi_arvalid_q, lsu_axi_arready_q;\n', '   logic                   lsu_axi_bvalid_q, lsu_axi_bready_q;\n', '   logic                   lsu_axi_rvalid_q, lsu_axi_rready_q;\n', '   logic [LSU_BUS_TAG-1:0] lsu_axi_bid_q, lsu_axi_rid_q;\n', '   logic [1:0]             lsu_axi_bresp_q, lsu_axi_rresp_q;\n', '   logic [63:0]            lsu_axi_rdata_q;\n', '\n', '   //------------------------------------------------------------------------------\n', '   // Load forwarding logic start\n', '   //------------------------------------------------------------------------------\n', '\n', '   // Buffer hit logic for bus load forwarding\n', '   assign ldst_byteen_hi_dc2[3:0]   = ldst_byteen_ext_dc2[7:4];\n', '   assign ldst_byteen_lo_dc2[3:0]   = ldst_byteen_ext_dc2[3:0];\n', '   for (genvar i=0; i<DEPTH; i++) begin\n', ""      // We can't forward from RESP for ahb since multiple writes to the same address can be in RESP and we can't find out their age\n"", '      assign ld_addr_hitvec_lo[i] = (lsu_addr_dc2[31:2] == buf_addr[i][31:2]) & buf_write[i] & ((buf_state[i] == WAIT) | (buf_state[i] == CMD)) & lsu_busreq_dc2;\n', '      assign ld_addr_hitvec_hi[i] = (end_addr_dc2[31:2] == buf_addr[i][31:2]) & buf_write[i] & ((buf_state[i] == WAIT) | (buf_state[i] == CMD)) & lsu_busreq_dc2;\n', '   end\n', '\n', '   for (genvar j=0; j<4; j++) begin\n', '     assign ld_byte_hit_buf_lo[j] = |(ld_byte_hitvecfn_lo[j]) | ld_byte_ibuf_hit_lo[j];\n', '     assign ld_byte_hit_buf_hi[j] = |(ld_byte_hitvecfn_hi[j]) | ld_byte_ibuf_hit_hi[j];\n', '     for (genvar i=0; i<DEPTH; i++) begin\n', '         assign ld_byte_hitvec_lo[j][i] = ld_addr_hitvec_lo[i] & buf_byteen[i][j] & ldst_byteen_lo_dc2[j];\n', '         assign ld_byte_hitvec_hi[j][i] = ld_addr_hitvec_hi[i] & buf_byteen[i][j] & ldst_byteen_hi_dc2[j];\n', '\n', '         assign ld_byte_hitvecfn_lo[j][i] = ld_byte_hitvec_lo[j][i] & ~(|(ld_byte_hitvec_lo[j] & buf_age_younger[i])) & ~ld_byte_ibuf_hit_lo[j];  // Kill the byte enable if younger entry exists or byte exists in ibuf\n', '         assign ld_byte_hitvecfn_hi[j][i] = ld_byte_hitvec_hi[j][i] & ~(|(ld_byte_hitvec_hi[j] & buf_age_younger[i])) & ~ld_byte_ibuf_hit_hi[j];  // Kill the byte enable if younger entry exists or byte exists in ibuf\n', '      end\n', '   end\n', '\n', '   // Hit in the ibuf\n', '   assign ld_addr_ibuf_hit_lo = (lsu_addr_dc2[31:2] == ibuf_addr[31:2]) & ibuf_write & ibuf_valid & lsu_busreq_dc2;\n', '   assign ld_addr_ibuf_hit_hi = (end_addr_dc2[31:2] == ibuf_addr[31:2]) & ibuf_write & ibuf_valid & lsu_busreq_dc2;\n', '\n', '   for (genvar i=0; i<4; i++) begin\n', '      assign ld_byte_ibuf_hit_lo[i] = ld_addr_ibuf_hit_lo & ibuf_byteen[i] & ldst_byteen_lo_dc2[i];\n', '      assign ld_byte_ibuf_hit_hi[i] = ld_addr_ibuf_hit_hi & ibuf_byteen[i] & ldst_byteen_hi_dc2[i];\n', '   end\n', '\n', '   always_comb begin\n', '      ld_fwddata_buf_lo[31:0] = {{8{ld_byte_ibuf_hit_lo[3]}},{8{ld_byte_ibuf_hit_lo[2]}},{8{ld_byte_ibuf_hit_lo[1]}},{8{ld_byte_ibuf_hit_lo[0]}}} & ibuf_data[31:0];\n', '      ld_fwddata_buf_hi[31:0] = {{8{ld_byte_ibuf_hit_hi[3]}},{8{ld_byte_ibuf_hit_hi[2]}},{8{ld_byte_ibuf_hit_hi[1]}},{8{ld_byte_ibuf_hit_hi[0]}}} & ibuf_data[31:0];\n', '      for (int i=0; i<DEPTH; i++) begin\n', '         ld_fwddata_buf_lo[7:0]   |= {8{ld_byte_hitvecfn_lo[0][i]}} & buf_data[i][7:0];\n', '         ld_fwddata_buf_lo[15:8]  |= {8{ld_byte_hitvecfn_lo[1][i]}} & buf_data[i][15:8];\n', '         ld_fwddata_buf_lo[23:16] |= {8{ld_byte_hitvecfn_lo[2][i]}} & buf_data[i][23:16];\n', '         ld_fwddata_buf_lo[31:24] |= {8{ld_byte_hitvecfn_lo[3][i]}} & buf_data[i][31:24];\n', '\n', '         ld_fwddata_buf_hi[7:0]   |= {8{ld_byte_hitvecfn_hi[0][i]}} & buf_data[i][7:0];\n', '         ld_fwddata_buf_hi[15:8]  |= {8{ld_byte_hitvecfn_hi[1][i]}} & buf_data[i][15:8];\n', '         ld_fwddata_buf_hi[23:16] |= {8{ld_byte_hitvecfn_hi[2][i]}} & buf_data[i][23:16];\n', '         ld_fwddata_buf_hi[31:24] |= {8{ld_byte_hitvecfn_hi[3][i]}} & buf_data[i][31:24];\n', '      end\n', '   end\n', '\n', '   //------------------------------------------------------------------------------\n', '   // Load forwarding logic end\n', '   //------------------------------------------------------------------------------\n', '\n', '`ifdef RV_BUILD_AHB_LITE\n', ""   assign bus_coalescing_disable = 1'b1;   // No coalescing for ahb\n"", '`else\n', '   assign bus_coalescing_disable = dec_tlu_wb_coalescing_disable;\n', '`endif\n', '\n', '   // Get the hi/lo byte enable\n', ""   assign ldst_byteen_dc5[3:0] = ({4{lsu_pkt_dc5.by}}   & 4'b0001) |\n"", ""                                 ({4{lsu_pkt_dc5.half}} & 4'b0011) |\n"", ""                                 ({4{lsu_pkt_dc5.word}} & 4'b1111);\n"", '\n', ""   assign {ldst_byteen_hi_dc5[3:0], ldst_byteen_lo_dc5[3:0]} = {4'b0,ldst_byteen_dc5[3:0]} << lsu_addr_dc5[1:0];\n"", ""   assign {store_data_hi_dc5[31:0], store_data_lo_dc5[31:0]} = {32'b0,store_data_dc5[31:0]} << {lsu_addr_dc5[1:0],3'b0};\n"", '   assign ldst_samedw_dc5 = (lsu_addr_dc5[3] == end_addr_dc5[3]);\n', '\n', '   //------------------------------------------------------------------------------\n', '   // Input buffer logic starts here\n', '   //------------------------------------------------------------------------------\n', '\n', ""   assign ibuf_byp   = lsu_busreq_dc5 & ((lsu_pkt_dc5.load  | no_word_merge_dc5) & ~ibuf_valid);    // Bypass if ibuf is empty and it's a load or no merge possible\n"", '   assign ibuf_wr_en = lsu_busreq_dc5 & (lsu_commit_dc5 | lsu_freeze_dc3) & ~ibuf_byp;\n', '   assign ibuf_rst   = ibuf_drain_vld & ~ibuf_wr_en;\n', '   assign ibuf_force_drain = lsu_busreq_dc2 & ~lsu_busreq_dc3 & ~lsu_busreq_dc4 & ~lsu_busreq_dc5 & ibuf_valid & (lsu_pkt_dc2.load | (ibuf_addr[31:2] != lsu_addr_dc2[31:2]));  // Move the ibuf to buf if there is a non-colaescable ld/st in dc2 but nothing in dc3/dc4/dc5\n', '   assign ibuf_drain_vld = ibuf_valid & (((ibuf_wr_en | (ibuf_timer == TIMER_MAX)) & ~(ibuf_merge_en & ibuf_merge_in)) | ibuf_byp | ibuf_force_drain | ibuf_sideeffect | ~ibuf_write | bus_coalescing_disable);\n', '   assign ibuf_tag_in[DEPTH_LOG2-1:0] = (ibuf_merge_en & ibuf_merge_in) ? ibuf_tag[DEPTH_LOG2-1:0] : (ldst_dual_dc5 ? WrPtr1_dc5 : WrPtr0_dc5);\n', '   assign ibuf_dualtag_in[DEPTH_LOG2-1:0] = WrPtr0_dc5;\n', '   assign ibuf_sz_in[1:0]   = {lsu_pkt_dc5.word, lsu_pkt_dc5.half}; // NOTE: Make sure lsu_pkt_dc3/dc4 are flopped in case of freeze (except the valid)\n', '   assign ibuf_addr_in[31:0] = ldst_dual_dc5 ? end_addr_dc5[31:0] : lsu_addr_dc5[31:0];\n', '   assign ibuf_byteen_in[3:0] = (ibuf_merge_en & ibuf_merge_in) ? (ibuf_byteen[3:0] | ldst_byteen_lo_dc5[3:0]) : (ldst_dual_dc5 ? ldst_byteen_hi_dc5[3:0] : ldst_byteen_lo_dc5[3:0]);\n', '   for (genvar i=0; i<4; i++) begin\n', '      assign ibuf_data_in[(8*i)+7:(8*i)] = (ibuf_merge_en & ibuf_merge_in) ? (ldst_byteen_lo_dc5[i] ? store_data_lo_dc5[(8*i)+7:(8*i)] : ibuf_data[(8*i)+7:(8*i)]) :\n', '                                                                             (ldst_dual_dc5 ? store_data_hi_dc5[(8*i)+7:(8*i)] : store_data_lo_dc5[(8*i)+7:(8*i)]);\n', '   end\n', ""   assign ibuf_timer_in = ibuf_wr_en ? '0 : (ibuf_timer < TIMER_MAX) ? (ibuf_timer + 1'b1) : ibuf_timer;\n"", '\n', '   assign ibuf_merge_en = lsu_busreq_dc5 & lsu_commit_dc5 & lsu_pkt_dc5.store & ibuf_valid & ibuf_write & (lsu_addr_dc5[31:2] == ibuf_addr[31:2]) & ~is_sideeffects_dc5 & ~bus_coalescing_disable;\n', ""   assign ibuf_merge_in = ~ldst_dual_dc5;   // If it's a unaligned store, merge needs to happen on the way out of ibuf\n"", '\n', '   // ibuf signals going to bus buffer after merging\n', '   for (genvar i=0; i<4; i++) begin\n', '      assign ibuf_byteen_out[i] = (ibuf_merge_en & ~ibuf_merge_in) ? (ibuf_byteen[i] | ldst_byteen_lo_dc5[i]) : ibuf_byteen[i];\n', '      assign ibuf_data_out[(8*i)+7:(8*i)] = (ibuf_merge_en & ~ibuf_merge_in) ? (ldst_byteen_lo_dc5[i] ? store_data_lo_dc5[(8*i)+7:(8*i)] : ibuf_data[(8*i)+7:(8*i)]) :\n', '                                                                                                        ibuf_data[(8*i)+7:(8*i)];\n', '   end\n', '\n', ""   rvdffsc #(.WIDTH(1))              ibuf_valid_ff     (.din(1'b1),                        .dout(ibuf_valid),      .en(ibuf_wr_en), .clear(ibuf_rst), .clk(lsu_free_c2_clk), .*);\n"", '   rvdffs  #(.WIDTH(DEPTH_LOG2))     ibuf_tagff        (.din(ibuf_tag_in),                 .dout(ibuf_tag),        .en(ibuf_wr_en),                   .clk(lsu_bus_ibuf_c1_clk), .*);\n', '   rvdffs  #(.WIDTH(DEPTH_LOG2))     ibuf_dualtagff    (.din(ibuf_dualtag_in),             .dout(ibuf_dualtag),    .en(ibuf_wr_en),                   .clk(lsu_bus_ibuf_c1_clk), .*);\n', '   rvdffs  #(.WIDTH(1))              ibuf_dualff       (.din(ldst_dual_dc5),               .dout(ibuf_dual),       .en(ibuf_wr_en),                   .clk(lsu_bus_ibuf_c1_clk), .*);\n', '   rvdffs  #(.WIDTH(1))              ibuf_samedwff     (.din(ldst_samedw_dc5),             .dout(ibuf_samedw),     .en(ibuf_wr_en),                   .clk(lsu_bus_ibuf_c1_clk), .*);\n', '   rvdffs  #(.WIDTH(1))              ibuf_nomergeff    (.din(no_dword_merge_dc5),          .dout(ibuf_nomerge),    .en(ibuf_wr_en),                   .clk(lsu_bus_ibuf_c1_clk), .*);\n', '   rvdffs  #(.WIDTH(1))              ibuf_nbff         (.din(lsu_nonblock_load_valid_dc5), .dout(ibuf_nb),         .en(ibuf_wr_en),                   .clk(lsu_bus_ibuf_c1_clk), .*);\n', '   rvdffs  #(.WIDTH(1))              ibuf_sideeffectff (.din(is_sideeffects_dc5),          .dout(ibuf_sideeffect), .en(ibuf_wr_en),                   .clk(lsu_bus_ibuf_c1_clk), .*);\n', '   rvdffs  #(.WIDTH(1))              ibuf_unsignff     (.din(lsu_pkt_dc5.unsign),          .dout(ibuf_unsign),     .en(ibuf_wr_en),                   .clk(lsu_bus_ibuf_c1_clk), .*);\n', '   rvdffs  #(.WIDTH(1))              ibuf_writeff      (.din(lsu_pkt_dc5.store),           .dout(ibuf_write),      .en(ibuf_wr_en),                   .clk(lsu_bus_ibuf_c1_clk), .*);\n', '   rvdffs  #(.WIDTH(2))              ibuf_szff         (.din(ibuf_sz_in[1:0]),             .dout(ibuf_sz),         .en(ibuf_wr_en),                   .clk(lsu_bus_ibuf_c1_clk), .*);\n', '   rvdffe  #(.WIDTH(32))             ibuf_addrff       (.din(ibuf_addr_in[31:0]),          .dout(ibuf_addr),       .en(ibuf_wr_en),                                              .*);\n', '   rvdffs  #(.WIDTH(4))              ibuf_byteenff     (.din(ibuf_byteen_in[3:0]),         .dout(ibuf_byteen),     .en(ibuf_wr_en),                   .clk(lsu_bus_ibuf_c1_clk), .*);\n', '   rvdffe  #(.WIDTH(32))             ibuf_dataff       (.din(ibuf_data_in[31:0]),          .dout(ibuf_data),       .en(ibuf_wr_en),                                              .*);\n', '   rvdff   #(.WIDTH(TIMER_LOG2))     ibuf_timerff      (.din(ibuf_timer_in),               .dout(ibuf_timer),                                         .clk(lsu_free_c2_clk),     .*);\n', '\n', '   //------------------------------------------------------------------------------\n', '   // Input buffer logic ends here\n', '   //------------------------------------------------------------------------------\n', '\n', '\n', '   //------------------------------------------------------------------------------\n', '   // Output buffer logic starts here\n', '   //------------------------------------------------------------------------------\n', '\n', ""   assign obuf_wr_wait = (buf_numvld_wrcmd_any[3:0] == 4'b1) & (buf_numvld_cmd_any[3:0] == 4'b1) & (obuf_wr_timer != TIMER_MAX) & ~bus_coalescing_disable & ~buf_nomerge[CmdPtr0] & ~obuf_force_wr_en;\n"", ""   assign obuf_wr_timer_in = obuf_wr_en ? 3'b0: (((buf_numvld_cmd_any > 4'b0) & (obuf_wr_timer < TIMER_MAX)) ? (obuf_wr_timer + 1'b1) : obuf_wr_timer);\n"", ""   assign obuf_force_wr_en = lsu_busreq_dc2 & ~lsu_busreq_dc3 & ~lsu_busreq_dc4 & ~lsu_busreq_dc5 & ~ibuf_valid & (buf_numvld_cmd_any[3:0] == 4'b1) & (lsu_addr_dc2[31:2] != buf_addr[CmdPtr0][31:2]);   // Entry in dc2 can't merge with entry going to obuf and there is no entry in between\n"", ""   assign ibuf_buf_byp = ibuf_byp & (buf_numvld_pend_any[3:0] == 4'b0) & ~ldst_dual_dc5 & lsu_pkt_dc5.store;\n"", '\n', '   assign obuf_wr_en = (lsu_bus_clk_en & ((ibuf_buf_byp & lsu_commit_dc5) |\n', '                                          ((buf_state[CmdPtr0] == CMD) & found_cmdptr0 & ~buf_cmd_state_bus_en[CmdPtr0] &\n', '                                          (~(buf_dual[CmdPtr0] & buf_samedw[CmdPtr0] & ~buf_write[CmdPtr0]) | found_cmdptr1 | buf_nomerge[CmdPtr0] | obuf_force_wr_en)))) &\n', '                       (bus_cmd_ready | ~obuf_valid) & ~obuf_wr_wait & ~bus_sideeffect_pend & ~bus_addr_match_pending;\n', '   assign obuf_rst   = bus_cmd_sent & ~obuf_wr_en;\n', '   assign obuf_write_in = ibuf_buf_byp ? lsu_pkt_dc5.store : buf_write[CmdPtr0];\n', '   assign obuf_sideeffect_in = ibuf_buf_byp ? is_sideeffects_dc5 : buf_sideeffect[CmdPtr0];\n', '   assign obuf_addr_in[31:0] = ibuf_buf_byp ? lsu_addr_dc5[31:0] : buf_addr[CmdPtr0];\n', '   assign obuf_sz_in[1:0]    = ibuf_buf_byp ? {lsu_pkt_dc5.word, lsu_pkt_dc5.half} : buf_sz[CmdPtr0];\n', '   assign obuf_merge_in      = obuf_merge_en;\n', ""   assign obuf_tag0_in[LSU_BUS_TAG-1:0] = ibuf_buf_byp ? LSU_BUS_TAG'(WrPtr0_dc5) : LSU_BUS_TAG'(CmdPtr0);\n"", ""   assign obuf_tag1_in[LSU_BUS_TAG-1:0] = LSU_BUS_TAG'(CmdPtr1);\n"", '\n', '   assign obuf_cmd_done_in    = ~(obuf_wr_en | obuf_rst) & (obuf_cmd_done | bus_wcmd_sent);\n', '   assign obuf_data_done_in   = ~(obuf_wr_en | obuf_rst) & (obuf_data_done | bus_wdata_sent);\n', '\n', ""   assign obuf_byteen0_in[7:0] = ibuf_buf_byp ? (lsu_addr_dc5[2] ? {ldst_byteen_lo_dc5[3:0],4'b0} : {4'b0,ldst_byteen_lo_dc5[3:0]}) :\n"", ""                                                (buf_addr[CmdPtr0][2] ? {buf_byteen[CmdPtr0],4'b0} : {4'b0,buf_byteen[CmdPtr0]});\n"", ""   assign obuf_byteen1_in[7:0] = buf_addr[CmdPtr1][2] ? {buf_byteen[CmdPtr1],4'b0} : {4'b0,buf_byteen[CmdPtr1]};\n"", ""   assign obuf_data0_in[63:0]  = ibuf_buf_byp ? (lsu_addr_dc5[2] ? {store_data_lo_dc5[31:0],32'b0} : {32'b0,store_data_lo_dc5[31:0]}) :\n"", ""                                                (buf_addr[CmdPtr0][2] ? {buf_data[CmdPtr0],32'b0} : {32'b0,buf_data[CmdPtr0]});\n"", ""   assign obuf_data1_in[63:0]  = buf_addr[CmdPtr1][2] ? {buf_data[CmdPtr1],32'b0} : {32'b0,buf_data[CmdPtr1]};\n"", '   for (genvar i=0 ;i<8; i++) begin\n', '      assign obuf_byteen_in[i] = obuf_byteen0_in[i] | (obuf_merge_en & obuf_byteen1_in[i]);\n', '      assign obuf_data_in[(8*i)+7:(8*i)] = (obuf_merge_en & obuf_byteen1_in[i]) ? obuf_data1_in[(8*i)+7:(8*i)] : obuf_data0_in[(8*i)+7:(8*i)];\n', '   end\n', '\n', ""   // No store obuf merging for AXI since all stores are sent non-posted. Can't track the second id right now\n"", '   assign obuf_merge_en = (CmdPtr0 != CmdPtr1) & found_cmdptr0 & found_cmdptr1 & (buf_state[CmdPtr0] == CMD) & (buf_state[CmdPtr1] == CMD) & ~buf_cmd_state_bus_en[CmdPtr0] & ~buf_sideeffect[CmdPtr0] &\n', '                          (~buf_write[CmdPtr0] & buf_dual[CmdPtr0] & ~buf_dualhi[CmdPtr0] & buf_samedw[CmdPtr0]);  // CmdPtr0/CmdPtr1 are for same load which is within a DW\n', '\n', '   rvdff_fpga   #(1)              obuf_wren_ff      (.din(obuf_wr_en),        .dout(obuf_wr_enQ),                                        .clk(lsu_busm_clk), .clken(lsu_bus_clk_en), .rawclk(clk), .*);\n', '   rvdff_fpga   #(1)              obuf_cmd_done_ff  (.din(obuf_cmd_done_in),  .dout(obuf_cmd_done),                                      .clk(lsu_busm_clk), .clken(lsu_bus_clk_en), .rawclk(clk), .*);\n', '   rvdff_fpga   #(1)              obuf_data_done_ff (.din(obuf_data_done_in), .dout(obuf_data_done),                                     .clk(lsu_busm_clk), .clken(lsu_bus_clk_en), .rawclk(clk), .*);\n', ""   rvdffsc_fpga #(1)              obuf_valid_ff     (.din(1'b1),              .dout(obuf_valid),     .clear(obuf_rst),  .en(obuf_wr_en), .clk(lsu_busm_clk), .clken(lsu_bus_clk_en), .rawclk(clk), .*);\n"", '   rvdff_fpga   #(TIMER_LOG2)     obuf_timerff      (.din(obuf_wr_timer_in),  .dout(obuf_wr_timer),                                      .clk(lsu_busm_clk), .clken(lsu_bus_clk_en), .rawclk(clk), .*);\n', '\n', '   rvdff_fpga #(1)            lsu_axi_awvalid_ff (.din(lsu_axi_awvalid),                .dout(lsu_axi_awvalid_q),                .clk(lsu_busm_clk), .clken(lsu_bus_clk_en), .rawclk(clk), .*);\n', '   rvdff_fpga #(1)            lsu_axi_awready_ff (.din(lsu_axi_awready),                .dout(lsu_axi_awready_q),                .clk(lsu_busm_clk), .clken(lsu_bus_clk_en), .rawclk(clk), .*);\n', '   rvdff_fpga #(1)            lsu_axi_wvalid_ff  (.din(lsu_axi_wvalid),                 .dout(lsu_axi_wvalid_q),                 .clk(lsu_busm_clk), .clken(lsu_bus_clk_en), .rawclk(clk), .*);\n', '   rvdff_fpga #(1)            lsu_axi_wready_ff  (.din(lsu_axi_wready),                 .dout(lsu_axi_wready_q),                 .clk(lsu_busm_clk), .clken(lsu_bus_clk_en), .rawclk(clk), .*);\n', '   rvdff_fpga #(1)            lsu_axi_arvalid_ff (.din(lsu_axi_arvalid),                .dout(lsu_axi_arvalid_q),                .clk(lsu_busm_clk), .clken(lsu_bus_clk_en), .rawclk(clk), .*);\n', '   rvdff_fpga #(1)            lsu_axi_arready_ff (.din(lsu_axi_arready),                .dout(lsu_axi_arready_q),                .clk(lsu_busm_clk), .clken(lsu_bus_clk_en), .rawclk(clk), .*);\n', '   rvdff_fpga  #(1)           lsu_axi_bvalid_ff  (.din(lsu_axi_bvalid),                 .dout(lsu_axi_bvalid_q),                 .clk(lsu_busm_clk), .clken(lsu_bus_clk_en), .rawclk(clk), .*);\n', '   rvdff_fpga  #(1)           lsu_axi_bready_ff  (.din(lsu_axi_bready),                 .dout(lsu_axi_bready_q),                 .clk(lsu_busm_clk), .clken(lsu_bus_clk_en), .rawclk(clk), .*);\n', '   rvdff_fpga  #(2)           lsu_axi_bresp_ff   (.din(lsu_axi_bresp[1:0]),             .dout(lsu_axi_bresp_q[1:0]),             .clk(lsu_busm_clk), .clken(lsu_bus_clk_en), .rawclk(clk), .*);\n', '   rvdff_fpga  #(LSU_BUS_TAG) lsu_axi_bid_ff     (.din(lsu_axi_bid[LSU_BUS_TAG-1:0]),   .dout(lsu_axi_bid_q[LSU_BUS_TAG-1:0]),   .clk(lsu_busm_clk), .clken(lsu_bus_clk_en), .rawclk(clk), .*);\n', '   rvdff_fpga  #(1)           lsu_axi_rvalid_ff  (.din(lsu_axi_rvalid),                 .dout(lsu_axi_rvalid_q),                 .clk(lsu_busm_clk), .clken(lsu_bus_clk_en), .rawclk(clk), .*);\n', '   rvdff_fpga  #(1)           lsu_axi_rready_ff  (.din(lsu_axi_rready),                 .dout(lsu_axi_rready_q),                 .clk(lsu_busm_clk), .clken(lsu_bus_clk_en), .rawclk(clk), .*);\n', '   rvdff_fpga  #(2)           lsu_axi_rresp_ff   (.din(lsu_axi_rresp[1:0]),             .dout(lsu_axi_rresp_q[1:0]),             .clk(lsu_busm_clk), .clken(lsu_bus_clk_en), .rawclk(clk), .*);\n', '   rvdff_fpga  #(LSU_BUS_TAG) lsu_axi_rid_ff     (.din(lsu_axi_rid[LSU_BUS_TAG-1:0]),   .dout(lsu_axi_rid_q[LSU_BUS_TAG-1:0]),   .clk(lsu_busm_clk), .clken(lsu_bus_clk_en), .rawclk(clk), .*);\n', '\n', '\n', '   rvdffs  #(.WIDTH(LSU_BUS_TAG))    obuf_tag0ff       (.din(obuf_tag0_in),                .dout(obuf_tag0),       .en(obuf_wr_en),                   .clk(lsu_bus_obuf_c1_clk), .*);\n', '   rvdffs  #(.WIDTH(LSU_BUS_TAG))    obuf_tag1ff       (.din(obuf_tag1_in),                .dout(obuf_tag1),       .en(obuf_wr_en),                   .clk(lsu_bus_obuf_c1_clk), .*);\n', '   rvdffs  #(.WIDTH(1))              obuf_mergeff      (.din(obuf_merge_in),               .dout(obuf_merge),      .en(obuf_wr_en),                   .clk(lsu_bus_obuf_c1_clk), .*);\n', '   rvdffs  #(.WIDTH(1))              obuf_writeff      (.din(obuf_write_in),               .dout(obuf_write),      .en(obuf_wr_en),                   .clk(lsu_bus_obuf_c1_clk), .*);\n', '   rvdffs  #(.WIDTH(1))              obuf_sideeffectff (.din(obuf_sideeffect_in),          .dout(obuf_sideeffect), .en(obuf_wr_en),                   .clk(lsu_bus_obuf_c1_clk), .*);\n', '   rvdffs  #(.WIDTH(2))              obuf_szff         (.din(obuf_sz_in[1:0]),             .dout(obuf_sz),         .en(obuf_wr_en),                   .clk(lsu_bus_obuf_c1_clk), .*);\n', '   rvdffe  #(.WIDTH(32))             obuf_addrff       (.din(obuf_addr_in[31:0]),          .dout(obuf_addr),       .en(obuf_wr_en),                                              .*);\n', '   rvdffs  #(.WIDTH(8))              obuf_byteenff     (.din(obuf_byteen_in[7:0]),         .dout(obuf_byteen),     .en(obuf_wr_en),                   .clk(lsu_bus_obuf_c1_clk), .*);\n', '   rvdffe  #(.WIDTH(64))             obuf_dataff       (.din(obuf_data_in[63:0]),          .dout(obuf_data),       .en(obuf_wr_en),                                              .*);\n', '\n', '   //------------------------------------------------------------------------------\n', '   // Output buffer logic ends here\n', '   //------------------------------------------------------------------------------\n', '\n', '   // Find the entry to allocate and entry to send\n', '   always_comb begin\n', ""      WrPtr0_dc3[DEPTH_LOG2-1:0] = '0;\n"", ""      WrPtr1_dc3[DEPTH_LOG2-1:0] = '0;\n"", ""      found_wrptr0  = '0;\n"", ""      found_wrptr1  = '0;\n"", '\n', '      // Find first write pointer\n', '      for (int i=0; i<DEPTH; i++) begin\n', '         if (~found_wrptr0) begin\n', ""            WrPtr0_dc3[DEPTH_LOG2-1:0] = DEPTH_LOG2'(i);\n"", ""            found_wrptr0 = (buf_state[i] == IDLE) & ~((ibuf_valid & (ibuf_tag == DEPTH_LOG2'(i)))                                               |\n"", ""                                                      (lsu_busreq_dc4 & ((WrPtr0_dc4 == DEPTH_LOG2'(i)) | (ldst_dual_dc4 & (WrPtr1_dc4 == DEPTH_LOG2'(i))))) |\n"", ""                                                      (lsu_busreq_dc5 & ((WrPtr0_dc5 == DEPTH_LOG2'(i)) | (ldst_dual_dc5 & (WrPtr1_dc5 == DEPTH_LOG2'(i))))));\n"", '            //found_wrptr = (buf_state[i] == IDLE);\n', '         end\n', '      end\n', '\n', '      // Find second write pointer\n', '      for (int i=0; i<DEPTH; i++) begin\n', '         if (~found_wrptr1) begin\n', ""            WrPtr1_dc3[DEPTH_LOG2-1:0] = DEPTH_LOG2'(i);\n"", ""            found_wrptr1 = (buf_state[i] == IDLE) & ~((ibuf_valid & (ibuf_tag == DEPTH_LOG2'(i)))                                               |\n"", ""                                                      (lsu_busreq_dc3 & (WrPtr0_dc3 == DEPTH_LOG2'(i)))                                         |\n"", ""                                                      (lsu_busreq_dc4 & ((WrPtr0_dc4 == DEPTH_LOG2'(i)) | (ldst_dual_dc4 & (WrPtr1_dc4 == DEPTH_LOG2'(i))))) |\n"", ""                                                      (lsu_busreq_dc5 & ((WrPtr0_dc5 == DEPTH_LOG2'(i)) | (ldst_dual_dc5 & (WrPtr1_dc5 == DEPTH_LOG2'(i))))));\n"", '            //found_wrptr = (buf_state[i] == IDLE);\n', '         end\n', '      end\n', '   end\n', '\n', '   // Get the command ptr\n', '   for (genvar i=0; i<DEPTH; i++) begin\n', '      // These should be one-hot\n', '      assign CmdPtr0Dec[i] = ~(|buf_age[i]) & (buf_state[i] == CMD) & ~buf_cmd_state_bus_en[i];\n', '      assign CmdPtr1Dec[i] = ~(|(buf_age[i] & ~CmdPtr0Dec)) & ~CmdPtr0Dec[i] & (buf_state[i] == CMD) & ~buf_cmd_state_bus_en[i];\n', '   end\n', '\n', '   assign found_cmdptr0 = |CmdPtr0Dec;\n', '   assign found_cmdptr1 = |CmdPtr1Dec;\n', ""   assign CmdPtr0 = f_Enc8to3(8'(CmdPtr0Dec[DEPTH-1:0]));\n"", ""   assign CmdPtr1 = f_Enc8to3(8'(CmdPtr1Dec[DEPTH-1:0]));\n"", '\n', '   // Age vector\n', '   for (genvar i=0; i<DEPTH; i++) begin: GenAgeVec\n', '      for (genvar j=0; j<DEPTH; j++) begin\n', '         assign buf_age_in[i][j] = (((buf_state[i] == IDLE) & buf_state_en[i]) &\n', '                                           (((buf_state[j] == WAIT) | ((buf_state[j] == CMD) & ~buf_cmd_state_bus_en[j]))            |       // Set age bit for older entries\n', ""                                            (ibuf_drain_vld & lsu_busreq_dc5 & (ibuf_byp | ldst_dual_dc5) & (DEPTH_LOG2'(i) == WrPtr0_dc5) & (DEPTH_LOG2'(j) == ibuf_tag))  |       // Set case for dual lo\n"", ""                                            (ibuf_byp & lsu_busreq_dc5 & ldst_dual_dc5 & (DEPTH_LOG2'(i) == WrPtr1_dc5) & (DEPTH_LOG2'(j) == WrPtr0_dc5))))      |     // ibuf bypass case\n"", '                                   buf_age[i][j];\n', '         assign buf_age[i][j]    = buf_ageQ[i][j] & ~((buf_state[j] == CMD) & buf_cmd_state_bus_en[j]);  // Reset case\n', '\n', ""         assign buf_age_younger[i][j] = (i == j) ? 1'b0: (~buf_age[i][j] & (buf_state[j] != IDLE));   // Younger entries\n"", ""         assign buf_age_temp[i][j] = buf_age[i][j] & ~(CmdPtr0 == DEPTH_LOG2'(j));   // Used to determine CmdPtr1\n"", '      end\n', '   end\n', '\n', '\n', '   //------------------------------------------------------------------------------\n', '   // Buffer logic\n', '   //------------------------------------------------------------------------------\n', '   for (genvar i=0; i<DEPTH; i++) begin\n', '\n', '      assign ibuf_drainvec_vld[i] = (ibuf_drain_vld & (i == ibuf_tag));\n', '      assign buf_byteen_in[i]     = ibuf_drainvec_vld[i] ? ibuf_byteen_out[3:0] : ((ibuf_byp & ldst_dual_dc5 & (i == WrPtr1_dc5)) ? ldst_byteen_hi_dc5[3:0] : ldst_byteen_lo_dc5[3:0]);\n', '      assign buf_addr_in[i]       = ibuf_drainvec_vld[i] ? ibuf_addr[31:0] : ((ibuf_byp & ldst_dual_dc5 & (i == WrPtr1_dc5)) ? end_addr_dc5[31:0] : lsu_addr_dc5[31:0]);\n', '      assign buf_dual_in[i]       = ibuf_drainvec_vld[i] ? ibuf_dual : ldst_dual_dc5;\n', '      assign buf_samedw_in[i]     = ibuf_drainvec_vld[i] ? ibuf_samedw : ldst_samedw_dc5;\n', '      assign buf_nomerge_in[i]    = ibuf_drainvec_vld[i] ? (ibuf_nomerge | ibuf_force_drain) : no_dword_merge_dc5;\n', ""      assign buf_dualhi_in[i]     = ibuf_drainvec_vld[i] ? ibuf_dual : (ibuf_byp & ldst_dual_dc5 & (i == WrPtr1_dc5));   // If it's dual, ibuf will always have the high\n"", '      assign buf_dualtag_in[i]    = ibuf_drainvec_vld[i] ? ibuf_dualtag : ((ibuf_byp & ldst_dual_dc5 & (i == WrPtr1_dc5)) ? WrPtr0_dc5 : WrPtr1_dc5);\n', '      assign buf_nb_in[i]         = ibuf_drainvec_vld[i] ? ibuf_nb : lsu_nonblock_load_valid_dc5;\n', '      assign buf_sideeffect_in[i] = ibuf_drainvec_vld[i] ? ibuf_sideeffect : is_sideeffects_dc5;\n', '      assign buf_unsign_in[i]     = ibuf_drainvec_vld[i] ? ibuf_unsign : lsu_pkt_dc5.unsign;\n', '      assign buf_sz_in[i]         = ibuf_drainvec_vld[i] ? ibuf_sz : {lsu_pkt_dc5.word, lsu_pkt_dc5.half};\n', '      assign buf_write_in[i]      = ibuf_drainvec_vld[i] ? ibuf_write : lsu_pkt_dc5.store;\n', '\n', '\n', '      // Buffer entry state machine\n', '      always_comb begin\n', '         buf_nxtstate[i]          = IDLE;\n', ""         buf_state_en[i]          = '0;\n"", ""         buf_cmd_state_bus_en[i]  = '0;\n"", ""         buf_resp_state_bus_en[i] = '0;\n"", ""         buf_state_bus_en[i]      = '0;\n"", ""         buf_wr_en[i]             = '0;\n"", ""         buf_data_in[i]           = '0;\n"", ""         buf_data_en[i]           = '0;\n"", ""         buf_error_en[i]          = '0;\n"", ""         buf_rst[i]               = '0;\n"", '\n', '         case (buf_state[i])\n', '            IDLE: begin\n', '                     buf_nxtstate[i] = lsu_bus_clk_en ? CMD : WAIT;\n', '                     buf_state_en[i] = (lsu_busreq_dc5 & (lsu_commit_dc5 | lsu_freeze_dc3) & (((ibuf_byp | ldst_dual_dc5) & ~ibuf_merge_en & (i == WrPtr0_dc5)) | (ibuf_byp & ldst_dual_dc5 & (i == WrPtr1_dc5)))) |\n', '                                       (ibuf_drain_vld & (i == ibuf_tag));\n', '                     buf_wr_en[i]    = buf_state_en[i];\n', '                     buf_data_en[i]  = buf_state_en[i];\n', '                     buf_data_in[i]   = (ibuf_drain_vld & (i == ibuf_tag)) ? ibuf_data_out[31:0] : store_data_lo_dc5[31:0];\n', '            end\n', '            WAIT: begin\n', '                     buf_nxtstate[i] = CMD;\n', '                     buf_state_en[i] = lsu_bus_clk_en;\n', '            end\n', '            CMD: begin\n', '                     buf_nxtstate[i]          = RESP;\n', '                     buf_cmd_state_bus_en[i]  = ((obuf_tag0 == i) | (obuf_merge & (obuf_tag1 == i))) & obuf_valid & obuf_wr_enQ;  // Just use the recently written obuf_valid\n', '                     buf_state_bus_en[i]      = buf_cmd_state_bus_en[i];\n', '                     buf_state_en[i]          = buf_state_bus_en[i] & lsu_bus_clk_en;\n', '            end\n', '            RESP: begin\n', '                     buf_nxtstate[i]           = (buf_write[i] & ~bus_rsp_write_error) ? IDLE : DONE;   // Need to go to done to handle errors\n', ""                     buf_resp_state_bus_en[i]  = (bus_rsp_write & (bus_rsp_write_tag == LSU_BUS_TAG'(i))) |\n"", ""                                                 (bus_rsp_read  & ((bus_rsp_read_tag == LSU_BUS_TAG'(i)) | (buf_dual[i] & buf_dualhi[i] & ~buf_write[i] & buf_samedw[i] & (bus_rsp_read_tag == LSU_BUS_TAG'(buf_dualtag[i])))));\n"", '                     buf_state_bus_en[i]       = buf_resp_state_bus_en[i];\n', '                     buf_state_en[i]           = buf_state_bus_en[i] & lsu_bus_clk_en;\n', '                     buf_data_en[i]            = buf_state_bus_en[i] & ~buf_write[i] & bus_rsp_read & lsu_bus_clk_en;\n', '                     // Need to capture the error for stores as well for AXI\n', ""                     buf_error_en[i]           = buf_state_bus_en[i] & lsu_bus_clk_en & ((bus_rsp_read_error  & (bus_rsp_read_tag  == LSU_BUS_TAG'(i))) |\n"", ""                                                                                         (bus_rsp_write_error & (bus_rsp_write_tag == LSU_BUS_TAG'(i))));\n"", '                     buf_data_in[i][31:0]      = (buf_state_en[i] & ~buf_error_en[i]) ? (buf_addr[i][2] ? bus_rsp_rdata[63:32] : bus_rsp_rdata[31:0]) : bus_rsp_rdata[31:0];\n', '            end\n', '            DONE: begin\n', '                     buf_nxtstate[i]           = IDLE;\n', '                     buf_rst[i]                = lsu_bus_clk_en_q & (buf_write[i] | ~buf_dual[i] | (buf_state[buf_dualtag[i]] == DONE));\n', '                     buf_state_en[i]           = buf_rst[i];\n', '            end\n', '            default : begin\n', '                     buf_nxtstate[i]          = IDLE;\n', ""                     buf_state_en[i]          = '0;\n"", ""                     buf_cmd_state_bus_en[i]  = '0;\n"", ""                     buf_resp_state_bus_en[i] = '0;\n"", ""                     buf_state_bus_en[i]      = '0;\n"", ""                     buf_wr_en[i]             = '0;\n"", ""                     buf_data_in[i]           = '0;\n"", ""                     buf_data_en[i]           = '0;\n"", ""                     buf_error_en[i]          = '0;\n"", ""                     buf_rst[i]               = '0;\n"", '            end\n', '         endcase\n', '      end\n', '\n', ""      assign buf_state[i] = state_t'(buf_state_out[i]);\n"", '      rvdffs  #(.WIDTH($bits(state_t))) buf_state_ff     (.din(buf_nxtstate[i]),             .dout(buf_state_out[i]),    .en(buf_state_en[i]),                                        .clk(lsu_bus_buf_c1_clk), .*);\n', '      rvdff   #(.WIDTH(DEPTH))          buf_ageff        (.din(buf_age_in[i]),               .dout(buf_ageQ[i]),                                                                    .clk(lsu_bus_buf_c1_clk), .*);\n', '      rvdffs  #(.WIDTH(DEPTH_LOG2))     buf_dualtagff    (.din(buf_dualtag_in[i]),           .dout(buf_dualtag[i]),    .en(buf_wr_en[i]),                                           .clk(lsu_bus_buf_c1_clk), .*);\n', '      rvdffs  #(.WIDTH(1))              buf_dualff       (.din(buf_dual_in[i]),              .dout(buf_dual[i]),       .en(buf_wr_en[i]),                                           .clk(lsu_bus_buf_c1_clk), .*);\n', '      rvdffs  #(.WIDTH(1))              buf_samedwff     (.din(buf_samedw_in[i]),            .dout(buf_samedw[i]),     .en(buf_wr_en[i]),                                           .clk(lsu_bus_buf_c1_clk), .*);\n', '      rvdffs  #(.WIDTH(1))              buf_nomergeff    (.din(buf_nomerge_in[i]),           .dout(buf_nomerge[i]),    .en(buf_wr_en[i]),                                           .clk(lsu_bus_buf_c1_clk), .*);\n', '      rvdffs  #(.WIDTH(1))              buf_dualhiff     (.din(buf_dualhi_in[i]),            .dout(buf_dualhi[i]),     .en(buf_wr_en[i]),                                           .clk(lsu_bus_buf_c1_clk), .*);\n', '      rvdffs  #(.WIDTH(1))              buf_nbff         (.din(buf_nb_in[i]),                .dout(buf_nb[i]),         .en(buf_wr_en[i]),                                           .clk(lsu_bus_buf_c1_clk), .*);\n', '      rvdffs  #(.WIDTH(1))              buf_sideeffectff (.din(buf_sideeffect_in[i]),        .dout(buf_sideeffect[i]), .en(buf_wr_en[i]),                                           .clk(lsu_bus_buf_c1_clk), .*);\n', '      rvdffs  #(.WIDTH(1))              buf_unsignff     (.din(buf_unsign_in[i]),            .dout(buf_unsign[i]),     .en(buf_wr_en[i]),                                           .clk(lsu_bus_buf_c1_clk), .*);\n', '      rvdffs  #(.WIDTH(1))              buf_writeff      (.din(buf_write_in[i]),             .dout(buf_write[i]),      .en(buf_wr_en[i]),                                           .clk(lsu_bus_buf_c1_clk), .*);\n', '      rvdffs  #(.WIDTH(2))              buf_szff         (.din(buf_sz_in[i]),                .dout(buf_sz[i]),         .en(buf_wr_en[i]),                                           .clk(lsu_bus_buf_c1_clk), .*);\n', '      rvdffe  #(.WIDTH(32))             buf_addrff       (.din(buf_addr_in[i][31:0]),        .dout(buf_addr[i]),       .en(buf_wr_en[i]),                                                                     .*);\n', '      rvdffs  #(.WIDTH(4))              buf_byteenff     (.din(buf_byteen_in[i][3:0]),       .dout(buf_byteen[i]),     .en(buf_wr_en[i]),                                           .clk(lsu_bus_buf_c1_clk), .*);\n', '      rvdffe  #(.WIDTH(32))             buf_dataff       (.din(buf_data_in[i][31:0]),        .dout(buf_data[i]),       .en(buf_data_en[i]),                                                                   .*);\n', ""      rvdffsc #(.WIDTH(1))              buf_errorff      (.din(1'b1),                        .dout(buf_error[i]),      .en(buf_error_en[i]),                    .clear(buf_rst[i]), .clk(lsu_bus_buf_c1_clk), .*);\n"", '\n', '   end\n', '\n', '   // buffer full logic\n', '   always_comb begin\n', ""      buf_numvld_any[3:0] =  ({3'b0,(lsu_pkt_dc1.valid & ~lsu_pkt_dc1.dma)} << (lsu_pkt_dc1.valid & ldst_dual_dc1)) +\n"", ""                             ({3'b0,lsu_busreq_dc2} << ldst_dual_dc2) +\n"", ""                             ({3'b0,lsu_busreq_dc3} << ldst_dual_dc3) +\n"", ""                             ({3'b0,lsu_busreq_dc4} << ldst_dual_dc4) +\n"", ""                             ({3'b0,lsu_busreq_dc5} << ldst_dual_dc5) +\n"", ""                             {3'b0,ibuf_valid};\n"", ""      buf_numvld_wrcmd_any[3:0] = 4'b0;\n"", ""      buf_numvld_cmd_any[3:0] = 4'b0;\n"", ""      buf_numvld_pend_any[3:0] = 4'b0;\n"", '      for (int i=0; i<DEPTH; i++) begin\n', ""         buf_numvld_any[3:0] += {3'b0, (buf_state[i] != IDLE)};\n"", ""         buf_numvld_wrcmd_any[3:0] += {3'b0, (buf_write[i] & (buf_state[i] == CMD) & ~buf_cmd_state_bus_en[i])};\n"", ""         buf_numvld_cmd_any[3:0]   += {3'b0, ((buf_state[i] == CMD) & ~buf_cmd_state_bus_en[i])};\n"", ""         buf_numvld_pend_any[3:0]   += {3'b0, ((buf_state[i] == WAIT) | ((buf_state[i] == CMD) & ~buf_cmd_state_bus_en[i]))};\n"", '      end\n', '   end\n', '\n', '   assign lsu_bus_buffer_pend_any = (buf_numvld_pend_any != 0);\n', '   assign lsu_bus_buffer_full_any = (buf_numvld_any[3:0] >= (DEPTH-1));\n', '   assign lsu_bus_buffer_empty_any = ~(|buf_state[DEPTH-1:0]) & ~ibuf_valid & ~obuf_valid;\n', '\n', '   // Freeze logic\n', '   assign FreezePtrEn  = lsu_busreq_dc3 & lsu_pkt_dc3.load & ld_freeze_dc3;\n', '   assign ld_freeze_en = (dec_nonblock_load_freeze_dc2 | (dec_tlu_dccm_nonblock_dma_disable & is_sideeffects_dc2)) & lsu_busreq_dc2 & lsu_pkt_dc2.load & ~lsu_freeze_dc3 & ~flush_dc2_up & ~ld_full_hit_dc2;\n', '   always_comb begin\n', '      ld_freeze_rst = flush_dc3 | (dec_tlu_cancel_e4 & ld_freeze_dc3);\n', '      for (int i=0; i<DEPTH; i++) begin\n', ""         ld_freeze_rst |= (buf_rst[i] & (DEPTH_LOG2'(i) == FreezePtr) & ~FreezePtrEn & ld_freeze_dc3);\n"", '      end\n', '   end\n', '\n', '   // Load signals for freeze\n', ""   assign ld_block_bus_data[31:0]     = 32'(({({32{buf_dual[FreezePtr]}} & buf_data[buf_dualtag[FreezePtr]]), buf_data[FreezePtr][31:0]}) >> (8*buf_addr[FreezePtr][1:0]));\n"", ""   assign ld_precise_bus_error         = (buf_error[FreezePtr] | (buf_dual[FreezePtr] & buf_error[buf_dualtag[FreezePtr]])) & ~buf_write[FreezePtr] & buf_rst[FreezePtr] & lsu_freeze_dc3 & ld_freeze_rst & ~flush_dc3;   // Don't give bus error for interrupts\n"", '   assign ld_bus_error_addr_dc3[31:0]  = buf_addr[FreezePtr][31:0];\n', '\n', '   // Non blocking ports\n', '   assign lsu_nonblock_load_valid_dc3 = lsu_busreq_dc3 & lsu_pkt_dc3.valid & lsu_pkt_dc3.load & ~flush_dc3 & ~dec_nonblock_load_freeze_dc3 & ~lsu_freeze_dc3;\n', '   assign lsu_nonblock_load_tag_dc3[DEPTH_LOG2-1:0] = WrPtr0_dc3[DEPTH_LOG2-1:0];\n', '   assign lsu_nonblock_load_inv_dc5 = lsu_nonblock_load_valid_dc5 & ~lsu_commit_dc5;\n', '   assign lsu_nonblock_load_inv_tag_dc5[DEPTH_LOG2-1:0] = WrPtr0_dc5[DEPTH_LOG2-1:0];      // dc5 tag needs to be accurate even if there is no invalidate\n', '\n', '   always_comb begin\n', ""      lsu_nonblock_load_data_valid_lo = '0;\n"", ""      lsu_nonblock_load_data_valid_hi = '0;\n"", ""      lsu_nonblock_load_data_error_lo = '0;\n"", ""      lsu_nonblock_load_data_error_hi = '0;\n"", ""      lsu_nonblock_load_data_tag[DEPTH_LOG2-1:0] = '0;\n"", ""      lsu_nonblock_load_data_lo[31:0] = '0;\n"", ""      lsu_nonblock_load_data_hi[31:0] = '0;\n"", '      for (int i=0; i<DEPTH; i++) begin\n', '          // Use buf_rst[i] instead of buf_state_en[i] for timing\n', '          lsu_nonblock_load_data_valid_hi      |= lsu_bus_clk_en_q & (buf_state[i] == DONE) & buf_rst[i] & buf_nb[i] & ~buf_error[i] & (buf_dual[i] & buf_dualhi[i]);\n', '          lsu_nonblock_load_data_valid_lo      |= lsu_bus_clk_en_q & (buf_state[i] == DONE) & buf_rst[i] & buf_nb[i] & ~buf_error[i] & (~buf_dual[i] | ~buf_dualhi[i]);\n', '          lsu_nonblock_load_data_error_hi      |= lsu_bus_clk_en_q & (buf_state[i] == DONE) & buf_rst[i] & buf_error[i] & buf_nb[i] & (buf_dual[i] & buf_dualhi[i]);\n', '          lsu_nonblock_load_data_error_lo      |= lsu_bus_clk_en_q & (buf_state[i] == DONE) & buf_rst[i] & buf_error[i] & buf_nb[i] & (~buf_dual[i] | ~buf_dualhi[i]);\n', ""          lsu_nonblock_load_data_tag[DEPTH_LOG2-1:0]   |= DEPTH_LOG2'(i) & {DEPTH_LOG2{((buf_state[i] == DONE) & buf_nb[i] & buf_rst[i] & (~buf_dual[i] | ~buf_dualhi[i]))}};\n"", '          lsu_nonblock_load_data_lo[31:0]      |= buf_data[i][31:0] & {32{((buf_state[i] == DONE) & buf_nb[i] & buf_rst[i] & (~buf_dual[i] | ~buf_dualhi[i]))}};\n', '          lsu_nonblock_load_data_hi[31:0]      |= buf_data[i][31:0] & {32{((buf_state[i] == DONE) & buf_nb[i] & buf_rst[i] & (buf_dual[i] & buf_dualhi[i]))}};\n', '      end\n', '   end\n', '\n', '   assign lsu_nonblock_addr_offset[1:0] = buf_addr[lsu_nonblock_load_data_tag][1:0];\n', '   assign lsu_nonblock_sz[1:0]          = buf_sz[lsu_nonblock_load_data_tag][1:0];\n', '   assign lsu_nonblock_unsign           = buf_unsign[lsu_nonblock_load_data_tag];\n', '   assign lsu_nonblock_dual             = buf_dual[lsu_nonblock_load_data_tag];\n', ""   assign lsu_nonblock_data_unalgn[31:0] = 32'({lsu_nonblock_load_data_hi[31:0], lsu_nonblock_load_data_lo[31:0]} >> 8*lsu_nonblock_addr_offset[1:0]);\n"", '\n', '   assign lsu_nonblock_load_data_valid = lsu_nonblock_load_data_valid_lo & (~lsu_nonblock_dual | lsu_nonblock_load_data_valid_hi);\n', '   assign lsu_nonblock_load_data_error = lsu_nonblock_load_data_error_lo | (lsu_nonblock_dual & lsu_nonblock_load_data_error_hi);\n', ""   assign lsu_nonblock_load_data = ({32{ lsu_nonblock_unsign & (lsu_nonblock_sz[1:0] == 2'b00)}} & {24'b0,lsu_nonblock_data_unalgn[7:0]}) |\n"", ""                                   ({32{ lsu_nonblock_unsign & (lsu_nonblock_sz[1:0] == 2'b01)}} & {16'b0,lsu_nonblock_data_unalgn[15:0]}) |\n"", ""                                   ({32{~lsu_nonblock_unsign & (lsu_nonblock_sz[1:0] == 2'b00)}} & {{24{lsu_nonblock_data_unalgn[7]}}, lsu_nonblock_data_unalgn[7:0]}) |\n"", ""                                   ({32{~lsu_nonblock_unsign & (lsu_nonblock_sz[1:0] == 2'b01)}} & {{16{lsu_nonblock_data_unalgn[15]}},lsu_nonblock_data_unalgn[15:0]}) |\n"", ""                                   ({32{(lsu_nonblock_sz[1:0] == 2'b10)}} & lsu_nonblock_data_unalgn[31:0]);\n"", '\n', '   // Determine if there is a pending return to sideeffect load/store\n', '   always_comb begin\n', '      bus_sideeffect_pend = obuf_valid & obuf_sideeffect & dec_tlu_sideeffect_posted_disable;\n', '      for (int i=0; i<DEPTH; i++) begin\n', '         bus_sideeffect_pend |= ((buf_state[i] == RESP) & buf_sideeffect[i] & dec_tlu_sideeffect_posted_disable);\n', '      end\n', '   end\n', '\n', '\n', '   // Imprecise bus errors\n', '   assign lsu_imprecise_error_load_any       = lsu_nonblock_load_data_error;   // This is to make sure we send only one imprecise error for loads\n', '\n', '\n', '   // We have no ordering rules for AXI. Need to check outstanding trxns to same address for AXI\n', '   always_comb begin\n', ""      bus_addr_match_pending = '0;\n"", '      for (int i=0; i<DEPTH; i++) begin\n', ""         bus_addr_match_pending |= (obuf_valid & (obuf_addr[31:3] == buf_addr[i][31:3]) & (buf_state[i] == RESP) & ~((obuf_tag0 == LSU_BUS_TAG'(i)) | (obuf_merge & (obuf_tag1 == LSU_BUS_TAG'(i)))));\n"", '      end\n', '   end\n', '\n', '   // Store imprecise error logic\n', '   always_comb begin\n', ""      lsu_imprecise_error_store_any = '0;\n"", ""      lsu_imprecise_error_store_tag = '0;\n"", '      for (int i=0; i<DEPTH; i++) begin\n', '         lsu_imprecise_error_store_any |= lsu_bus_clk_en_q & (buf_state[i] == DONE) & buf_error[i] & buf_write[i];\n', ""         lsu_imprecise_error_store_tag |= DEPTH_LOG2'(i) & {DEPTH_LOG2{((buf_state[i] == DONE) & buf_error[i] & buf_write[i])}};\n"", '      end\n', '   end\n', '   assign lsu_imprecise_error_addr_any[31:0] = lsu_imprecise_error_load_any ? buf_addr[lsu_nonblock_load_data_tag] : buf_addr[lsu_imprecise_error_store_tag];\n', '\n', '   // Generic bus signals\n', '   assign bus_cmd_ready                      = obuf_write ? ((obuf_cmd_done | obuf_data_done) ? (obuf_cmd_done ? lsu_axi_wready : lsu_axi_awready) : (lsu_axi_awready & lsu_axi_wready)) : lsu_axi_arready;\n', '   assign bus_wcmd_sent                      = lsu_axi_awvalid & lsu_axi_awready;\n', '   assign bus_wdata_sent                     = lsu_axi_wvalid & lsu_axi_wready;\n', '   assign bus_cmd_sent                       = ((obuf_cmd_done | bus_wcmd_sent) & (obuf_data_done | bus_wdata_sent)) | (lsu_axi_arvalid & lsu_axi_arready);\n', '\n', '   assign bus_rsp_read                       = lsu_axi_rvalid_q & lsu_axi_rready_q;\n', '   assign bus_rsp_write                      = lsu_axi_bvalid_q & lsu_axi_bready_q;\n', '   assign bus_rsp_read_tag[LSU_BUS_TAG-1:0]  = lsu_axi_rid_q[LSU_BUS_TAG-1:0];\n', '   assign bus_rsp_write_tag[LSU_BUS_TAG-1:0] = lsu_axi_bid_q[LSU_BUS_TAG-1:0];\n', ""   assign bus_rsp_write_error                = bus_rsp_write & (lsu_axi_bresp_q[1:0] != 2'b0);\n"", ""   assign bus_rsp_read_error                 = bus_rsp_read  & (lsu_axi_rresp_q[1:0] != 2'b0);\n"", '   assign bus_rsp_rdata[63:0]                = lsu_axi_rdata_q[63:0];\n', '\n', '   // AXI command signals\n', '   assign lsu_axi_awvalid               = obuf_valid & obuf_write & ~obuf_cmd_done & ~bus_addr_match_pending;\n', ""   assign lsu_axi_awid[LSU_BUS_TAG-1:0] = LSU_BUS_TAG'(obuf_tag0);\n"", ""   assign lsu_axi_awaddr[31:0]          = obuf_sideeffect ? obuf_addr[31:0] : {obuf_addr[31:3],3'b0};\n"", ""   assign lsu_axi_awsize[2:0]           = obuf_sideeffect ? {1'b0, obuf_sz[1:0]} : 3'b011;\n"", ""   assign lsu_axi_awprot[2:0]           = '0;\n"", ""   assign lsu_axi_awcache[3:0]          = obuf_sideeffect ? 4'b0 : 4'b1111;\n"", '   assign lsu_axi_awregion[3:0]         = obuf_addr[31:28];\n', ""   assign lsu_axi_awlen[7:0]            = '0;\n"", ""   assign lsu_axi_awburst[1:0]          = 2'b01;\n"", ""   assign lsu_axi_awqos[3:0]            = '0;\n"", ""   assign lsu_axi_awlock                = '0;\n"", '\n', '   assign lsu_axi_wvalid                = obuf_valid & obuf_write & ~obuf_data_done & ~bus_addr_match_pending;\n', '   assign lsu_axi_wstrb[7:0]            = obuf_byteen[7:0] & {8{obuf_write}};\n', '   assign lsu_axi_wdata[63:0]           = obuf_data[63:0];\n', ""   assign lsu_axi_wlast                 = '1;\n"", '\n', '   assign lsu_axi_arvalid               = obuf_valid & ~obuf_write & ~bus_addr_match_pending;\n', ""   assign lsu_axi_arid[LSU_BUS_TAG-1:0] = LSU_BUS_TAG'(obuf_tag0);\n"", ""   assign lsu_axi_araddr[31:0]          = obuf_sideeffect ? obuf_addr[31:0] : {obuf_addr[31:3],3'b0};\n"", ""   assign lsu_axi_arsize[2:0]           = obuf_sideeffect ? {1'b0, obuf_sz[1:0]} : 3'b011;\n"", ""   assign lsu_axi_arprot[2:0]           = '0;\n"", ""   assign lsu_axi_arcache[3:0]          = obuf_sideeffect ? 4'b0 : 4'b1111;\n"", '   assign lsu_axi_arregion[3:0]         = obuf_addr[31:28];\n', ""   assign lsu_axi_arlen[7:0]            = '0;\n"", ""   assign lsu_axi_arburst[1:0]          = 2'b01;\n"", ""   assign lsu_axi_arqos[3:0]            = '0;\n"", ""   assign lsu_axi_arlock                = '0;\n"", '\n', '   assign lsu_axi_bready = 1;\n', '   assign lsu_axi_rready = 1;\n', '\n', '   // PMU signals\n', '   assign lsu_pmu_bus_trxn  = (lsu_axi_awvalid_q & lsu_axi_awready_q) | (lsu_axi_wvalid_q & lsu_axi_wready_q) | (lsu_axi_arvalid_q & lsu_axi_arready_q);\n', '   assign lsu_pmu_bus_misaligned = lsu_busreq_dc2 & ldst_dual_dc2;\n', '   assign lsu_pmu_bus_error = ld_bus_error_dc3 | lsu_imprecise_error_load_any | lsu_imprecise_error_store_any;\n', '   assign lsu_pmu_bus_busy  = (lsu_axi_awvalid_q & ~lsu_axi_awready_q) | (lsu_axi_wvalid_q & ~lsu_axi_wready_q) | (lsu_axi_arvalid_q & ~lsu_axi_arready_q);\n', '\n', '   rvdffe #(.WIDTH(64))          lsu_axi_rdata_ff   (.din(lsu_axi_rdata[63:0]),            .dout(lsu_axi_rdata_q[63:0]),            .en(lsu_axi_rvalid & lsu_bus_clk_en), .*);\n', '\n', '   // General flops\n', ""   rvdffsc #(.WIDTH(1))          ld_freezeff            (.din(1'b1),                    .dout(ld_freeze_dc3),       .en(ld_freeze_en), .clear(ld_freeze_rst), .clk(lsu_free_c2_clk), .*);\n"", '   rvdffs  #(.WIDTH(DEPTH_LOG2)) lsu_FreezePtrff        (.din(WrPtr0_dc3),              .dout(FreezePtr),           .en(FreezePtrEn),                         .clk(lsu_free_c2_clk), .*);\n', '   rvdff   #(.WIDTH(1))          ld_bus_errorff         (.din(ld_precise_bus_error),    .dout(ld_bus_error_dc3),                                              .clk(lsu_free_c2_clk), .*);\n', '   rvdff   #(.WIDTH(32))         ld_bus_dataff          (.din(ld_block_bus_data[31:0]), .dout(ld_bus_data_dc3[31:0]),                                         .clk(lsu_free_c2_clk), .*);\n', '\n', '   rvdff #(.WIDTH(DEPTH_LOG2)) lsu_WrPtr0_dc4ff (.din(WrPtr0_dc3), .dout(WrPtr0_dc4), .clk(lsu_c2_dc4_clk), .*);\n', '   rvdff #(.WIDTH(DEPTH_LOG2)) lsu_WrPtr0_dc5ff (.din(WrPtr0_dc4), .dout(WrPtr0_dc5), .clk(lsu_c2_dc5_clk), .*);\n', '   rvdff #(.WIDTH(DEPTH_LOG2)) lsu_WrPtr1_dc4ff (.din(WrPtr1_dc3), .dout(WrPtr1_dc4), .clk(lsu_c2_dc4_clk), .*);\n', '   rvdff #(.WIDTH(DEPTH_LOG2)) lsu_WrPtr1_dc5ff (.din(WrPtr1_dc4), .dout(WrPtr1_dc5), .clk(lsu_c2_dc5_clk), .*);\n', '\n', ""   rvdff #(.WIDTH(1)) lsu_busreq_dc3ff (.din(lsu_busreq_dc2 & ~lsu_freeze_dc3 & ~ld_full_hit_dc2), .dout(lsu_busreq_dc3), .clk(lsu_c2_dc3_clk), .*);  // Don't want dc2 to dc3 propagation during freeze. Maybe used freeze gated clock\n"", '   rvdff #(.WIDTH(1)) lsu_busreq_dc4ff (.din(lsu_busreq_dc3 & ~flush_dc4),      .dout(lsu_busreq_dc4), .clk(lsu_c2_dc4_clk), .*);\n', '   rvdff #(.WIDTH(1)) lsu_busreq_dc5ff (.din(lsu_busreq_dc4 & ~flush_dc5),      .dout(lsu_busreq_dc5), .clk(lsu_c2_dc5_clk), .*);\n', '\n', '   rvdff_fpga #(.WIDTH(1)) dec_nonblock_load_freeze_dc3ff (.din(dec_nonblock_load_freeze_dc2), .dout(dec_nonblock_load_freeze_dc3), .clk(lsu_freeze_c2_dc3_clk), .clken(lsu_freeze_c2_dc3_clken), .rawclk(clk), .*);\n', '\n', '\n', '\n', '   rvdff #(.WIDTH(1)) lsu_nonblock_load_valid_dc4ff  (.din(lsu_nonblock_load_valid_dc3),  .dout(lsu_nonblock_load_valid_dc4), .clk(lsu_c2_dc4_clk), .*);\n', '   rvdff #(.WIDTH(1)) lsu_nonblock_load_valid_dc5ff  (.din(lsu_nonblock_load_valid_dc4),  .dout(lsu_nonblock_load_valid_dc5), .clk(lsu_c2_dc5_clk), .*);\n', '\n', '`ifdef ASSERT_ON\n', '\n', '   for (genvar i=0; i<4; i++) begin: GenByte\n', '      assert_ld_byte_hitvecfn_lo_onehot: assert #0 ($onehot0(ld_byte_hitvecfn_lo[i][DEPTH-1:0]));\n', '      assert_ld_byte_hitvecfn_hi_onehot: assert #0 ($onehot0(ld_byte_hitvecfn_hi[i][DEPTH-1:0]));\n', '   end\n', '\n', '   assert_CmdPtr0Dec_onehot: assert #0 ($onehot0(CmdPtr0Dec[DEPTH-1:0]));\n', '   assert_CmdPtr1Dec_onehot: assert #0 ($onehot0(CmdPtr1Dec[DEPTH-1:0]));\n', '\n', '`endif\n', '\n', 'endmodule // lsu_bus_buffer\n']"
"['// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '\n', '//********************************************************************************\n', '// $Id$\n', '//\n', '//\n', '// Owner:\n', '// Function: lsu interface with interface queue\n', '// Comments:\n', '//\n', '//********************************************************************************\n', 'module lsu_bus_intf\n', '   import veer_types::*;\n', '(\n', '   input logic                          clk,\n', '   input logic                          rst_l,\n', '   input logic                          scan_mode,\n', '   input logic                          dec_tlu_dccm_nonblock_dma_disable, // disable dma nonblock\n', '   input logic                          dec_tlu_wb_coalescing_disable,    // disable write buffer coalescing\n', '   input logic                          dec_tlu_ld_miss_byp_wb_disable,   // disable ld miss bypass of the write buffer\n', '   input logic                          dec_tlu_sideeffect_posted_disable,  // disable posted writes to sideeffect addr to the bus\n', '\n', '   // various clocks needed for the bus reads and writes\n', '   input logic                          lsu_c1_dc3_clk,\n', '   input logic                          lsu_c1_dc4_clk,\n', '   input logic                          lsu_c1_dc5_clk,\n', '   input logic                          lsu_c2_dc3_clk,\n', '   input logic                          lsu_c2_dc4_clk,\n', '   input logic                          lsu_c2_dc5_clk,\n', '   input logic                          lsu_freeze_c1_dc2_clk,\n', '   input logic                          lsu_freeze_c1_dc3_clk,\n', '   input logic                          lsu_freeze_c2_dc2_clk,\n', '   input logic                          lsu_freeze_c2_dc3_clk,\n', '   input logic                          lsu_freeze_c1_dc2_clken,\n', '   input logic                          lsu_freeze_c1_dc3_clken,\n', '   input logic                          lsu_freeze_c2_dc2_clken,\n', '   input logic                          lsu_freeze_c2_dc3_clken,\n', '   input logic                          lsu_bus_ibuf_c1_clk,\n', '   input logic                          lsu_bus_obuf_c1_clk,\n', '   input logic                          lsu_bus_buf_c1_clk,\n', '   input logic                          lsu_free_c2_clk,\n', '   input logic                          free_clk,\n', '   input logic                          lsu_busm_clk,\n', '\n', '   input logic                          lsu_busreq_dc2,                   // bus request is in dc2\n', '\n', '   input                                lsu_pkt_t lsu_pkt_dc1,            // lsu packet flowing down the pipe\n', '   input                                lsu_pkt_t lsu_pkt_dc2,            // lsu packet flowing down the pipe\n', '   input                                lsu_pkt_t lsu_pkt_dc3,            // lsu packet flowing down the pipe\n', '   input                                lsu_pkt_t lsu_pkt_dc4,            // lsu packet flowing down the pipe\n', '   input                                lsu_pkt_t lsu_pkt_dc5,            // lsu packet flowing down the pipe\n', '\n', '   input logic [31:0]                   lsu_addr_dc1,                     // lsu address flowing down the pipe\n', '   input logic [31:0]                   lsu_addr_dc2,                     // lsu address flowing down the pipe\n', '   input logic [31:0]                   lsu_addr_dc3,                     // lsu address flowing down the pipe\n', '   input logic [31:0]                   lsu_addr_dc4,                     // lsu address flowing down the pipe\n', '   input logic [31:0]                   lsu_addr_dc5,                     // lsu address flowing down the pipe\n', '\n', '   input logic [31:0]                   end_addr_dc1,                     // lsu address flowing down the pipe\n', '   input logic [31:0]                   end_addr_dc2,                     // lsu address flowing down the pipe\n', '   input logic [31:0]                   end_addr_dc3,                     // lsu address flowing down the pipe\n', '   input logic [31:0]                   end_addr_dc4,                     // lsu address flowing down the pipe\n', '   input logic [31:0]                   end_addr_dc5,                     // lsu address flowing down the pipe\n', '\n', '   input logic                          addr_external_dc2,                // lsu instruction going to external\n', '   input logic                          addr_external_dc3,                // lsu instruction going to external\n', '   input logic                          addr_external_dc4,                // lsu instruction going to external\n', '   input logic                          addr_external_dc5,                // lsu instruction going to external\n', '\n', '   input logic [63:0]                   store_data_dc2,                   // store data flowing down the pipe\n', '   input logic [63:0]                   store_data_dc3,                   // store data flowing down the pipe\n', '   input logic [31:0]                   store_data_dc4,                   // store data flowing down the pipe\n', '   input logic [31:0]                   store_data_dc5,                   // store data flowing down the pipe\n', '\n', '   input logic                          lsu_commit_dc5,                   // lsu instruction in dc5 commits\n', '   input logic                          is_sideeffects_dc2,               // lsu attribute is side_effects\n', '   input logic                          is_sideeffects_dc3,               // lsu attribute is side_effects\n', '   input logic                          flush_dc2_up,                     // flush\n', '   input logic                          flush_dc3,                        // flush\n', '   input logic                          flush_dc4,                        // flush\n', '   input logic                          flush_dc5,                        // flush\n', '   input logic                          dec_tlu_cancel_e4,                // cancel the bus load in dc4 and reset the freeze\n', '\n', '   output logic                         lsu_freeze_dc3,                   // load goes to external and asserts freeze\n', '   output logic                         lsu_busreq_dc5,                   // bus request is in dc5\n', '   output logic                         lsu_bus_buffer_pend_any,          // bus buffer has a pending bus entry\n', '   output logic                         lsu_bus_buffer_full_any,          // write buffer is full\n', '   output logic                         lsu_bus_buffer_empty_any,         // write buffer is empty\n', '   output logic [31:0]                  bus_read_data_dc3,                // the bus return data\n', '\n', '   output logic                         ld_bus_error_dc3,                 // bus error in dc3\n', '   output logic [31:0]                  ld_bus_error_addr_dc3,            // address of the bus error\n', '\n', '   output logic                         lsu_imprecise_error_load_any,     // imprecise load bus error\n', '   output logic                         lsu_imprecise_error_store_any,    // imprecise store bus error\n', '   output logic [31:0]                  lsu_imprecise_error_addr_any,     // address of the imprecise error\n', '\n', '   // Non-blocking loads\n', '   input  logic                                dec_nonblock_load_freeze_dc2,\n', '   output logic                                lsu_nonblock_load_valid_dc3,     // there is an external load -> put in the cam\n', '   output logic [`RV_LSU_NUM_NBLOAD_WIDTH-1:0] lsu_nonblock_load_tag_dc3,       // the tag of the external non block load\n', '   output logic                                lsu_nonblock_load_inv_dc5,       // invalidate signal for the cam entry for non block loads\n', '   output logic [`RV_LSU_NUM_NBLOAD_WIDTH-1:0] lsu_nonblock_load_inv_tag_dc5,   // tag of the enrty which needs to be invalidated\n', '   output logic                                lsu_nonblock_load_data_valid,    // the non block is valid - sending information back to the cam\n', '   output logic                                lsu_nonblock_load_data_error,    // non block load has an error\n', '   output logic [`RV_LSU_NUM_NBLOAD_WIDTH-1:0] lsu_nonblock_load_data_tag,      // the tag of the non block load sending the data/error\n', '   output logic [31:0]                         lsu_nonblock_load_data,          // Data of the non block load\n', '\n', '   // PMU events\n', '   output logic                         lsu_pmu_bus_trxn,\n', '   output logic                         lsu_pmu_bus_misaligned,\n', '   output logic                         lsu_pmu_bus_error,\n', '   output logic                         lsu_pmu_bus_busy,\n', '\n', '   // AXI Write Channels\n', '   output logic                            lsu_axi_awvalid,\n', '   input  logic                            lsu_axi_awready,\n', '   output logic [`RV_LSU_BUS_TAG-1:0]      lsu_axi_awid,\n', '   output logic [31:0]                     lsu_axi_awaddr,\n', '   output logic [3:0]                      lsu_axi_awregion,\n', '   output logic [7:0]                      lsu_axi_awlen,\n', '   output logic [2:0]                      lsu_axi_awsize,\n', '   output logic [1:0]                      lsu_axi_awburst,\n', '   output logic                            lsu_axi_awlock,\n', '   output logic [3:0]                      lsu_axi_awcache,\n', '   output logic [2:0]                      lsu_axi_awprot,\n', '   output logic [3:0]                      lsu_axi_awqos,\n', '\n', '   output logic                            lsu_axi_wvalid,\n', '   input  logic                            lsu_axi_wready,\n', '   output logic [63:0]                     lsu_axi_wdata,\n', '   output logic [7:0]                      lsu_axi_wstrb,\n', '   output logic                            lsu_axi_wlast,\n', '\n', '   input  logic                            lsu_axi_bvalid,\n', '   output logic                            lsu_axi_bready,\n', '   input  logic [1:0]                      lsu_axi_bresp,\n', '   input  logic [`RV_LSU_BUS_TAG-1:0]      lsu_axi_bid,\n', '\n', '   // AXI Read Channels\n', '   output logic                            lsu_axi_arvalid,\n', '   input  logic                            lsu_axi_arready,\n', '   output logic [`RV_LSU_BUS_TAG-1:0]      lsu_axi_arid,\n', '   output logic [31:0]                     lsu_axi_araddr,\n', '   output logic [3:0]                      lsu_axi_arregion,\n', '   output logic [7:0]                      lsu_axi_arlen,\n', '   output logic [2:0]                      lsu_axi_arsize,\n', '   output logic [1:0]                      lsu_axi_arburst,\n', '   output logic                            lsu_axi_arlock,\n', '   output logic [3:0]                      lsu_axi_arcache,\n', '   output logic [2:0]                      lsu_axi_arprot,\n', '   output logic [3:0]                      lsu_axi_arqos,\n', '\n', '   input  logic                            lsu_axi_rvalid,\n', '   output logic                            lsu_axi_rready,\n', '   input  logic [`RV_LSU_BUS_TAG-1:0]      lsu_axi_rid,\n', '   input  logic [63:0]                     lsu_axi_rdata,\n', '   input  logic [1:0]                      lsu_axi_rresp,\n', '   input  logic                            lsu_axi_rlast,\n', '\n', '   input logic                          lsu_bus_clk_en\n', '\n', ');\n', '\n', '`include ""global.h""\n', '\n', '   logic              ld_freeze_dc3;\n', '\n', '   logic              lsu_bus_clk_en_q;\n', '   logic              ldst_dual_dc1, ldst_dual_dc2, ldst_dual_dc3, ldst_dual_dc4, ldst_dual_dc5;\n', '   logic              lsu_busreq_dc3, lsu_busreq_dc4;\n', '\n', '   logic [3:0]        ldst_byteen_dc2, ldst_byteen_dc3, ldst_byteen_dc4, ldst_byteen_dc5;\n', '   logic [7:0]        ldst_byteen_ext_dc2, ldst_byteen_ext_dc3, ldst_byteen_ext_dc4, ldst_byteen_ext_dc5;\n', '   logic [3:0]        ldst_byteen_hi_dc2, ldst_byteen_hi_dc3, ldst_byteen_hi_dc4, ldst_byteen_hi_dc5;\n', '   logic [3:0]        ldst_byteen_lo_dc2, ldst_byteen_lo_dc3, ldst_byteen_lo_dc4, ldst_byteen_lo_dc5;\n', '   logic              is_sideeffects_dc4, is_sideeffects_dc5;\n', '\n', '\n', '   logic [63:0]       store_data_ext_dc3, store_data_ext_dc4, store_data_ext_dc5;\n', '   logic [31:0]       store_data_hi_dc3, store_data_hi_dc4, store_data_hi_dc5;\n', '   logic [31:0]       store_data_lo_dc3, store_data_lo_dc4, store_data_lo_dc5;\n', '\n', '   logic              addr_match_dw_lo_dc5_dc4, addr_match_dw_lo_dc5_dc3, addr_match_dw_lo_dc5_dc2;\n', '   logic              addr_match_word_lo_dc5_dc4, addr_match_word_lo_dc5_dc3, addr_match_word_lo_dc5_dc2;\n', '   logic              no_word_merge_dc5, no_dword_merge_dc5;\n', '\n', '   logic              ld_addr_dc3hit_lo_lo, ld_addr_dc3hit_hi_lo, ld_addr_dc3hit_lo_hi, ld_addr_dc3hit_hi_hi;\n', '   logic              ld_addr_dc4hit_lo_lo, ld_addr_dc4hit_hi_lo, ld_addr_dc4hit_lo_hi, ld_addr_dc4hit_hi_hi;\n', '   logic              ld_addr_dc5hit_lo_lo, ld_addr_dc5hit_hi_lo, ld_addr_dc5hit_lo_hi, ld_addr_dc5hit_hi_hi;\n', '\n', '   logic [3:0]        ld_byte_dc3hit_lo_lo, ld_byte_dc3hit_hi_lo, ld_byte_dc3hit_lo_hi, ld_byte_dc3hit_hi_hi;\n', '   logic [3:0]        ld_byte_dc4hit_lo_lo, ld_byte_dc4hit_hi_lo, ld_byte_dc4hit_lo_hi, ld_byte_dc4hit_hi_hi;\n', '   logic [3:0]        ld_byte_dc5hit_lo_lo, ld_byte_dc5hit_hi_lo, ld_byte_dc5hit_lo_hi, ld_byte_dc5hit_hi_hi;\n', '\n', '   logic [3:0]        ld_byte_hit_lo, ld_byte_dc3hit_lo, ld_byte_dc4hit_lo, ld_byte_dc5hit_lo;\n', '   logic [3:0]        ld_byte_hit_hi, ld_byte_dc3hit_hi, ld_byte_dc4hit_hi, ld_byte_dc5hit_hi;\n', '\n', '   logic [31:0]       ld_fwddata_dc3pipe_lo, ld_fwddata_dc4pipe_lo, ld_fwddata_dc5pipe_lo;\n', '   logic [31:0]       ld_fwddata_dc3pipe_hi, ld_fwddata_dc4pipe_hi, ld_fwddata_dc5pipe_hi;\n', '\n', '   logic [3:0]        ld_byte_hit_buf_lo, ld_byte_hit_buf_hi;\n', '   logic [31:0]       ld_fwddata_buf_lo, ld_fwddata_buf_hi;\n', '\n', '   logic              ld_hit_rdbuf_hi, ld_hit_rdbuf_lo;\n', '   logic [31:0]       ld_fwddata_rdbuf_hi, ld_fwddata_rdbuf_lo;\n', '\n', '   logic [63:0]       ld_fwddata_lo, ld_fwddata_hi;\n', '   logic [31:0]       ld_fwddata_dc2, ld_fwddata_dc3;\n', '   logic [31:0]       ld_bus_data_dc3;\n', '\n', '   logic              ld_full_hit_hi_dc2, ld_full_hit_lo_dc2;\n', '   logic              ld_hit_dc2, ld_full_hit_dc2, ld_full_hit_dc3;\n', '   logic              is_aligned_dc5;\n', '\n', '   logic [63:32]     ld_fwddata_dc2_nc;\n', '\n', '   logic              lsu_write_buffer_empty_any;\n', ""   assign lsu_write_buffer_empty_any = 1'b1;\n"", '\n', ""   assign ldst_byteen_dc2[3:0] = ({4{lsu_pkt_dc2.by}}   & 4'b0001) |\n"", ""                                 ({4{lsu_pkt_dc2.half}} & 4'b0011) |\n"", ""                                 ({4{lsu_pkt_dc2.word}} & 4'b1111);\n"", '   assign ldst_dual_dc1 = (lsu_addr_dc1[2] != end_addr_dc1[2]);\n', '   assign lsu_freeze_dc3 = ld_freeze_dc3 & ~(flush_dc4 | flush_dc5);\n', '\n', '   // Determine if the packet is word aligned\n', ""   assign is_aligned_dc5  = (lsu_pkt_dc5.word & (lsu_addr_dc5[1:0] == 2'b0)) |\n"", ""                            (lsu_pkt_dc5.half & (lsu_addr_dc5[0] == 1'b0));\n"", '\n', '   // Read/Write Buffer\n', '   lsu_bus_buffer bus_buffer (\n', '      .*\n', '   );\n', '\n', '   // Logic to determine if dc5 store can be coalesced or not with younger stores. Bypass ibuf if cannot colaesced\n', '   assign addr_match_dw_lo_dc5_dc4 = (lsu_addr_dc5[31:3] == lsu_addr_dc4[31:3]);\n', '   assign addr_match_dw_lo_dc5_dc3 = (lsu_addr_dc5[31:3] == lsu_addr_dc3[31:3]);\n', '   assign addr_match_dw_lo_dc5_dc2 = (lsu_addr_dc5[31:3] == lsu_addr_dc2[31:3]);\n', '\n', '   assign addr_match_word_lo_dc5_dc4 = addr_match_dw_lo_dc5_dc4 & ~(lsu_addr_dc5[2]^lsu_addr_dc4[2]);\n', '   assign addr_match_word_lo_dc5_dc3 = addr_match_dw_lo_dc5_dc3 & ~(lsu_addr_dc5[2]^lsu_addr_dc3[2]);\n', '   assign addr_match_word_lo_dc5_dc2 = addr_match_dw_lo_dc5_dc2 & ~(lsu_addr_dc5[2]^lsu_addr_dc2[2]);\n', '\n', '   assign no_word_merge_dc5  = lsu_busreq_dc5 & ~ldst_dual_dc5 &\n', '                               ((lsu_busreq_dc4 & (lsu_pkt_dc4.load | ~addr_match_word_lo_dc5_dc4)) |\n', '                                (lsu_busreq_dc3 & ~lsu_busreq_dc4 & (lsu_pkt_dc3.load | ~addr_match_word_lo_dc5_dc3)) |\n', '                                (lsu_busreq_dc2 & ~lsu_busreq_dc3 & ~lsu_busreq_dc4 & (lsu_pkt_dc2.load | ~addr_match_word_lo_dc5_dc2)));\n', '\n', '   assign no_dword_merge_dc5  = lsu_busreq_dc5 & ~ldst_dual_dc5 &\n', '                                ((lsu_busreq_dc4 & (lsu_pkt_dc4.load | ~addr_match_dw_lo_dc5_dc4)) |\n', '                                 (lsu_busreq_dc3 & ~lsu_busreq_dc4 & (lsu_pkt_dc3.load | ~addr_match_dw_lo_dc5_dc3)) |\n', '                                 (lsu_busreq_dc2 & ~lsu_busreq_dc3 & ~lsu_busreq_dc4 & (lsu_pkt_dc2.load | ~addr_match_dw_lo_dc5_dc2)));\n', '\n', '   // Create Hi/Lo signals\n', ""   assign ldst_byteen_ext_dc2[7:0] = {4'b0,ldst_byteen_dc2[3:0]} << lsu_addr_dc2[1:0];\n"", ""   assign ldst_byteen_ext_dc3[7:0] = {4'b0,ldst_byteen_dc3[3:0]} << lsu_addr_dc3[1:0];\n"", ""   assign ldst_byteen_ext_dc4[7:0] = {4'b0,ldst_byteen_dc4[3:0]} << lsu_addr_dc4[1:0];\n"", ""   assign ldst_byteen_ext_dc5[7:0] = {4'b0,ldst_byteen_dc5[3:0]} << lsu_addr_dc5[1:0];\n"", '\n', ""   assign store_data_ext_dc3[63:0] = {32'b0,store_data_dc3[31:0]} << {lsu_addr_dc3[1:0],3'b0};\n"", ""   assign store_data_ext_dc4[63:0] = {32'b0,store_data_dc4[31:0]} << {lsu_addr_dc4[1:0],3'b0};\n"", ""   assign store_data_ext_dc5[63:0] = {32'b0,store_data_dc5[31:0]} << {lsu_addr_dc5[1:0],3'b0};\n"", '\n', '   assign ldst_byteen_hi_dc2[3:0]   = ldst_byteen_ext_dc2[7:4];\n', '   assign ldst_byteen_lo_dc2[3:0]   = ldst_byteen_ext_dc2[3:0];\n', '   assign ldst_byteen_hi_dc3[3:0]   = ldst_byteen_ext_dc3[7:4];\n', '   assign ldst_byteen_lo_dc3[3:0]   = ldst_byteen_ext_dc3[3:0];\n', '   assign ldst_byteen_hi_dc4[3:0]   = ldst_byteen_ext_dc4[7:4];\n', '   assign ldst_byteen_lo_dc4[3:0]   = ldst_byteen_ext_dc4[3:0];\n', '   assign ldst_byteen_hi_dc5[3:0]   = ldst_byteen_ext_dc5[7:4];\n', '   assign ldst_byteen_lo_dc5[3:0]   = ldst_byteen_ext_dc5[3:0];\n', '\n', '   assign store_data_hi_dc3[31:0]   = store_data_ext_dc3[63:32];\n', '   assign store_data_lo_dc3[31:0]   = store_data_ext_dc3[31:0];\n', '   assign store_data_hi_dc4[31:0]   = store_data_ext_dc4[63:32];\n', '   assign store_data_lo_dc4[31:0]   = store_data_ext_dc4[31:0];\n', '   assign store_data_hi_dc5[31:0]   = store_data_ext_dc5[63:32];\n', '   assign store_data_lo_dc5[31:0]   = store_data_ext_dc5[31:0];\n', '\n', '   assign ld_addr_dc3hit_lo_lo = (lsu_addr_dc2[31:2] == lsu_addr_dc3[31:2]) & lsu_pkt_dc3.valid & lsu_pkt_dc3.store & lsu_busreq_dc2;\n', '   assign ld_addr_dc3hit_lo_hi = (end_addr_dc2[31:2] == lsu_addr_dc3[31:2]) & lsu_pkt_dc3.valid & lsu_pkt_dc3.store & lsu_busreq_dc2;\n', '   assign ld_addr_dc3hit_hi_lo = (lsu_addr_dc2[31:2] == end_addr_dc3[31:2]) & lsu_pkt_dc3.valid & lsu_pkt_dc3.store & lsu_busreq_dc2;\n', '   assign ld_addr_dc3hit_hi_hi = (end_addr_dc2[31:2] == end_addr_dc3[31:2]) & lsu_pkt_dc3.valid & lsu_pkt_dc3.store & lsu_busreq_dc2;\n', '\n', '   assign ld_addr_dc4hit_lo_lo = (lsu_addr_dc2[31:2] == lsu_addr_dc4[31:2]) & lsu_pkt_dc4.valid & lsu_pkt_dc4.store & lsu_busreq_dc2;\n', '   assign ld_addr_dc4hit_lo_hi = (end_addr_dc2[31:2] == lsu_addr_dc4[31:2]) & lsu_pkt_dc4.valid & lsu_pkt_dc4.store & lsu_busreq_dc2;\n', '   assign ld_addr_dc4hit_hi_lo = (lsu_addr_dc2[31:2] == end_addr_dc4[31:2]) & lsu_pkt_dc4.valid & lsu_pkt_dc4.store & lsu_busreq_dc2;\n', '   assign ld_addr_dc4hit_hi_hi = (end_addr_dc2[31:2] == end_addr_dc4[31:2]) & lsu_pkt_dc4.valid & lsu_pkt_dc4.store & lsu_busreq_dc2;\n', '\n', '   assign ld_addr_dc5hit_lo_lo = (lsu_addr_dc2[31:2] == lsu_addr_dc5[31:2]) & lsu_pkt_dc5.valid & lsu_pkt_dc5.store & lsu_busreq_dc2;\n', '   assign ld_addr_dc5hit_lo_hi = (end_addr_dc2[31:2] == lsu_addr_dc5[31:2]) & lsu_pkt_dc5.valid & lsu_pkt_dc5.store & lsu_busreq_dc2;\n', '   assign ld_addr_dc5hit_hi_lo = (lsu_addr_dc2[31:2] == end_addr_dc5[31:2]) & lsu_pkt_dc5.valid & lsu_pkt_dc5.store & lsu_busreq_dc2;\n', '   assign ld_addr_dc5hit_hi_hi = (end_addr_dc2[31:2] == end_addr_dc5[31:2]) & lsu_pkt_dc5.valid & lsu_pkt_dc5.store & lsu_busreq_dc2;\n', '\n', '   for (genvar i=0; i<4; i++) begin\n', '      assign ld_byte_dc3hit_lo_lo[i] = ld_addr_dc3hit_lo_lo & ldst_byteen_lo_dc3[i] & ldst_byteen_lo_dc2[i];\n', '      assign ld_byte_dc3hit_lo_hi[i] = ld_addr_dc3hit_lo_hi & ldst_byteen_lo_dc3[i] & ldst_byteen_hi_dc2[i];\n', '      assign ld_byte_dc3hit_hi_lo[i] = ld_addr_dc3hit_hi_lo & ldst_byteen_hi_dc3[i] & ldst_byteen_lo_dc2[i];\n', '      assign ld_byte_dc3hit_hi_hi[i] = ld_addr_dc3hit_hi_hi & ldst_byteen_hi_dc3[i] & ldst_byteen_hi_dc2[i];\n', '\n', '      assign ld_byte_dc4hit_lo_lo[i] = ld_addr_dc4hit_lo_lo & ldst_byteen_lo_dc4[i] & ldst_byteen_lo_dc2[i];\n', '      assign ld_byte_dc4hit_lo_hi[i] = ld_addr_dc4hit_lo_hi & ldst_byteen_lo_dc4[i] & ldst_byteen_hi_dc2[i];\n', '      assign ld_byte_dc4hit_hi_lo[i] = ld_addr_dc4hit_hi_lo & ldst_byteen_hi_dc4[i] & ldst_byteen_lo_dc2[i];\n', '      assign ld_byte_dc4hit_hi_hi[i] = ld_addr_dc4hit_hi_hi & ldst_byteen_hi_dc4[i] & ldst_byteen_hi_dc2[i];\n', '\n', '      assign ld_byte_dc5hit_lo_lo[i] = ld_addr_dc5hit_lo_lo & ldst_byteen_lo_dc5[i] & ldst_byteen_lo_dc2[i];\n', '      assign ld_byte_dc5hit_lo_hi[i] = ld_addr_dc5hit_lo_hi & ldst_byteen_lo_dc5[i] & ldst_byteen_hi_dc2[i];\n', '      assign ld_byte_dc5hit_hi_lo[i] = ld_addr_dc5hit_hi_lo & ldst_byteen_hi_dc5[i] & ldst_byteen_lo_dc2[i];\n', '      assign ld_byte_dc5hit_hi_hi[i] = ld_addr_dc5hit_hi_hi & ldst_byteen_hi_dc5[i] & ldst_byteen_hi_dc2[i];\n', '\n', '      assign ld_byte_hit_lo[i] = ld_byte_dc3hit_lo_lo[i] | ld_byte_dc3hit_hi_lo[i] |\n', '                                 ld_byte_dc4hit_lo_lo[i] | ld_byte_dc4hit_hi_lo[i] |\n', '                                 ld_byte_dc5hit_lo_lo[i] | ld_byte_dc5hit_hi_lo[i] |\n', '                                 ld_byte_hit_buf_lo[i];\n', '                                 //ld_hit_rdbuf_lo;\n', '      assign ld_byte_hit_hi[i] = ld_byte_dc3hit_lo_hi[i] | ld_byte_dc3hit_hi_hi[i] |\n', '                                 ld_byte_dc4hit_lo_hi[i] | ld_byte_dc4hit_hi_hi[i] |\n', '                                 ld_byte_dc5hit_lo_hi[i] | ld_byte_dc5hit_hi_hi[i] |\n', '                                 ld_byte_hit_buf_hi[i];\n', '                                 //ld_hit_rdbuf_hi;\n', '\n', '      assign ld_byte_dc3hit_lo[i] = ld_byte_dc3hit_lo_lo[i] | ld_byte_dc3hit_hi_lo[i];\n', '      assign ld_byte_dc4hit_lo[i] = ld_byte_dc4hit_lo_lo[i] | ld_byte_dc4hit_hi_lo[i];\n', '      assign ld_byte_dc5hit_lo[i] = ld_byte_dc5hit_lo_lo[i] | ld_byte_dc5hit_hi_lo[i];\n', '\n', '      assign ld_byte_dc3hit_hi[i] = ld_byte_dc3hit_lo_hi[i] | ld_byte_dc3hit_hi_hi[i];\n', '      assign ld_byte_dc4hit_hi[i] = ld_byte_dc4hit_lo_hi[i] | ld_byte_dc4hit_hi_hi[i];\n', '      assign ld_byte_dc5hit_hi[i] = ld_byte_dc5hit_lo_hi[i] | ld_byte_dc5hit_hi_hi[i];\n', '\n', '      assign ld_fwddata_dc3pipe_lo[(8*i)+7:(8*i)] = ({8{ld_byte_dc3hit_lo_lo[i]}} & store_data_lo_dc3[(8*i)+7:(8*i)]) |\n', '                                                    ({8{ld_byte_dc3hit_hi_lo[i]}} & store_data_hi_dc3[(8*i)+7:(8*i)]);\n', '      assign ld_fwddata_dc4pipe_lo[(8*i)+7:(8*i)] = ({8{ld_byte_dc4hit_lo_lo[i]}} & store_data_lo_dc4[(8*i)+7:(8*i)]) |\n', '                                                    ({8{ld_byte_dc4hit_hi_lo[i]}} & store_data_hi_dc4[(8*i)+7:(8*i)]);\n', '      assign ld_fwddata_dc5pipe_lo[(8*i)+7:(8*i)] = ({8{ld_byte_dc5hit_lo_lo[i]}} & store_data_lo_dc5[(8*i)+7:(8*i)]) |\n', '                                                    ({8{ld_byte_dc5hit_hi_lo[i]}} & store_data_hi_dc5[(8*i)+7:(8*i)]);\n', '\n', '      assign ld_fwddata_dc3pipe_hi[(8*i)+7:(8*i)] = ({8{ld_byte_dc3hit_lo_hi[i]}} & store_data_lo_dc3[(8*i)+7:(8*i)]) |\n', '                                                    ({8{ld_byte_dc3hit_hi_hi[i]}} & store_data_hi_dc3[(8*i)+7:(8*i)]);\n', '      assign ld_fwddata_dc4pipe_hi[(8*i)+7:(8*i)] = ({8{ld_byte_dc4hit_lo_hi[i]}} & store_data_lo_dc4[(8*i)+7:(8*i)]) |\n', '                                                    ({8{ld_byte_dc4hit_hi_hi[i]}} & store_data_hi_dc4[(8*i)+7:(8*i)]);\n', '      assign ld_fwddata_dc5pipe_hi[(8*i)+7:(8*i)] = ({8{ld_byte_dc5hit_lo_hi[i]}} & store_data_lo_dc5[(8*i)+7:(8*i)]) |\n', '                                                    ({8{ld_byte_dc5hit_hi_hi[i]}} & store_data_hi_dc5[(8*i)+7:(8*i)]);\n', '\n', '      // Final muxing between dc3/dc4/dc5\n', '      assign ld_fwddata_lo[(8*i)+7:(8*i)] = ld_byte_dc3hit_lo[i]    ? ld_fwddata_dc3pipe_lo[(8*i)+7:(8*i)] :\n', '                                            ld_byte_dc4hit_lo[i]    ? ld_fwddata_dc4pipe_lo[(8*i)+7:(8*i)] :\n', '                                            ld_byte_dc5hit_lo[i]    ? ld_fwddata_dc5pipe_lo[(8*i)+7:(8*i)] :\n', '                                                                      ld_fwddata_buf_lo[(8*i)+7:(8*i)];\n', '\n', '      assign ld_fwddata_hi[(8*i)+7:(8*i)] = ld_byte_dc3hit_hi[i]    ? ld_fwddata_dc3pipe_hi[(8*i)+7:(8*i)] :\n', '                                            ld_byte_dc4hit_hi[i]    ? ld_fwddata_dc4pipe_hi[(8*i)+7:(8*i)] :\n', '                                            ld_byte_dc5hit_hi[i]    ? ld_fwddata_dc5pipe_hi[(8*i)+7:(8*i)] :\n', '                                                                      ld_fwddata_buf_hi[(8*i)+7:(8*i)];\n', '\n', '   end\n', '\n', '   always_comb begin\n', ""      ld_full_hit_lo_dc2 = 1'b1;\n"", ""      ld_full_hit_hi_dc2 = 1'b1;\n"", '      for (int i=0; i<4; i++) begin\n', '         ld_full_hit_lo_dc2 &= (ld_byte_hit_lo[i] | ~ldst_byteen_lo_dc2[i]);\n', '         ld_full_hit_hi_dc2 &= (ld_byte_hit_hi[i] | ~ldst_byteen_hi_dc2[i]);\n', '      end\n', '   end\n', '\n', '   // This will be high if atleast one byte hit the stores in pipe/write buffer (dc3/dc4/dc5/wrbuf)\n', '   assign ld_hit_dc2 = (|ld_byte_hit_lo[3:0]) | (|ld_byte_hit_hi[3:0]);\n', '\n', '   // This will be high if all the bytes of load hit the stores in pipe/write buffer (dc3/dc4/dc5/wrbuf)\n', '   assign ld_full_hit_dc2 = ld_full_hit_lo_dc2 & ld_full_hit_hi_dc2 & lsu_busreq_dc2 & lsu_pkt_dc2.load & ~is_sideeffects_dc2;\n', '\n', '   assign {ld_fwddata_dc2_nc[63:32], ld_fwddata_dc2[31:0]} = {ld_fwddata_hi[31:0], ld_fwddata_lo[31:0]} >> (8*lsu_addr_dc2[1:0]);\n', '   assign bus_read_data_dc3[31:0]                           = ld_full_hit_dc3 ? ld_fwddata_dc3[31:0] : ld_bus_data_dc3[31:0];\n', '\n', '   // Fifo flops\n', '\n', '   rvdff #(.WIDTH(1)) clken_ff (.din(lsu_bus_clk_en), .dout(lsu_bus_clk_en_q), .clk(free_clk), .*);\n', '\n', '   rvdff_fpga #(.WIDTH(1)) ldst_dual_dc2ff    (.din(ldst_dual_dc1),        .dout(ldst_dual_dc2),        .clk(lsu_freeze_c1_dc2_clk), .clken(lsu_freeze_c1_dc2_clken), .rawclk(clk), .*);\n', '   rvdff_fpga #(.WIDTH(1)) lsu_full_hit_dc3ff (.din(ld_full_hit_dc2),      .dout(ld_full_hit_dc3),      .clk(lsu_freeze_c2_dc3_clk), .clken(lsu_freeze_c2_dc3_clken), .rawclk(clk), .*);\n', '   rvdff_fpga #(.WIDTH(1)) ldst_dual_dc3ff    (.din(ldst_dual_dc2),        .dout(ldst_dual_dc3),        .clk(lsu_freeze_c1_dc3_clk), .clken(lsu_freeze_c1_dc3_clken), .rawclk(clk), .*);\n', '   rvdff_fpga #(4)         lsu_byten_dc3ff    (.din(ldst_byteen_dc2[3:0]), .dout(ldst_byteen_dc3[3:0]), .clk(lsu_freeze_c1_dc3_clk), .clken(lsu_freeze_c1_dc3_clken), .rawclk(clk), .*);\n', '\n', '   rvdff #(.WIDTH(32)) lsu_fwddata_dc3ff (.din(ld_fwddata_dc2[31:0]), .dout(ld_fwddata_dc3[31:0]), .clk(lsu_c1_dc3_clk), .*);\n', '\n', '   rvdff #(.WIDTH(1)) ldst_dual_dc4ff (.din(ldst_dual_dc3), .dout(ldst_dual_dc4), .clk(lsu_c1_dc4_clk), .*);\n', '   rvdff #(.WIDTH(1)) ldst_dual_dc5ff (.din(ldst_dual_dc4), .dout(ldst_dual_dc5), .clk(lsu_c1_dc5_clk), .*);\n', '   rvdff #(.WIDTH(1)) is_sideeffects_dc4ff (.din(is_sideeffects_dc3), .dout(is_sideeffects_dc4), .clk(lsu_c1_dc4_clk), .*);\n', '   rvdff #(.WIDTH(1)) is_sideeffects_dc5ff (.din(is_sideeffects_dc4), .dout(is_sideeffects_dc5), .clk(lsu_c1_dc5_clk), .*);\n', '\n', '   rvdff #(4) lsu_byten_dc4ff (.*, .din(ldst_byteen_dc3[3:0]), .dout(ldst_byteen_dc4[3:0]), .clk(lsu_c1_dc4_clk));\n', '   rvdff #(4) lsu_byten_dc5ff (.*, .din(ldst_byteen_dc4[3:0]), .dout(ldst_byteen_dc5[3:0]), .clk(lsu_c1_dc5_clk));\n', '\n', '`ifdef ASSERT_ON\n', '   // Assertion to check ld imprecise error comes with right address\n', '   // property lsu_ld_imprecise_error_check;\n', '   //    @(posedge clk) disable iff (~rst_l) lsu_imprecise_error_load_any |-> (lsu_imprecise_error_addr_any[31:0] == ld_imprecise_bus_error_addr[31:0]);\n', '   // endproperty\n', '   // assert_ld_imprecise_error_check: assert property (lsu_ld_imprecise_error_check) else\n', '   //   $display(""Wrong imprecise error address when lsu_imprecise_error_load_any asserted"");\n', '\n', '   // // Assertion to check st imprecise error comes with right address\n', '   // property lsu_st_imprecise_error_check;\n', '   //    @(posedge clk) disable iff (~rst_l) lsu_imprecise_error_store_any |-> (lsu_imprecise_error_addr_any[31:0] == store_bus_error_addr[31:0]);\n', '   // endproperty\n', '   // assert_st_imprecise_error_check: assert property (lsu_st_imprecise_error_check) else\n', '   //   $display(""Wrong imprecise error address when lsu_imprecise_error_store_any asserted"");\n', '\n', '`endif\n', '\n', 'endmodule // lsu_bus_intf\n']"
"['// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '\n', '//********************************************************************************\n', '// $Id$\n', '//\n', '//\n', '// Owner:\n', '// Function: Clock Generation Block\n', '// Comments: All the clocks are generate here\n', '//\n', '// //********************************************************************************\n', '\n', '\n', 'module lsu_clkdomain\n', '   import veer_types::*;\n', '(\n', '   input logic      clk,                               // clock\n', '   input logic      free_clk,                          // clock\n', '   input logic      rst_l,                             // reset\n', '\n', '   // Inputs\n', '   input logic      clk_override,                      // chciken bit to turn off clock gating\n', '   input logic      lsu_freeze_dc3,                    // freeze\n', '   input logic      addr_in_dccm_dc2,                  // address in dccm\n', '   input logic      addr_in_pic_dc2,                   // address is in pic\n', '   input logic      dma_dccm_req,                      // dma is active\n', '   input logic      dma_mem_write,                     // dma write is active\n', '   input logic      load_stbuf_reqvld_dc3,             // instruction to stbuf\n', '   input logic      store_stbuf_reqvld_dc3,            // instruction to stbuf\n', '   input logic      stbuf_reqvld_any,                  // stbuf is draining\n', '   input logic      stbuf_reqvld_flushed_any,          // instruction going to stbuf is flushed\n', '   input logic      lsu_busreq_dc5,                    // busreq in dc5\n', '   input logic      lsu_bus_buffer_pend_any,           // bus buffer has a pending bus entry\n', '   input logic      lsu_bus_buffer_empty_any,          // external bus buffer is empty\n', '   input logic      lsu_stbuf_empty_any,               // stbuf is empty\n', '   //input logic      lsu_load_stall_any,                // Need to turn on clocks for this case\n', '\n', '   input logic      lsu_bus_clk_en,               // bus clock enable\n', '\n', '   input lsu_pkt_t  lsu_p,                             // lsu packet in decode\n', '   input lsu_pkt_t  lsu_pkt_dc1,                       // lsu packet in dc1\n', '   input lsu_pkt_t  lsu_pkt_dc2,                       // lsu packet in dc2\n', '   input lsu_pkt_t  lsu_pkt_dc3,                       // lsu packet in dc3\n', '   input lsu_pkt_t  lsu_pkt_dc4,                       // lsu packet in dc4\n', '   input lsu_pkt_t  lsu_pkt_dc5,                       // lsu packet in dc5\n', '\n', '   // Outputs\n', '   output logic     lsu_c1_dc3_clk,                    // dc3 pipe single pulse clock\n', '   output logic     lsu_c1_dc4_clk,                    // dc4 pipe single pulse clock\n', '   output logic     lsu_c1_dc5_clk,                    // dc5 pipe single pulse clock\n', '\n', '   output logic     lsu_c2_dc3_clk,                    // dc3 pipe double pulse clock\n', '   output logic     lsu_c2_dc4_clk,                    // dc4 pipe double pulse clock\n', '   output logic     lsu_c2_dc5_clk,                    // dc5 pipe double pulse clock\n', '\n', '   output logic     lsu_store_c1_dc1_clken,              // store in dc1\n', '   output logic     lsu_store_c1_dc2_clken,              // store in dc2\n', '   output logic     lsu_store_c1_dc3_clken,              // store in dc3\n', '   output logic     lsu_store_c1_dc4_clk,              // store in dc4\n', '   output logic     lsu_store_c1_dc5_clk,              // store in dc5\n', '\n', '   output logic     lsu_freeze_c1_dc1_clken,             // freeze\n', '   output logic     lsu_freeze_c1_dc2_clken,             // freeze\n', '   output logic     lsu_freeze_c1_dc3_clken,             // freeze\n', '\n', '   output logic     lsu_freeze_c1_dc2_clk,             // freeze\n', '   output logic     lsu_freeze_c1_dc3_clk,             // freeze\n', '\n', '   output logic     lsu_freeze_c2_dc1_clk,\n', '   output logic     lsu_freeze_c2_dc2_clk,\n', '   output logic     lsu_freeze_c2_dc3_clk,\n', '   output logic     lsu_freeze_c2_dc4_clk,\n', '\n', '   output logic     lsu_freeze_c2_dc1_clken,\n', '   output logic     lsu_freeze_c2_dc2_clken,\n', '   output logic     lsu_freeze_c2_dc3_clken,\n', '   output logic     lsu_freeze_c2_dc4_clken,\n', '\n', '   output logic     lsu_dccm_c1_dc3_clk,               // dccm clock\n', '   output logic     lsu_dccm_c1_dc3_clken,\n', '\n', '   output logic     lsu_pic_c1_dc3_clken,              // pic clock enable\n', '\n', '   output logic     lsu_stbuf_c1_clk,\n', '   output logic     lsu_bus_obuf_c1_clk,               // ibuf clock\n', '   output logic     lsu_bus_ibuf_c1_clk,               // ibuf clock\n', '   output logic     lsu_bus_buf_c1_clk,                // ibuf clock\n', '   output logic     lsu_busm_clk,                      // bus clock\n', '\n', '   output logic     lsu_free_c2_clk,\n', '\n', '   input  logic     scan_mode\n', ');\n', '\n', '   logic lsu_c1_dc1_clken, lsu_c1_dc2_clken, lsu_c1_dc3_clken, lsu_c1_dc4_clken, lsu_c1_dc5_clken;\n', '   logic lsu_c2_dc3_clken, lsu_c2_dc4_clken, lsu_c2_dc5_clken;\n', '   logic lsu_c1_dc1_clken_q, lsu_c1_dc2_clken_q, lsu_c1_dc3_clken_q, lsu_c1_dc4_clken_q, lsu_c1_dc5_clken_q;\n', '   logic lsu_store_c1_dc4_clken, lsu_store_c1_dc5_clken;\n', '\n', '   logic lsu_freeze_c1_dc4_clken;\n', '\n', '   logic lsu_freeze_c1_dc1_clken_q, lsu_freeze_c1_dc2_clken_q, lsu_freeze_c1_dc3_clken_q, lsu_freeze_c1_dc4_clken_q;\n', '\n', '   logic lsu_stbuf_c1_clken;\n', '   logic lsu_bus_ibuf_c1_clken, lsu_bus_obuf_c1_clken, lsu_bus_buf_c1_clken;\n', '\n', '\n', '   logic lsu_free_c1_clken, lsu_free_c1_clken_q, lsu_free_c2_clken;\n', '   logic lsu_bus_valid_clken;\n', '\n', '   //-------------------------------------------------------------------------------------------\n', '   // Clock Enable logic\n', '   //-------------------------------------------------------------------------------------------\n', '\n', '   // Also use the flopped clock enable. We want to turn on the clocks from dc1->dc5 even if there is a freeze\n', '   assign lsu_c1_dc1_clken = lsu_p.valid | dma_dccm_req | clk_override;\n', '   assign lsu_c1_dc2_clken = lsu_pkt_dc1.valid | lsu_c1_dc1_clken_q | clk_override;\n', '   assign lsu_c1_dc3_clken = lsu_pkt_dc2.valid | lsu_c1_dc2_clken_q | clk_override;\n', '   assign lsu_c1_dc4_clken = lsu_pkt_dc3.valid | lsu_c1_dc3_clken_q | clk_override;\n', '   assign lsu_c1_dc5_clken = lsu_pkt_dc4.valid | lsu_c1_dc4_clken_q | clk_override;\n', '\n', '   assign lsu_c2_dc3_clken = lsu_c1_dc3_clken | lsu_c1_dc3_clken_q | clk_override;\n', '   assign lsu_c2_dc4_clken = lsu_c1_dc4_clken | lsu_c1_dc4_clken_q | clk_override;\n', '   assign lsu_c2_dc5_clken = lsu_c1_dc5_clken | lsu_c1_dc5_clken_q | clk_override;\n', '\n', '   assign lsu_store_c1_dc1_clken = ((lsu_c1_dc1_clken & (lsu_p.store | dma_mem_write)) | clk_override) & ~lsu_freeze_dc3;\n', '   assign lsu_store_c1_dc2_clken = ((lsu_c1_dc2_clken & lsu_pkt_dc1.store) | clk_override) & ~lsu_freeze_dc3;\n', '   assign lsu_store_c1_dc3_clken = ((lsu_c1_dc3_clken & lsu_pkt_dc2.store) | clk_override) & ~lsu_freeze_dc3;\n', '   assign lsu_store_c1_dc4_clken = (lsu_c1_dc4_clken & lsu_pkt_dc3.store) | clk_override;\n', '   assign lsu_store_c1_dc5_clken = (lsu_c1_dc5_clken & lsu_pkt_dc4.store) | clk_override;\n', '\n', '   assign lsu_freeze_c1_dc1_clken = (lsu_p.valid | dma_dccm_req | clk_override) & ~lsu_freeze_dc3;\n', '   assign lsu_freeze_c1_dc2_clken = (lsu_pkt_dc1.valid | clk_override) & ~lsu_freeze_dc3;\n', '   assign lsu_freeze_c1_dc3_clken = (lsu_pkt_dc2.valid | clk_override) & ~lsu_freeze_dc3;\n', '   assign lsu_freeze_c1_dc4_clken = (lsu_pkt_dc3.valid | clk_override) & ~lsu_freeze_dc3;\n', '\n', '   assign lsu_freeze_c2_dc1_clken = (lsu_freeze_c1_dc1_clken | lsu_freeze_c1_dc1_clken_q | clk_override) & ~lsu_freeze_dc3;\n', '   assign lsu_freeze_c2_dc2_clken = (lsu_freeze_c1_dc2_clken | lsu_freeze_c1_dc2_clken_q | clk_override) & ~lsu_freeze_dc3;\n', '   assign lsu_freeze_c2_dc3_clken = (lsu_freeze_c1_dc3_clken | lsu_freeze_c1_dc3_clken_q | clk_override) & ~lsu_freeze_dc3;\n', '   assign lsu_freeze_c2_dc4_clken = (lsu_freeze_c1_dc4_clken | lsu_freeze_c1_dc4_clken_q | clk_override) & ~lsu_freeze_dc3;\n', '\n', '\n', '   assign lsu_stbuf_c1_clken = load_stbuf_reqvld_dc3 | store_stbuf_reqvld_dc3 | stbuf_reqvld_any | stbuf_reqvld_flushed_any | clk_override;\n', '   assign lsu_bus_ibuf_c1_clken = lsu_busreq_dc5 | clk_override;\n', '   assign lsu_bus_obuf_c1_clken = ((lsu_bus_buffer_pend_any | lsu_busreq_dc5) & lsu_bus_clk_en) | clk_override;\n', '   assign lsu_bus_buf_c1_clken  = ~lsu_bus_buffer_empty_any | lsu_busreq_dc5 | clk_override;\n', '\n', '   assign lsu_dccm_c1_dc3_clken = ((lsu_c1_dc3_clken & addr_in_dccm_dc2) | clk_override) & ~lsu_freeze_dc3;\n', '   assign lsu_pic_c1_dc3_clken  = ((lsu_c1_dc3_clken & addr_in_pic_dc2) | clk_override) & ~lsu_freeze_dc3;\n', '\n', '   assign lsu_free_c1_clken = (lsu_p.valid | lsu_pkt_dc1.valid | lsu_pkt_dc2.valid | lsu_pkt_dc3.valid | lsu_pkt_dc4.valid | lsu_pkt_dc5.valid) |\n', '                              ~lsu_bus_buffer_empty_any | ~lsu_stbuf_empty_any | clk_override;\n', '   assign lsu_free_c2_clken = lsu_free_c1_clken | lsu_free_c1_clken_q | clk_override;\n', '\n', '    // Flops\n', '   rvdff #(1) lsu_free_c1_clkenff (.din(lsu_free_c1_clken), .dout(lsu_free_c1_clken_q), .clk(free_clk), .*);\n', '\n', '   rvdff #(1) lsu_c1_dc1_clkenff (.din(lsu_c1_dc1_clken), .dout(lsu_c1_dc1_clken_q), .clk(lsu_free_c2_clk), .*);\n', '   rvdff #(1) lsu_c1_dc2_clkenff (.din(lsu_c1_dc2_clken), .dout(lsu_c1_dc2_clken_q), .clk(lsu_free_c2_clk), .*);\n', '   rvdff #(1) lsu_c1_dc3_clkenff (.din(lsu_c1_dc3_clken), .dout(lsu_c1_dc3_clken_q), .clk(lsu_free_c2_clk), .*);\n', '   rvdff #(1) lsu_c1_dc4_clkenff (.din(lsu_c1_dc4_clken), .dout(lsu_c1_dc4_clken_q), .clk(lsu_free_c2_clk), .*);\n', '   rvdff #(1) lsu_c1_dc5_clkenff (.din(lsu_c1_dc5_clken), .dout(lsu_c1_dc5_clken_q), .clk(lsu_free_c2_clk), .*);\n', '\n', '   rvdff_fpga #(1) lsu_freeze_c1_dc1_clkenff (.din(lsu_freeze_c1_dc1_clken), .dout(lsu_freeze_c1_dc1_clken_q), .clk(lsu_freeze_c2_dc1_clk), .clken(lsu_freeze_c2_dc1_clken), .rawclk(clk), .*);\n', '   rvdff_fpga #(1) lsu_freeze_c1_dc2_clkenff (.din(lsu_freeze_c1_dc2_clken), .dout(lsu_freeze_c1_dc2_clken_q), .clk(lsu_freeze_c2_dc2_clk), .clken(lsu_freeze_c2_dc2_clken), .rawclk(clk), .*);\n', '   rvdff_fpga #(1) lsu_freeze_c1_dc3_clkenff (.din(lsu_freeze_c1_dc3_clken), .dout(lsu_freeze_c1_dc3_clken_q), .clk(lsu_freeze_c2_dc3_clk), .clken(lsu_freeze_c2_dc3_clken), .rawclk(clk), .*);\n', '   rvdff_fpga #(1) lsu_freeze_c1_dc4_clkenff (.din(lsu_freeze_c1_dc4_clken), .dout(lsu_freeze_c1_dc4_clken_q), .clk(lsu_freeze_c2_dc4_clk), .clken(lsu_freeze_c2_dc4_clken), .rawclk(clk), .*);\n', '\n', '   // Clock Headers\n', '   rvoclkhdr lsu_c1dc3_cgc ( .en(lsu_c1_dc3_clken), .l1clk(lsu_c1_dc3_clk), .* );\n', '   rvoclkhdr lsu_c1dc4_cgc ( .en(lsu_c1_dc4_clken), .l1clk(lsu_c1_dc4_clk), .* );\n', '   rvoclkhdr lsu_c1dc5_cgc ( .en(lsu_c1_dc5_clken), .l1clk(lsu_c1_dc5_clk), .* );\n', '\n', '   rvoclkhdr lsu_c2dc3_cgc ( .en(lsu_c2_dc3_clken), .l1clk(lsu_c2_dc3_clk), .* );\n', '   rvoclkhdr lsu_c2dc4_cgc ( .en(lsu_c2_dc4_clken), .l1clk(lsu_c2_dc4_clk), .* );\n', '   rvoclkhdr lsu_c2dc5_cgc ( .en(lsu_c2_dc5_clken), .l1clk(lsu_c2_dc5_clk), .* );\n', '\n', '   rvoclkhdr lsu_store_c1dc4_cgc (.en(lsu_store_c1_dc4_clken), .l1clk(lsu_store_c1_dc4_clk), .*);\n', '   rvoclkhdr lsu_store_c1dc5_cgc (.en(lsu_store_c1_dc5_clken), .l1clk(lsu_store_c1_dc5_clk), .*);\n', '\n', '`ifdef RV_FPGA_OPTIMIZE\n', ""   assign lsu_freeze_c1_dc2_clk = 1'b0;\n"", ""   assign lsu_freeze_c1_dc3_clk = 1'b0;\n"", ""   assign lsu_freeze_c2_dc1_clk = 1'b0;\n"", ""   assign lsu_freeze_c2_dc2_clk = 1'b0;\n"", ""   assign lsu_freeze_c2_dc3_clk = 1'b0;\n"", ""   assign lsu_freeze_c2_dc4_clk = 1'b0;\n"", '\n', ""   assign lsu_busm_clk = 1'b0;\n"", ""   assign lsu_dccm_c1_dc3_clk = 1'b0;\n"", '\n', '`else\n', '   rvclkhdr lsu_freeze_c1dc2_cgc ( .en(lsu_freeze_c1_dc2_clken), .l1clk(lsu_freeze_c1_dc2_clk), .* );  // ifndef FPGA_OPTIMIZE\n', '   rvclkhdr lsu_freeze_c1dc3_cgc ( .en(lsu_freeze_c1_dc3_clken), .l1clk(lsu_freeze_c1_dc3_clk), .* );  // ifndef FPGA_OPTIMIZE\n', '   rvclkhdr lsu_freeze_c2dc1_cgc ( .en(lsu_freeze_c2_dc1_clken), .l1clk(lsu_freeze_c2_dc1_clk), .* );  // ifndef FPGA_OPTIMIZE\n', '   rvclkhdr lsu_freeze_c2dc2_cgc ( .en(lsu_freeze_c2_dc2_clken), .l1clk(lsu_freeze_c2_dc2_clk), .* );  // ifndef FPGA_OPTIMIZE\n', '   rvclkhdr lsu_freeze_c2dc3_cgc ( .en(lsu_freeze_c2_dc3_clken), .l1clk(lsu_freeze_c2_dc3_clk), .* );  // ifndef FPGA_OPTIMIZE\n', '   rvclkhdr lsu_freeze_c2dc4_cgc ( .en(lsu_freeze_c2_dc4_clken), .l1clk(lsu_freeze_c2_dc4_clk), .* );  // ifndef FPGA_OPTIMIZE\n', '\n', '   rvclkhdr lsu_busm_cgc (.en(lsu_bus_clk_en), .l1clk(lsu_busm_clk), .*);                              // ifndef FPGA_OPTIMIZE\n', '   rvclkhdr lsu_dccm_c1dc3_cgc (.en(lsu_dccm_c1_dc3_clken), .l1clk(lsu_dccm_c1_dc3_clk), .*);          // ifndef FPGA_OPTIMIZE\n', '\n', '`endif\n', '\n', '   rvoclkhdr lsu_stbuf_c1_cgc ( .en(lsu_stbuf_c1_clken), .l1clk(lsu_stbuf_c1_clk), .* );\n', '   rvoclkhdr lsu_bus_ibuf_c1_cgc ( .en(lsu_bus_ibuf_c1_clken), .l1clk(lsu_bus_ibuf_c1_clk), .* );\n', '   rvoclkhdr lsu_bus_obuf_c1_cgc ( .en(lsu_bus_obuf_c1_clken), .l1clk(lsu_bus_obuf_c1_clk), .* );\n', '   rvoclkhdr lsu_bus_buf_c1_cgc  ( .en(lsu_bus_buf_c1_clken),  .l1clk(lsu_bus_buf_c1_clk), .* );\n', '\n', '\n', '\n', '   rvoclkhdr lsu_free_cgc (.en(lsu_free_c2_clken), .l1clk(lsu_free_c2_clk), .*);\n', '\n', 'endmodule\n', '\n']"
"['// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '\n', '//********************************************************************************\n', '// $Id$\n', '//\n', '//\n', '// Owner:\n', '// Function: DCCM for LSU pipe\n', '// Comments: Single ported memory\n', '//\n', '//\n', '// DC1 -> DC2 -> DC3 -> DC4 (Commit)\n', '//\n', '// //********************************************************************************\n', '\n', 'module lsu_dccm_ctl\n', '   import veer_types::*;\n', '(\n', '   input logic                             lsu_freeze_c2_dc2_clk,     // clocks\n', '   input logic                             lsu_freeze_c2_dc3_clk,\n', '   input logic                             lsu_freeze_c2_dc2_clken,     // clocks\n', '   input logic                             lsu_freeze_c2_dc3_clken,\n', '   input logic                             lsu_dccm_c1_dc3_clk,\n', '   input logic                             lsu_dccm_c1_dc3_clken,\n', '   input logic                             lsu_pic_c1_dc3_clken,\n', '\n', '   input logic                             rst_l,\n', '   input logic                             clk,\n', '   input logic                             lsu_freeze_dc3,            // freze\n', '\n', '   input                                   lsu_pkt_t lsu_pkt_dc3,     // lsu packets\n', '   input                                   lsu_pkt_t lsu_pkt_dc1,\n', '   input logic                             addr_in_dccm_dc1,          // address maps to dccm\n', '   input logic                             addr_in_pic_dc1,           // address maps to pic\n', '   input logic                             addr_in_pic_dc3,           // address maps to pic\n', '   input logic [31:0]                      lsu_addr_dc1,              // starting byte address for loads\n', '   input logic [`RV_DCCM_BITS-1:0]         end_addr_dc1,              // last address used to calculate unaligned\n', '   input logic [`RV_DCCM_BITS-1:0]         lsu_addr_dc3,              // starting byte address for loads\n', '\n', '   input logic                             stbuf_reqvld_any,          // write enable\n', '   input logic                             stbuf_addr_in_pic_any,     // stbuf is going to pic\n', '   input logic [`RV_LSU_SB_BITS-1:0]       stbuf_addr_any,            // stbuf address (aligned)\n', '\n', '   input logic [`RV_DCCM_DATA_WIDTH-1:0]   stbuf_data_any,            // the read out from stbuf\n', '   input logic [`RV_DCCM_ECC_WIDTH-1:0]    stbuf_ecc_any,             // the encoded data with ECC bits\n', '   input logic [`RV_DCCM_DATA_WIDTH-1:0]   stbuf_fwddata_hi_dc3,      // stbuf fowarding to load\n', '   input logic [`RV_DCCM_DATA_WIDTH-1:0]   stbuf_fwddata_lo_dc3,      // stbuf fowarding to load\n', '   input logic [`RV_DCCM_BYTE_WIDTH-1:0]   stbuf_fwdbyteen_hi_dc3,    // stbuf fowarding to load\n', '   input logic [`RV_DCCM_BYTE_WIDTH-1:0]   stbuf_fwdbyteen_lo_dc3,    // stbuf fowarding to load\n', '\n', '   input logic                             lsu_double_ecc_error_dc3,  // lsu has a DED\n', '   input logic [`RV_DCCM_DATA_WIDTH-1:0]   store_ecc_datafn_hi_dc3,   // store data\n', '   input logic [`RV_DCCM_DATA_WIDTH-1:0]   store_ecc_datafn_lo_dc3,   // store data\n', '\n', '   output logic [`RV_DCCM_DATA_WIDTH-1:0]  dccm_data_hi_dc3,          // data from the dccm\n', '   output logic [`RV_DCCM_DATA_WIDTH-1:0]  dccm_data_lo_dc3,          // data from the dccm\n', '   output logic [`RV_DCCM_ECC_WIDTH-1:0]   dccm_data_ecc_hi_dc3,      // data from the dccm + ecc\n', '   output logic [`RV_DCCM_ECC_WIDTH-1:0]   dccm_data_ecc_lo_dc3,\n', '   output logic [`RV_DCCM_DATA_WIDTH-1:0]  lsu_ld_data_dc3,           // right justified, ie load byte will have data at 7:0\n', '   output logic [`RV_DCCM_DATA_WIDTH-1:0]  lsu_ld_data_corr_dc3,      // right justified, ie load byte will have data at 7:0\n', '   output logic [31:0]                     picm_mask_data_dc3,        // pic data to stbuf\n', '   output logic                            lsu_stbuf_commit_any,      // stbuf wins the dccm port or is to pic\n', '   output logic                            lsu_dccm_rden_dc3,         // dccm read\n', '\n', '   output logic                            dccm_dma_rvalid,           // dccm serviving the dma load\n', '   output logic                            dccm_dma_ecc_error,        // DMA load had ecc error\n', '   output logic [63:0]                     dccm_dma_rdata,            // dccm data to dma request\n', '\n', '   // DCCM ports\n', '   output logic                            dccm_wren,                // dccm interface -- write\n', '   output logic                            dccm_rden,                // dccm interface -- write\n', '   output logic [`RV_DCCM_BITS-1:0]        dccm_wr_addr,             // dccm interface -- wr addr\n', '   output logic [`RV_DCCM_BITS-1:0]        dccm_rd_addr_lo,          // dccm interface -- read address for lo bank\n', '   output logic [`RV_DCCM_BITS-1:0]        dccm_rd_addr_hi,          // dccm interface -- read address for hi bank\n', '   output logic [`RV_DCCM_FDATA_WIDTH-1:0] dccm_wr_data,             // dccm write data\n', '\n', '   input logic [`RV_DCCM_FDATA_WIDTH-1:0]  dccm_rd_data_lo,          // dccm read data back from the dccm\n', '   input logic [`RV_DCCM_FDATA_WIDTH-1:0]  dccm_rd_data_hi,          // dccm read data back from the dccm\n', '\n', '   // PIC ports\n', '   output logic                            picm_wren,          // write to pic\n', '   output logic                            picm_rden,          // read to pick\n', '   output logic                            picm_mken,          // write to pic need a mask\n', '   output logic [31:0]                     picm_addr,          // address for pic access - shared between reads and write\n', '   output logic [31:0]                     picm_wr_data,       // write data\n', '   input logic [31:0]                      picm_rd_data,       // read data\n', '\n', '   input logic                             scan_mode           // scan mode\n', ');\n', '\n', '`include ""global.h""\n', '\n', '   `ifdef RV_DCCM_ENABLE\n', ""      localparam DCCM_ENABLE = 1'b1;\n"", '   `else\n', ""      localparam DCCM_ENABLE = 1'b0;\n"", '   `endif\n', '\n', '   localparam DCCM_WIDTH_BITS = $clog2(DCCM_BYTE_WIDTH);\n', '   localparam PIC_BITS        =`RV_PIC_BITS;\n', '\n', '   logic                        lsu_dccm_rden_dc1, lsu_dccm_rden_dc2;\n', '   logic [DCCM_DATA_WIDTH-1:0]  dccm_data_hi_dc2, dccm_data_lo_dc2;\n', '   logic [DCCM_ECC_WIDTH-1:0]   dccm_data_ecc_hi_dc2, dccm_data_ecc_lo_dc2;\n', '   logic [63:0]  dccm_dout_dc3, dccm_corr_dout_dc3;\n', '   logic [63:0]  stbuf_fwddata_dc3;\n', '   logic [7:0]   stbuf_fwdbyteen_dc3;\n', '   logic [63:0]  lsu_rdata_dc3, lsu_rdata_corr_dc3;\n', '   logic [63:0]  picm_rd_data_dc3;\n', '   logic [31:0]  picm_rd_data_lo_dc3;\n', '   logic [63:32] lsu_ld_data_dc3_nc, lsu_ld_data_corr_dc3_nc;\n', '\n', '   assign dccm_dma_rvalid      = lsu_pkt_dc3.valid & lsu_pkt_dc3.load & lsu_pkt_dc3.dma;\n', '   assign dccm_dma_ecc_error   = lsu_double_ecc_error_dc3;\n', '   assign dccm_dma_rdata[63:0] = lsu_pkt_dc3.dword ? lsu_rdata_corr_dc3[63:0] : {2{lsu_rdata_corr_dc3[31:0]}}; // Need to replicate the data for non-dw access since ecc correction is done only in lower word\n', '\n', '\n', '   assign {lsu_ld_data_dc3_nc[63:32],      lsu_ld_data_dc3[31:0]}      = lsu_rdata_dc3[63:0] >> 8*lsu_addr_dc3[1:0];\n', '   assign {lsu_ld_data_corr_dc3_nc[63:32], lsu_ld_data_corr_dc3[31:0]} = lsu_rdata_corr_dc3[63:0] >> 8*lsu_addr_dc3[1:0];\n', '\n', '   assign dccm_dout_dc3[63:0] = {dccm_data_hi_dc3[DCCM_DATA_WIDTH-1:0], dccm_data_lo_dc3[DCCM_DATA_WIDTH-1:0]};\n', '   assign dccm_corr_dout_dc3[63:0] = {store_ecc_datafn_hi_dc3[DCCM_DATA_WIDTH-1:0], store_ecc_datafn_lo_dc3[DCCM_DATA_WIDTH-1:0]};\n', '   assign stbuf_fwddata_dc3[63:0] = {stbuf_fwddata_hi_dc3[DCCM_DATA_WIDTH-1:0], stbuf_fwddata_lo_dc3[DCCM_DATA_WIDTH-1:0]};\n', '   assign stbuf_fwdbyteen_dc3[7:0] = {stbuf_fwdbyteen_hi_dc3[DCCM_BYTE_WIDTH-1:0], stbuf_fwdbyteen_lo_dc3[DCCM_BYTE_WIDTH-1:0]};\n', '\n', '   for (genvar i=0; i<8; i++) begin: GenLoop\n', '      assign lsu_rdata_dc3[(8*i)+7:8*i]      = stbuf_fwdbyteen_dc3[i] ? stbuf_fwddata_dc3[(8*i)+7:8*i] :\n', '                                                                        (addr_in_pic_dc3 ? picm_rd_data_dc3[(8*i)+7:8*i] :  dccm_dout_dc3[(8*i)+7:8*i]);\n', '      assign lsu_rdata_corr_dc3[(8*i)+7:8*i] = stbuf_fwdbyteen_dc3[i] ? stbuf_fwddata_dc3[(8*i)+7:8*i] :\n', '                                                                        (addr_in_pic_dc3 ? picm_rd_data_dc3[(8*i)+7:8*i] :  dccm_corr_dout_dc3[(8*i)+7:8*i]);\n', '   end\n', '\n', '   assign lsu_stbuf_commit_any = stbuf_reqvld_any & ~lsu_freeze_dc3 & (\n', '                                 (~(lsu_dccm_rden_dc1 | picm_rden | picm_mken)) |\n', '                                 ((picm_rden | picm_mken) & ~stbuf_addr_in_pic_any) |\n', '                                 (lsu_dccm_rden_dc1 & (stbuf_addr_in_pic_any | (~((stbuf_addr_any[DCCM_WIDTH_BITS+:DCCM_BANK_BITS] == lsu_addr_dc1[DCCM_WIDTH_BITS+:DCCM_BANK_BITS]) |\n', '                                                                                  (stbuf_addr_any[DCCM_WIDTH_BITS+:DCCM_BANK_BITS] == end_addr_dc1[DCCM_WIDTH_BITS+:DCCM_BANK_BITS]))))));\n', '\n', '   // No need to read for aligned word/dword stores since ECC will come by new data completely\n', ""   assign lsu_dccm_rden_dc1 = lsu_pkt_dc1.valid & (lsu_pkt_dc1.load | (lsu_pkt_dc1.store & (~(lsu_pkt_dc1.word | lsu_pkt_dc1.dword) | (lsu_addr_dc1[1:0] != 2'b0)))) & addr_in_dccm_dc1;\n"", '\n', '   // DCCM inputs\n', '   assign dccm_wren = lsu_stbuf_commit_any & ~stbuf_addr_in_pic_any;\n', '   assign dccm_rden = lsu_dccm_rden_dc1 & addr_in_dccm_dc1;\n', '   assign dccm_wr_addr[DCCM_BITS-1:0] = stbuf_addr_any[DCCM_BITS-1:0];\n', '   assign dccm_rd_addr_lo[DCCM_BITS-1:0] = lsu_addr_dc1[DCCM_BITS-1:0];\n', '   assign dccm_rd_addr_hi[DCCM_BITS-1:0] = end_addr_dc1[DCCM_BITS-1:0];\n', '   assign dccm_wr_data[DCCM_FDATA_WIDTH-1:0] = {stbuf_ecc_any[DCCM_ECC_WIDTH-1:0],stbuf_data_any[DCCM_DATA_WIDTH-1:0]};\n', '\n', '   // DCCM outputs\n', '   assign dccm_data_lo_dc2[DCCM_DATA_WIDTH-1:0] = dccm_rd_data_lo[DCCM_DATA_WIDTH-1:0];\n', '   assign dccm_data_hi_dc2[DCCM_DATA_WIDTH-1:0] = dccm_rd_data_hi[DCCM_DATA_WIDTH-1:0];\n', '\n', '   assign dccm_data_ecc_lo_dc2[DCCM_ECC_WIDTH-1:0] = dccm_rd_data_lo[DCCM_FDATA_WIDTH-1:DCCM_DATA_WIDTH];\n', '   assign dccm_data_ecc_hi_dc2[DCCM_ECC_WIDTH-1:0] = dccm_rd_data_hi[DCCM_FDATA_WIDTH-1:DCCM_DATA_WIDTH];\n', '\n', '   // PIC signals. PIC ignores the lower 2 bits of address since PIC memory registers are 32-bits\n', '   assign picm_wren = lsu_stbuf_commit_any & stbuf_addr_in_pic_any;\n', '   assign picm_rden = lsu_pkt_dc1.valid & lsu_pkt_dc1.load & addr_in_pic_dc1;\n', '   assign picm_mken = lsu_pkt_dc1.valid & lsu_pkt_dc1.store & addr_in_pic_dc1;  // Get the mask for stores\n', ""   assign picm_addr[31:0] = (picm_rden | picm_mken) ? (`RV_PIC_BASE_ADDR | {17'b0,lsu_addr_dc1[14:0]}) : (`RV_PIC_BASE_ADDR | {{32-PIC_BITS{1'b0}},stbuf_addr_any[`RV_PIC_BITS-1:0]});\n"", ""   //assign picm_addr[31:0] = (picm_rden | picm_mken) ? {`RV_PIC_REGION,`RV_PIC_OFFSET,3'b0,lsu_addr_dc1[14:0]} : {`RV_PIC_REGION,`RV_PIC_OFFSET,{18-PIC_BITS{1'b0}},stbuf_addr_any[`RV_PIC_BITS-1:0]};\n"", '   assign picm_wr_data[31:0] = stbuf_data_any[31:0];\n', '\n', '\n', '   // Flops\n', '   assign picm_mask_data_dc3[31:0] = picm_rd_data_lo_dc3[31:0];\n', '   assign picm_rd_data_dc3[63:0] = {picm_rd_data_lo_dc3[31:0], picm_rd_data_lo_dc3[31:0]} ;\n', '   rvdffe #(32) picm_data_ff (.*, .din(picm_rd_data[31:0]), .dout(picm_rd_data_lo_dc3[31:0]), .en(lsu_pic_c1_dc3_clken));\n', '   if (DCCM_ENABLE == 1) begin: Gen_dccm_enable\n', '\n', '      rvdff_fpga #(1) dccm_rden_dc2ff (.*, .din(lsu_dccm_rden_dc1), .dout(lsu_dccm_rden_dc2), .clk(lsu_freeze_c2_dc2_clk), .clken(lsu_freeze_c2_dc2_clken), .rawclk(clk));\n', '      rvdff_fpga #(1) dccm_rden_dc3ff (.*, .din(lsu_dccm_rden_dc2), .dout(lsu_dccm_rden_dc3), .clk(lsu_freeze_c2_dc3_clk), .clken(lsu_freeze_c2_dc3_clken), .rawclk(clk));\n', '\n', '      rvdff_fpga #(DCCM_DATA_WIDTH) dccm_data_hi_ff    (.*, .din(dccm_data_hi_dc2[DCCM_DATA_WIDTH-1:0]),    .dout(dccm_data_hi_dc3[DCCM_DATA_WIDTH-1:0]),    .clk(lsu_dccm_c1_dc3_clk), .clken(lsu_dccm_c1_dc3_clken), .rawclk(clk));\n', '      rvdff_fpga #(DCCM_DATA_WIDTH) dccm_data_lo_ff    (.*, .din(dccm_data_lo_dc2[DCCM_DATA_WIDTH-1:0]),    .dout(dccm_data_lo_dc3[DCCM_DATA_WIDTH-1:0]),    .clk(lsu_dccm_c1_dc3_clk), .clken(lsu_dccm_c1_dc3_clken), .rawclk(clk));\n', '      rvdff_fpga #(DCCM_ECC_WIDTH) dccm_data_ecc_hi_ff (.*, .din(dccm_data_ecc_hi_dc2[DCCM_ECC_WIDTH-1:0]), .dout(dccm_data_ecc_hi_dc3[DCCM_ECC_WIDTH-1:0]), .clk(lsu_dccm_c1_dc3_clk), .clken(lsu_dccm_c1_dc3_clken), .rawclk(clk));\n', '      rvdff_fpga #(DCCM_ECC_WIDTH) dccm_data_ecc_lo_ff (.*, .din(dccm_data_ecc_lo_dc2[DCCM_ECC_WIDTH-1:0]), .dout(dccm_data_ecc_lo_dc3[DCCM_ECC_WIDTH-1:0]), .clk(lsu_dccm_c1_dc3_clk), .clken(lsu_dccm_c1_dc3_clken), .rawclk(clk));\n', '\n', '   end else begin: Gen_dccm_disable\n', ""      assign lsu_dccm_rden_dc2 = '0;\n"", ""      assign lsu_dccm_rden_dc3 = '0;\n"", ""      assign dccm_data_hi_dc3[DCCM_DATA_WIDTH-1:0] = '0;\n"", ""      assign dccm_data_lo_dc3[DCCM_DATA_WIDTH-1:0] = '0;\n"", ""      assign dccm_data_ecc_hi_dc3[DCCM_ECC_WIDTH-1:0] = '0;\n"", ""      assign dccm_data_ecc_lo_dc3[DCCM_ECC_WIDTH-1:0] = '0;\n"", '   end\n', '\n', 'endmodule\n']"
"['// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '\n', '//********************************************************************************\n', '// $Id$\n', '//\n', '//\n', '// Owner:\n', '// Function: DCCM for LSU pipe\n', '// Comments: Single ported memory\n', '//\n', '//\n', '// DC1 -> DC2 -> DC3 -> DC4 (Commit)\n', '//\n', '// //********************************************************************************\n', '\n', 'module lsu_dccm_mem\n', '   import veer_types::*;\n', '(\n', '   input logic         clk,                                              // clock\n', '   input logic         free_clk,                                         // clock\n', '   input logic         rst_l,\n', '   input logic         lsu_freeze_dc3,                                   // freeze\n', '   input logic         clk_override,                                     // clock override\n', '\n', '   input logic         dccm_wren,                                        // write enable\n', '   input logic         dccm_rden,                                        // read enable\n', '   input logic [`RV_DCCM_BITS-1:0]  dccm_wr_addr,                        // write address\n', '   input logic [`RV_DCCM_BITS-1:0]  dccm_rd_addr_lo,                     // read address\n', '   input logic [`RV_DCCM_BITS-1:0]  dccm_rd_addr_hi,                     // read address for the upper bank in case of a misaligned access\n', '   input logic [`RV_DCCM_FDATA_WIDTH-1:0]  dccm_wr_data,                 // write data\n', '\n', '   output logic [`RV_DCCM_FDATA_WIDTH-1:0] dccm_rd_data_lo,              // read data from the lo bank\n', '   output logic [`RV_DCCM_FDATA_WIDTH-1:0] dccm_rd_data_hi,              // read data from the hi bank\n', '\n', '   input  logic         scan_mode\n', ');\n', '\n', '`include ""global.h""\n', '\n', '   localparam DCCM_WIDTH_BITS = $clog2(DCCM_BYTE_WIDTH);\n', '   localparam DCCM_INDEX_BITS = (DCCM_BITS - DCCM_BANK_BITS - DCCM_WIDTH_BITS);\n', '\n', '   logic [DCCM_NUM_BANKS-1:0]         wren_bank;\n', '   logic [DCCM_NUM_BANKS-1:0]         rden_bank;\n', '   logic [DCCM_NUM_BANKS-1:0] [DCCM_BITS-1:(DCCM_BANK_BITS+2)]   addr_bank;\n', '   logic [DCCM_BITS-1:(DCCM_BANK_BITS+DCCM_WIDTH_BITS)] rd_addr_even, rd_addr_odd;\n', '   logic                              rd_unaligned;\n', '   logic [DCCM_NUM_BANKS-1:0] [DCCM_FDATA_WIDTH-1:0]   dccm_bank_dout;\n', '   logic [DCCM_FDATA_WIDTH-1:0]       wrdata;\n', '\n', '   logic [DCCM_NUM_BANKS-1:0]         wren_bank_q;\n', '   logic [DCCM_NUM_BANKS-1:0]         rden_bank_q;\n', '   logic [DCCM_NUM_BANKS-1:0][DCCM_BITS-1:(DCCM_BANK_BITS+2)]    addr_bank_q;\n', '   logic [DCCM_FDATA_WIDTH-1:0]       dccm_wr_data_q;\n', '\n', '   logic [(DCCM_WIDTH_BITS+DCCM_BANK_BITS-1):DCCM_WIDTH_BITS]      dccm_rd_addr_lo_q;\n', '   logic [(DCCM_WIDTH_BITS+DCCM_BANK_BITS-1):DCCM_WIDTH_BITS]      dccm_rd_addr_hi_q;\n', '\n', '   logic [DCCM_NUM_BANKS-1:0]            dccm_clk;\n', '   logic [DCCM_NUM_BANKS-1:0]            dccm_clken;\n', '\n', '   logic [DCCM_FDATA_WIDTH-1:0]          dccm_rd_data_lo_q, dccm_rd_data_hi_q;\n', '   logic                                 lsu_freeze_dc3_q;\n', '\n', '   assign rd_unaligned = (dccm_rd_addr_lo[DCCM_WIDTH_BITS+:DCCM_BANK_BITS] != dccm_rd_addr_hi[DCCM_WIDTH_BITS+:DCCM_BANK_BITS]);\n', '\n', '`ifdef RV_FPGA_OPTIMIZE\n', '   // Align the read data\n', '   assign dccm_rd_data_lo[DCCM_FDATA_WIDTH-1:0]  = lsu_freeze_dc3_q ? dccm_rd_data_lo_q[DCCM_FDATA_WIDTH-1:0] : dccm_bank_dout[dccm_rd_addr_lo_q[DCCM_WIDTH_BITS+:DCCM_BANK_BITS]][DCCM_FDATA_WIDTH-1:0];\n', '   assign dccm_rd_data_hi[DCCM_FDATA_WIDTH-1:0]  = lsu_freeze_dc3_q ? dccm_rd_data_hi_q[DCCM_FDATA_WIDTH-1:0] : dccm_bank_dout[dccm_rd_addr_hi_q[DCCM_WIDTH_BITS+:DCCM_BANK_BITS]][DCCM_FDATA_WIDTH-1:0];\n', '\n', '   rvdff  #(1) lsu_freeze_dc3ff(.din(lsu_freeze_dc3), .dout(lsu_freeze_dc3_q), .clk(free_clk), .*);\n', '   rvdffe #(DCCM_FDATA_WIDTH) dccm_rd_data_loff(.din(dccm_rd_data_lo), .dout(dccm_rd_data_lo_q), .en(~lsu_freeze_dc3_q), .*);\n', '   rvdffe #(DCCM_FDATA_WIDTH) dccm_rd_data_hiff(.din(dccm_rd_data_hi), .dout(dccm_rd_data_hi_q), .en(~lsu_freeze_dc3_q), .*);\n', '`else\n', '   // Align the read data\n', '   assign dccm_rd_data_lo[DCCM_FDATA_WIDTH-1:0]  = dccm_bank_dout[dccm_rd_addr_lo_q[DCCM_WIDTH_BITS+:DCCM_BANK_BITS]][DCCM_FDATA_WIDTH-1:0];\n', '   assign dccm_rd_data_hi[DCCM_FDATA_WIDTH-1:0]  = dccm_bank_dout[dccm_rd_addr_hi_q[DCCM_WIDTH_BITS+:DCCM_BANK_BITS]][DCCM_FDATA_WIDTH-1:0];\n', '`endif\n', '\n', '   // Generate even/odd address\n', '   // assign rd_addr_even[(DCCM_BANK_BITS+DCCM_WIDTH_BITS)+:DCCM_INDEX_BITS] = dccm_rd_addr_lo[2] ? dccm_rd_addr_hi[(DCCM_BANK_BITS+DCCM_WIDTH_BITS)+:DCCM_INDEX_BITS] :\n', '   //                                                                                               dccm_rd_addr_lo[(DCCM_BANK_BITS+DCCM_WIDTH_BITS)+:DCCM_INDEX_BITS];\n', '\n', '   // assign rd_addr_odd[(DCCM_BANK_BITS+DCCM_WIDTH_BITS)+:DCCM_INDEX_BITS]  = dccm_rd_addr_lo[2] ? dccm_rd_addr_lo[(DCCM_BANK_BITS+DCCM_WIDTH_BITS)+:DCCM_INDEX_BITS] :\n', '   //                                                                                               dccm_rd_addr_hi[(DCCM_BANK_BITS+DCCM_WIDTH_BITS)+:DCCM_INDEX_BITS];\n', '\n', '   // 8 Banks, 16KB each (2048 x 72)\n', '   for (genvar i=0; i<DCCM_NUM_BANKS; i++) begin: mem_bank\n', '      assign  wren_bank[i]        = dccm_wren & (dccm_wr_addr[2+:DCCM_BANK_BITS] == i);\n', '      assign  rden_bank[i]        = dccm_rden & ((dccm_rd_addr_hi[2+:DCCM_BANK_BITS] == i) | (dccm_rd_addr_lo[2+:DCCM_BANK_BITS] == i));\n', '      assign  addr_bank[i][(DCCM_BANK_BITS+DCCM_WIDTH_BITS)+:DCCM_INDEX_BITS] = wren_bank[i] ? dccm_wr_addr[(DCCM_BANK_BITS+DCCM_WIDTH_BITS)+:DCCM_INDEX_BITS] :\n', '                                                                                (((dccm_rd_addr_hi[2+:DCCM_BANK_BITS] == i) & rd_unaligned) ?\n', '                                                                                                    dccm_rd_addr_hi[(DCCM_BANK_BITS+DCCM_WIDTH_BITS)+:DCCM_INDEX_BITS] :\n', '                                                                                                    dccm_rd_addr_lo[(DCCM_BANK_BITS+DCCM_WIDTH_BITS)+:DCCM_INDEX_BITS]);\n', '\n', '      // if (i%2 == 0) begin\n', '      //    assign  addr_bank[i][(DCCM_BANK_BITS+DCCM_WIDTH_BITS)+:DCCM_INDEX_BITS] = wren_bank[i] ? dccm_wr_addr[(DCCM_BANK_BITS+DCCM_WIDTH_BITS)+:DCCM_INDEX_BITS] :\n', '      //                                                                                             rd_addr_even[(DCCM_BANK_BITS+DCCM_WIDTH_BITS)+:DCCM_INDEX_BITS];\n', '      // end else begin\n', '      //    assign  addr_bank[i][(DCCM_BANK_BITS+DCCM_WIDTH_BITS)+:DCCM_INDEX_BITS] = wren_bank[i] ? dccm_wr_addr[(DCCM_BANK_BITS+DCCM_WIDTH_BITS)+:DCCM_INDEX_BITS] :\n', '      //                                                                                             rd_addr_odd[(DCCM_BANK_BITS+DCCM_WIDTH_BITS)+:DCCM_INDEX_BITS];\n', '      // end\n', '\n', '      // clock gating section\n', '      assign  dccm_clken[i] = (wren_bank[i] | rden_bank[i] | clk_override) & ~lsu_freeze_dc3;\n', '      rvoclkhdr lsu_dccm_cgc (.en(dccm_clken[i]), .l1clk(dccm_clk[i]), .*);\n', '      // end clock gating section\n', '\n', '      `RV_DCCM_DATA_CELL  dccm_bank (\n', '                                     // Primary ports\n', '                                     .CLK(dccm_clk[i]),\n', '                                     .WE(wren_bank[i]),\n', '                                     .ADR(addr_bank[i]),\n', '                                     .D(dccm_wr_data[DCCM_FDATA_WIDTH-1:0]),\n', '                                     .Q(dccm_bank_dout[i][DCCM_FDATA_WIDTH-1:0])\n', '\n', '                                    );\n', '\n', '   end : mem_bank\n', '\n', '   // Flops\n', '   rvdffs  #(DCCM_BANK_BITS) rd_addr_lo_ff (.*, .din(dccm_rd_addr_lo[DCCM_WIDTH_BITS+:DCCM_BANK_BITS]), .dout(dccm_rd_addr_lo_q[DCCM_WIDTH_BITS+:DCCM_BANK_BITS]), .en(~lsu_freeze_dc3), .clk(free_clk));\n', '   rvdffs  #(DCCM_BANK_BITS) rd_addr_hi_ff (.*, .din(dccm_rd_addr_hi[DCCM_WIDTH_BITS+:DCCM_BANK_BITS]), .dout(dccm_rd_addr_hi_q[DCCM_WIDTH_BITS+:DCCM_BANK_BITS]), .en(~lsu_freeze_dc3), .clk(free_clk));\n', '\n', 'endmodule // lsu_dccm_mem\n', '\n', '\n']"
"['// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '\n', '//********************************************************************************\n', '// $Id$\n', '//\n', '//\n', '// Owner:\n', '// Function: Top level file for load store unit\n', '// Comments:\n', '//\n', '//\n', '// DC1 -> DC2 -> DC3 -> DC4 (Commit)\n', '//\n', '//********************************************************************************\n', 'module lsu_ecc\n', '   import veer_types::*;\n', '(\n', '\n', '   input logic        lsu_c2_dc4_clk,                      // clocks\n', '   input logic        lsu_c1_dc4_clk,\n', '   input logic        lsu_c1_dc5_clk,\n', '   input logic        clk,\n', '   input logic        rst_l,\n', '\n', '   input lsu_pkt_t    lsu_pkt_dc3,                        // packet in dc3\n', '   input logic        lsu_dccm_rden_dc3,                  // dccm rden\n', '   input logic        addr_in_dccm_dc3,                   // address in dccm\n', '   input logic [`RV_DCCM_BITS-1:0]       lsu_addr_dc3,    // start address\n', '   input logic [`RV_DCCM_BITS-1:0]       end_addr_dc3,    // end address\n', '   input logic [63:0]                    store_data_dc3,  // store data\n', '   input logic [`RV_DCCM_DATA_WIDTH-1:0] stbuf_data_any,\n', '\n', '   input logic [`RV_DCCM_DATA_WIDTH-1:0] stbuf_fwddata_hi_dc3,  // data forward from the store buffer\n', '   input logic [`RV_DCCM_DATA_WIDTH-1:0] stbuf_fwddata_lo_dc3,  // data forward from the store buffer\n', '   input logic [`RV_DCCM_BYTE_WIDTH-1:0] stbuf_fwdbyteen_hi_dc3,// which bytes from the store buffer are on\n', '   input logic [`RV_DCCM_BYTE_WIDTH-1:0] stbuf_fwdbyteen_lo_dc3,// which bytes from the store buffer are on\n', '\n', '   input logic [`RV_DCCM_DATA_WIDTH-1:0] dccm_data_hi_dc3,     // raw data from mem\n', '   input logic [`RV_DCCM_DATA_WIDTH-1:0] dccm_data_lo_dc3,     // raw data from mem\n', '   input logic [`RV_DCCM_ECC_WIDTH-1:0]  dccm_data_ecc_hi_dc3, // ecc read out from mem\n', '   input logic [`RV_DCCM_ECC_WIDTH-1:0]  dccm_data_ecc_lo_dc3, // ecc read out from mem\n', '\n', '   input logic                           dec_tlu_core_ecc_disable,  // disables the ecc computation and error flagging\n', '\n', '   output logic [`RV_DCCM_DATA_WIDTH-1:0] store_ecc_datafn_hi_dc3,  // final store data either from stbuf or SEC DCCM readout\n', '   output logic [`RV_DCCM_DATA_WIDTH-1:0] store_ecc_datafn_lo_dc3,\n', '\n', '   output logic [`RV_DCCM_ECC_WIDTH-1:0] stbuf_ecc_any,\n', '   output logic        single_ecc_error_hi_dc3,                   // sec detected\n', '   output logic        single_ecc_error_lo_dc3,                   // sec detected on lower dccm bank\n', '   output logic        lsu_single_ecc_error_dc3,                  // or of the 2\n', '   output logic        lsu_double_ecc_error_dc3,                  // double error detected\n', '\n', '   input logic         scan_mode\n', ' );\n', '\n', '`include ""global.h""\n', '\n', '   `ifdef RV_DCCM_ENABLE\n', ""      localparam DCCM_ENABLE = 1'b1;\n"", '   `else\n', ""      localparam DCCM_ENABLE = 1'b0;\n"", '   `endif\n', '\n', '   logic [DCCM_DATA_WIDTH-1:0] sec_data_hi_dc3;\n', '   logic [DCCM_DATA_WIDTH-1:0] sec_data_lo_dc3;\n', '\n', '\n', '   logic        double_ecc_error_hi_dc3, double_ecc_error_lo_dc3;\n', '\n', '   logic        ldst_dual_dc3;\n', '   logic        is_ldst_dc3;\n', '   logic        is_ldst_hi_dc3, is_ldst_lo_dc3;\n', '   logic [7:0]  ldst_byteen_dc3;\n', '   logic [7:0]  store_byteen_dc3;\n', '   logic [7:0]  store_byteen_ext_dc3;\n', '   logic [DCCM_BYTE_WIDTH-1:0]  store_byteen_hi_dc3, store_byteen_lo_dc3;\n', '\n', '   logic [163:0] store_data_ext_dc3;\n', '   logic [DCCM_DATA_WIDTH-1:0]  store_data_hi_dc3, store_data_lo_dc3;\n', '   logic [6:0]                  ecc_out_hi_nc, ecc_out_lo_nc;\n', '\n', '\n', '   assign ldst_dual_dc3 = (lsu_addr_dc3[2] != end_addr_dc3[2]);\n', '   assign is_ldst_dc3 = lsu_pkt_dc3.valid & (lsu_pkt_dc3.load | lsu_pkt_dc3.store) & addr_in_dccm_dc3 & lsu_dccm_rden_dc3;\n', '   assign is_ldst_lo_dc3 = is_ldst_dc3 & ~dec_tlu_core_ecc_disable;\n', '   assign is_ldst_hi_dc3 = is_ldst_dc3 & ldst_dual_dc3 & ~dec_tlu_core_ecc_disable;\n', '\n', ""   assign ldst_byteen_dc3[7:0] = ({8{lsu_pkt_dc3.by}}   & 8'b0000_0001) |\n"", ""                                 ({8{lsu_pkt_dc3.half}} & 8'b0000_0011) |\n"", ""                                 ({8{lsu_pkt_dc3.word}} & 8'b0000_1111) |\n"", ""                                 ({8{lsu_pkt_dc3.dword}} & 8'b1111_1111);\n"", '   assign store_byteen_dc3[7:0] = ldst_byteen_dc3[7:0] & {8{lsu_pkt_dc3.store}};\n', '\n', '   assign store_byteen_ext_dc3[7:0] = store_byteen_dc3[7:0] << lsu_addr_dc3[1:0];\n', '   assign store_byteen_hi_dc3[DCCM_BYTE_WIDTH-1:0] = store_byteen_ext_dc3[7:4];\n', '   assign store_byteen_lo_dc3[DCCM_BYTE_WIDTH-1:0] = store_byteen_ext_dc3[3:0];\n', '\n', ""   assign store_data_ext_dc3[63:0] = store_data_dc3[63:0] << {lsu_addr_dc3[1:0], 3'b000};\n"", '   assign store_data_hi_dc3[DCCM_DATA_WIDTH-1:0]  = store_data_ext_dc3[63:32];\n', '   assign store_data_lo_dc3[DCCM_DATA_WIDTH-1:0]  = store_data_ext_dc3[31:0];\n', '\n', '\n', '   // Merge store data and sec data\n', '   // This is used for loads as well for ecc error case. store_byteen will be 0 for loads\n', '   for (genvar i=0; i<DCCM_BYTE_WIDTH; i++) begin\n', '      assign store_ecc_datafn_hi_dc3[(8*i)+7:(8*i)] = store_byteen_hi_dc3[i] ? store_data_hi_dc3[(8*i)+7:(8*i)] :\n', '                                                                               (stbuf_fwdbyteen_hi_dc3[i] ? stbuf_fwddata_hi_dc3[(8*i)+7:(8*i)] : sec_data_hi_dc3[(8*i)+7:(8*i)]);\n', '      assign store_ecc_datafn_lo_dc3[(8*i)+7:(8*i)] = store_byteen_lo_dc3[i] ? store_data_lo_dc3[(8*i)+7:(8*i)] :\n', '                                                                               (stbuf_fwdbyteen_lo_dc3[i] ? stbuf_fwddata_lo_dc3[(8*i)+7:(8*i)] : sec_data_lo_dc3[(8*i)+7:(8*i)]);\n', '   end\n', '\n', '   if (DCCM_ENABLE == 1) begin: Gen_dccm_enable\n', '      //Detect/Repair for Hi/Lo\n', '      rvecc_decode lsu_ecc_decode_hi (\n', '         // Inputs\n', '         .en(is_ldst_hi_dc3),\n', ""         .sed_ded (1'b0),    // 1 : means only detection\n"", '         .din(dccm_data_hi_dc3[DCCM_DATA_WIDTH-1:0]),\n', '         .ecc_in(dccm_data_ecc_hi_dc3[DCCM_ECC_WIDTH-1:0]),\n', '         // Outputs\n', '         .dout(sec_data_hi_dc3[DCCM_DATA_WIDTH-1:0]),\n', '         .ecc_out (ecc_out_hi_nc[6:0]),\n', '         .single_ecc_error(single_ecc_error_hi_dc3),\n', '         .double_ecc_error(double_ecc_error_hi_dc3),\n', '         .*\n', '      );\n', '\n', '      rvecc_decode lsu_ecc_decode_lo (\n', '         // Inputs\n', '         .en(is_ldst_lo_dc3),\n', ""         .sed_ded (1'b0),    // 1 : means only detection\n"", '         .din(dccm_data_lo_dc3[DCCM_DATA_WIDTH-1:0] ),\n', '         .ecc_in(dccm_data_ecc_lo_dc3[DCCM_ECC_WIDTH-1:0]),\n', '         // Outputs\n', '         .dout(sec_data_lo_dc3[DCCM_DATA_WIDTH-1:0]),\n', '         .ecc_out (ecc_out_lo_nc[6:0]),\n', '         .single_ecc_error(single_ecc_error_lo_dc3),\n', '         .double_ecc_error(double_ecc_error_lo_dc3),\n', '         .*\n', '      );\n', '\n', '      // Generate the ECC bits for store buffer drain\n', '      rvecc_encode lsu_ecc_encode (\n', '         //Inputs\n', '         .din(stbuf_data_any[DCCM_DATA_WIDTH-1:0]),\n', '         //Outputs\n', '         .ecc_out(stbuf_ecc_any[DCCM_ECC_WIDTH-1:0]),\n', '         .*\n', '      );\n', '   end else begin: Gen_dccm_disable // block: Gen_dccm_enable\n', ""      assign sec_data_hi_dc3[DCCM_DATA_WIDTH-1:0] = '0;\n"", ""      assign sec_data_lo_dc3[DCCM_DATA_WIDTH-1:0] = '0;\n"", ""      assign single_ecc_error_hi_dc3 = '0;\n"", ""      assign double_ecc_error_hi_dc3 = '0;\n"", ""      assign single_ecc_error_lo_dc3 = '0;\n"", ""      assign double_ecc_error_lo_dc3 = '0;\n"", '\n', ""      assign stbuf_ecc_any[DCCM_ECC_WIDTH-1:0] = '0;\n"", '   end\n', '\n', '   assign lsu_single_ecc_error_dc3 = single_ecc_error_hi_dc3 | single_ecc_error_lo_dc3;\n', '   assign lsu_double_ecc_error_dc3 = double_ecc_error_hi_dc3 | double_ecc_error_lo_dc3;\n', '\n', '\n', '`ifdef ASSERT_ON\n', '\n', '//   ecc_check: assert property (@(posedge clk) ~(single_ecc_error_lo_dc3 | single_ecc_error_hi_dc3));\n', '\n', '`endif\n', '\n', 'endmodule // lsu_ecc\n']"
"['// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '\n', '//********************************************************************************\n', '// $Id$\n', '//\n', '//\n', '// Owner:\n', '// Function: LSU control\n', '// Comments:\n', '//\n', '//\n', '// DC1 -> DC2 -> DC3 -> DC4 (Commit)\n', '//\n', '//********************************************************************************\n', 'module lsu_lsc_ctl\n', '   import veer_types::*;\n', '(\n', '   input logic         rst_l,\n', '   input logic         clk,\n', '\n', '   // clocks per pipe\n', '   input logic        lsu_c1_dc4_clk,\n', '   input logic        lsu_c1_dc5_clk,\n', '   input logic        lsu_c2_dc4_clk,\n', '   input logic        lsu_c2_dc5_clk,\n', '   // freez clocks per pipe\n', '   input logic        lsu_freeze_c1_dc1_clken,\n', '   input logic        lsu_freeze_c1_dc2_clken,\n', '   input logic        lsu_freeze_c1_dc2_clk,\n', '   input logic        lsu_freeze_c1_dc3_clken,\n', '   input logic        lsu_freeze_c1_dc3_clk,\n', '   input logic        lsu_freeze_c2_dc1_clk,\n', '   input logic        lsu_freeze_c2_dc2_clk,\n', '   input logic        lsu_freeze_c2_dc3_clk,\n', '   input logic        lsu_freeze_c2_dc1_clken,\n', '   input logic        lsu_freeze_c2_dc2_clken,\n', '   input logic        lsu_freeze_c2_dc3_clken,\n', '\n', '   input logic        lsu_store_c1_dc1_clken,\n', '   input logic        lsu_store_c1_dc2_clken,\n', '   input logic        lsu_store_c1_dc3_clken,\n', '   input logic        lsu_store_c1_dc4_clk,\n', '   input logic        lsu_store_c1_dc5_clk,\n', '\n', '   input logic [31:0] i0_result_e4_eff,\n', '   input logic [31:0] i1_result_e4_eff,\n', '\n', '   input logic [31:0] i0_result_e2,\n', '\n', '   input logic         ld_bus_error_dc3,\n', '   input logic [31:0]  ld_bus_error_addr_dc3,\n', '   input logic         lsu_single_ecc_error_dc3,\n', '   input logic         lsu_single_ecc_error_dc5,\n', '   input logic         lsu_double_ecc_error_dc3,\n', '   input logic         lsu_freeze_dc3,\n', '\n', '   input logic         lsu_i0_valid_dc3,\n', '   input logic         flush_dc2_up,\n', '   input logic         flush_dc3,\n', '   input logic         flush_dc4,\n', '   input logic         flush_dc5,\n', '\n', '   input logic [31:0]  exu_lsu_rs1_d, // address\n', '   input logic [31:0]  exu_lsu_rs2_d, // store data\n', '\n', '   input lsu_pkt_t     lsu_p,         // lsu control packet\n', '   input logic [11:0]  dec_lsu_offset_d,\n', '\n', '   input  logic [31:0] picm_mask_data_dc3,\n', '   input  logic [31:0] lsu_ld_data_dc3,\n', '   input  logic [31:0] lsu_ld_data_corr_dc3,\n', '   input  logic [31:0]  bus_read_data_dc3,\n', '   output logic [31:0] lsu_result_dc3,\n', '   output logic [31:0] lsu_result_corr_dc4,   // This is the ECC corrected data going to RF\n', '   // lsu address down the pipe\n', '   output logic [31:0] lsu_addr_dc1,\n', '   output logic [31:0] lsu_addr_dc2,\n', '   output logic [31:0] lsu_addr_dc3,\n', '   output logic [31:0] lsu_addr_dc4,\n', '   output logic [31:0] lsu_addr_dc5,\n', '   // lsu address down the pipe - needed to check unaligned\n', '   output logic [31:0] end_addr_dc1,\n', '   output logic [31:0] end_addr_dc2,\n', '   output logic [31:0] end_addr_dc3,\n', '   output logic [31:0] end_addr_dc4,\n', '   output logic [31:0] end_addr_dc5,\n', '   // store data down the pipe\n', '   output logic [63:0] store_data_dc2,\n', '   output logic [63:0] store_data_dc3,\n', '   output logic [31:0] store_data_dc4,\n', '   output logic [31:0] store_data_dc5,\n', '\n', '   input  logic [31:0]    dec_tlu_mrac_ff,\n', '   output logic           lsu_exc_dc2,\n', '   output lsu_error_pkt_t lsu_error_pkt_dc3,\n', '   output logic           lsu_single_ecc_error_incr,    // Increment the counter for Single ECC error\n', '   output logic           lsu_freeze_external_ints_dc3,\n', '   output logic           is_sideeffects_dc2,\n', '   output logic           is_sideeffects_dc3,\n', '   output logic           lsu_commit_dc5,\n', '   // address in dccm/pic/external per pipe stage\n', '   output logic        addr_in_dccm_dc1,\n', '   output logic        addr_in_dccm_dc2,\n', '   output logic        addr_in_dccm_dc3,\n', '   output logic        addr_in_pic_dc1,\n', '   output logic        addr_in_pic_dc2,\n', '   output logic        addr_in_pic_dc3,\n', '   output logic        addr_external_dc2,\n', '   output logic        addr_external_dc3,\n', '   output logic        addr_external_dc4,\n', '   output logic        addr_external_dc5,\n', '\n', '   // DMA slave\n', '   input logic        dma_dccm_req,\n', '   input logic [31:0] dma_mem_addr,\n', '   input logic [2:0]  dma_mem_sz,\n', '   input logic        dma_mem_write,\n', '   input logic [63:0] dma_mem_wdata,\n', '\n', '   // Store buffer related signals\n', '   output lsu_pkt_t    lsu_pkt_dc1,\n', '   output lsu_pkt_t    lsu_pkt_dc2,\n', '   output lsu_pkt_t    lsu_pkt_dc3,\n', '   output lsu_pkt_t    lsu_pkt_dc4,\n', '   output lsu_pkt_t    lsu_pkt_dc5,\n', '\n', '   input  logic        scan_mode\n', '\n', '   );\n', '\n', '`include ""global.h""\n', '\n', '   logic [31:0]        full_addr_dc1;\n', '   logic [31:0]        full_end_addr_dc1;\n', '   logic [31:0]        lsu_rs1_d;\n', '   logic [11:0]        lsu_offset_d;\n', '   logic [31:0]        rs1_dc1;\n', '   logic [11:0]        offset_dc1;\n', '   logic [12:0]        end_addr_offset_dc1;\n', '   logic [31:0]        lsu_ld_datafn_dc3;\n', '   logic [31:0]        lsu_ld_datafn_corr_dc3;\n', '   logic [31:0]        lsu_result_corr_dc3;\n', '   logic [2:0]         addr_offset_dc1;\n', '\n', '   logic [63:0]        dma_mem_wdata_shifted;\n', '   logic               addr_external_dc1;\n', '   logic               access_fault_dc1, misaligned_fault_dc1;\n', '   logic               access_fault_dc2, misaligned_fault_dc2;\n', '   logic               access_fault_dc3, misaligned_fault_dc3;\n', '\n', '   logic [63:0]        store_data_d;\n', '   logic [63:0]        store_data_dc1;\n', '   logic [63:0]        store_data_pre_dc2;\n', '   logic [63:0]        store_data_pre_dc3;\n', '   logic [63:0]        store_data_dc2_in;\n', '\n', '   logic [31:0]        rs1_dc1_raw;\n', '\n', '   lsu_pkt_t           dma_pkt_d;\n', '   lsu_pkt_t           lsu_pkt_dc1_in, lsu_pkt_dc2_in, lsu_pkt_dc3_in, lsu_pkt_dc4_in, lsu_pkt_dc5_in;\n', '\n', '   // Premux the rs1/offset for dma\n', '   assign lsu_rs1_d[31:0] = dma_dccm_req ? dma_mem_addr[31:0] : exu_lsu_rs1_d[31:0];\n', '   assign lsu_offset_d[11:0] = dec_lsu_offset_d[11:0] & ~{12{dma_dccm_req}};\n', '\n', '   rvdffe #(32) rs1ff (.*, .din(lsu_rs1_d[31:0]), .dout(rs1_dc1_raw[31:0]), .en(lsu_freeze_c1_dc1_clken));\n', '   rvdffe #(12) offsetff (.*, .din(lsu_offset_d[11:0]), .dout(offset_dc1[11:0]), .en(lsu_freeze_c1_dc1_clken));\n', '\n', '   assign rs1_dc1[31:0] = (lsu_pkt_dc1.load_ldst_bypass_c1) ? lsu_result_dc3[31:0] : rs1_dc1_raw[31:0];\n', '\n', '\n', '   // generate the ls address\n', '   // need to refine this is memory is only 128KB\n', '   rvlsadder   lsadder  (.rs1(rs1_dc1[31:0]),\n', '                       .offset(offset_dc1[11:0]),\n', '                       .dout(full_addr_dc1[31:0])\n', '                       );\n', '\n', '   // Module to generate the memory map of the address\n', '   lsu_addrcheck addrcheck (\n', '              .start_addr_dc1(full_addr_dc1[31:0]),\n', '              .end_addr_dc1(full_end_addr_dc1[31:0]),\n', '              .*\n', '  );\n', '\n', '   // Calculate start/end address for load/store\n', ""   assign addr_offset_dc1[2:0]      = ({3{lsu_pkt_dc1.half}} & 3'b01) | ({3{lsu_pkt_dc1.word}} & 3'b11) | ({3{lsu_pkt_dc1.dword}} & 3'b111);\n"", ""   assign end_addr_offset_dc1[12:0] = {offset_dc1[11],offset_dc1[11:0]} + {9'b0,addr_offset_dc1[2:0]};\n"", '   assign full_end_addr_dc1[31:0]   = rs1_dc1[31:0] + {{19{end_addr_offset_dc1[12]}},end_addr_offset_dc1[12:0]};\n', '   assign end_addr_dc1[31:0]        = full_end_addr_dc1[31:0];\n', '   assign lsu_exc_dc2               = access_fault_dc2 | misaligned_fault_dc2;\n', '   assign lsu_freeze_external_ints_dc3 = lsu_freeze_dc3 & is_sideeffects_dc3;\n', '\n', '   // Increment the single bit ecc counter\n', '   assign lsu_single_ecc_error_incr = lsu_single_ecc_error_dc5 & (lsu_commit_dc5 | lsu_pkt_dc5.dma);\n', '\n', '   // Generate exception packet\n', '   assign lsu_error_pkt_dc3.exc_valid = (access_fault_dc3 | misaligned_fault_dc3 | ld_bus_error_dc3 | lsu_double_ecc_error_dc3) & lsu_pkt_dc3.valid & ~lsu_pkt_dc3.dma & ~flush_dc3;\n', '   assign lsu_error_pkt_dc3.single_ecc_error = lsu_single_ecc_error_dc3 & ~(access_fault_dc3 | misaligned_fault_dc3 | lsu_double_ecc_error_dc3);\n', '   assign lsu_error_pkt_dc3.inst_type = lsu_pkt_dc3.store;\n', '   assign lsu_error_pkt_dc3.dma_valid = lsu_pkt_dc3.dma;\n', '   assign lsu_error_pkt_dc3.inst_pipe = ~lsu_i0_valid_dc3;\n', '   assign lsu_error_pkt_dc3.exc_type  = ~misaligned_fault_dc3;\n', '   // assign lsu_error_pkt_dc3.addr[31:0] = (access_fault_dc3 | misaligned_fault_dc3) ? lsu_addr_dc3[31:0] : ld_bus_error_addr_dc3[31:0];\n', '   assign lsu_error_pkt_dc3.addr[31:0] = lsu_addr_dc3[31:0];\n', '\n', '\n', '   //Create DMA packet\n', '   assign dma_pkt_d.valid   = dma_dccm_req;\n', ""   assign dma_pkt_d.dma     = 1'b1;\n"", ""   assign dma_pkt_d.unsign  = '0;\n"", '   assign dma_pkt_d.store   = dma_mem_write;\n', '   assign dma_pkt_d.load    = ~dma_mem_write;\n', ""   assign dma_pkt_d.by      = (dma_mem_sz[2:0] == 3'b0);\n"", ""   assign dma_pkt_d.half    = (dma_mem_sz[2:0] == 3'b1);\n"", ""   assign dma_pkt_d.word    = (dma_mem_sz[2:0] == 3'b10);\n"", ""   assign dma_pkt_d.dword   = (dma_mem_sz[2:0] == 3'b11);\n"", ""   assign dma_pkt_d.load_ldst_bypass_c1  = '0;\n"", ""   assign dma_pkt_d.store_data_bypass_c1 = '0;\n"", ""   assign dma_pkt_d.store_data_bypass_c2 = '0;\n"", ""   assign dma_pkt_d.store_data_bypass_i0_e2_c2 = '0;\n"", ""   assign dma_pkt_d.store_data_bypass_e4_c1 = '0;\n"", ""   assign dma_pkt_d.store_data_bypass_e4_c2 = '0;\n"", ""   assign dma_pkt_d.store_data_bypass_e4_c3 = '0;\n"", '\n', '   always_comb begin\n', '      lsu_pkt_dc1_in = dma_dccm_req ? dma_pkt_d : lsu_p;\n', '      lsu_pkt_dc2_in = lsu_pkt_dc1;\n', '      lsu_pkt_dc3_in = lsu_pkt_dc2;\n', '      lsu_pkt_dc4_in = lsu_pkt_dc3;\n', '      lsu_pkt_dc5_in = lsu_pkt_dc4;\n', '\n', '      lsu_pkt_dc1_in.valid = (lsu_p.valid & ~flush_dc2_up) | dma_dccm_req;\n', '      lsu_pkt_dc2_in.valid = lsu_pkt_dc1.valid & ~(flush_dc2_up & ~lsu_pkt_dc1.dma);\n', '      lsu_pkt_dc3_in.valid = lsu_pkt_dc2.valid & ~(flush_dc2_up & ~lsu_pkt_dc2.dma);\n', '      lsu_pkt_dc4_in.valid = lsu_pkt_dc3.valid & ~(flush_dc3 & ~lsu_pkt_dc3.dma) & ~lsu_freeze_dc3;\n', '      lsu_pkt_dc5_in.valid = lsu_pkt_dc4.valid & ~(flush_dc4 & ~lsu_pkt_dc4.dma);\n', '   end\n', '\n', '   // C2 clock for valid and C1 for other bits of packet\n', '   rvdff #(1) lsu_pkt_vlddc4ff (.*, .din(lsu_pkt_dc4_in.valid), .dout(lsu_pkt_dc4.valid), .clk(lsu_c2_dc4_clk));\n', '   rvdff #(1) lsu_pkt_vlddc5ff (.*, .din(lsu_pkt_dc5_in.valid), .dout(lsu_pkt_dc5.valid), .clk(lsu_c2_dc5_clk));\n', '\n', '   rvdffe #($bits(lsu_pkt_t)-1) lsu_pkt_dc1ff (.*, .din(lsu_pkt_dc1_in[$bits(lsu_pkt_t)-1:1]), .dout(lsu_pkt_dc1[$bits(lsu_pkt_t)-1:1]), .en(lsu_freeze_c1_dc1_clken));\n', '   rvdffe #($bits(lsu_pkt_t)-1) lsu_pkt_dc2ff (.*, .din(lsu_pkt_dc2_in[$bits(lsu_pkt_t)-1:1]), .dout(lsu_pkt_dc2[$bits(lsu_pkt_t)-1:1]), .en(lsu_freeze_c1_dc2_clken));\n', '   rvdffe #($bits(lsu_pkt_t)-1) lsu_pkt_dc3ff (.*, .din(lsu_pkt_dc3_in[$bits(lsu_pkt_t)-1:1]), .dout(lsu_pkt_dc3[$bits(lsu_pkt_t)-1:1]), .en(lsu_freeze_c1_dc3_clken));\n', '   rvdff #($bits(lsu_pkt_t)-1) lsu_pkt_dc4ff (.*, .din(lsu_pkt_dc4_in[$bits(lsu_pkt_t)-1:1]), .dout(lsu_pkt_dc4[$bits(lsu_pkt_t)-1:1]), .clk(lsu_c1_dc4_clk));\n', '   rvdff #($bits(lsu_pkt_t)-1) lsu_pkt_dc5ff (.*, .din(lsu_pkt_dc5_in[$bits(lsu_pkt_t)-1:1]), .dout(lsu_pkt_dc5[$bits(lsu_pkt_t)-1:1]), .clk(lsu_c1_dc5_clk));\n', '\n', '   assign lsu_ld_datafn_dc3[31:0] = addr_external_dc3 ? bus_read_data_dc3[31:0] : lsu_ld_data_dc3[31:0];\n', '   assign lsu_ld_datafn_corr_dc3[31:0] = addr_external_dc3 ? bus_read_data_dc3[31:0] : lsu_ld_data_corr_dc3[31:0];\n', '\n', '   // this result must look at prior stores and merge them in\n', ""   assign lsu_result_dc3[31:0] = ({32{ lsu_pkt_dc3.unsign & lsu_pkt_dc3.by  }} & {24'b0,lsu_ld_datafn_dc3[7:0]}) |\n"", ""                                 ({32{ lsu_pkt_dc3.unsign & lsu_pkt_dc3.half}} & {16'b0,lsu_ld_datafn_dc3[15:0]}) |\n"", '                                 ({32{~lsu_pkt_dc3.unsign & lsu_pkt_dc3.by  }} & {{24{  lsu_ld_datafn_dc3[7]}}, lsu_ld_datafn_dc3[7:0]}) |\n', '                                 ({32{~lsu_pkt_dc3.unsign & lsu_pkt_dc3.half}} & {{16{  lsu_ld_datafn_dc3[15]}},lsu_ld_datafn_dc3[15:0]}) |\n', '                                 ({32{lsu_pkt_dc3.word}} &                       lsu_ld_datafn_dc3[31:0]);\n', '\n', ""   assign lsu_result_corr_dc3[31:0] = ({32{ lsu_pkt_dc3.unsign & lsu_pkt_dc3.by  }} & {24'b0,lsu_ld_datafn_corr_dc3[7:0]}) |\n"", ""                                      ({32{ lsu_pkt_dc3.unsign & lsu_pkt_dc3.half}} & {16'b0,lsu_ld_datafn_corr_dc3[15:0]}) |\n"", '                                      ({32{~lsu_pkt_dc3.unsign & lsu_pkt_dc3.by  }} & {{24{  lsu_ld_datafn_corr_dc3[7]}}, lsu_ld_datafn_corr_dc3[7:0]}) |\n', '                                      ({32{~lsu_pkt_dc3.unsign & lsu_pkt_dc3.half}} & {{16{  lsu_ld_datafn_corr_dc3[15]}},lsu_ld_datafn_corr_dc3[15:0]}) |\n', '                                      ({32{lsu_pkt_dc3.word}} &                       lsu_ld_datafn_corr_dc3[31:0]);\n', '\n', '\n', ""   // absence load/store all 0's\n"", '   assign lsu_addr_dc1[31:0] = full_addr_dc1[31:0];\n', '\n', '   // Interrupt as a flush source allows the WB to occur\n', '   assign lsu_commit_dc5 = lsu_pkt_dc5.valid & (lsu_pkt_dc5.store | lsu_pkt_dc5.load) & ~flush_dc5 & ~lsu_pkt_dc5.dma;\n', '\n', ""   assign dma_mem_wdata_shifted[63:0] = dma_mem_wdata[63:0] >> {dma_mem_addr[2:0], 3'b000};   // Shift the dma data to lower bits to make it consistent to lsu stores\n"", ""   assign store_data_d[63:0] = dma_dccm_req ? dma_mem_wdata_shifted[63:0] : {32'b0,exu_lsu_rs2_d[31:0]};\n"", '\n', '   assign store_data_dc2_in[63:32] = store_data_dc1[63:32];\n', '   assign store_data_dc2_in[31:0] = (lsu_pkt_dc1.store_data_bypass_c1) ? lsu_result_dc3[31:0] :\n', '                                    (lsu_pkt_dc1.store_data_bypass_e4_c1[1]) ? i1_result_e4_eff[31:0] :\n', '                                    (lsu_pkt_dc1.store_data_bypass_e4_c1[0]) ? i0_result_e4_eff[31:0] : store_data_dc1[31:0];\n', '\n', '   assign store_data_dc2[63:32] = store_data_pre_dc2[63:32];\n', '   assign store_data_dc2[31:0] = (lsu_pkt_dc2.store_data_bypass_i0_e2_c2) ? i0_result_e2[31:0]     :\n', '                                 (lsu_pkt_dc2.store_data_bypass_c2)       ? lsu_result_dc3[31:0]   :\n', '                                 (lsu_pkt_dc2.store_data_bypass_e4_c2[1]) ? i1_result_e4_eff[31:0] :\n', '                                 (lsu_pkt_dc2.store_data_bypass_e4_c2[0]) ? i0_result_e4_eff[31:0] : store_data_pre_dc2[31:0];\n', '\n', '   assign store_data_dc3[63:32] = store_data_pre_dc3[63:32];\n', '   assign store_data_dc3[31:0] = (picm_mask_data_dc3[31:0] | {32{~addr_in_pic_dc3}}) &\n', '                                 ((lsu_pkt_dc3.store_data_bypass_e4_c3[1]) ? i1_result_e4_eff[31:0] :\n', '                                  (lsu_pkt_dc3.store_data_bypass_e4_c3[0]) ? i0_result_e4_eff[31:0] : store_data_pre_dc3[31:0]);\n', '\n', '   rvdff #(32) lsu_result_corr_dc4ff (.*, .din(lsu_result_corr_dc3[31:0]), .dout(lsu_result_corr_dc4[31:0]), .clk(lsu_c1_dc4_clk));\n', '\n', '   rvdffe #(64) sddc1ff (.*, .din(store_data_d[63:0]),  .dout(store_data_dc1[63:0]), .en(lsu_store_c1_dc1_clken));\n', '   rvdffe #(64) sddc2ff (.*, .din(store_data_dc2_in[63:0]), .dout(store_data_pre_dc2[63:0]), .en(lsu_store_c1_dc2_clken));\n', '   rvdffe #(64) sddc3ff (.*, .din(store_data_dc2[63:0]), .dout(store_data_pre_dc3[63:0]), .en(~lsu_freeze_dc3 & lsu_store_c1_dc3_clken) );\n', '\n', '   rvdff #(32) sddc4ff (.*, .din(store_data_dc3[31:0]), .dout(store_data_dc4[31:0]), .clk(lsu_store_c1_dc4_clk));\n', '   rvdff #(32) sddc5ff (.*, .din(store_data_dc4[31:0]), .dout(store_data_dc5[31:0]), .clk(lsu_store_c1_dc5_clk));\n', '\n', '   rvdffe #(32) sadc2ff (.*, .din(lsu_addr_dc1[31:0]), .dout(lsu_addr_dc2[31:0]), .en(lsu_freeze_c1_dc2_clken));\n', '   rvdffe #(32) sadc3ff (.*, .din(lsu_addr_dc2[31:0]), .dout(lsu_addr_dc3[31:0]), .en(lsu_freeze_c1_dc3_clken));\n', '   rvdff #(32) sadc4ff (.*, .din(lsu_addr_dc3[31:0]), .dout(lsu_addr_dc4[31:0]), .clk(lsu_c1_dc4_clk));\n', '   rvdff #(32) sadc5ff (.*, .din(lsu_addr_dc4[31:0]), .dout(lsu_addr_dc5[31:0]), .clk(lsu_c1_dc5_clk));\n', '\n', '   rvdffe #(32) end_addr_dc2ff (.*, .din(end_addr_dc1[31:0]), .dout(end_addr_dc2[31:0]), .en(lsu_freeze_c1_dc2_clken));\n', '   rvdffe #(32) end_addr_dc3ff (.*, .din(end_addr_dc2[31:0]), .dout(end_addr_dc3[31:0]), .en(lsu_freeze_c1_dc3_clken));\n', '   rvdff #(32) end_addr_dc4ff (.*, .din(end_addr_dc3[31:0]), .dout(end_addr_dc4[31:0]), .clk(lsu_c1_dc4_clk));\n', '   rvdff #(32) end_addr_dc5ff (.*, .din(end_addr_dc4[31:0]), .dout(end_addr_dc5[31:0]), .clk(lsu_c1_dc5_clk));\n', '\n', '   rvdff_fpga #(1) addr_in_dccm_dc2ff     (.din(addr_in_dccm_dc1),     .dout(addr_in_dccm_dc2),     .clk(lsu_freeze_c1_dc2_clk), .rawclk(clk), .clken(lsu_freeze_c1_dc2_clken), .*);\n', '   rvdff_fpga #(1) addr_in_dccm_dc3ff     (.din(addr_in_dccm_dc2),     .dout(addr_in_dccm_dc3),     .clk(lsu_freeze_c1_dc3_clk), .rawclk(clk), .clken(lsu_freeze_c1_dc3_clken), .*);\n', '   rvdff_fpga #(1) addr_in_pic_dc2ff      (.din(addr_in_pic_dc1),      .dout(addr_in_pic_dc2),      .clk(lsu_freeze_c1_dc2_clk), .rawclk(clk), .clken(lsu_freeze_c1_dc2_clken), .*);\n', '   rvdff_fpga #(1) addr_in_pic_dc3ff      (.din(addr_in_pic_dc2),      .dout(addr_in_pic_dc3),      .clk(lsu_freeze_c1_dc3_clk), .rawclk(clk), .clken(lsu_freeze_c1_dc3_clken), .*);\n', '   rvdff_fpga #(1) access_fault_dc2ff     (.din(access_fault_dc1),     .dout(access_fault_dc2),     .clk(lsu_freeze_c1_dc2_clk), .rawclk(clk), .clken(lsu_freeze_c1_dc2_clken), .*);\n', '   rvdff_fpga #(1) access_fault_dc3ff     (.din(access_fault_dc2),     .dout(access_fault_dc3),     .clk(lsu_freeze_c1_dc3_clk), .rawclk(clk), .clken(lsu_freeze_c1_dc3_clken), .*);\n', '   rvdff_fpga #(1) addr_external_dc2ff    (.din(addr_external_dc1),    .dout(addr_external_dc2),    .clk(lsu_freeze_c1_dc2_clk), .rawclk(clk), .clken(lsu_freeze_c1_dc2_clken), .*);\n', '   rvdff_fpga #(1) addr_external_dc3ff    (.din(addr_external_dc2),    .dout(addr_external_dc3),    .clk(lsu_freeze_c1_dc3_clk), .rawclk(clk), .clken(lsu_freeze_c1_dc3_clken), .*);\n', '   rvdff_fpga #(1) misaligned_fault_dc2ff (.din(misaligned_fault_dc1), .dout(misaligned_fault_dc2), .clk(lsu_freeze_c1_dc2_clk), .rawclk(clk), .clken(lsu_freeze_c1_dc2_clken), .*);\n', '   rvdff_fpga #(1) misaligned_fault_dc3ff (.din(misaligned_fault_dc2), .dout(misaligned_fault_dc3), .clk(lsu_freeze_c1_dc3_clk), .rawclk(clk), .clken(lsu_freeze_c1_dc3_clken), .*);\n', '   rvdff_fpga #(1) lsu_pkt_vlddc1ff       (.din(lsu_pkt_dc1_in.valid), .dout(lsu_pkt_dc1.valid),    .clk(lsu_freeze_c2_dc1_clk), .rawclk(clk), .clken(lsu_freeze_c2_dc1_clken), .*);\n', '   rvdff_fpga #(1) lsu_pkt_vlddc2ff       (.din(lsu_pkt_dc2_in.valid), .dout(lsu_pkt_dc2.valid),    .clk(lsu_freeze_c2_dc2_clk), .rawclk(clk), .clken(lsu_freeze_c2_dc2_clken), .*);\n', '   rvdff_fpga #(1) lsu_pkt_vlddc3ff       (.din(lsu_pkt_dc3_in.valid), .dout(lsu_pkt_dc3.valid),    .clk(lsu_freeze_c2_dc3_clk), .rawclk(clk), .clken(lsu_freeze_c2_dc3_clken), .*);\n', '\n', '   rvdff #(1) addr_external_dc4ff(.din(addr_external_dc3), .dout(addr_external_dc4), .clk(lsu_c1_dc4_clk), .*);\n', '   rvdff #(1) addr_external_dc5ff(.din(addr_external_dc4), .dout(addr_external_dc5), .clk(lsu_c1_dc5_clk), .*);\n', '\n', '\n', 'endmodule\n']"
"['// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '\n', '//********************************************************************************\n', '// $Id$\n', '//\n', '//\n', '// Owner:\n', '// Function: Store Buffer\n', '// Comments: Dual writes and single drain\n', '//\n', '//\n', '// DC1 -> DC2 -> DC3 -> DC4 (Commit)\n', '//\n', '// //********************************************************************************\n', '\n', '\n', 'module lsu_stbuf\n', '   import veer_types::*;\n', '(\n', '   input logic        clk,                                // core clock\n', '   input logic        rst_l,                              // reset\n', '\n', '   input logic        lsu_freeze_c2_dc2_clk,              // freeze clock\n', '   input logic        lsu_freeze_c2_dc3_clk,              // freeze clock\n', '   input logic        lsu_freeze_c1_dc2_clk,              // freeze clock\n', '   input logic        lsu_freeze_c1_dc3_clk,              // freeze clock\n', '\n', '   input logic        lsu_freeze_c2_dc2_clken,\n', '   input logic        lsu_freeze_c2_dc3_clken,\n', '   input logic        lsu_freeze_c1_dc2_clken,\n', '   input logic        lsu_freeze_c1_dc3_clken,\n', '\n', '   input logic        lsu_c1_dc4_clk,                     // lsu pipe clock\n', '   input logic        lsu_c1_dc5_clk,                     // lsu pipe clock\n', '   input logic        lsu_c2_dc4_clk,                     // lsu pipe clock\n', '   input logic        lsu_c2_dc5_clk,                     // lsu pipe clock\n', '   input logic        lsu_stbuf_c1_clk,                   // stbuf clock\n', '   input logic        lsu_free_c2_clk,                    // free clk\n', '\n', '   // Store Buffer input\n', '   input logic        load_stbuf_reqvld_dc3,             // core instruction goes to stbuf\n', '   input logic        store_stbuf_reqvld_dc3,             // core instruction goes to stbuf\n', '   //input logic        ldst_stbuf_reqvld_dc3,\n', '   input logic        addr_in_pic_dc2,                    // address is in pic\n', '   input logic        addr_in_pic_dc3,                    // address is in pic\n', '   input logic        addr_in_dccm_dc2,                    // address is in pic\n', '   input logic        addr_in_dccm_dc3,                    // address is in pic\n', '   input logic [`RV_DCCM_DATA_WIDTH-1:0] store_ecc_datafn_hi_dc3,   // data to write\n', '   input logic [`RV_DCCM_DATA_WIDTH-1:0] store_ecc_datafn_lo_dc3,   // data to write\n', '\n', '   input logic        isldst_dc1,                         // instruction in dc1 is lsu\n', '   input logic        dccm_ldst_dc2,                         // instruction in dc2 is lsu\n', '   input logic        dccm_ldst_dc3,                         // instruction in dc3 is lsu\n', '\n', '   input logic        single_ecc_error_hi_dc3,            // single ecc error in hi bank\n', '   input logic        single_ecc_error_lo_dc3,            // single ecc error in lo bank\n', '   input logic        lsu_single_ecc_error_dc5,           // single_ecc_error in either bank staged to the dc5 - needed for the load repairs\n', '   input logic        lsu_commit_dc5,                     // lsu commits\n', '   input logic        lsu_freeze_dc3,                     // lsu freeze\n', '   input logic        flush_prior_dc5,                    // Flush is due to i0 and ld/st is in i1\n', '\n', '   // Store Buffer output\n', '   output logic                  stbuf_reqvld_any,         // stbuf is draining\n', '   output logic                  stbuf_reqvld_flushed_any, // Top entry is flushed\n', '   output logic                  stbuf_addr_in_pic_any,    // address maps to pic\n', '   output logic [`RV_DCCM_BYTE_WIDTH-1:0] stbuf_byteen_any, // which bytes are active\n', '   output logic [`RV_LSU_SB_BITS-1:0]  stbuf_addr_any,        // address\n', '   output logic [`RV_DCCM_DATA_WIDTH-1:0] stbuf_data_any,   // stbuf data\n', '\n', '   input  logic       lsu_stbuf_commit_any,                 // pop the stbuf as it commite\n', '   output logic       lsu_stbuf_full_any,                   // stbuf is full\n', '   output logic       lsu_stbuf_empty_any,                  // stbuf is empty\n', '   output logic       lsu_stbuf_nodma_empty_any,            // stbuf is empty except dma\n', ""   output logic       lsu_load_ecc_stbuf_full_dc3,          // Load with ecc error can't allocate to stbuf\n"", '\n', '   input logic [`RV_LSU_SB_BITS-1:0] lsu_addr_dc1,            // lsu address\n', '   input logic [`RV_LSU_SB_BITS-1:0] lsu_addr_dc2,\n', '   input logic [`RV_LSU_SB_BITS-1:0] lsu_addr_dc3,\n', '\n', '   input logic [`RV_LSU_SB_BITS-1:0] end_addr_dc1,            // lsu end addrress - needed to check unaligned\n', '   input logic [`RV_LSU_SB_BITS-1:0] end_addr_dc2,\n', '   input logic [`RV_LSU_SB_BITS-1:0] end_addr_dc3,\n', '\n', '   // Forwarding signals\n', '   input logic        lsu_cmpen_dc2,                       // needed for forwarding stbuf - load\n', '   input lsu_pkt_t    lsu_pkt_dc2,\n', '   input lsu_pkt_t    lsu_pkt_dc3,\n', '   input lsu_pkt_t    lsu_pkt_dc5,\n', '\n', '   output logic [`RV_DCCM_DATA_WIDTH-1:0] stbuf_fwddata_hi_dc3,     // stbuf data\n', '   output logic [`RV_DCCM_DATA_WIDTH-1:0] stbuf_fwddata_lo_dc3,\n', '   output logic [`RV_DCCM_BYTE_WIDTH-1:0] stbuf_fwdbyteen_hi_dc3,\n', '   output logic [`RV_DCCM_BYTE_WIDTH-1:0] stbuf_fwdbyteen_lo_dc3,\n', '\n', '   input  logic       scan_mode\n', '\n', ');\n', '\n', '`include ""global.h""\n', '\n', '   localparam DEPTH = LSU_STBUF_DEPTH;\n', '   localparam DATA_WIDTH = DCCM_DATA_WIDTH;\n', '   localparam BYTE_WIDTH = DCCM_BYTE_WIDTH;\n', '   localparam DEPTH_LOG2 = $clog2(DEPTH);\n', '\n', '   logic [DEPTH-1:0]       stbuf_data_vld;\n', '   logic [DEPTH-1:0]       stbuf_drain_vld;\n', '   logic [DEPTH-1:0]       stbuf_flush_vld;\n', '   logic [DEPTH-1:0]       stbuf_addr_in_pic;\n', '   logic [DEPTH-1:0]       stbuf_dma;\n', '   logic [DEPTH-1:0][LSU_SB_BITS-1:0] stbuf_addr;\n', '   logic [DEPTH-1:0][BYTE_WIDTH-1:0]  stbuf_byteen;\n', '   logic [DEPTH-1:0][DATA_WIDTH-1:0] stbuf_data;\n', '\n', '   logic [DEPTH-1:0]       sel_lo;\n', '   logic [DEPTH-1:0]       stbuf_wr_en;\n', '   logic [DEPTH-1:0]       stbuf_data_en;\n', '   logic [DEPTH-1:0]       stbuf_drain_or_flush_en;\n', '   logic [DEPTH-1:0]       stbuf_flush_en;\n', '   logic [DEPTH-1:0]       stbuf_drain_en;\n', '   logic [DEPTH-1:0]       stbuf_reset;\n', '   logic [DEPTH-1:0][LSU_SB_BITS-1:0] stbuf_addrin;\n', '   logic [DEPTH-1:0][DATA_WIDTH-1:0] stbuf_datain;\n', '   logic [DEPTH-1:0][BYTE_WIDTH-1:0]  stbuf_byteenin;\n', '\n', '   logic [7:0]             ldst_byteen_dc3;\n', '   logic [7:0]             store_byteen_ext_dc3;\n', '   logic [BYTE_WIDTH-1:0]  store_byteen_hi_dc3;\n', '   logic [BYTE_WIDTH-1:0]  store_byteen_lo_dc3;\n', '\n', '   logic                   ldst_stbuf_reqvld_dc3;\n', '   logic                   dual_ecc_error_dc3;\n', '   logic                   dual_stbuf_write_dc3;\n', '\n', '   logic                   WrPtrEn, RdPtrEn;\n', '   logic [DEPTH_LOG2-1:0]  WrPtr, RdPtr;\n', '   logic [DEPTH_LOG2-1:0]  NxtWrPtr, NxtRdPtr;\n', '   logic [DEPTH_LOG2-1:0]  WrPtrPlus1, WrPtrPlus1_dc5, WrPtrPlus2, RdPtrPlus1;\n', '   logic [DEPTH_LOG2-1:0]  WrPtr_dc3, WrPtr_dc4, WrPtr_dc5;\n', '   logic                   ldst_dual_dc1, ldst_dual_dc2, ldst_dual_dc3, ldst_dual_dc4, ldst_dual_dc5;\n', '   logic                   ldst_stbuf_reqvld_dc4, ldst_stbuf_reqvld_dc5;\n', '   logic                   dual_stbuf_write_dc4, dual_stbuf_write_dc5;\n', '\n', '   logic [3:0]             stbuf_numvld_any, stbuf_specvld_any;\n', '   logic [1:0]             stbuf_specvld_dc1, stbuf_specvld_dc2, stbuf_specvld_dc3;\n', '   logic                   stbuf_oneavl_any, stbuf_twoavl_any;\n', '\n', '   logic                   cmpen_hi_dc2, cmpen_lo_dc2, jit_in_same_region;\n', '\n', '   logic [LSU_SB_BITS-1:$clog2(BYTE_WIDTH)]  cmpaddr_hi_dc2, cmpaddr_lo_dc2;\n', '\n', '   logic                   stbuf_ldmatch_hi_hi, stbuf_ldmatch_hi_lo;\n', '   logic                   stbuf_ldmatch_lo_hi, stbuf_ldmatch_lo_lo;\n', '   logic [BYTE_WIDTH-1:0]  stbuf_fwdbyteen_hi_hi, stbuf_fwdbyteen_hi_lo;\n', '   logic [BYTE_WIDTH-1:0]  stbuf_fwdbyteen_lo_hi, stbuf_fwdbyteen_lo_lo;\n', '   logic [DATA_WIDTH-1:0]  stbuf_fwddata_hi_hi, stbuf_fwddata_hi_lo;\n', '   logic [DATA_WIDTH-1:0]  stbuf_fwddata_lo_hi, stbuf_fwddata_lo_lo;\n', '\n', '   logic [DEPTH-1:0]                 stbuf_ldmatch_hi, stbuf_ldmatch_lo;\n', '   logic [DEPTH-1:0][BYTE_WIDTH-1:0] stbuf_fwdbyteenvec_hi, stbuf_fwdbyteenvec_lo;\n', '   logic [DEPTH-1:0][DATA_WIDTH-1:0] stbuf_fwddatavec_hi, stbuf_fwddatavec_lo;\n', '   logic [DATA_WIDTH-1:0]            stbuf_fwddata_hi_dc2, stbuf_fwddata_lo_dc2;\n', '   logic [DATA_WIDTH-1:0]            stbuf_fwddata_hi_fn_dc2, stbuf_fwddata_lo_fn_dc2;\n', '   logic [BYTE_WIDTH-1:0]            stbuf_fwdbyteen_hi_dc2, stbuf_fwdbyteen_lo_dc2;\n', '   logic [BYTE_WIDTH-1:0]            stbuf_fwdbyteen_hi_fn_dc2, stbuf_fwdbyteen_lo_fn_dc2;\n', '   logic                             stbuf_load_repair_dc5;\n', '   //----------------------------------------\n', '   // Logic starts here\n', '   //----------------------------------------\n', '   // Create high/low byte enables\n', ""   assign ldst_byteen_dc3[7:0] = ({8{lsu_pkt_dc3.by}}   & 8'b0000_0001) |\n"", ""                                 ({8{lsu_pkt_dc3.half}} & 8'b0000_0011) |\n"", ""                                 ({8{lsu_pkt_dc3.word}} & 8'b0000_1111) |\n"", ""                                 ({8{lsu_pkt_dc3.dword}} & 8'b1111_1111);\n"", '   assign store_byteen_ext_dc3[7:0] = ldst_byteen_dc3[7:0] << lsu_addr_dc3[1:0];\n', '   assign store_byteen_hi_dc3[BYTE_WIDTH-1:0] = store_byteen_ext_dc3[7:4];\n', '   assign store_byteen_lo_dc3[BYTE_WIDTH-1:0] = store_byteen_ext_dc3[3:0];\n', '\n', ""   assign RdPtrPlus1[DEPTH_LOG2-1:0] = RdPtr[DEPTH_LOG2-1:0] + 1'b1;\n"", ""   assign WrPtrPlus1[DEPTH_LOG2-1:0] = WrPtr[DEPTH_LOG2-1:0] + 1'b1;\n"", ""   assign WrPtrPlus2[DEPTH_LOG2-1:0] = WrPtr[DEPTH_LOG2-1:0] + 2'b10;\n"", ""   assign WrPtrPlus1_dc5[DEPTH_LOG2-1:0] = WrPtr_dc5[DEPTH_LOG2-1:0] + 1'b1;\n"", '\n', '   // ecc error on both hi/lo\n', '   assign ldst_dual_dc1      = (lsu_addr_dc1[2] != end_addr_dc1[2]);\n', '   assign dual_ecc_error_dc3 = (single_ecc_error_hi_dc3 & single_ecc_error_lo_dc3);\n', '   assign dual_stbuf_write_dc3   = ldst_dual_dc3 & (store_stbuf_reqvld_dc3 | dual_ecc_error_dc3);\n', '   assign ldst_stbuf_reqvld_dc3  = store_stbuf_reqvld_dc3 |\n', ""                                   (load_stbuf_reqvld_dc3 & (dual_ecc_error_dc3 ? stbuf_twoavl_any : stbuf_oneavl_any));   // Don't correct ecc if not enough entries. Load will be flushed and come back again\n"", '   assign stbuf_load_repair_dc5 = lsu_single_ecc_error_dc5 & (lsu_pkt_dc5.valid & lsu_pkt_dc5.load & ~flush_prior_dc5);\n', '\n', '   // Store Buffer instantiation\n', '   for (genvar i=0; i<DEPTH; i++) begin: GenStBuf\n', '      assign stbuf_wr_en[i] = ldst_stbuf_reqvld_dc3 & ((i == WrPtr[DEPTH_LOG2-1:0]) |\n', '                                                       (i == WrPtrPlus1[DEPTH_LOG2-1:0] & dual_stbuf_write_dc3));\n', '      assign stbuf_data_en[i] = stbuf_wr_en[i];\n', '      assign stbuf_drain_or_flush_en[i] = ldst_stbuf_reqvld_dc5 & ~lsu_pkt_dc5.dma & ((i == WrPtr_dc5[DEPTH_LOG2-1:0]) |\n', '                                                                                      (i == WrPtrPlus1_dc5[DEPTH_LOG2-1:0] & dual_stbuf_write_dc5));\n', '      assign stbuf_drain_en[i] = (stbuf_drain_or_flush_en[i] & lsu_commit_dc5) | (stbuf_wr_en[i] & lsu_pkt_dc3.dma);\n', '      assign stbuf_flush_en[i] = stbuf_drain_or_flush_en[i] & ~lsu_commit_dc5;\n', '      assign stbuf_reset[i] = (lsu_stbuf_commit_any | stbuf_reqvld_flushed_any) & (i == RdPtr[DEPTH_LOG2-1:0]);\n', '\n', '      // Mux select for start/end address\n', '      assign sel_lo[i] = (~ldst_dual_dc3 | (store_stbuf_reqvld_dc3 | single_ecc_error_lo_dc3)) & (i == WrPtr[DEPTH_LOG2-1:0]);\n', '      assign stbuf_addrin[i][LSU_SB_BITS-1:0]  = sel_lo[i] ? lsu_addr_dc3[LSU_SB_BITS-1:0] : end_addr_dc3[LSU_SB_BITS-1:0];\n', '      assign stbuf_byteenin[i][BYTE_WIDTH-1:0] = sel_lo[i] ? store_byteen_lo_dc3[BYTE_WIDTH-1:0] : store_byteen_hi_dc3[BYTE_WIDTH-1:0];\n', '      assign stbuf_datain[i][DATA_WIDTH-1:0]  = sel_lo[i] ? store_ecc_datafn_lo_dc3[DATA_WIDTH-1:0] : store_ecc_datafn_hi_dc3[DATA_WIDTH-1:0];\n', '\n', ""      rvdffsc #(.WIDTH(1)) stbuf_data_vldff (.din(1'b1), .dout(stbuf_data_vld[i]), .en(stbuf_wr_en[i]), .clear(stbuf_reset[i]), .clk(lsu_stbuf_c1_clk), .*);\n"", ""      rvdffsc #(.WIDTH(1)) stbuf_drain_vldff (.din(1'b1), .dout(stbuf_drain_vld[i]), .en(stbuf_drain_en[i]), .clear(stbuf_reset[i]), .clk(lsu_free_c2_clk), .*);\n"", ""      rvdffsc #(.WIDTH(1)) stbuf_flush_vldff (.din(1'b1), .dout(stbuf_flush_vld[i]), .en(stbuf_flush_en[i]), .clear(stbuf_reset[i]), .clk(lsu_free_c2_clk), .*);\n"", '      rvdffs #(.WIDTH(1)) stbuf_dma_picff (.din(lsu_pkt_dc3.dma), .dout(stbuf_dma[i]), .en(stbuf_wr_en[i]), .clk(lsu_stbuf_c1_clk), .*);\n', '      rvdffs #(.WIDTH(1)) stbuf_addr_in_picff (.din(addr_in_pic_dc3), .dout(stbuf_addr_in_pic[i]), .en(stbuf_wr_en[i]), .clk(lsu_stbuf_c1_clk), .*);\n', '      rvdffe #(.WIDTH(LSU_SB_BITS)) stbuf_addrff (.din(stbuf_addrin[i][LSU_SB_BITS-1:0]), .dout(stbuf_addr[i][LSU_SB_BITS-1:0]), .en(stbuf_wr_en[i]), .*);\n', '      rvdffs #(.WIDTH(BYTE_WIDTH)) stbuf_byteenff (.din(stbuf_byteenin[i][BYTE_WIDTH-1:0]), .dout(stbuf_byteen[i][BYTE_WIDTH-1:0]), .en(stbuf_wr_en[i]), .clk(lsu_stbuf_c1_clk), .*);\n', '      rvdffe #(.WIDTH(DATA_WIDTH)) stbuf_dataff (.din(stbuf_datain[i][DATA_WIDTH-1:0]), .dout(stbuf_data[i][DATA_WIDTH-1:0]), .en(stbuf_data_en[i]), .*);\n', '\n', '   end\n', '\n', '   // WrPtr flops to dc5\n', '   assign WrPtr_dc3[DEPTH_LOG2-1:0] = WrPtr[DEPTH_LOG2-1:0];\n', '   rvdff #(.WIDTH(DEPTH_LOG2)) WrPtr_dc4ff (.din(WrPtr_dc3[DEPTH_LOG2-1:0]), .dout(WrPtr_dc4[DEPTH_LOG2-1:0]), .clk(lsu_c1_dc4_clk), .*);\n', '   rvdff #(.WIDTH(DEPTH_LOG2)) WrPtr_dc5ff (.din(WrPtr_dc4[DEPTH_LOG2-1:0]), .dout(WrPtr_dc5[DEPTH_LOG2-1:0]), .clk(lsu_c1_dc5_clk), .*);\n', '\n', '   rvdff_fpga #(.WIDTH(1)) ldst_dual_dc2ff (.din(ldst_dual_dc1), .dout(ldst_dual_dc2), .clk(lsu_freeze_c1_dc2_clk), .clken(lsu_freeze_c1_dc2_clken), .rawclk(clk), .*);\n', '   rvdff_fpga #(.WIDTH(1)) ldst_dual_dc3ff (.din(ldst_dual_dc2), .dout(ldst_dual_dc3), .clk(lsu_freeze_c1_dc3_clk), .clken(lsu_freeze_c1_dc3_clken), .rawclk(clk), .*);\n', '   rvdff_fpga #(.WIDTH(BYTE_WIDTH)) stbuf_fwdbyteen_hi_dc3ff (.din(stbuf_fwdbyteen_hi_fn_dc2[BYTE_WIDTH-1:0]), .dout(stbuf_fwdbyteen_hi_dc3[BYTE_WIDTH-1:0]), .clk(lsu_freeze_c1_dc3_clk), .clken(lsu_freeze_c1_dc3_clken), .rawclk(clk), .*);\n', '   rvdff_fpga #(.WIDTH(BYTE_WIDTH)) stbuf_fwdbyteen_lo_dc3ff (.din(stbuf_fwdbyteen_lo_fn_dc2[BYTE_WIDTH-1:0]), .dout(stbuf_fwdbyteen_lo_dc3[BYTE_WIDTH-1:0]), .clk(lsu_freeze_c1_dc3_clk), .clken(lsu_freeze_c1_dc3_clken), .rawclk(clk), .*);\n', '\n', '   rvdff #(.WIDTH(1)) ldst_dual_dc4ff (.din(ldst_dual_dc3), .dout(ldst_dual_dc4), .clk(lsu_c1_dc4_clk), .*);\n', '   rvdff #(.WIDTH(1)) ldst_dual_dc5ff (.din(ldst_dual_dc4), .dout(ldst_dual_dc5), .clk(lsu_c1_dc5_clk), .*);\n', '\n', '   rvdff #(.WIDTH(1)) dual_stbuf_write_dc4ff (.din(dual_stbuf_write_dc3), .dout(dual_stbuf_write_dc4), .clk(lsu_c1_dc4_clk), .*);\n', '   rvdff #(.WIDTH(1)) dual_stbuf_write_dc5ff (.din(dual_stbuf_write_dc4), .dout(dual_stbuf_write_dc5), .clk(lsu_c1_dc5_clk), .*);\n', '   rvdff #(.WIDTH(1)) ldst_reqvld_dc4ff (.din(ldst_stbuf_reqvld_dc3), .dout(ldst_stbuf_reqvld_dc4), .clk(lsu_c2_dc4_clk), .*);\n', '   rvdff #(.WIDTH(1)) ldst_reqvld_dc5ff (.din(ldst_stbuf_reqvld_dc4), .dout(ldst_stbuf_reqvld_dc5), .clk(lsu_c2_dc5_clk), .*);\n', '\n', '   // Store Buffer drain logic\n', '   assign stbuf_reqvld_flushed_any = stbuf_flush_vld[RdPtr];\n', '   assign stbuf_reqvld_any = stbuf_drain_vld[RdPtr];\n', '   assign stbuf_addr_in_pic_any = stbuf_addr_in_pic[RdPtr];\n', '   assign stbuf_addr_any[LSU_SB_BITS-1:0] = stbuf_addr[RdPtr][LSU_SB_BITS-1:0];\n', '   assign stbuf_byteen_any[BYTE_WIDTH-1:0] = stbuf_byteen[RdPtr][BYTE_WIDTH-1:0];    // Not needed as we always write all the bytes\n', '   assign stbuf_data_any[DATA_WIDTH-1:0] = stbuf_data[RdPtr][DATA_WIDTH-1:0];\n', '\n', '   // Update the RdPtr/WrPtr logic\n', '   // Need to revert the WrPtr for flush cases. Also revert the pipe WrPtrs\n', '\n', '   assign WrPtrEn = ldst_stbuf_reqvld_dc3;\n', '   assign NxtWrPtr[DEPTH_LOG2-1:0] = (ldst_stbuf_reqvld_dc3 & dual_stbuf_write_dc3) ? WrPtrPlus2[DEPTH_LOG2-1:0] : WrPtrPlus1[DEPTH_LOG2-1:0];\n', '   assign RdPtrEn = lsu_stbuf_commit_any | stbuf_reqvld_flushed_any;\n', '   assign NxtRdPtr[DEPTH_LOG2-1:0] = RdPtrPlus1[DEPTH_LOG2-1:0];\n', '\n', '\n', '   always_comb begin\n', ""      //stbuf_numvld_any[3:0] =  {3'b0,isldst_dc3} << ldst_dual_dc3;  // Use isldst_dc3 for timing reason\n"", ""      stbuf_numvld_any[3:0] = '0;\n"", '      for (int i=0; i<DEPTH; i++) begin\n', ""         stbuf_numvld_any[3:0] += {3'b0, stbuf_data_vld[i]};\n"", '      end\n', '   end\n', '\n', ""   assign stbuf_specvld_dc1[1:0] = {1'b0,isldst_dc1} << (isldst_dc1 & ldst_dual_dc1);    // Gate dual with isldst to avoid X propagation\n"", ""   assign stbuf_specvld_dc2[1:0] = {1'b0,dccm_ldst_dc2} << (dccm_ldst_dc2 & ldst_dual_dc2);\n"", ""   assign stbuf_specvld_dc3[1:0] = {1'b0,dccm_ldst_dc3} << (dccm_ldst_dc3 & ldst_dual_dc3);\n"", ""   assign stbuf_specvld_any[3:0] = stbuf_numvld_any[3:0] +  {2'b0, stbuf_specvld_dc1[1:0]} + {2'b0, stbuf_specvld_dc2[1:0]} + {2'b0, stbuf_specvld_dc3[1:0]};\n"", '\n', '   assign lsu_stbuf_full_any = (stbuf_specvld_any[3:0] > (DEPTH - 2));\n', ""   assign lsu_stbuf_empty_any = (stbuf_numvld_any[3:0] == 4'b0);\n"", '   assign lsu_stbuf_nodma_empty_any = ~(|(stbuf_data_vld[DEPTH-1:0] & ~stbuf_dma[DEPTH-1:0]));\n', '   assign lsu_load_ecc_stbuf_full_dc3 = load_stbuf_reqvld_dc3 & ~ldst_stbuf_reqvld_dc3;\n', '\n', '   assign stbuf_oneavl_any = (stbuf_numvld_any[3:0] < DEPTH);\n', '   assign stbuf_twoavl_any = (stbuf_numvld_any[3:0] < (DEPTH - 1));\n', '\n', '   // Load forwarding logic\n', '   assign cmpen_hi_dc2 = lsu_cmpen_dc2 & ldst_dual_dc2;\n', '   assign cmpaddr_hi_dc2[LSU_SB_BITS-1:$clog2(BYTE_WIDTH)] = end_addr_dc2[LSU_SB_BITS-1:$clog2(BYTE_WIDTH)];\n', '\n', '   assign cmpen_lo_dc2 = lsu_cmpen_dc2;\n', '   assign cmpaddr_lo_dc2[LSU_SB_BITS-1:$clog2(BYTE_WIDTH)] = lsu_addr_dc2[LSU_SB_BITS-1:$clog2(BYTE_WIDTH)];\n', '   assign jit_in_same_region = (addr_in_pic_dc2 & addr_in_pic_dc3) | (addr_in_dccm_dc2 & addr_in_dccm_dc3);\n', '\n', '   // JIT forwarding\n', '   assign stbuf_ldmatch_hi_hi = (end_addr_dc3[LSU_SB_BITS-1:$clog2(BYTE_WIDTH)] == cmpaddr_hi_dc2[LSU_SB_BITS-1:$clog2(BYTE_WIDTH)]) & ~(cmpen_hi_dc2 & lsu_pkt_dc2.dma & ~lsu_pkt_dc3.dma) & jit_in_same_region;\n', '   assign stbuf_ldmatch_hi_lo = (lsu_addr_dc3[LSU_SB_BITS-1:$clog2(BYTE_WIDTH)] == cmpaddr_hi_dc2[LSU_SB_BITS-1:$clog2(BYTE_WIDTH)]) & ~(cmpen_hi_dc2 & lsu_pkt_dc2.dma & ~lsu_pkt_dc3.dma) & jit_in_same_region;\n', '   assign stbuf_ldmatch_lo_hi = (end_addr_dc3[LSU_SB_BITS-1:$clog2(BYTE_WIDTH)] == cmpaddr_lo_dc2[LSU_SB_BITS-1:$clog2(BYTE_WIDTH)]) & ~(cmpen_lo_dc2 & lsu_pkt_dc2.dma & ~lsu_pkt_dc3.dma) & jit_in_same_region;\n', '   assign stbuf_ldmatch_lo_lo = (lsu_addr_dc3[LSU_SB_BITS-1:$clog2(BYTE_WIDTH)] == cmpaddr_lo_dc2[LSU_SB_BITS-1:$clog2(BYTE_WIDTH)]) & ~(cmpen_lo_dc2 & lsu_pkt_dc2.dma & ~lsu_pkt_dc3.dma) & jit_in_same_region;\n', '\n', '   for (genvar i=0; i<BYTE_WIDTH; i++) begin\n', '      assign stbuf_fwdbyteen_hi_hi[i] = stbuf_ldmatch_hi_hi & store_byteen_hi_dc3[i] & ldst_stbuf_reqvld_dc3 & dual_stbuf_write_dc3;\n', '      assign stbuf_fwdbyteen_hi_lo[i] = stbuf_ldmatch_hi_lo & store_byteen_lo_dc3[i] & ldst_stbuf_reqvld_dc3;\n', '      assign stbuf_fwdbyteen_lo_hi[i] = stbuf_ldmatch_lo_hi & store_byteen_hi_dc3[i] & ldst_stbuf_reqvld_dc3 & dual_stbuf_write_dc3;\n', '      assign stbuf_fwdbyteen_lo_lo[i] = stbuf_ldmatch_lo_lo & store_byteen_lo_dc3[i] & ldst_stbuf_reqvld_dc3;\n', '\n', '      assign stbuf_fwddata_hi_hi[(8*i)+7:(8*i)] = {8{stbuf_fwdbyteen_hi_hi[i]}} & store_ecc_datafn_hi_dc3[(8*i)+7:(8*i)];\n', '      assign stbuf_fwddata_hi_lo[(8*i)+7:(8*i)] = {8{stbuf_fwdbyteen_hi_lo[i]}} & store_ecc_datafn_lo_dc3[(8*i)+7:(8*i)];\n', '      assign stbuf_fwddata_lo_hi[(8*i)+7:(8*i)] = {8{stbuf_fwdbyteen_lo_hi[i]}} & store_ecc_datafn_hi_dc3[(8*i)+7:(8*i)];\n', '      assign stbuf_fwddata_lo_lo[(8*i)+7:(8*i)] = {8{stbuf_fwdbyteen_lo_lo[i]}} & store_ecc_datafn_lo_dc3[(8*i)+7:(8*i)];\n', '   end\n', '\n', '\n', '   always_comb begin: GenLdFwd\n', ""      stbuf_fwdbyteen_hi_dc2[BYTE_WIDTH-1:0]   = '0;\n"", ""      stbuf_fwdbyteen_lo_dc2[BYTE_WIDTH-1:0]   = '0;\n"", '      for (int i=0; i<DEPTH; i++) begin\n', '         stbuf_ldmatch_hi[i] = (stbuf_addr[i][LSU_SB_BITS-1:$clog2(BYTE_WIDTH)] == cmpaddr_hi_dc2[LSU_SB_BITS-1:$clog2(BYTE_WIDTH)]) &\n', '                               (stbuf_drain_vld[i] | ~lsu_pkt_dc2.dma) & ~stbuf_flush_vld[i] & ((stbuf_addr_in_pic[i] & addr_in_pic_dc2) | (~stbuf_addr_in_pic[i] & addr_in_dccm_dc2));\n', '         stbuf_ldmatch_lo[i] = (stbuf_addr[i][LSU_SB_BITS-1:$clog2(BYTE_WIDTH)] == cmpaddr_lo_dc2[LSU_SB_BITS-1:$clog2(BYTE_WIDTH)]) &\n', '                               (stbuf_drain_vld[i] | ~lsu_pkt_dc2.dma) & ~stbuf_flush_vld[i] & ((stbuf_addr_in_pic[i] & addr_in_pic_dc2) | (~stbuf_addr_in_pic[i] & addr_in_dccm_dc2));\n', '\n', '         for (int j=0; j<BYTE_WIDTH; j++) begin\n', '            stbuf_fwdbyteenvec_hi[i][j] = stbuf_ldmatch_hi[i] & stbuf_byteen[i][j] & stbuf_data_vld[i];\n', '            stbuf_fwdbyteen_hi_dc2[j] |= stbuf_fwdbyteenvec_hi[i][j];\n', '\n', '            stbuf_fwdbyteenvec_lo[i][j] = stbuf_ldmatch_lo[i] & stbuf_byteen[i][j] & stbuf_data_vld[i];\n', '            stbuf_fwdbyteen_lo_dc2[j] |= stbuf_fwdbyteenvec_lo[i][j];\n', '         end\n', '      end\n', '   end // block: GenLdFwd\n', '\n', '   for (genvar i=0; i<DEPTH; i++) begin\n', '      for (genvar j=0; j<BYTE_WIDTH; j++) begin\n', '         assign stbuf_fwddatavec_hi[i][(8*j)+7:(8*j)] = {8{stbuf_fwdbyteenvec_hi[i][j]}} & stbuf_data[i][(8*j)+7:(8*j)];\n', '         assign stbuf_fwddatavec_lo[i][(8*j)+7:(8*j)] = {8{stbuf_fwdbyteenvec_lo[i][j]}} & stbuf_data[i][(8*j)+7:(8*j)];\n', '      end\n', '   end\n', '\n', '   always_comb begin\n', ""      stbuf_fwddata_hi_dc2[DATA_WIDTH-1:0] = '0;\n"", ""      stbuf_fwddata_lo_dc2[DATA_WIDTH-1:0] = '0;\n"", '      for (int i=0; i<DEPTH; i++) begin\n', '         // Byte0\n', ""         if (stbuf_fwdbyteenvec_hi[DEPTH_LOG2'(WrPtr[DEPTH_LOG2-1:0] + DEPTH_LOG2'(i))][0]) begin\n"", ""            stbuf_fwddata_hi_dc2[7:0] = stbuf_fwddatavec_hi[DEPTH_LOG2'(WrPtr[DEPTH_LOG2-1:0] + DEPTH_LOG2'(i))][7:0];\n"", '         end\n', ""         if (stbuf_fwdbyteenvec_lo[DEPTH_LOG2'(WrPtr[DEPTH_LOG2-1:0] + DEPTH_LOG2'(i))][0]) begin\n"", ""            stbuf_fwddata_lo_dc2[7:0] = stbuf_fwddatavec_lo[DEPTH_LOG2'(WrPtr[DEPTH_LOG2-1:0] + DEPTH_LOG2'(i))][7:0];\n"", '         end\n', '\n', '         // Byte1\n', ""         if (stbuf_fwdbyteenvec_hi[DEPTH_LOG2'(WrPtr[DEPTH_LOG2-1:0] + DEPTH_LOG2'(i))][1]) begin\n"", ""            stbuf_fwddata_hi_dc2[15:8] = stbuf_fwddatavec_hi[DEPTH_LOG2'(WrPtr[DEPTH_LOG2-1:0] + DEPTH_LOG2'(i))][15:8];\n"", '         end\n', ""         if (stbuf_fwdbyteenvec_lo[DEPTH_LOG2'(WrPtr[DEPTH_LOG2-1:0] + DEPTH_LOG2'(i))][1]) begin\n"", ""            stbuf_fwddata_lo_dc2[15:8] = stbuf_fwddatavec_lo[DEPTH_LOG2'(WrPtr[DEPTH_LOG2-1:0] + DEPTH_LOG2'(i))][15:8];\n"", '         end\n', '\n', '         // Byte2\n', ""         if (stbuf_fwdbyteenvec_hi[DEPTH_LOG2'(WrPtr[DEPTH_LOG2-1:0] + DEPTH_LOG2'(i))][2]) begin\n"", ""            stbuf_fwddata_hi_dc2[23:16] = stbuf_fwddatavec_hi[DEPTH_LOG2'(WrPtr[DEPTH_LOG2-1:0] + DEPTH_LOG2'(i))][23:16];\n"", '         end\n', ""         if (stbuf_fwdbyteenvec_lo[DEPTH_LOG2'(WrPtr[DEPTH_LOG2-1:0] + DEPTH_LOG2'(i))][2]) begin\n"", ""            stbuf_fwddata_lo_dc2[23:16] = stbuf_fwddatavec_lo[DEPTH_LOG2'(WrPtr[DEPTH_LOG2-1:0] + DEPTH_LOG2'(i))][23:16];\n"", '         end\n', '\n', '         // Byte3\n', ""         if (stbuf_fwdbyteenvec_hi[DEPTH_LOG2'(WrPtr[DEPTH_LOG2-1:0] + DEPTH_LOG2'(i))][3]) begin\n"", ""            stbuf_fwddata_hi_dc2[31:24] = stbuf_fwddatavec_hi[DEPTH_LOG2'(WrPtr[DEPTH_LOG2-1:0] + DEPTH_LOG2'(i))][31:24];\n"", '         end\n', ""         if (stbuf_fwdbyteenvec_lo[DEPTH_LOG2'(WrPtr[DEPTH_LOG2-1:0] + DEPTH_LOG2'(i))][3]) begin\n"", ""            stbuf_fwddata_lo_dc2[31:24] = stbuf_fwddatavec_lo[DEPTH_LOG2'(WrPtr[DEPTH_LOG2-1:0] + DEPTH_LOG2'(i))][31:24];\n"", '         end\n', '      end\n', '   end\n', '\n', '   for (genvar i=0; i<BYTE_WIDTH; i++) begin\n', '      assign stbuf_fwdbyteen_hi_fn_dc2[i] = stbuf_fwdbyteen_hi_hi[i] | stbuf_fwdbyteen_hi_lo[i] | stbuf_fwdbyteen_hi_dc2[i];\n', '      assign stbuf_fwdbyteen_lo_fn_dc2[i] = stbuf_fwdbyteen_lo_hi[i] | stbuf_fwdbyteen_lo_lo[i] | stbuf_fwdbyteen_lo_dc2[i];\n', '\n', '      assign stbuf_fwddata_hi_fn_dc2[(8*i)+7:(8*i)] = (stbuf_fwdbyteen_hi_hi[i] | stbuf_fwdbyteen_hi_lo[i]) ?\n', '                                                                         (stbuf_fwddata_hi_hi[(8*i)+7:(8*i)] | stbuf_fwddata_hi_lo[(8*i)+7:(8*i)]) :\n', '                                                                         stbuf_fwddata_hi_dc2[(8*i)+7:(8*i)];\n', '      assign stbuf_fwddata_lo_fn_dc2[(8*i)+7:(8*i)] = (stbuf_fwdbyteen_lo_hi[i] | stbuf_fwdbyteen_lo_lo[i]) ?\n', '                                                                         (stbuf_fwddata_lo_hi[(8*i)+7:(8*i)] | stbuf_fwddata_lo_lo[(8*i)+7:(8*i)]) :\n', '                                                                         stbuf_fwddata_lo_dc2[(8*i)+7:(8*i)];\n', '   end\n', '\n', '   // Flops\n', '   rvdffs #(.WIDTH(DEPTH_LOG2)) WrPtrff (.din(NxtWrPtr[DEPTH_LOG2-1:0]), .dout(WrPtr[DEPTH_LOG2-1:0]), .en(WrPtrEn), .clk(lsu_stbuf_c1_clk), .*);\n', '   rvdffs #(.WIDTH(DEPTH_LOG2)) RdPtrff (.din(NxtRdPtr[DEPTH_LOG2-1:0]), .dout(RdPtr[DEPTH_LOG2-1:0]), .en(RdPtrEn), .clk(lsu_stbuf_c1_clk), .*);\n', '\n', '\n', '   rvdffe #(.WIDTH(DATA_WIDTH)) stbuf_fwddata_hi_dc3ff (.din(stbuf_fwddata_hi_fn_dc2[DATA_WIDTH-1:0]), .dout(stbuf_fwddata_hi_dc3[DATA_WIDTH-1:0]), .en(lsu_freeze_c1_dc3_clken), .*);\n', '   rvdffe #(.WIDTH(DATA_WIDTH)) stbuf_fwddata_lo_dc3ff (.din(stbuf_fwddata_lo_fn_dc2[DATA_WIDTH-1:0]), .dout(stbuf_fwddata_lo_dc3[DATA_WIDTH-1:0]), .en(lsu_freeze_c1_dc3_clken), .*);\n', '\n', '`ifdef ASSERT_ON\n', '\n', '   assert_drainorflushvld_notvld: assert #0 (~(|((stbuf_drain_vld[DEPTH-1:0] | stbuf_flush_vld[DEPTH-1:0]) & ~stbuf_data_vld[DEPTH-1:0])));\n', '   assert_drainAndflushvld:       assert #0 (~(|(stbuf_drain_vld[DEPTH-1:0] & stbuf_flush_vld[DEPTH-1:0])));\n', '   assert_stbufempty:             assert #0 (~lsu_stbuf_empty_any | lsu_stbuf_nodma_empty_any);\n', '\n', '   property ldecc_stbuffull_commit;\n', ""      @(posedge clk)  disable iff(~rst_l) (load_stbuf_reqvld_dc3 & lsu_load_ecc_stbuf_full_dc3) |-> ##2 (lsu_commit_dc5 == 1'b0);\n"", '   endproperty\n', '   assert_ldecc_stbuffull_commit: assert property (ldecc_stbuffull_commit) else\n', '      $display(""load with ecc error committed with store buffer full"");\n', '`endif\n', '\n', 'endmodule\n', '\n']"
"['// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '\n', '//********************************************************************************\n', '// $Id$\n', '//\n', '//\n', '// Owner:\n', '// Function: LSU Trigger logic\n', '// Comments:\n', '//\n', '//********************************************************************************\n', 'module lsu_trigger\n', '   import veer_types::*;\n', '(\n', '   input logic         clk,                          // clock\n', '   input logic         lsu_free_c2_clk,              // clock\n', '   input logic         rst_l,                        // reset\n', '\n', '   input trigger_pkt_t [3:0] trigger_pkt_any,        // trigger packet from dec\n', '   input lsu_pkt_t     lsu_pkt_dc3,                  // lsu packet\n', '   input logic [31:0]  lsu_addr_dc3,                 // address\n', '   input logic [31:0]  lsu_result_dc3,               // load data\n', '   input logic [31:0]  store_data_dc3,               // store data\n', '\n', '   output logic [3:0] lsu_trigger_match_dc3          // match result\n', ');\n', '\n', '   logic [3:0][31:0]  lsu_match_data;\n', '   logic [3:0]        lsu_trigger_data_match;\n', '   logic [31:0]       store_data_trigger_dc3;\n', '\n', '   assign store_data_trigger_dc3[31:0] = { ({16{lsu_pkt_dc3.word}} & store_data_dc3[31:16]) , ({8{(lsu_pkt_dc3.half | lsu_pkt_dc3.word)}} & store_data_dc3[15:8]), store_data_dc3[7:0]};\n', '\n', '\n', '   for (genvar i=0; i<4; i++) begin\n', '      assign lsu_match_data[i][31:0] = ({32{~trigger_pkt_any[i].select}} & lsu_addr_dc3[31:0]) |\n', '                                       ({32{trigger_pkt_any[i].select & trigger_pkt_any[i].store}} & store_data_trigger_dc3[31:0]);\n', '\n', '\n', '      rvmaskandmatch trigger_match (.mask(trigger_pkt_any[i].tdata2[31:0]), .data(lsu_match_data[i][31:0]), .masken(trigger_pkt_any[i].match), .match(lsu_trigger_data_match[i]));\n', '\n', '      assign lsu_trigger_match_dc3[i] = lsu_pkt_dc3.valid & ~lsu_pkt_dc3.dma &\n', '                                        ((trigger_pkt_any[i].store & lsu_pkt_dc3.store) | (trigger_pkt_any[i].load & lsu_pkt_dc3.load & ~trigger_pkt_any[i].select)) &\n', '                                        lsu_trigger_data_match[i];\n', '   end\n', '\n', '\n', 'endmodule // lsu_trigger\n']"
"['//********************************************************************************\n', '// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '//********************************************************************************\n', '\n', 'module mem\n', '   import veer_types::*;\n', '(\n', '   input logic         clk,\n', '   input logic         rst_l,\n', '   input logic         lsu_freeze_dc3,\n', '   input logic         dccm_clk_override,\n', '   input logic         icm_clk_override,\n', '   input logic         dec_tlu_core_ecc_disable,\n', '\n', '   //DCCM ports\n', '   input logic         dccm_wren,\n', '   input logic         dccm_rden,\n', '   input logic [`RV_DCCM_BITS-1:0]  dccm_wr_addr,\n', '   input logic [`RV_DCCM_BITS-1:0]  dccm_rd_addr_lo,\n', '   input logic [`RV_DCCM_BITS-1:0]  dccm_rd_addr_hi,\n', '   input logic [`RV_DCCM_FDATA_WIDTH-1:0]  dccm_wr_data,\n', '\n', '\n', '   output logic [`RV_DCCM_FDATA_WIDTH-1:0]  dccm_rd_data_lo,\n', '   output logic [`RV_DCCM_FDATA_WIDTH-1:0]  dccm_rd_data_hi,\n', '\n', '\n', '`ifdef RV_ICCM_ENABLE\n', '   //ICCM ports\n', '   input logic [`RV_ICCM_BITS-1:2]  iccm_rw_addr,\n', '   input logic         iccm_wren,\n', '   input logic         iccm_rden,\n', '   input logic [2:0]   iccm_wr_size,\n', '   input logic [77:0]  iccm_wr_data,\n', '\n', '   output logic [155:0] iccm_rd_data,\n', '`endif\n', '   // Icache and Itag Ports\n', '`ifdef RV_ICACHE_ENABLE //temp\n', '   input  logic [31:2]  ic_rw_addr,\n', '   input  logic [3:0]   ic_tag_valid,\n', '   input  logic [3:0]   ic_wr_en,\n', '   input  logic         ic_rd_en,\n', '   input  logic [127:0] ic_premux_data,     // Premux data to be muxed with each way of the Icache.\n', '   input  logic         ic_sel_premux_data, // Premux data sel\n', '\n', '`ifdef RV_ICACHE_ECC\n', '   input  logic [83:0]               ic_wr_data,         // Data to fill to the Icache. With ECC\n', '   input  logic [41:0]               ic_debug_wr_data,   // Debug wr cache.\n', '`else\n', '   input  logic [67:0]               ic_wr_data,         // Data to fill to the Icache. With Parity\n', '   input  logic [33:0]               ic_debug_wr_data,   // Debug wr cache.\n', '`endif\n', '\n', '\n', '\n', '   input  logic [15:2]               ic_debug_addr,      // Read/Write addresss to the Icache.\n', '   input  logic                      ic_debug_rd_en,     // Icache debug rd\n', '   input  logic                      ic_debug_wr_en,     // Icache debug wr\n', '   input  logic                      ic_debug_tag_array, // Debug tag array\n', '   input  logic [3:0]                ic_debug_way,       // Debug way. Rd or Wr.\n', '\n', '`endif\n', '\n', '`ifdef RV_ICACHE_ECC\n', '   output logic [167:0]              ic_rd_data ,        // Data read from Icache. 2x64bits + parity bits. F2 stage. With ECC\n', '   output logic [24:0]               ictag_debug_rd_data,// Debug icache tag.\n', '`else\n', '   output logic [135:0]              ic_rd_data ,        // Data read from Icache. 2x64bits + parity bits. F2 stage. With Parity\n', '   output logic [20:0]               ictag_debug_rd_data,// Debug icache tag.\n', '`endif\n', '\n', '   output logic [3:0]   ic_rd_hit,\n', '   output logic         ic_tag_perr,        // Icache Tag parity error\n', '\n', '\n', '   input  logic         scan_mode\n', '\n', ');\n', '`include ""global.h""\n', '\n', ' `ifdef RV_DCCM_ENABLE\n', ""      localparam DCCM_ENABLE = 1'b1;\n"", '   `else\n', ""      localparam DCCM_ENABLE = 1'b0;\n"", '   `endif\n', '\n', '   logic free_clk;\n', ""   rvoclkhdr free_cg   ( .en(1'b1),         .l1clk(free_clk), .* );\n"", '\n', '   // DCCM Instantiation\n', '   if (DCCM_ENABLE == 1) begin: Gen_dccm_enable\n', '      lsu_dccm_mem dccm (\n', '         .clk_override(dccm_clk_override),\n', '         .*\n', '      );\n', '   end else begin: Gen_dccm_disable\n', ""      assign dccm_rd_data_lo = '0;\n"", ""      assign dccm_rd_data_hi = '0;\n"", '   end\n', '\n', '`ifdef RV_ICACHE_ENABLE\n', '   ifu_ic_mem icm  (\n', '      .clk_override(icm_clk_override),\n', '      .*\n', '   );\n', '`else\n', ""   assign   ic_rd_hit[3:0] = '0;\n"", ""   assign   ic_tag_perr    = '0 ;\n"", ""   assign   ic_rd_data  = '0 ;\n"", ""   assign   ictag_debug_rd_data  = '0 ;\n"", '`endif\n', '\n', '`ifdef RV_ICCM_ENABLE\n', '   ifu_iccm_mem iccm (.*,\n', '                  .clk_override(icm_clk_override),\n', '                  .iccm_rw_addr(iccm_rw_addr[`RV_ICCM_BITS-1:2]),\n', '                  .iccm_rd_data(iccm_rd_data[155:0])\n', '                   );\n', '`endif\n', '\n', 'endmodule\n']"
"['//********************************************************************************\n', '// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '//********************************************************************************\n', '\n', '//********************************************************************************\n', '// Function: Programmable Interrupt Controller\n', '// Comments:\n', '//********************************************************************************\n', '\n', 'module pic_ctrl\n', '                  (\n', '\n', '                     input  logic                   clk,                  // Core clock\n', '                     input  logic                   free_clk,             // free clock\n', '                     input  logic                   active_clk,           // active clock\n', '                     input  logic                   rst_l,                // Reset for all flops\n', '                     input  logic                   clk_override,         // Clock over-ride for gating\n', '                     input  logic                   lsu_freeze_dc3,       // LSU pipeline freeze\n', '                     input  logic [`RV_PIC_TOTAL_INT_PLUS1-1:0]   extintsrc_req,        // Interrupt requests\n', '                     input  logic [31:0]            picm_addr,            // Address of the register\n', '                     input  logic [31:0]            picm_wr_data,         // Data to be written to the register\n', '                     input  logic                   picm_wren,            // Write enable to the register\n', '                     input  logic                   picm_rden,            // Read enable for the register\n', '                     input  logic                   picm_mken,            // Read the Mask for the register\n', '                     input  logic [3:0]             meicurpl,             // Current Priority Level\n', '                     input  logic [3:0]             meipt,                // Current Priority Threshold\n', '\n', '                     output logic                   mexintpend,           // External Inerrupt request to the core\n', '                     output logic [7:0]             claimid,              // Claim Id of the requested interrupt\n', '                     output logic [3:0]             pl,                   // Priority level of the requested interrupt\n', '                     output logic [31:0]            picm_rd_data,         // Read data of the register\n', '                     output logic                   mhwakeup,             // Wake-up interrupt request\n', '                     input  logic                   scan_mode             // scan mode\n', '\n', ');\n', '`include ""global.h""\n', '\n', 'localparam NUM_LEVELS            = $clog2(TOTAL_INT);\n', 'localparam INTPRIORITY_BASE_ADDR = `RV_PIC_BASE_ADDR ;\n', ""localparam INTPEND_BASE_ADDR     = `RV_PIC_BASE_ADDR + 32'h00001000 ;\n"", ""localparam INTENABLE_BASE_ADDR   = `RV_PIC_BASE_ADDR + 32'h00002000 ;\n"", ""localparam EXT_INTR_PIC_CONFIG   = `RV_PIC_BASE_ADDR + 32'h00003000 ;\n"", ""localparam EXT_INTR_GW_CONFIG    = `RV_PIC_BASE_ADDR + 32'h00004000 ;\n"", ""localparam EXT_INTR_GW_CLEAR     = `RV_PIC_BASE_ADDR + 32'h00005000 ;\n"", '\n', '\n', 'localparam INTPEND_SIZE          = (TOTAL_INT < 32)  ? 32  :\n', '                                   (TOTAL_INT < 64)  ? 64  :\n', '                                   (TOTAL_INT < 128) ? 128 :\n', '                                   (TOTAL_INT < 256) ? 256 :\n', '                                   (TOTAL_INT < 512) ? 512 :  1024 ;\n', '\n', 'localparam INT_GRPS              =   INTPEND_SIZE / 32 ;\n', 'localparam INTPRIORITY_BITS      =  4 ;\n', 'localparam ID_BITS               =  8 ;\n', ""localparam int GW_CONFIG[TOTAL_INT-1:0] = '{default:0} ;\n"", '\n', 'logic  addr_intpend_base_match;\n', 'logic  addr_intenable_base_match;\n', 'logic  addr_intpriority_base_match;\n', 'logic  addr_config_pic_match ;\n', 'logic  addr_config_gw_base_match ;\n', 'logic  addr_clear_gw_base_match ;\n', 'logic  mexintpend_in;\n', 'logic  mhwakeup_in ;\n', 'logic  intpend_reg_read ;\n', '\n', 'logic [31:0]                                 picm_rd_data_in, intpend_rd_out;\n', 'logic                                        intenable_rd_out ;\n', 'logic [INTPRIORITY_BITS-1:0]                 intpriority_rd_out;\n', 'logic [1:0]                                  gw_config_rd_out;\n', '\n', 'logic [TOTAL_INT-1:0] [INTPRIORITY_BITS-1:0] intpriority_reg;\n', 'logic [TOTAL_INT-1:0] [INTPRIORITY_BITS-1:0] intpriority_reg_inv;\n', 'logic [TOTAL_INT-1:0]                        intpriority_reg_we;\n', 'logic [TOTAL_INT-1:0]                        intpriority_reg_re;\n', 'logic [TOTAL_INT-1:0] [1:0]                  gw_config_reg;\n', '\n', 'logic [TOTAL_INT-1:0]                        intenable_reg;\n', 'logic [TOTAL_INT-1:0]                        intenable_reg_we;\n', 'logic [TOTAL_INT-1:0]                        intenable_reg_re;\n', 'logic [TOTAL_INT-1:0]                        gw_config_reg_we;\n', 'logic [TOTAL_INT-1:0]                        gw_config_reg_re;\n', 'logic [TOTAL_INT-1:0]                        gw_clear_reg_we;\n', '\n', 'logic [INTPEND_SIZE-1:0]                     intpend_reg_extended;\n', '\n', 'logic [TOTAL_INT-1:0] [INTPRIORITY_BITS-1:0] intpend_w_prior_en;\n', 'logic [TOTAL_INT-1:0] [ID_BITS-1:0]          intpend_id;\n', 'logic [INTPRIORITY_BITS-1:0]                 maxint;\n', 'logic [INTPRIORITY_BITS-1:0]                 selected_int_priority;\n', 'logic [INT_GRPS-1:0] [31:0]                  intpend_rd_part_out ;\n', '\n', 'logic                                        config_reg;\n', 'logic                                        intpriord;\n', 'logic                                        config_reg_we ;\n', 'logic                                        config_reg_re ;\n', 'logic                                        config_reg_in ;\n', 'logic                                        prithresh_reg_write , prithresh_reg_read;\n', 'logic                                        intpriority_reg_read ;\n', 'logic                                        intenable_reg_read   ;\n', 'logic                                        gw_config_reg_read   ;\n', 'logic                                        picm_wren_ff , picm_rden_ff ;\n', 'logic [31:0]                                 picm_addr_ff;\n', 'logic [31:0]                                 picm_wr_data_ff;\n', 'logic [3:0]                                  mask;\n', 'logic                                        picm_mken_ff;\n', 'logic [ID_BITS-1:0]                          claimid_in ;\n', 'logic [INTPRIORITY_BITS-1:0]                 pl_in ;\n', 'logic [INTPRIORITY_BITS-1:0]                 pl_in_q ;\n', '\n', '   logic                                     picm_rden_in, picm_mken_in;\n', '\n', 'logic [TOTAL_INT-1:0]                        extintsrc_req_sync;\n', 'logic [TOTAL_INT-1:0]                        extintsrc_req_gw;\n', '\n', '// clkens\n', '   logic                                     pic_addr_c1_clken;\n', '   logic                                     pic_data_c1_clken;\n', '   logic                                     pic_pri_c1_clken;\n', '   logic                                     pic_int_c1_clken;\n', '   logic                                     gw_config_c1_clken;\n', '\n', '// clocks\n', '   logic                                     pic_addr_c1_clk;\n', '   logic                                     pic_data_c1_clk;\n', '   logic                                     pic_pri_c1_clk;\n', '   logic                                     pic_int_c1_clk;\n', '   logic                                     gw_config_c1_clk;\n', '\n', '// ---- Clock gating section ------\n', '// c1 clock enables\n', '   assign pic_addr_c1_clken   = (picm_mken | picm_rden | picm_wren | clk_override) & ~lsu_freeze_dc3;\n', '   assign pic_data_c1_clken   = picm_wren | clk_override;\n', '   assign pic_pri_c1_clken    = (addr_intpriority_base_match & (picm_wren_ff | picm_rden_ff)) | clk_override;\n', '   assign pic_int_c1_clken    = (addr_intenable_base_match & (picm_wren_ff | picm_rden_ff))   | clk_override;\n', '   assign gw_config_c1_clken  = (addr_config_gw_base_match & (picm_wren_ff | picm_rden_ff))   | clk_override;\n', '\n', '   // C1 - 1 clock pulse for data\n', '   rvoclkhdr pic_addr_c1_cgc   ( .en(pic_addr_c1_clken), .l1clk(pic_addr_c1_clk), .* );\n', '   rvoclkhdr pic_data_c1_cgc   ( .en(pic_data_c1_clken), .l1clk(pic_data_c1_clk), .* );\n', '   rvoclkhdr pic_pri_c1_cgc    ( .en(pic_pri_c1_clken),  .l1clk(pic_pri_c1_clk),  .* );\n', '   rvoclkhdr pic_int_c1_cgc    ( .en(pic_int_c1_clken),  .l1clk(pic_int_c1_clk),  .* );\n', '   rvoclkhdr gw_config_c1_cgc  ( .en(gw_config_c1_clken),  .l1clk(gw_config_c1_clk),  .* );\n', '\n', '// ------ end clock gating section ------------------------\n', '\n', 'assign addr_intpend_base_match      = (picm_addr_ff[31:6]            == INTPEND_BASE_ADDR[31:6]) ;\n', 'assign addr_intenable_base_match    = (picm_addr_ff[31:NUM_LEVELS+2] == INTENABLE_BASE_ADDR[31:NUM_LEVELS+2]) ;\n', 'assign addr_intpriority_base_match  = (picm_addr_ff[31:NUM_LEVELS+2] == INTPRIORITY_BASE_ADDR[31:NUM_LEVELS+2]) ;\n', 'assign addr_config_pic_match        = (picm_addr_ff[31:0]            == EXT_INTR_PIC_CONFIG[31:0]) ;\n', 'assign addr_config_gw_base_match    = (picm_addr_ff[31:NUM_LEVELS+2] == EXT_INTR_GW_CONFIG[31:NUM_LEVELS+2]) ;\n', 'assign addr_clear_gw_base_match     = (picm_addr_ff[31:NUM_LEVELS+2] == EXT_INTR_GW_CLEAR[31:NUM_LEVELS+2]) ;\n', '\n', 'assign picm_rden_in = lsu_freeze_dc3 ? picm_rden_ff : picm_rden;\n', 'assign picm_mken_in = lsu_freeze_dc3 ? picm_mken_ff : picm_mken;\n', '\n', 'rvdff #(32)                picm_add_flop   (.*, .din (picm_addr),                    .dout(picm_addr_ff),         .clk(pic_addr_c1_clk));\n', 'rvdff  #(1)                picm_wre_flop   (.*, .din (picm_wren),                    .dout(picm_wren_ff),         .clk(active_clk));\n', 'rvdff  #(1)                picm_rde_flop   (.*, .din (picm_rden_in),                 .dout(picm_rden_ff),         .clk(active_clk));\n', 'rvdff  #(1)                picm_mke_flop   (.*, .din (picm_mken_in),                 .dout(picm_mken_ff),         .clk(active_clk));\n', 'rvdff #(32)                picm_dat_flop   (.*, .din (picm_wr_data[31:0]),           .dout(picm_wr_data_ff[31:0]), .clk(pic_data_c1_clk));\n', '\n', 'rvsyncss  #(TOTAL_INT-1) sync_inst\n', '(\n', ' .clk (free_clk),\n', ' .dout(extintsrc_req_sync[TOTAL_INT-1:1]),\n', ' .din (extintsrc_req[TOTAL_INT-1:1]),\n', ' .*) ;\n', '\n', 'assign extintsrc_req_sync[0] = extintsrc_req[0];\n', '\n', 'genvar i, l, m , j, k;\n', 'for (i=0; i<TOTAL_INT ; i++) begin  : SETREG\n', '\n', ' if (i > 0 ) begin : NON_ZERO_INT\n', '     assign intpriority_reg_we[i] =  addr_intpriority_base_match & (picm_addr_ff[NUM_LEVELS+1:2] == i) & picm_wren_ff;\n', '     assign intpriority_reg_re[i] =  addr_intpriority_base_match & (picm_addr_ff[NUM_LEVELS+1:2] == i) & picm_rden_ff;\n', '\n', '     assign intenable_reg_we[i]   =  addr_intenable_base_match   & (picm_addr_ff[NUM_LEVELS+1:2] == i) & picm_wren_ff;\n', '     assign intenable_reg_re[i]   =  addr_intenable_base_match   & (picm_addr_ff[NUM_LEVELS+1:2] == i) & picm_rden_ff;\n', '\n', '     assign gw_config_reg_we[i]   =  addr_config_gw_base_match   & (picm_addr_ff[NUM_LEVELS+1:2] == i) & picm_wren_ff;\n', '     assign gw_config_reg_re[i]   =  addr_config_gw_base_match   & (picm_addr_ff[NUM_LEVELS+1:2] == i) & picm_rden_ff;\n', '\n', '     assign gw_clear_reg_we[i]    =  addr_clear_gw_base_match   & (picm_addr_ff[NUM_LEVELS+1:2] == i) & picm_wren_ff ;\n', '\n', '     rvdffs #(INTPRIORITY_BITS) intpriority_ff  (.*, .en( intpriority_reg_we[i]), .din (picm_wr_data_ff[INTPRIORITY_BITS-1:0]), .dout(intpriority_reg[i]), .clk(pic_pri_c1_clk));\n', '     rvdffs #(1)                 intenable_ff   (.*, .en( intenable_reg_we[i]),   .din (picm_wr_data_ff[0]),                    .dout(intenable_reg[i]),   .clk(pic_int_c1_clk));\n', '\n', '\n', '//     if (GW_CONFIG[i]) begin\n', '\n', '        rvdffs #(2)                 gw_config_ff   (.*, .en( gw_config_reg_we[i]),   .din (picm_wr_data_ff[1:0]),                  .dout(gw_config_reg[i]),   .clk(gw_config_c1_clk));\n', '        configurable_gw config_gw_inst(.*, .gw_clk(free_clk),\n', '                         .extintsrc_req_sync(extintsrc_req_sync[i]) ,\n', '                         .meigwctrl_polarity(gw_config_reg[i][0]) ,\n', '                         .meigwctrl_type(gw_config_reg[i][1]) ,\n', '                         .meigwclr(gw_clear_reg_we[i]) ,\n', '                         .extintsrc_req_config(extintsrc_req_gw[i])\n', '                            );\n', '//    end else begin\n', '//        assign extintsrc_req_gw[i] = extintsrc_req_sync[i] ;\n', ""//        assign gw_config_reg[i]    = '0 ;\n"", '//    end\n', '\n', '\n', ' end else begin : INT_ZERO\n', ""     assign intpriority_reg_we[i] =  1'b0 ;\n"", ""     assign intpriority_reg_re[i] =  1'b0 ;\n"", ""     assign intenable_reg_we[i]   =  1'b0 ;\n"", ""     assign intenable_reg_re[i]   =  1'b0 ;\n"", '\n', ""     assign gw_config_reg_we[i]   =  1'b0 ;\n"", ""     assign gw_config_reg_re[i]   =  1'b0 ;\n"", ""     assign gw_clear_reg_we[i]    =  1'b0 ;\n"", '\n', ""     assign gw_config_reg[i]    = '0 ;\n"", '\n', ""     assign intpriority_reg[i] = {INTPRIORITY_BITS{1'b0}} ;\n"", ""     assign intenable_reg[i]   = 1'b0 ;\n"", ""     assign extintsrc_req_gw[i] = 1'b0 ;\n"", ' end\n', '\n', '\n', '    assign intpriority_reg_inv[i] =  intpriord ? ~intpriority_reg[i] : intpriority_reg[i] ;\n', '\n', '    assign intpend_w_prior_en[i]  =  {INTPRIORITY_BITS{(extintsrc_req_gw[i] & intenable_reg[i])}} & intpriority_reg_inv[i] ;\n', '    assign intpend_id[i]          =  i ;\n', 'end\n', '\n', '\n', '        assign pl_in[INTPRIORITY_BITS-1:0]                  =      selected_int_priority[INTPRIORITY_BITS-1:0] ;\n', '\n', '`ifdef RV_PIC_2CYCLE\n', '        logic [NUM_LEVELS/2:0] [TOTAL_INT+2:0] [INTPRIORITY_BITS-1:0] level_intpend_w_prior_en;\n', '        logic [NUM_LEVELS/2:0] [TOTAL_INT+2:0] [ID_BITS-1:0]          level_intpend_id;\n', '        logic [NUM_LEVELS:NUM_LEVELS/2] [(TOTAL_INT/2**(NUM_LEVELS/2))+1:0] [INTPRIORITY_BITS-1:0] levelx_intpend_w_prior_en;\n', '        logic [NUM_LEVELS:NUM_LEVELS/2] [(TOTAL_INT/2**(NUM_LEVELS/2))+1:0] [ID_BITS-1:0]          levelx_intpend_id;\n', '\n', ""        assign level_intpend_w_prior_en[0][TOTAL_INT+2:0] = {4'b0,4'b0,4'b0,intpend_w_prior_en[TOTAL_INT-1:0]} ;\n"", ""        assign level_intpend_id[0][TOTAL_INT+2:0]         = {8'b0,8'b0,8'b0,intpend_id[TOTAL_INT-1:0]} ;\n"", '\n', '        logic [(TOTAL_INT/2**(NUM_LEVELS/2)):0] [INTPRIORITY_BITS-1:0] l2_intpend_w_prior_en_ff;\n', '        logic [(TOTAL_INT/2**(NUM_LEVELS/2)):0] [ID_BITS-1:0]          l2_intpend_id_ff;\n', '\n', ""        assign levelx_intpend_w_prior_en[NUM_LEVELS/2][(TOTAL_INT/2**(NUM_LEVELS/2))+1:0] = {{1*INTPRIORITY_BITS{1'b0}},l2_intpend_w_prior_en_ff[(TOTAL_INT/2**(NUM_LEVELS/2)):0]} ;\n"", ""        assign levelx_intpend_id[NUM_LEVELS/2][(TOTAL_INT/2**(NUM_LEVELS/2))+1:0]         = {{1*ID_BITS{1'b1}},l2_intpend_id_ff[(TOTAL_INT/2**(NUM_LEVELS/2)):0]} ;\n"", '\n', '/////////  Do the prioritization of the interrupts here  ////////////\n', '       for (l=0; l<NUM_LEVELS/2 ; l++) begin : TOP_LEVEL\n', '          for (m=0; m<=(TOTAL_INT)/(2**(l+1)) ; m++) begin : COMPARE\n', '             if ( m == (TOTAL_INT)/(2**(l+1))) begin\n', ""                  assign level_intpend_w_prior_en[l+1][m+1] = '0 ;\n"", ""                  assign level_intpend_id[l+1][m+1]         = '0 ;\n"", '             end\n', '             cmp_and_mux  #(.ID_BITS(ID_BITS),\n', '                            .INTPRIORITY_BITS(INTPRIORITY_BITS)) cmp_l1 (\n', '                            .a_id(level_intpend_id[l][2*m]),\n', '                            .a_priority(level_intpend_w_prior_en[l][2*m]),\n', '                            .b_id(level_intpend_id[l][2*m+1]),\n', '                            .b_priority(level_intpend_w_prior_en[l][2*m+1]),\n', '                            .out_id(level_intpend_id[l+1][m]),\n', '                            .out_priority(level_intpend_w_prior_en[l+1][m])) ;\n', '\n', '          end\n', '       end\n', '\n', '              for (i=0; i<=TOTAL_INT/2**(NUM_LEVELS/2) ; i++) begin : MIDDLE_FLOPS\n', '                rvdff #(INTPRIORITY_BITS) level2_intpend_prior_reg  (.*, .din (level_intpend_w_prior_en[NUM_LEVELS/2][i]), .dout(l2_intpend_w_prior_en_ff[i]),  .clk(free_clk));\n', '                rvdff #(ID_BITS)          level2_intpend_id_reg     (.*, .din (level_intpend_id[NUM_LEVELS/2][i]),         .dout(l2_intpend_id_ff[i]),          .clk(free_clk));\n', '              end\n', '\n', '       for (j=NUM_LEVELS/2; j<NUM_LEVELS ; j++) begin : BOT_LEVELS\n', '          for (k=0; k<=(TOTAL_INT)/(2**(j+1)) ; k++) begin : COMPARE\n', '             if ( k == (TOTAL_INT)/(2**(j+1))) begin\n', ""                  assign levelx_intpend_w_prior_en[j+1][k+1] = '0 ;\n"", ""                  assign levelx_intpend_id[j+1][k+1]         = '0 ;\n"", '             end\n', '                  cmp_and_mux  #(.ID_BITS(ID_BITS),\n', '                              .INTPRIORITY_BITS(INTPRIORITY_BITS))\n', '                       cmp_l1 (\n', '                              .a_id(levelx_intpend_id[j][2*k]),\n', '                              .a_priority(levelx_intpend_w_prior_en[j][2*k]),\n', '                              .b_id(levelx_intpend_id[j][2*k+1]),\n', '                              .b_priority(levelx_intpend_w_prior_en[j][2*k+1]),\n', '                              .out_id(levelx_intpend_id[j+1][k]),\n', '                              .out_priority(levelx_intpend_w_prior_en[j+1][k])) ;\n', '          end\n', '        end\n', '              assign claimid_in[ID_BITS-1:0]                      =      levelx_intpend_id[NUM_LEVELS][0] ;   // This is the last level output\n', '              assign selected_int_priority[INTPRIORITY_BITS-1:0]  =      levelx_intpend_w_prior_en[NUM_LEVELS][0] ;\n', '\n', '`else\n', '        logic [NUM_LEVELS:0] [TOTAL_INT+1:0] [INTPRIORITY_BITS-1:0] level_intpend_w_prior_en;\n', '        logic [NUM_LEVELS:0] [TOTAL_INT+1:0] [ID_BITS-1:0]          level_intpend_id;\n', '\n', ""        assign level_intpend_w_prior_en[0][TOTAL_INT+1:0] = {{2*INTPRIORITY_BITS{1'b0}},intpend_w_prior_en[TOTAL_INT-1:0]} ;\n"", ""        assign level_intpend_id[0][TOTAL_INT+1:0] = {{2*ID_BITS{1'b1}},intpend_id[TOTAL_INT-1:0]} ;\n"", '\n', '//////////  Do the prioritization of the interrupts here  ////////////\n', '///////// genvar l, m , j, k;  already declared outside ifdef\n', '        for (l=0; l<NUM_LEVELS ; l++) begin : LEVEL\n', '           for (m=0; m<=(TOTAL_INT)/(2**(l+1)) ; m++) begin : COMPARE\n', '              if ( m == (TOTAL_INT)/(2**(l+1))) begin\n', ""                   assign level_intpend_w_prior_en[l+1][m+1] = '0 ;\n"", ""                   assign level_intpend_id[l+1][m+1]         = '0 ;\n"", '              end\n', '              cmp_and_mux  #(.ID_BITS(ID_BITS),\n', '                             .INTPRIORITY_BITS(INTPRIORITY_BITS)) cmp_l1 (\n', '                             .a_id(level_intpend_id[l][2*m]),\n', '                             .a_priority(level_intpend_w_prior_en[l][2*m]),\n', '                             .b_id(level_intpend_id[l][2*m+1]),\n', '                             .b_priority(level_intpend_w_prior_en[l][2*m+1]),\n', '                             .out_id(level_intpend_id[l+1][m]),\n', '                             .out_priority(level_intpend_w_prior_en[l+1][m])) ;\n', '\n', '           end\n', '        end\n', '               assign claimid_in[ID_BITS-1:0]                      =      level_intpend_id[NUM_LEVELS][0] ;   // This is the last level output\n', '               assign selected_int_priority[INTPRIORITY_BITS-1:0]  =      level_intpend_w_prior_en[NUM_LEVELS][0] ;\n', '\n', '`endif\n', '\n', '\n', '///////////////////////////////////////////////////////////////////////\n', '// Config Reg`\n', '///////////////////////////////////////////////////////////////////////\n', 'assign config_reg_we               =  addr_config_pic_match & picm_wren_ff;\n', 'assign config_reg_re               =  addr_config_pic_match & picm_rden_ff;\n', '\n', 'assign config_reg_in  =  picm_wr_data_ff[0] ;   //\n', 'rvdffs #(1) config_reg_ff  (.*, .clk(free_clk), .en(config_reg_we), .din (config_reg_in), .dout(config_reg));\n', '\n', 'assign intpriord  = config_reg ;\n', '\n', '\n', '///////////////////////////////////////////////////////////////////////\n', '// Thresh-hold Reg`\n', '///////////////////////////////////////////////////////////////////////\n', '//assign prithresh_reg_write              =  addr_prithresh_match & picm_wren_ff;\n', '//assign prithresh_reg_read               =  addr_prithresh_match & picm_rden_ff;\n', '//\n', '//assign prithresh_reg_in[INTPRIORITY_BITS-1:0]  =  picm_wr_data_ff[INTPRIORITY_BITS-1:0] ;   // Thresh-hold priority.\n', '//rvdffs #(INTPRIORITY_BITS) prithresh_reg_ff  (.*, .en(prithresh_reg_write), .din (prithresh_reg_in[INTPRIORITY_BITS-1:0]), .dout(prithresh_reg[INTPRIORITY_BITS-1:0]));\n', '//\n', '\n', '//////////////////////////////////////////////////////////////////////////\n', '// Send the interrupt to the core if it is above the thresh-hold\n', '//////////////////////////////////////////////////////////////////////////\n', '///////////////////////////////////////////////////////////\n', '/// ClaimId  Reg and Corresponding PL\n', '///////////////////////////////////////////////////////////\n', '// logic   atleast_one_int_enabled_in,atleast_one_int_enabled ;\n', '// logic   mexintpend_unq ;\n', '// logic   mhwakeup_unq ;\n', '//\n', 'assign pl_in_q[INTPRIORITY_BITS-1:0] = intpriord ? ~pl_in : pl_in ;\n', 'rvdff #(ID_BITS)          claimid_ff (.*,  .din (claimid_in[ID_BITS-1:00]),    .dout(claimid[ID_BITS-1:00]),         .clk(free_clk));\n', 'rvdff  #(INTPRIORITY_BITS) pl_ff      (.*, .din (pl_in_q[INTPRIORITY_BITS-1:0]), .dout(pl[INTPRIORITY_BITS-1:0]),         .clk(free_clk));\n', '\n', 'logic [INTPRIORITY_BITS-1:0] meipt_inv , meicurpl_inv ;\n', 'assign meipt_inv[INTPRIORITY_BITS-1:0]    = intpriord ? ~meipt[INTPRIORITY_BITS-1:0]    : meipt[INTPRIORITY_BITS-1:0] ;\n', 'assign meicurpl_inv[INTPRIORITY_BITS-1:0] = intpriord ? ~meicurpl[INTPRIORITY_BITS-1:0] : meicurpl[INTPRIORITY_BITS-1:0] ;\n', 'assign mexintpend_in = (( selected_int_priority[INTPRIORITY_BITS-1:0] > meipt_inv[INTPRIORITY_BITS-1:0]) &\n', '                        ( selected_int_priority[INTPRIORITY_BITS-1:0] > meicurpl_inv[INTPRIORITY_BITS-1:0]) );\n', 'rvdff #(1) mexintpend_ff  (.*, .clk(free_clk), .din (mexintpend_in), .dout(mexintpend));\n', '\n', 'assign maxint[INTPRIORITY_BITS-1:0]      =  intpriord ? 0 : 15 ;\n', 'assign mhwakeup_in = ( pl_in_q[INTPRIORITY_BITS-1:0] == maxint) ;\n', 'rvdff #(1) wake_up_ff  (.*, .clk(free_clk), .din (mhwakeup_in), .dout(mhwakeup));\n', '\n', '\n', '// assign atleast_one_int_enabled_in      =  |intenable_reg[TOTAL_INT-1:0] ;\n', '// rvdff #(1) one_int_en_ff  (.*, .din (atleast_one_int_enabled_in), .dout(atleast_one_int_enabled));\n', '//\n', '// assign mexintpend  = mexintpend_unq & atleast_one_int_enabled ;\n', '// assign mhwakeup    = mhwakeup_unq   & atleast_one_int_enabled ;\n', '\n', '\n', '\n', '//////////////////////////////////////////////////////////////////////////\n', '//  Reads of register.\n', '//  1- intpending\n', '//////////////////////////////////////////////////////////////////////////\n', '\n', 'assign intpend_reg_read     =  addr_intpend_base_match     & picm_rden_ff ;\n', 'assign intpriority_reg_read =  addr_intpriority_base_match & picm_rden_ff;\n', 'assign intenable_reg_read   =  addr_intenable_base_match   & picm_rden_ff;\n', 'assign gw_config_reg_read   =  addr_config_gw_base_match   & picm_rden_ff;\n', '\n', ""assign intpend_reg_extended[INTPEND_SIZE-1:0]  = {{INTPEND_SIZE-TOTAL_INT{1'b0}},extintsrc_req_gw[TOTAL_INT-1:0]} ;\n"", '\n', '   for (i=0; i<(INT_GRPS); i++) begin\n', '            assign intpend_rd_part_out[i] =  (({32{intpend_reg_read & picm_addr_ff[5:2] == i}}) & intpend_reg_extended[((32*i)+31):(32*i)]) ;\n', '   end\n', '\n', '   always_comb begin : INTPEND_RD\n', ""         intpend_rd_out =  '0 ;\n"", '         for (int i=0; i<INT_GRPS; i++) begin\n', '               intpend_rd_out |=  intpend_rd_part_out[i] ;\n', '         end\n', '   end\n', '\n', '   always_comb begin : INTEN_RD\n', ""         intenable_rd_out =  '0 ;\n"", ""         intpriority_rd_out =  '0 ;\n"", ""         gw_config_rd_out =  '0 ;\n"", '         for (int i=0; i<TOTAL_INT; i++) begin\n', '              if (intenable_reg_re[i]) begin\n', '               intenable_rd_out    =  intenable_reg[i]  ;\n', '              end\n', '              if (intpriority_reg_re[i]) begin\n', '               intpriority_rd_out  =  intpriority_reg[i] ;\n', '              end\n', '              if (gw_config_reg_re[i]) begin\n', '               gw_config_rd_out  =  gw_config_reg[i] ;\n', '              end\n', '         end\n', '   end\n', '\n', '\n', ' assign picm_rd_data_in[31:0] = ({32{intpend_reg_read      }} &   intpend_rd_out                                                    ) |\n', ""                                ({32{intpriority_reg_read  }} &  {{32-INTPRIORITY_BITS{1'b0}}, intpriority_rd_out                 } ) |\n"", ""                                ({32{intenable_reg_read    }} &  {31'b0 , intenable_rd_out                                        } ) |\n"", ""                                ({32{gw_config_reg_read    }} &  {30'b0 , gw_config_rd_out                                        } ) |\n"", ""                                ({32{config_reg_re         }} &  {31'b0 , config_reg                                              } ) |\n"", ""                                ({32{picm_mken_ff & mask[3]}} &  {30'b0 , 2'b11                                                   } ) |\n"", ""                                ({32{picm_mken_ff & mask[2]}} &  {31'b0 , 1'b1                                                    } ) |\n"", ""                                ({32{picm_mken_ff & mask[1]}} &  {28'b0 , 4'b1111                                                 } ) |\n"", ""                                ({32{picm_mken_ff & mask[0]}} &   32'b0                                                             ) ;\n"", '\n', '\n', 'assign picm_rd_data[31:0] = picm_rd_data_in[31:0] ;\n', '\n', 'logic [14:0] address;\n', '\n', 'assign address[14:0] = picm_addr_ff[14:0];\n', '\n', '`include ""pic_map_auto.h""\n', '\n', 'endmodule\n', '\n', '\n', 'module cmp_and_mux #(parameter ID_BITS=8,\n', '                               INTPRIORITY_BITS = 4)\n', '                    (\n', '                        input  logic [ID_BITS-1:0]       a_id,\n', '                        input  logic [INTPRIORITY_BITS-1:0] a_priority,\n', '\n', '                        input  logic [ID_BITS-1:0]       b_id,\n', '                        input  logic [INTPRIORITY_BITS-1:0] b_priority,\n', '\n', '                        output logic [ID_BITS-1:0]       out_id,\n', '                        output logic [INTPRIORITY_BITS-1:0] out_priority\n', '\n', '                    );\n', '\n', 'logic   a_is_lt_b ;\n', '\n', 'assign  a_is_lt_b  = ( a_priority[INTPRIORITY_BITS-1:0] < b_priority[INTPRIORITY_BITS-1:0] ) ;\n', '// assign  a_is_eq_b  = ( a_priority[INTPRIORITY_BITS-1:0] == b_priority[INTPRIORITY_BITS-1:0]) ;\n', '\n', 'assign  out_id[ID_BITS-1:0]                = a_is_lt_b ? b_id[ID_BITS-1:0] :\n', '                                                         a_id[ID_BITS-1:0] ;\n', 'assign  out_priority[INTPRIORITY_BITS-1:0] = a_is_lt_b ? b_priority[INTPRIORITY_BITS-1:0] :\n', '                                                         a_priority[INTPRIORITY_BITS-1:0] ;\n', 'endmodule // cmp_and_mux\n', '\n', '\n', 'module configurable_gw (\n', '                             input logic gw_clk,\n', '                             input logic rst_l,\n', '\n', '                             input logic extintsrc_req_sync ,\n', '                             input logic meigwctrl_polarity ,\n', '                             input logic meigwctrl_type ,\n', '                             input logic meigwclr ,\n', '\n', '                             output logic extintsrc_req_config\n', '                            );\n', '\n', '\n', '  logic  gw_int_pending_in , gw_int_pending ;\n', '\n', '  assign gw_int_pending_in =  (extintsrc_req_sync ^ meigwctrl_polarity) | (gw_int_pending & ~meigwclr) ;\n', '  rvdff #(1) int_pend_ff        (.*, .clk(gw_clk), .din (gw_int_pending_in),     .dout(gw_int_pending));\n', '\n', '  assign extintsrc_req_config =  meigwctrl_type ? ((extintsrc_req_sync ^  meigwctrl_polarity) | gw_int_pending) : (extintsrc_req_sync ^  meigwctrl_polarity) ;\n', '\n', 'endmodule // configurable_gw\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n']"
"['// SPDX-License-Identifier: Apache-2.0\n', ""// Copyright 2019 Western Digital Corporation or it's affiliates.\n"", '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License\n', '\n', 'module rvjtag_tap #(\n', 'parameter AWIDTH = 7\n', ')\n', '(\n', 'input               trst,\n', 'input               tck,\n', 'input               tms,\n', 'input               tdi,\n', 'output   reg        tdo,\n', 'output              tdoEnable,\n', '\n', 'output [31:0]       wr_data,\n', 'output [AWIDTH-1:0] wr_addr,\n', 'output              wr_en,\n', 'output              rd_en,\n', '\n', 'input   [31:0]      rd_data,\n', 'input   [1:0]       rd_status,\n', '\n', 'output  reg         dmi_reset,\n', 'output  reg         dmi_hard_reset,\n', '\n', 'input   [2:0]       idle,\n', 'input   [1:0]       dmi_stat,\n', '/*\n', ""--  revisionCode        : 4'h0;\n"", ""--  manufacturersIdCode : 11'h45;\n"", ""--  deviceIdCode        : 16'h0001;\n"", ""--  order MSB .. LSB -> [4 bit version or revision] [16 bit part number] [11 bit manufacturer id] [value of 1'b1 in LSB]\n"", '*/\n', 'input   [31:1]      jtag_id,\n', 'input   [3:0]       version\n', ');\n', '\n', 'localparam USER_DR_LENGTH = AWIDTH + 34;\n', '\n', '\n', 'reg [USER_DR_LENGTH-1:0] sr, nsr, dr;\n', '\n', '///////////////////////////////////////////////////////\n', '//                      Tap controller\n', '///////////////////////////////////////////////////////\n', 'logic[3:0] state, nstate;\n', 'logic [4:0] ir;\n', 'wire jtag_reset;\n', 'wire shift_dr;\n', 'wire pause_dr;\n', 'wire update_dr;\n', 'wire capture_dr;\n', 'wire shift_ir;\n', 'wire pause_ir ;\n', 'wire update_ir ;\n', 'wire capture_ir;\n', 'wire[1:0] dr_en;\n', 'wire devid_sel;\n', 'wire [5:0] abits;\n', '\n', 'assign abits = AWIDTH[5:0];\n', '\n', '\n', 'localparam TEST_LOGIC_RESET_STATE = 0;\n', 'localparam RUN_TEST_IDLE_STATE    = 1;\n', 'localparam SELECT_DR_SCAN_STATE   = 2;\n', 'localparam CAPTURE_DR_STATE       = 3;\n', 'localparam SHIFT_DR_STATE         = 4;\n', 'localparam EXIT1_DR_STATE         = 5;\n', 'localparam PAUSE_DR_STATE         = 6;\n', 'localparam EXIT2_DR_STATE         = 7;\n', 'localparam UPDATE_DR_STATE        = 8;\n', 'localparam SELECT_IR_SCAN_STATE   = 9;\n', 'localparam CAPTURE_IR_STATE       = 10;\n', 'localparam SHIFT_IR_STATE         = 11;\n', 'localparam EXIT1_IR_STATE         = 12;\n', 'localparam PAUSE_IR_STATE         = 13;\n', 'localparam EXIT2_IR_STATE         = 14;\n', 'localparam UPDATE_IR_STATE        = 15;\n', '\n', 'always_comb  begin\n', '    nstate = state;\n', '    case(state)\n', '    TEST_LOGIC_RESET_STATE: nstate = tms ? TEST_LOGIC_RESET_STATE : RUN_TEST_IDLE_STATE;\n', '    RUN_TEST_IDLE_STATE:    nstate = tms ? SELECT_DR_SCAN_STATE   : RUN_TEST_IDLE_STATE;\n', '    SELECT_DR_SCAN_STATE:   nstate = tms ? SELECT_IR_SCAN_STATE   : CAPTURE_DR_STATE;\n', '    CAPTURE_DR_STATE:       nstate = tms ? EXIT1_DR_STATE         : SHIFT_DR_STATE;\n', '    SHIFT_DR_STATE:         nstate = tms ? EXIT1_DR_STATE         : SHIFT_DR_STATE;\n', '    EXIT1_DR_STATE:         nstate = tms ? UPDATE_DR_STATE        : PAUSE_DR_STATE;\n', '    PAUSE_DR_STATE:         nstate = tms ? EXIT2_DR_STATE         : PAUSE_DR_STATE;\n', '    EXIT2_DR_STATE:         nstate = tms ? UPDATE_DR_STATE        : SHIFT_DR_STATE;\n', '    UPDATE_DR_STATE:        nstate = tms ? SELECT_DR_SCAN_STATE   : RUN_TEST_IDLE_STATE;\n', '    SELECT_IR_SCAN_STATE:   nstate = tms ? TEST_LOGIC_RESET_STATE : CAPTURE_IR_STATE;\n', '    CAPTURE_IR_STATE:       nstate = tms ? EXIT1_IR_STATE         : SHIFT_IR_STATE;\n', '    SHIFT_IR_STATE:         nstate = tms ? EXIT1_IR_STATE         : SHIFT_IR_STATE;\n', '    EXIT1_IR_STATE:         nstate = tms ? UPDATE_IR_STATE        : PAUSE_IR_STATE;\n', '    PAUSE_IR_STATE:         nstate = tms ? EXIT2_IR_STATE         : PAUSE_IR_STATE;\n', '    EXIT2_IR_STATE:         nstate = tms ? UPDATE_IR_STATE        : SHIFT_IR_STATE;\n', '    UPDATE_IR_STATE:        nstate = tms ? SELECT_DR_SCAN_STATE   : RUN_TEST_IDLE_STATE;\n', '    default:                nstate = TEST_LOGIC_RESET_STATE;\n', '    endcase\n', 'end\n', '\n', 'always @ (posedge tck or negedge trst) begin\n', '    if(!trst) state <= TEST_LOGIC_RESET_STATE;\n', '    else state <= nstate;\n', 'end\n', '\n', 'assign jtag_reset = state == TEST_LOGIC_RESET_STATE;\n', 'assign shift_dr   = state == SHIFT_DR_STATE;\n', 'assign pause_dr   = state == PAUSE_DR_STATE;\n', 'assign update_dr  = state == UPDATE_DR_STATE;\n', 'assign capture_dr = state == CAPTURE_DR_STATE;\n', 'assign shift_ir   = state == SHIFT_IR_STATE;\n', 'assign pause_ir   = state == PAUSE_IR_STATE;\n', 'assign update_ir  = state == UPDATE_IR_STATE;\n', 'assign capture_ir = state == CAPTURE_IR_STATE;\n', '\n', 'assign tdoEnable = shift_dr | shift_ir;\n', '\n', '///////////////////////////////////////////////////////\n', '//                      IR register\n', '///////////////////////////////////////////////////////\n', '\n', 'always @ (negedge tck or negedge trst) begin\n', ""   if (!trst) ir <= 5'b1;\n"", '   else begin\n', ""      if (jtag_reset) ir <= 5'b1;\n"", ""      else if (update_ir) ir <= (sr[4:0] == '0) ? 5'h1f :sr[4:0];\n"", '   end\n', 'end\n', '\n', '\n', ""assign devid_sel  = ir == 5'b00001;\n"", ""assign dr_en[0]   = ir == 5'b10000;\n"", ""assign dr_en[1]   = ir == 5'b10001;\n"", '\n', '///////////////////////////////////////////////////////\n', '//                      Shift register\n', '///////////////////////////////////////////////////////\n', 'always @ (posedge tck or negedge trst) begin\n', '    if(!trst)begin\n', ""        sr <= '0;\n"", '    end\n', '    else begin\n', '        sr <= nsr;\n', '    end\n', 'end\n', '\n', '// SR next value\n', 'always_comb begin\n', '    nsr = sr;\n', '    case(1)\n', '    shift_dr:   begin\n', '                    case(1)\n', '                    dr_en[1]:   nsr = {tdi, sr[USER_DR_LENGTH-1:1]};\n', '\n', '                    dr_en[0],\n', ""                    devid_sel:  nsr = {{USER_DR_LENGTH-32{1'b0}},tdi, sr[31:1]};\n"", ""                    default:    nsr = {{USER_DR_LENGTH-1{1'b0}},tdi}; // bypass\n"", '                    endcase\n', '                end\n', '    capture_dr: begin\n', ""                    nsr[0] = 1'b0;\n"", '                    case(1)\n', ""                    dr_en[0]:   nsr = {{USER_DR_LENGTH-15{1'b0}}, idle, dmi_stat, abits, version};\n"", ""                    dr_en[1]:   nsr = {{AWIDTH{1'b0}}, rd_data, rd_status};\n"", ""                    devid_sel:  nsr = {{USER_DR_LENGTH-32{1'b0}}, jtag_id, 1'b1};\n"", '                    endcase\n', '                end\n', ""    shift_ir:   nsr = {{USER_DR_LENGTH-5{1'b0}},tdi, sr[4:1]};\n"", ""    capture_ir: nsr = {{USER_DR_LENGTH-1{1'b0}},1'b1};\n"", '    endcase\n', 'end\n', '\n', '// TDO retiming\n', 'always @ (negedge tck ) tdo <= sr[0];\n', '\n', '// DMI CS register\n', 'always @ (posedge tck or negedge trst) begin\n', '    if(!trst) begin\n', ""        dmi_hard_reset <= 1'b0;\n"", ""        dmi_reset      <= 1'b0;\n"", '    end\n', '    else if (update_dr & dr_en[0]) begin\n', '        dmi_hard_reset <= sr[17];\n', '        dmi_reset      <= sr[16];\n', '    end\n', '    else begin\n', ""        dmi_hard_reset <= 1'b0;\n"", ""        dmi_reset      <= 1'b0;\n"", '    end\n', 'end\n', '\n', '// DR register\n', 'always @ (posedge tck or negedge trst) begin\n', '    if(!trst)\n', ""        dr <=  '0;\n"", '    else begin\n', '        if (update_dr & dr_en[1])\n', '            dr <= sr;\n', '        else\n', ""            dr <= {dr[USER_DR_LENGTH-1:2],2'b0};\n"", '    end\n', 'end\n', '\n', 'assign {wr_addr, wr_data, wr_en, rd_en} = dr;\n', '\n', '\n', '\n', '\n', 'endmodule\n']"
"['// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '\n', '//********************************************************************************\n', '// $Id$\n', '//\n', '// Function: Top level VEER core file\n', '// Comments:\n', '//\n', '//********************************************************************************\n', 'module veer\n', '   import veer_types::*;\n', '(\n', '   input logic                  clk,\n', '   input logic                  rst_l,\n', '   input logic                  dbg_rst_l,\n', '   input logic [31:1]           rst_vec,\n', '   input logic                  nmi_int,\n', '   input logic [31:1]           nmi_vec,\n', '   output logic                 core_rst_l,   // This is ""rst_l | dbg_rst_l""\n', '\n', '   output logic [63:0] trace_rv_i_insn_ip,\n', '   output logic [63:0] trace_rv_i_address_ip,\n', '   output logic [2:0]  trace_rv_i_valid_ip,\n', '   output logic [2:0]  trace_rv_i_exception_ip,\n', '   output logic [4:0]  trace_rv_i_ecause_ip,\n', '   output logic [2:0]  trace_rv_i_interrupt_ip,\n', '   output logic [31:0] trace_rv_i_tval_ip,\n', '\n', '\n', '   output logic                 lsu_freeze_dc3,\n', '   output logic                 dccm_clk_override,\n', '   output logic                 icm_clk_override,\n', '   output logic                 dec_tlu_core_ecc_disable,\n', '\n', '   // external halt/run interface\n', '   input logic  i_cpu_halt_req,    // Asynchronous Halt request to CPU\n', '   input logic  i_cpu_run_req,     // Asynchronous Restart request to CPU\n', '   output logic o_cpu_halt_ack,    // Core Acknowledge to Halt request\n', ""   output logic o_cpu_halt_status, // 1'b1 indicates processor is halted\n"", '   output logic o_cpu_run_ack,     // Core Acknowledge to run request\n', '   output logic o_debug_mode_status, // Core to the PMU that core is in debug mode. When core is in debug mode, the PMU should refrain from sendng a halt or run request\n', '\n', '   // external MPC halt/run interface\n', '   input logic mpc_debug_halt_req, // Async halt request\n', '   input logic mpc_debug_run_req, // Async run request\n', '   input logic mpc_reset_run_req, // Run/halt after reset\n', '   output logic mpc_debug_halt_ack, // Halt ack\n', '   output logic mpc_debug_run_ack, // Run ack\n', '   output logic debug_brkpt_status, // debug breakpoint\n', '\n', '   output logic [1:0] dec_tlu_perfcnt0, // toggles when perf counter 0 has an event inc\n', '   output logic [1:0] dec_tlu_perfcnt1,\n', '   output logic [1:0] dec_tlu_perfcnt2,\n', '   output logic [1:0] dec_tlu_perfcnt3,\n', '\n', '   // DCCM ports\n', '   output logic                          dccm_wren,\n', '   output logic                          dccm_rden,\n', '   output logic [`RV_DCCM_BITS-1:0]          dccm_wr_addr,\n', '   output logic [`RV_DCCM_BITS-1:0]          dccm_rd_addr_lo,\n', '   output logic [`RV_DCCM_BITS-1:0]          dccm_rd_addr_hi,\n', '   output logic [`RV_DCCM_FDATA_WIDTH-1:0]   dccm_wr_data,\n', '\n', '   input logic [`RV_DCCM_FDATA_WIDTH-1:0]    dccm_rd_data_lo,\n', '   input logic [`RV_DCCM_FDATA_WIDTH-1:0]    dccm_rd_data_hi,\n', '\n', '`ifdef RV_ICCM_ENABLE\n', '   // ICCM ports\n', '   output logic [`RV_ICCM_BITS-1:2]           iccm_rw_addr,\n', '   output logic                  iccm_wren,\n', '   output logic                  iccm_rden,\n', '   output logic [2:0]            iccm_wr_size,\n', '   output logic [77:0]           iccm_wr_data,\n', '\n', '   input  logic [155:0]          iccm_rd_data,\n', '`endif\n', '\n', '   // ICache , ITAG  ports\n', '   output logic [31:2]           ic_rw_addr,\n', '   output logic [3:0]            ic_tag_valid,\n', '   output logic [3:0]            ic_wr_en,\n', '   output logic                  ic_rd_en,\n', '\n', '`ifdef RV_ICACHE_ECC\n', '   output logic [83:0]               ic_wr_data,         // Data to fill to the Icache. With ECC\n', '   input  logic [167:0]              ic_rd_data ,        // Data read from Icache. 2x64bits + parity bits. F2 stage. With ECC\n', '   input  logic [24:0]               ictag_debug_rd_data,// Debug icache tag.\n', '   output logic [41:0]               ic_debug_wr_data,   // Debug wr cache.\n', '`else\n', '   output logic [67:0]               ic_wr_data,         // Data to fill to the Icache. With Parity\n', '   input  logic [135:0]              ic_rd_data ,        // Data read from Icache. 2x64bits + parity bits. F2 stage. With Parity\n', '   input  logic [20:0]               ictag_debug_rd_data,// Debug icache tag.\n', '   output logic [33:0]               ic_debug_wr_data,   // Debug wr cache.\n', '`endif\n', '\n', '   output logic [127:0]              ic_premux_data,     // Premux data to be muxed with each way of the Icache.\n', '   output logic                      ic_sel_premux_data, // Select premux data\n', '\n', '\n', '   output logic [15:2]               ic_debug_addr,      // Read/Write addresss to the Icache.\n', '   output logic                      ic_debug_rd_en,     // Icache debug rd\n', '   output logic                      ic_debug_wr_en,     // Icache debug wr\n', '   output logic                      ic_debug_tag_array, // Debug tag array\n', '   output logic [3:0]                ic_debug_way,       // Debug way. Rd or Wr.\n', '\n', '\n', '\n', '   input  logic [3:0]            ic_rd_hit,\n', '   input  logic                  ic_tag_perr,        // Icache Tag parity error\n', '\n', '`ifdef RV_BUILD_AXI4\n', '   //-------------------------- LSU AXI signals--------------------------\n', '   // AXI Write Channels\n', '   output logic                            lsu_axi_awvalid,\n', '   input  logic                            lsu_axi_awready,\n', '   output logic [`RV_LSU_BUS_TAG-1:0]      lsu_axi_awid,\n', '   output logic [31:0]                     lsu_axi_awaddr,\n', '   output logic [3:0]                      lsu_axi_awregion,\n', '   output logic [7:0]                      lsu_axi_awlen,\n', '   output logic [2:0]                      lsu_axi_awsize,\n', '   output logic [1:0]                      lsu_axi_awburst,\n', '   output logic                            lsu_axi_awlock,\n', '   output logic [3:0]                      lsu_axi_awcache,\n', '   output logic [2:0]                      lsu_axi_awprot,\n', '   output logic [3:0]                      lsu_axi_awqos,\n', '\n', '   output logic                            lsu_axi_wvalid,\n', '   input  logic                            lsu_axi_wready,\n', '   output logic [63:0]                     lsu_axi_wdata,\n', '   output logic [7:0]                      lsu_axi_wstrb,\n', '   output logic                            lsu_axi_wlast,\n', '\n', '   input  logic                            lsu_axi_bvalid,\n', '   output logic                            lsu_axi_bready,\n', '   input  logic [1:0]                      lsu_axi_bresp,\n', '   input  logic [`RV_LSU_BUS_TAG-1:0]      lsu_axi_bid,\n', '\n', '   // AXI Read Channels\n', '   output logic                            lsu_axi_arvalid,\n', '   input  logic                            lsu_axi_arready,\n', '   output logic [`RV_LSU_BUS_TAG-1:0]      lsu_axi_arid,\n', '   output logic [31:0]                     lsu_axi_araddr,\n', '   output logic [3:0]                      lsu_axi_arregion,\n', '   output logic [7:0]                      lsu_axi_arlen,\n', '   output logic [2:0]                      lsu_axi_arsize,\n', '   output logic [1:0]                      lsu_axi_arburst,\n', '   output logic                            lsu_axi_arlock,\n', '   output logic [3:0]                      lsu_axi_arcache,\n', '   output logic [2:0]                      lsu_axi_arprot,\n', '   output logic [3:0]                      lsu_axi_arqos,\n', '\n', '   input  logic                            lsu_axi_rvalid,\n', '   output logic                            lsu_axi_rready,\n', '   input  logic [`RV_LSU_BUS_TAG-1:0]      lsu_axi_rid,\n', '   input  logic [63:0]                     lsu_axi_rdata,\n', '   input  logic [1:0]                      lsu_axi_rresp,\n', '   input  logic                            lsu_axi_rlast,\n', '\n', '   //-------------------------- IFU AXI signals--------------------------\n', '   // AXI Write Channels\n', '   output logic                            ifu_axi_awvalid,\n', '   input  logic                            ifu_axi_awready,\n', '   output logic [`RV_IFU_BUS_TAG-1:0]      ifu_axi_awid,\n', '   output logic [31:0]                     ifu_axi_awaddr,\n', '   output logic [3:0]                      ifu_axi_awregion,\n', '   output logic [7:0]                      ifu_axi_awlen,\n', '   output logic [2:0]                      ifu_axi_awsize,\n', '   output logic [1:0]                      ifu_axi_awburst,\n', '   output logic                            ifu_axi_awlock,\n', '   output logic [3:0]                      ifu_axi_awcache,\n', '   output logic [2:0]                      ifu_axi_awprot,\n', '   output logic [3:0]                      ifu_axi_awqos,\n', '\n', '   output logic                            ifu_axi_wvalid,\n', '   input  logic                            ifu_axi_wready,\n', '   output logic [63:0]                     ifu_axi_wdata,\n', '   output logic [7:0]                      ifu_axi_wstrb,\n', '   output logic                            ifu_axi_wlast,\n', '\n', '   input  logic                            ifu_axi_bvalid,\n', '   output logic                            ifu_axi_bready,\n', '   input  logic [1:0]                      ifu_axi_bresp,\n', '   input  logic [`RV_IFU_BUS_TAG-1:0]      ifu_axi_bid,\n', '\n', '   // AXI Read Channels\n', '   output logic                            ifu_axi_arvalid,\n', '   input  logic                            ifu_axi_arready,\n', '   output logic [`RV_IFU_BUS_TAG-1:0]      ifu_axi_arid,\n', '   output logic [31:0]                     ifu_axi_araddr,\n', '   output logic [3:0]                      ifu_axi_arregion,\n', '   output logic [7:0]                      ifu_axi_arlen,\n', '   output logic [2:0]                      ifu_axi_arsize,\n', '   output logic [1:0]                      ifu_axi_arburst,\n', '   output logic                            ifu_axi_arlock,\n', '   output logic [3:0]                      ifu_axi_arcache,\n', '   output logic [2:0]                      ifu_axi_arprot,\n', '   output logic [3:0]                      ifu_axi_arqos,\n', '\n', '   input  logic                            ifu_axi_rvalid,\n', '   output logic                            ifu_axi_rready,\n', '   input  logic [`RV_IFU_BUS_TAG-1:0]      ifu_axi_rid,\n', '   input  logic [63:0]                     ifu_axi_rdata,\n', '   input  logic [1:0]                      ifu_axi_rresp,\n', '   input  logic                            ifu_axi_rlast,\n', '\n', '   //-------------------------- SB AXI signals--------------------------\n', '   // AXI Write Channels\n', '   output logic                            sb_axi_awvalid,\n', '   input  logic                            sb_axi_awready,\n', '   output logic [`RV_SB_BUS_TAG-1:0]       sb_axi_awid,\n', '   output logic [31:0]                     sb_axi_awaddr,\n', '   output logic [3:0]                      sb_axi_awregion,\n', '   output logic [7:0]                      sb_axi_awlen,\n', '   output logic [2:0]                      sb_axi_awsize,\n', '   output logic [1:0]                      sb_axi_awburst,\n', '   output logic                            sb_axi_awlock,\n', '   output logic [3:0]                      sb_axi_awcache,\n', '   output logic [2:0]                      sb_axi_awprot,\n', '   output logic [3:0]                      sb_axi_awqos,\n', '\n', '   output logic                            sb_axi_wvalid,\n', '   input  logic                            sb_axi_wready,\n', '   output logic [63:0]                     sb_axi_wdata,\n', '   output logic [7:0]                      sb_axi_wstrb,\n', '   output logic                            sb_axi_wlast,\n', '\n', '   input  logic                            sb_axi_bvalid,\n', '   output logic                            sb_axi_bready,\n', '   input  logic [1:0]                      sb_axi_bresp,\n', '   input  logic [`RV_SB_BUS_TAG-1:0]       sb_axi_bid,\n', '\n', '   // AXI Read Channels\n', '   output logic                            sb_axi_arvalid,\n', '   input  logic                            sb_axi_arready,\n', '   output logic [`RV_SB_BUS_TAG-1:0]       sb_axi_arid,\n', '   output logic [31:0]                     sb_axi_araddr,\n', '   output logic [3:0]                      sb_axi_arregion,\n', '   output logic [7:0]                      sb_axi_arlen,\n', '   output logic [2:0]                      sb_axi_arsize,\n', '   output logic [1:0]                      sb_axi_arburst,\n', '   output logic                            sb_axi_arlock,\n', '   output logic [3:0]                      sb_axi_arcache,\n', '   output logic [2:0]                      sb_axi_arprot,\n', '   output logic [3:0]                      sb_axi_arqos,\n', '\n', '   input  logic                            sb_axi_rvalid,\n', '   output logic                            sb_axi_rready,\n', '   input  logic [`RV_SB_BUS_TAG-1:0]       sb_axi_rid,\n', '   input  logic [63:0]                     sb_axi_rdata,\n', '   input  logic [1:0]                      sb_axi_rresp,\n', '   input  logic                            sb_axi_rlast,\n', '\n', '   //-------------------------- DMA AXI signals--------------------------\n', '   // AXI Write Channels\n', '   input  logic                         dma_axi_awvalid,\n', '   output logic                         dma_axi_awready,\n', '   input  logic [`RV_DMA_BUS_TAG-1:0]   dma_axi_awid,\n', '   input  logic [31:0]                  dma_axi_awaddr,\n', '   input  logic [2:0]                   dma_axi_awsize,\n', '   input  logic [2:0]                   dma_axi_awprot,\n', '   input  logic [7:0]                   dma_axi_awlen,\n', '   input  logic [1:0]                   dma_axi_awburst,\n', '\n', '\n', '   input  logic                         dma_axi_wvalid,\n', '   output logic                         dma_axi_wready,\n', '   input  logic [63:0]                  dma_axi_wdata,\n', '   input  logic [7:0]                   dma_axi_wstrb,\n', '   input  logic                         dma_axi_wlast,\n', '\n', '   output logic                         dma_axi_bvalid,\n', '   input  logic                         dma_axi_bready,\n', '   output logic [1:0]                   dma_axi_bresp,\n', '   output logic [`RV_DMA_BUS_TAG-1:0]   dma_axi_bid,\n', '\n', '   // AXI Read Channels\n', '   input  logic                         dma_axi_arvalid,\n', '   output logic                         dma_axi_arready,\n', '   input  logic [`RV_DMA_BUS_TAG-1:0]   dma_axi_arid,\n', '   input  logic [31:0]                  dma_axi_araddr,\n', '   input  logic [2:0]                   dma_axi_arsize,\n', '   input  logic [2:0]                   dma_axi_arprot,\n', '   input  logic [7:0]                   dma_axi_arlen,\n', '   input  logic [1:0]                   dma_axi_arburst,\n', '\n', '   output logic                         dma_axi_rvalid,\n', '   input  logic                         dma_axi_rready,\n', '   output logic [`RV_DMA_BUS_TAG-1:0]   dma_axi_rid,\n', '   output logic [63:0]                  dma_axi_rdata,\n', '   output logic [1:0]                   dma_axi_rresp,\n', '   output logic                         dma_axi_rlast,\n', '\n', '`endif\n', '\n', '`ifdef RV_BUILD_AHB_LITE\n', ' //// AHB LITE BUS\n', '   output logic [31:0]           haddr,\n', '   output logic [2:0]            hburst,\n', '   output logic                  hmastlock,\n', '   output logic [3:0]            hprot,\n', '   output logic [2:0]            hsize,\n', '   output logic [1:0]            htrans,\n', '   output logic                  hwrite,\n', '\n', '   input  logic [63:0]           hrdata,\n', '   input  logic                  hready,\n', '   input  logic                  hresp,\n', '\n', '   // LSU AHB Master\n', '   output logic [31:0]          lsu_haddr,\n', '   output logic [2:0]           lsu_hburst,\n', '   output logic                 lsu_hmastlock,\n', '   output logic [3:0]           lsu_hprot,\n', '   output logic [2:0]           lsu_hsize,\n', '   output logic [1:0]           lsu_htrans,\n', '   output logic                 lsu_hwrite,\n', '   output logic [63:0]          lsu_hwdata,\n', '\n', '   input  logic [63:0]          lsu_hrdata,\n', '   input  logic                 lsu_hready,\n', '   input  logic                 lsu_hresp,\n', '\n', '   //System Bus Debug Master\n', '   output logic [31:0]          sb_haddr,\n', '   output logic [2:0]           sb_hburst,\n', '   output logic                 sb_hmastlock,\n', '   output logic [3:0]           sb_hprot,\n', '   output logic [2:0]           sb_hsize,\n', '   output logic [1:0]           sb_htrans,\n', '   output logic                 sb_hwrite,\n', '   output logic [63:0]          sb_hwdata,\n', '\n', '   input  logic [63:0]          sb_hrdata,\n', '   input  logic                 sb_hready,\n', '   input  logic                 sb_hresp,\n', '\n', '   // DMA Slave\n', '   input logic [31:0]            dma_haddr,\n', '   input logic [2:0]             dma_hburst,\n', '   input logic                   dma_hmastlock,\n', '   input logic [3:0]             dma_hprot,\n', '   input logic [2:0]             dma_hsize,\n', '   input logic [1:0]             dma_htrans,\n', '   input logic                   dma_hwrite,\n', '   input logic [63:0]            dma_hwdata,\n', '   input logic                   dma_hsel,\n', '   input logic                   dma_hreadyin,\n', '\n', '   output  logic [63:0]          dma_hrdata,\n', '   output  logic                 dma_hreadyout,\n', '   output  logic                 dma_hresp,\n', '\n', '`endif //  `ifdef RV_BUILD_AHB_LITE\n', '\n', '   input   logic                 lsu_bus_clk_en,\n', '   input   logic                 ifu_bus_clk_en,\n', '   input   logic                 dbg_bus_clk_en,\n', '   input   logic                 dma_bus_clk_en,\n', '\n', '   //Debug module\n', '   input  logic                  dmi_reg_en,\n', '   input  logic [6:0]            dmi_reg_addr,\n', '   input  logic                  dmi_reg_wr_en,\n', '   input  logic [31:0]           dmi_reg_wdata,\n', '   output logic [31:0]           dmi_reg_rdata,\n', '   input  logic                  dmi_hard_reset,\n', '\n', '   input logic [`RV_PIC_TOTAL_INT:1]           extintsrc_req,\n', '   input logic                   timer_int,\n', '   input logic                   scan_mode\n', ');\n', '\n', '`include ""global.h""\n', '\n', '\n', '\n', '// for the testbench\n', '// `define DATAWIDTH 64\n', '`define ADDRWIDTH 32\n', '\n', '`ifndef RV_BUILD_AXI4\n', '\n', '   // LSU AXI signals\n', '   // AXI Write Channels\n', '   logic                         lsu_axi_awvalid;\n', '   logic                         lsu_axi_awready;\n', '   logic [LSU_BUS_TAG-1:0]       lsu_axi_awid;\n', '   logic [31:0]                  lsu_axi_awaddr;\n', '   logic [3:0]                   lsu_axi_awregion;\n', '   logic [7:0]                   lsu_axi_awlen;\n', '   logic [2:0]                   lsu_axi_awsize;\n', '   logic [1:0]                   lsu_axi_awburst;\n', '   logic                         lsu_axi_awlock;\n', '   logic [3:0]                   lsu_axi_awcache;\n', '   logic [2:0]                   lsu_axi_awprot;\n', '   logic [3:0]                   lsu_axi_awqos;\n', '\n', '   logic                         lsu_axi_wvalid;\n', '   logic                         lsu_axi_wready;\n', '   logic [63:0]                  lsu_axi_wdata;\n', '   logic [7:0]                   lsu_axi_wstrb;\n', '   logic                         lsu_axi_wlast;\n', '\n', '   logic                         lsu_axi_bvalid;\n', '   logic                         lsu_axi_bready;\n', '   logic [1:0]                   lsu_axi_bresp;\n', '   logic [LSU_BUS_TAG-1:0]       lsu_axi_bid;\n', '\n', '   // AXI Read Channels\n', '   logic                         lsu_axi_arvalid;\n', '   logic                         lsu_axi_arready;\n', '   logic [LSU_BUS_TAG-1:0]       lsu_axi_arid;\n', '   logic [31:0]                  lsu_axi_araddr;\n', '   logic [3:0]                   lsu_axi_arregion;\n', '   logic [7:0]                   lsu_axi_arlen;\n', '   logic [2:0]                   lsu_axi_arsize;\n', '   logic [1:0]                   lsu_axi_arburst;\n', '   logic                         lsu_axi_arlock;\n', '   logic [3:0]                   lsu_axi_arcache;\n', '   logic [2:0]                   lsu_axi_arprot;\n', '   logic [3:0]                   lsu_axi_arqos;\n', '\n', '   logic                         lsu_axi_rvalid;\n', '   logic                         lsu_axi_rready;\n', '   logic [LSU_BUS_TAG-1:0]       lsu_axi_rid;\n', '   logic [63:0]                  lsu_axi_rdata;\n', '   logic [1:0]                   lsu_axi_rresp;\n', '   logic                         lsu_axi_rlast;\n', '\n', '   // IFU AXI signals\n', '   // AXI Write Channels\n', '   logic                         ifu_axi_awvalid;\n', '   logic                         ifu_axi_awready;\n', '   logic [IFU_BUS_TAG-1:0]       ifu_axi_awid;\n', '   logic [31:0]                  ifu_axi_awaddr;\n', '   logic [3:0]                   ifu_axi_awregion;\n', '   logic [7:0]                   ifu_axi_awlen;\n', '   logic [2:0]                   ifu_axi_awsize;\n', '   logic [1:0]                   ifu_axi_awburst;\n', '   logic                         ifu_axi_awlock;\n', '   logic [3:0]                   ifu_axi_awcache;\n', '   logic [2:0]                   ifu_axi_awprot;\n', '   logic [3:0]                   ifu_axi_awqos;\n', '\n', '   logic                         ifu_axi_wvalid;\n', '   logic                         ifu_axi_wready;\n', '   logic [63:0]                  ifu_axi_wdata;\n', '   logic [7:0]                   ifu_axi_wstrb;\n', '   logic                         ifu_axi_wlast;\n', '\n', '   logic                         ifu_axi_bvalid;\n', '   logic                         ifu_axi_bready;\n', '   logic [1:0]                   ifu_axi_bresp;\n', '   logic [IFU_BUS_TAG-1:0]       ifu_axi_bid;\n', '\n', '   // AXI Read Channels\n', '   logic                         ifu_axi_arvalid;\n', '   logic                         ifu_axi_arready;\n', '   logic [IFU_BUS_TAG-1:0]       ifu_axi_arid;\n', '   logic [31:0]                  ifu_axi_araddr;\n', '   logic [3:0]                   ifu_axi_arregion;\n', '   logic [7:0]                   ifu_axi_arlen;\n', '   logic [2:0]                   ifu_axi_arsize;\n', '   logic [1:0]                   ifu_axi_arburst;\n', '   logic                         ifu_axi_arlock;\n', '   logic [3:0]                   ifu_axi_arcache;\n', '   logic [2:0]                   ifu_axi_arprot;\n', '   logic [3:0]                   ifu_axi_arqos;\n', '\n', '   logic                         ifu_axi_rvalid;\n', '   logic                         ifu_axi_rready;\n', '   logic [IFU_BUS_TAG-1:0]       ifu_axi_rid;\n', '   logic [63:0]                  ifu_axi_rdata;\n', '   logic [1:0]                   ifu_axi_rresp;\n', '   logic                         ifu_axi_rlast;\n', '\n', '   // SB AXI signals\n', '   // AXI Write Channels\n', '   logic                         sb_axi_awvalid;\n', '   logic                         sb_axi_awready;\n', '   logic [SB_BUS_TAG-1:0]        sb_axi_awid;\n', '   logic [31:0]                  sb_axi_awaddr;\n', '   logic [3:0]                   sb_axi_awregion;\n', '   logic [7:0]                   sb_axi_awlen;\n', '   logic [2:0]                   sb_axi_awsize;\n', '   logic [1:0]                   sb_axi_awburst;\n', '   logic                         sb_axi_awlock;\n', '   logic [3:0]                   sb_axi_awcache;\n', '   logic [2:0]                   sb_axi_awprot;\n', '   logic [3:0]                   sb_axi_awqos;\n', '\n', '   logic                         sb_axi_wvalid;\n', '   logic                         sb_axi_wready;\n', '   logic [63:0]                  sb_axi_wdata;\n', '   logic [7:0]                   sb_axi_wstrb;\n', '   logic                         sb_axi_wlast;\n', '\n', '   logic                         sb_axi_bvalid;\n', '   logic                         sb_axi_bready;\n', '   logic [1:0]                   sb_axi_bresp;\n', '   logic [SB_BUS_TAG-1:0]        sb_axi_bid;\n', '\n', '   // AXI Read Channels\n', '   logic                         sb_axi_arvalid;\n', '   logic                         sb_axi_arready;\n', '   logic [SB_BUS_TAG-1:0]        sb_axi_arid;\n', '   logic [31:0]                  sb_axi_araddr;\n', '   logic [3:0]                   sb_axi_arregion;\n', '   logic [7:0]                   sb_axi_arlen;\n', '   logic [2:0]                   sb_axi_arsize;\n', '   logic [1:0]                   sb_axi_arburst;\n', '   logic                         sb_axi_arlock;\n', '   logic [3:0]                   sb_axi_arcache;\n', '   logic [2:0]                   sb_axi_arprot;\n', '   logic [3:0]                   sb_axi_arqos;\n', '\n', '   logic                         sb_axi_rvalid;\n', '   logic                         sb_axi_rready;\n', '   logic [SB_BUS_TAG-1:0]        sb_axi_rid;\n', '   logic [63:0]                  sb_axi_rdata;\n', '   logic [1:0]                   sb_axi_rresp;\n', '   logic                         sb_axi_rlast;\n', '\n', '   // DMA AXI signals\n', '   // AXI Write Channels\n', '   logic                         dma_axi_awvalid;\n', '   logic                         dma_axi_awready;\n', '   logic [`RV_DMA_BUS_TAG-1:0]   dma_axi_awid;\n', '   logic [31:0]                  dma_axi_awaddr;\n', '   logic [2:0]                   dma_axi_awsize;\n', '   logic [2:0]                   dma_axi_awprot;\n', '   logic [3:0]                   dma_axi_awcache;\n', '   logic [7:0]                   dma_axi_awlen;\n', '   logic [1:0]                   dma_axi_awburst;\n', '\n', '   logic                         dma_axi_wvalid;\n', '   logic                         dma_axi_wready;\n', '   logic [63:0]                  dma_axi_wdata;\n', '   logic [7:0]                   dma_axi_wstrb;\n', '   logic                         dma_axi_wlast;\n', '\n', '   logic                         dma_axi_bvalid;\n', '   logic                         dma_axi_bready;\n', '   logic [1:0]                   dma_axi_bresp;\n', '   logic [`RV_DMA_BUS_TAG-1:0]   dma_axi_bid;\n', '\n', '   // AXI Read Channels\n', '   logic                         dma_axi_arvalid;\n', '   logic                         dma_axi_arready;\n', '   logic [`RV_DMA_BUS_TAG-1:0]   dma_axi_arid;\n', '   logic [31:0]                  dma_axi_araddr;\n', '   logic [2:0]                   dma_axi_arsize;\n', '   logic [2:0]                   dma_axi_arprot;\n', '   logic [3:0]                   dma_axi_arcache;\n', '   logic [7:0]                   dma_axi_arlen;\n', '   logic [1:0]                   dma_axi_arburst;\n', '\n', '   logic                         dma_axi_rvalid;\n', '   logic                         dma_axi_rready;\n', '   logic [`RV_DMA_BUS_TAG-1:0]   dma_axi_rid;\n', '   logic [63:0]                  dma_axi_rdata;\n', '   logic [1:0]                   dma_axi_rresp;\n', '   logic                         dma_axi_rlast;\n', '`endif\n', '\n', '`ifdef RV_BUILD_AHB_LITE\n', '   logic [63:0]              hwdata_nc;\n', '`endif\n', '\n', '   //----------------------------------------------------------------------\n', '   //\n', '   //----------------------------------------------------------------------\n', '\n', '   logic [1:0]                   ifu_pmu_instr_aligned;\n', '   logic                         ifu_pmu_align_stall;\n', '   logic                         dma_slv_algn_err;\n', '// Icache debug\n', '`ifdef RV_ICACHE_ECC\n', '   logic [41:0] ifu_ic_debug_rd_data; // diagnostic icache read data\n', '`else\n', '   logic [33:0] ifu_ic_debug_rd_data; // diagnostic icache read data\n', '`endif\n', '   logic ifu_ic_debug_rd_data_valid; // diagnostic icache read data valid\n', '   cache_debug_pkt_t dec_tlu_ic_diag_pkt; // packet of DICAWICS, DICAD0/1, DICAGO info for icache diagnostics\n', '\n', '\n', '   logic  [31:0] gpr_i0_rs1_d;\n', '   logic  [31:0] gpr_i0_rs2_d;\n', '   logic  [31:0] gpr_i1_rs1_d;\n', '   logic  [31:0] gpr_i1_rs2_d;\n', '\n', '   logic [31:0] i0_rs1_bypass_data_d;\n', '   logic [31:0] i0_rs2_bypass_data_d;\n', '   logic [31:0] i1_rs1_bypass_data_d;\n', '   logic [31:0] i1_rs2_bypass_data_d;\n', '   logic [31:0] exu_i0_result_e1, exu_i1_result_e1;\n', '   logic  [31:1] exu_i0_pc_e1;\n', ""   logic  [31:1] exu_i1_pc_e1;  // from the primary alu's\n"", '   logic [31:1]  exu_npc_e4;\n', '   logic [31:1] dec_tlu_i0_pc_e4;\n', '   logic [31:1] dec_tlu_i1_pc_e4;\n', '\n', '   alu_pkt_t  i0_ap, i1_ap;\n', '\n', '   // Trigger signals\n', '   trigger_pkt_t [3:0]     trigger_pkt_any;\n', '   logic [3:0]             lsu_trigger_match_dc3;\n', '   logic        dec_ib3_valid_d, dec_ib2_valid_d;\n', '   logic        dec_ib1_valid_eff_d;\n', '   logic        dec_ib0_valid_eff_d;\n', '\n', '\n', '   logic [31:0] dec_i0_immed_d;\n', '   logic [31:0] dec_i1_immed_d;\n', '\n', '   logic [12:1] dec_i0_br_immed_d;\n', '   logic [12:1] dec_i1_br_immed_d;\n', '\n', '   logic         dec_i0_select_pc_d;\n', '   logic         dec_i1_select_pc_d;\n', '\n', '   logic [31:1] dec_i0_pc_d, dec_i1_pc_d;\n', '   logic        dec_i0_rs1_bypass_en_d;\n', '   logic        dec_i0_rs2_bypass_en_d;\n', '   logic        dec_i1_rs1_bypass_en_d;\n', '   logic        dec_i1_rs2_bypass_en_d;\n', '\n', '\n', '   logic         dec_i0_alu_decode_d;\n', '   logic         dec_i1_alu_decode_d;\n', '\n', '   rets_pkt_t exu_rets_e1_pkt;\n', '   rets_pkt_t exu_rets_e4_pkt;\n', '\n', '   logic         dec_tlu_cancel_e4;\n', '   logic         ifu_miss_state_idle;\n', '   logic         dec_tlu_flush_noredir_wb;\n', '   logic         dec_tlu_flush_leak_one_wb;\n', '   logic         dec_tlu_flush_err_wb;\n', '   logic         ifu_i0_valid, ifu_i1_valid;\n', '   logic [31:0]  ifu_i0_instr, ifu_i1_instr;\n', '   logic [31:1]  ifu_i0_pc, ifu_i1_pc;\n', '\n', '   logic        exu_i0_flush_final;\n', '   logic        exu_i1_flush_final;\n', '\n', '   logic        exu_flush_final;    // flush upper; either i0 or i1\n', '   logic        exu_flush_upper_e2;    // flush upper, either i0 or i1\n', '\n', '   logic [31:1] exu_flush_path_final;\n', '\n', '   logic [31:0] exu_lsu_rs1_d;\n', '   logic [31:0] exu_lsu_rs2_d;\n', '\n', '\n', '   lsu_pkt_t    lsu_p;\n', '\n', '   logic [11:0] dec_lsu_offset_d;\n', '   logic        dec_i0_lsu_d;       // chose which gpr value to use\n', '   logic        dec_i1_lsu_d;\n', '\n', '   logic [31:0]  lsu_result_dc3;\n', '   logic [31:0]  lsu_result_corr_dc4;    // ECC corrected lsu load data\n', '   lsu_error_pkt_t lsu_error_pkt_dc3;\n', '   logic         lsu_single_ecc_error_incr;    // Increment the counter for Single ECC error\n', '   logic         lsu_freeze_external_ints_dc3;\n', '   logic         lsu_imprecise_error_load_any;\n', '   logic         lsu_imprecise_error_store_any;\n', '   logic [31:0]  lsu_imprecise_error_addr_any;\n', '   logic         lsu_load_stall_any;       // This is for blocking stores\n', '   logic         lsu_store_stall_any;       // This is for blocking stores\n', ""   logic         lsu_load_ecc_stbuf_full_dc3;   // Load with ecc error can't allocate to stbuf\n"", '   logic         lsu_idle_any;\n', '   logic         lsu_halt_idle_any;   // This is used to enter halt mode. Exclude DMA\n', '\n', '   // Non-blocking loads\n', '   logic                                  lsu_nonblock_load_valid_dc3;\n', '   logic [`RV_LSU_NUM_NBLOAD_WIDTH-1:0]   lsu_nonblock_load_tag_dc3;\n', '   logic                                  lsu_nonblock_load_inv_dc5;\n', '   logic [`RV_LSU_NUM_NBLOAD_WIDTH-1:0]   lsu_nonblock_load_inv_tag_dc5;\n', '   logic                                  lsu_nonblock_load_data_valid;\n', '   logic [`RV_LSU_NUM_NBLOAD_WIDTH-1:0]   lsu_nonblock_load_data_tag;\n', '   logic [31:0]                           lsu_nonblock_load_data;\n', '\n', '   logic        flush_final_e3;\n', '   logic        i0_flush_final_e3;\n', '\n', '   logic        dec_csr_ren_d;\n', '\n', '   logic [31:0] exu_csr_rs1_e1;\n', '\n', '   logic        dec_tlu_flush_lower_wb;\n', ""   logic        dec_tlu_i0_kill_writeb_wb;    // I0 is flushed, don't writeback any results to arch state\n"", ""   logic        dec_tlu_i1_kill_writeb_wb;    // I1 is flushed, don't writeback any results to arch state\n"", '   logic        dec_tlu_fence_i_wb;           // flush is a fence_i rfnpc, flush icache\n', '\n', '   logic dec_tlu_i0_valid_e4;\n', '   logic dec_tlu_i1_valid_e4;\n', '   logic [31:1] dec_tlu_flush_path_wb;\n', '   logic [31:0] dec_tlu_mrac_ff;        // CSR for memory region control\n', '\n', '   logic        ifu_i0_pc4, ifu_i1_pc4;\n', '\n', '   mul_pkt_t  mul_p;\n', '\n', '   logic [31:0] exu_mul_result_e3;\n', '\n', '   logic dec_i0_mul_d;\n', '   logic dec_i1_mul_d;\n', '\n', '   div_pkt_t  div_p;\n', '\n', '   logic [31:0] exu_div_result;\n', '   logic exu_div_finish;\n', '   logic exu_div_stall;\n', '\n', '\n', '   logic dec_i0_div_d;\n', '   logic dec_i1_div_d;\n', '\n', '\n', '   logic [15:0] ifu_illegal_inst;\n', '\n', '   logic        dec_i1_valid_e1;\n', '\n', '   logic        dec_div_decode_e4;\n', '\n', '   logic [31:1] pred_correct_npc_e2;\n', '\n', '   logic [31:0] exu_i0_result_e4;\n', '   logic [31:0] exu_i1_result_e4;\n', '\n', '   logic        dec_i0_rs1_bypass_en_e3;\n', '   logic        dec_i0_rs2_bypass_en_e3;\n', '   logic        dec_i1_rs1_bypass_en_e3;\n', '   logic        dec_i1_rs2_bypass_en_e3;\n', '   logic [31:0] i0_rs1_bypass_data_e3;\n', '   logic [31:0] i0_rs2_bypass_data_e3;\n', '   logic [31:0] i1_rs1_bypass_data_e3;\n', '   logic [31:0] i1_rs2_bypass_data_e3;\n', '   logic        dec_i0_sec_decode_e3;\n', '   logic        dec_i1_sec_decode_e3;\n', '   logic [31:1] dec_i0_pc_e3;\n', '   logic [31:1] dec_i1_pc_e3;\n', '\n', '   logic        dec_i0_rs1_bypass_en_e2;\n', '   logic        dec_i0_rs2_bypass_en_e2;\n', '   logic        dec_i1_rs1_bypass_en_e2;\n', '   logic        dec_i1_rs2_bypass_en_e2;\n', '   logic [31:0] i0_rs1_bypass_data_e2;\n', '   logic [31:0] i0_rs2_bypass_data_e2;\n', '   logic [31:0] i1_rs1_bypass_data_e2;\n', '   logic [31:0] i1_rs2_bypass_data_e2;\n', '\n', '   logic        exu_i0_flush_lower_e4;     // to tlu for lower branch flushes\n', '   logic        exu_i1_flush_lower_e4;\n', '   logic [31:1] exu_i0_flush_path_e4;\n', '   logic [31:1] exu_i1_flush_path_e4;\n', '\n', '   br_tlu_pkt_t dec_tlu_br0_wb_pkt;\n', '   br_tlu_pkt_t dec_tlu_br1_wb_pkt;\n', '\n', '\n', '   predict_pkt_t  exu_mp_pkt;\n', '   logic [`RV_BHT_GHR_RANGE]  exu_mp_eghr;\n', '\n', '   logic [`RV_BHT_GHR_RANGE]  exu_i0_br_fghr_e4;\n', '   logic [1:0]  exu_i0_br_hist_e4;\n', '   logic [1:0]  exu_i0_br_bank_e4;\n', '   logic        exu_i0_br_error_e4;\n', '   logic        exu_i0_br_start_error_e4;\n', '   logic        exu_i0_br_valid_e4;\n', '   logic        exu_i0_br_mp_e4;\n', '   logic        exu_i0_br_ret_e4;\n', '   logic        exu_i0_br_call_e4;\n', '   logic        exu_i0_br_middle_e4;\n', '   logic [`RV_BHT_GHR_RANGE]  exu_i1_br_fghr_e4;\n', '\n', '   logic [1:0]  exu_i1_br_hist_e4;\n', '   logic [1:0]  exu_i1_br_bank_e4;\n', '   logic        exu_i1_br_error_e4;\n', '   logic        exu_i1_br_start_error_e4;\n', '   logic        exu_i1_br_valid_e4;\n', '   logic        exu_i1_br_mp_e4;\n', '   logic        exu_i1_br_ret_e4;\n', '   logic        exu_i1_br_call_e4;\n', '   logic        exu_i1_br_middle_e4;\n', '\n', '`ifdef RV_BTB_48\n', '   logic [1:0]       exu_i0_br_way_e4;\n', '   logic [1:0]       exu_i1_br_way_e4;\n', '`else\n', '   logic        exu_i0_br_way_e4;\n', '   logic        exu_i1_br_way_e4;\n', '`endif\n', '   logic        dec_i0_lsu_decode_d;\n', '\n', '   logic [`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] exu_i0_br_index_e4;\n', '   logic [`RV_BTB_ADDR_HI:`RV_BTB_ADDR_LO] exu_i1_br_index_e4;\n', '\n', '   logic                    dma_mem_dccm_req;\n', '\n', '   logic        dma_dccm_req;\n', '   logic        dma_iccm_req;\n', '   logic [31:0] dma_mem_addr;\n', '   logic [2:0]  dma_mem_sz;\n', '   logic        dma_mem_write;\n', '   logic [63:0] dma_mem_wdata;\n', '\n', '   logic        dccm_dma_rvalid;\n', '   logic        dccm_dma_ecc_error;\n', '   logic [63:0] dccm_dma_rdata;\n', '   logic        iccm_dma_rvalid;\n', '   logic        iccm_dma_ecc_error;\n', '   logic [63:0] iccm_dma_rdata;\n', '\n', '   logic        dma_dccm_stall_any;       // Stall the ld/st in decode if asserted\n', '   logic        dma_iccm_stall_any;       // Stall the fetch\n', '   logic        dccm_ready;\n', '   logic        iccm_ready;\n', '\n', '   logic [31:0] i0_result_e4_eff;\n', '   logic [31:0] i1_result_e4_eff;\n', '\n', '   logic [31:0] i0_result_e2;\n', '\n', '   logic        ifu_i0_icaf;\n', '   logic        ifu_i1_icaf;\n', '   logic        ifu_i0_icaf_second;\n', '   logic        ifu_i1_icaf_second;\n', '   logic        ifu_i0_perr;\n', '   logic        ifu_i1_perr;\n', '   logic        ifu_i0_sbecc;\n', '   logic        ifu_i1_sbecc;\n', '   logic        ifu_i0_dbecc;\n', '   logic        ifu_i1_dbecc;\n', '   logic        iccm_dma_sb_error;\n', '\n', '   br_pkt_t i0_brp;\n', '   br_pkt_t i1_brp;\n', '\n', '   predict_pkt_t  i0_predict_p_d;\n', '   predict_pkt_t  i1_predict_p_d;\n', '\n', '   // logic extint_pend,wakeup;\n', '      // PIC ports\n', '   logic                  picm_wren;\n', '   logic                  picm_rden;\n', '   logic                  picm_mken;\n', '   logic [31:0]           picm_addr;\n', '   logic [31:0]           picm_wr_data;\n', '   logic [31:0]           picm_rd_data;\n', '\n', '\n', '   // feature disable from mfdc\n', '   logic  dec_tlu_sec_alu_disable;\n', '   logic  dec_tlu_dccm_nonblock_dma_disable; // disable dma nonblock\n', '   logic  dec_tlu_non_blocking_disable;\n', '   logic  dec_tlu_fast_div_disable;\n', '   logic  dec_tlu_bpred_disable;\n', '   logic  dec_tlu_wb_coalescing_disable;\n', '   logic  dec_tlu_ld_miss_byp_wb_disable;\n', '   logic  dec_tlu_sideeffect_posted_disable;\n', '   logic [2:0] dec_tlu_dma_qos_prty;\n', '   // clock gating overrides from mcgc\n', '   logic  dec_tlu_misc_clk_override;\n', '   logic  dec_tlu_exu_clk_override;\n', '   logic  dec_tlu_ifu_clk_override;\n', '   logic  dec_tlu_lsu_clk_override;\n', '   logic  dec_tlu_bus_clk_override;\n', '   logic  dec_tlu_pic_clk_override;\n', '   logic  dec_tlu_dccm_clk_override;\n', '   logic  dec_tlu_icm_clk_override;\n', '\n', '   assign        dccm_clk_override = dec_tlu_dccm_clk_override;   // dccm memory\n', '   assign        icm_clk_override = dec_tlu_icm_clk_override;    // icache/iccm memory\n', '\n', '   // -----------------------DEBUG  START -------------------------------\n', '\n', '   logic [31:0]            dbg_cmd_addr;              // the address of the debug command to used by the core\n', '   logic [31:0]            dbg_cmd_wrdata;            // If the debug command is a write command, this has the data to be written to the CSR/GPR\n', '   logic                   dbg_cmd_valid;             // commad is being driven by the dbg module. One pulse. Only dirven when core_halted has been seen\n', '   logic                   dbg_cmd_write;             // 1: write command; 0: read_command\n', '   logic [1:0]             dbg_cmd_type;              // 0:gpr 1:csr 2: memory\n', '   logic [1:0]             dbg_cmd_size;              // size of the abstract mem access debug command\n', '   logic                   dbg_halt_req;              // Sticky signal indicating that the debug module wants to start the entering of debug mode ( start the halting sequence )\n', '   logic                   dbg_resume_req;            // Sticky signal indicating that the debug module wants to resume from debug mode\n', '   logic                   dbg_core_rst_l;            // Core reset from DM\n', '\n', '   logic                   core_dbg_cmd_done;         // Final muxed cmd done to debug\n', '   logic                   core_dbg_cmd_fail;         // Final muxed cmd done to debug\n', '   logic [31:0]            core_dbg_rddata;           // Final muxed cmd done to debug\n', '\n', '   logic                   dma_dbg_cmd_done;          // Abstarct memory command sent to dma is done\n', '   logic                   dma_dbg_cmd_fail;          // Abstarct memory command sent to dma failed\n', '   logic [31:0]            dma_dbg_rddata;            // Read data for abstract memory access\n', '\n', '   logic                   dbg_dma_bubble;            // Debug needs a bubble to send a valid\n', '   logic                   dma_dbg_ready;             // DMA is ready to accept debug request\n', '\n', '   logic [31:0]            dec_dbg_rddata;            // The core drives this data ( intercepts the pipe and sends it here )\n', '   logic                   dec_dbg_cmd_done;          // This will be treated like a valid signal\n', '   logic                   dec_dbg_cmd_fail;          // Abstract command failed\n', '   logic                   dec_tlu_mpc_halted_only;   // Only halted due to MPC\n', '   logic                   dec_tlu_dbg_halted;        // The core has finished the queiscing sequence. Sticks this signal high\n', '   logic                   dec_tlu_pmu_fw_halted;     // The core has finished the queiscing sequence. Sticks this signal high\n', '   logic                   dec_tlu_resume_ack;\n', '   logic                   dec_tlu_debug_mode;        // Core is in debug mode\n', '   logic                   dec_debug_wdata_rs1_d;\n', '   logic                   dec_tlu_stall_dma;         // stall dma accesses, tlu is attempting to enter halt/debug mode\n', '\n', '   logic [4:2]             dec_i0_data_en;\n', '   logic [4:1]             dec_i0_ctl_en;\n', '   logic [4:2]             dec_i1_data_en;\n', '   logic [4:1]             dec_i1_ctl_en;\n', '\n', '   logic                   dec_nonblock_load_freeze_dc2;\n', '\n', '   // PMU Signals\n', '   logic                   exu_pmu_i0_br_misp;\n', '   logic                   exu_pmu_i0_br_ataken;\n', '   logic                   exu_pmu_i0_pc4;\n', '   logic                   exu_pmu_i1_br_misp;\n', '   logic                   exu_pmu_i1_br_ataken;\n', '   logic                   exu_pmu_i1_pc4;\n', '\n', '   logic                   lsu_pmu_misaligned_dc3;\n', '   logic                   lsu_pmu_bus_trxn;\n', '   logic                   lsu_pmu_bus_misaligned;\n', '   logic                   lsu_pmu_bus_error;\n', '   logic                   lsu_pmu_bus_busy;\n', '\n', '   logic                   ifu_pmu_fetch_stall;\n', '   logic                   ifu_pmu_ic_miss;\n', '   logic                   ifu_pmu_ic_hit;\n', '   logic                   ifu_pmu_bus_error;\n', '   logic                   ifu_pmu_bus_busy;\n', '   logic                   ifu_pmu_bus_trxn;\n', '\n', '   logic                   active_state;\n', '   logic                   free_clk, active_clk;\n', '   logic                   dec_pause_state_cg;\n', '\n', '   logic                   lsu_nonblock_load_data_error;\n', '\n', '   logic [15:0]            ifu_i0_cinst;\n', '   logic [15:0]            ifu_i1_cinst;\n', '\n', '   trace_pkt_t  trace_rv_trace_pkt;\n', '\n', '\n', '   assign active_state = ~dec_pause_state_cg | dec_tlu_flush_lower_wb | dec_tlu_misc_clk_override;\n', '\n', ""   rvoclkhdr free_cg   ( .en(1'b1),         .l1clk(free_clk), .* );\n"", '   rvoclkhdr active_cg ( .en(active_state), .l1clk(active_clk), .* );\n', '\n', '\n', '   assign core_dbg_cmd_done = dma_dbg_cmd_done | dec_dbg_cmd_done;\n', '   assign core_dbg_cmd_fail = dma_dbg_cmd_fail | dec_dbg_cmd_fail;\n', '   assign core_dbg_rddata[31:0] = dma_dbg_cmd_done ? dma_dbg_rddata[31:0] : dec_dbg_rddata[31:0];\n', '\n', '   dbg dbg (\n', '      .rst_l(core_rst_l),\n', '      .clk_override(dec_tlu_misc_clk_override),\n', '      .*\n', '   );\n', '\n', '   // -----------------   DEBUG END -----------------------------\n', '\n', '   assign core_rst_l = rst_l & (dbg_core_rst_l | scan_mode);\n', '\n', '   // fetch\n', '   ifu ifu (\n', '       .clk_override(dec_tlu_ifu_clk_override),\n', '       .rst_l(core_rst_l),\n', '       .*\n', '   );\n', '\n', '   exu exu (\n', '      .clk_override(dec_tlu_exu_clk_override),\n', '      .rst_l(core_rst_l),\n', '      .*\n', '   );\n', '\n', '   lsu lsu (\n', '      .clk_override(dec_tlu_lsu_clk_override),\n', '      .rst_l(core_rst_l),\n', '      .*\n', '   );\n', '\n', '   logic [7:0]  pic_claimid;\n', '   logic [3:0]  pic_pl, dec_tlu_meicurpl, dec_tlu_meipt;\n', '\n', '   logic        mexintpend;\n', '   logic        mhwakeup;\n', '\n', '   logic        dec_tlu_claim_ack_wb;\n', '\n', '   dec dec (\n', '            .dbg_cmd_wrdata(dbg_cmd_wrdata[1:0]),\n', '            .rst_l(core_rst_l),\n', '            .*\n', '            );\n', '\n', '   pic_ctrl  pic_ctrl_inst (\n', '                  .clk_override(dec_tlu_pic_clk_override),\n', '                  .picm_mken (picm_mken),\n', ""                  .extintsrc_req({extintsrc_req[`RV_PIC_TOTAL_INT:1],1'b0}),\n"", '                  .pl(pic_pl[3:0]),\n', '                  .claimid(pic_claimid[7:0]),\n', '                  .meicurpl(dec_tlu_meicurpl[3:0]),\n', '                  .meipt(dec_tlu_meipt[3:0]),\n', '                  .rst_l(core_rst_l),\n', '                     .*);\n', '\n', '   dma_ctrl dma_ctrl (\n', '      .rst_l(core_rst_l),\n', '      .clk_override(dec_tlu_misc_clk_override),\n', '      .*\n', '   );\n', '\n', '`ifdef RV_BUILD_AHB_LITE\n', '\n', '   // AXI4 -> AHB Gasket for LSU\n', '   axi4_to_ahb #(.TAG(LSU_BUS_TAG)) lsu_axi4_to_ahb (\n', '      .rst_l(core_rst_l),\n', '      .clk_override(dec_tlu_bus_clk_override),\n', '      .bus_clk_en(lsu_bus_clk_en),\n', '\n', '      // AXI Write Channels\n', '      .axi_awvalid(lsu_axi_awvalid),\n', '      .axi_awready(lsu_axi_awready),\n', '      .axi_awid(lsu_axi_awid[LSU_BUS_TAG-1:0]),\n', '      .axi_awaddr(lsu_axi_awaddr[31:0]),\n', '      .axi_awsize(lsu_axi_awsize[2:0]),\n', '      .axi_awprot(lsu_axi_awprot[2:0]),\n', '\n', '      .axi_wvalid(lsu_axi_wvalid),\n', '      .axi_wready(lsu_axi_wready),\n', '      .axi_wdata(lsu_axi_wdata[63:0]),\n', '      .axi_wstrb(lsu_axi_wstrb[7:0]),\n', '      .axi_wlast(lsu_axi_wlast),\n', '\n', '      .axi_bvalid(lsu_axi_bvalid),\n', '      .axi_bready(lsu_axi_bready),\n', '      .axi_bresp(lsu_axi_bresp[1:0]),\n', '      .axi_bid(lsu_axi_bid[LSU_BUS_TAG-1:0]),\n', '\n', '      // AXI Read Channels\n', '      .axi_arvalid(lsu_axi_arvalid),\n', '      .axi_arready(lsu_axi_arready),\n', '      .axi_arid(lsu_axi_arid[LSU_BUS_TAG-1:0]),\n', '      .axi_araddr(lsu_axi_araddr[31:0]),\n', '      .axi_arsize(lsu_axi_arsize[2:0]),\n', '      .axi_arprot(lsu_axi_arprot[2:0]),\n', '\n', '      .axi_rvalid(lsu_axi_rvalid),\n', '      .axi_rready(lsu_axi_rready),\n', '      .axi_rid(lsu_axi_rid[LSU_BUS_TAG-1:0]),\n', '      .axi_rdata(lsu_axi_rdata[63:0]),\n', '      .axi_rresp(lsu_axi_rresp[1:0]),\n', '      .axi_rlast(lsu_axi_rlast),\n', '      // AHB-LITE signals\n', '      .ahb_haddr(lsu_haddr[31:0]),\n', '      .ahb_hburst(lsu_hburst),\n', '      .ahb_hmastlock(lsu_hmastlock),\n', '      .ahb_hprot(lsu_hprot[3:0]),\n', '      .ahb_hsize(lsu_hsize[2:0]),\n', '      .ahb_htrans(lsu_htrans[1:0]),\n', '      .ahb_hwrite(lsu_hwrite),\n', '      .ahb_hwdata(lsu_hwdata[63:0]),\n', '\n', '      .ahb_hrdata(lsu_hrdata[63:0]),\n', '      .ahb_hready(lsu_hready),\n', '      .ahb_hresp(lsu_hresp),\n', '\n', '      .*\n', '   );\n', '\n', '   // AXI4 -> AHB Gasket for System Bus\n', '   axi4_to_ahb #(.TAG(SB_BUS_TAG)) sb_axi4_to_ahb (\n', '      .rst_l(dbg_rst_l),\n', '      .clk_override(dec_tlu_bus_clk_override),\n', '      .bus_clk_en(dbg_bus_clk_en),\n', '\n', '      // AXI Write Channels\n', '      .axi_awvalid(sb_axi_awvalid),\n', '      .axi_awready(sb_axi_awready),\n', '      .axi_awid(sb_axi_awid[SB_BUS_TAG-1:0]),\n', '      .axi_awaddr(sb_axi_awaddr[31:0]),\n', '      .axi_awsize(sb_axi_awsize[2:0]),\n', '      .axi_awprot(sb_axi_awprot[2:0]),\n', '\n', '      .axi_wvalid(sb_axi_wvalid),\n', '      .axi_wready(sb_axi_wready),\n', '      .axi_wdata(sb_axi_wdata[63:0]),\n', '      .axi_wstrb(sb_axi_wstrb[7:0]),\n', '      .axi_wlast(sb_axi_wlast),\n', '\n', '      .axi_bvalid(sb_axi_bvalid),\n', '      .axi_bready(sb_axi_bready),\n', '      .axi_bresp(sb_axi_bresp[1:0]),\n', '      .axi_bid(sb_axi_bid[SB_BUS_TAG-1:0]),\n', '\n', '      // AXI Read Channels\n', '      .axi_arvalid(sb_axi_arvalid),\n', '      .axi_arready(sb_axi_arready),\n', '      .axi_arid(sb_axi_arid[SB_BUS_TAG-1:0]),\n', '      .axi_araddr(sb_axi_araddr[31:0]),\n', '      .axi_arsize(sb_axi_arsize[2:0]),\n', '      .axi_arprot(sb_axi_arprot[2:0]),\n', '\n', '      .axi_rvalid(sb_axi_rvalid),\n', '      .axi_rready(sb_axi_rready),\n', '      .axi_rid(sb_axi_rid[SB_BUS_TAG-1:0]),\n', '      .axi_rdata(sb_axi_rdata[63:0]),\n', '      .axi_rresp(sb_axi_rresp[1:0]),\n', '      .axi_rlast(sb_axi_rlast),\n', '      // AHB-LITE signals\n', '      .ahb_haddr(sb_haddr[31:0]),\n', '      .ahb_hburst(sb_hburst),\n', '      .ahb_hmastlock(sb_hmastlock),\n', '      .ahb_hprot(sb_hprot[3:0]),\n', '      .ahb_hsize(sb_hsize[2:0]),\n', '      .ahb_htrans(sb_htrans[1:0]),\n', '      .ahb_hwrite(sb_hwrite),\n', '      .ahb_hwdata(sb_hwdata[63:0]),\n', '\n', '      .ahb_hrdata(sb_hrdata[63:0]),\n', '      .ahb_hready(sb_hready),\n', '      .ahb_hresp(sb_hresp),\n', '\n', '      .*\n', '   );\n', '\n', '   axi4_to_ahb #(.TAG(IFU_BUS_TAG)) ifu_axi4_to_ahb (\n', '      .clk(clk),\n', '      .rst_l(core_rst_l),\n', '      .clk_override(dec_tlu_bus_clk_override),\n', '      .bus_clk_en(ifu_bus_clk_en),\n', '\n', '       // AHB-Lite signals\n', '      .ahb_haddr(haddr[31:0]),\n', '      .ahb_hburst(hburst),\n', '      .ahb_hmastlock(hmastlock),\n', '      .ahb_hprot(hprot[3:0]),\n', '      .ahb_hsize(hsize[2:0]),\n', '      .ahb_htrans(htrans[1:0]),\n', '      .ahb_hwrite(hwrite),\n', '      .ahb_hwdata(hwdata_nc[63:0]),\n', '\n', '      .ahb_hrdata(hrdata[63:0]),\n', '      .ahb_hready(hready),\n', '      .ahb_hresp(hresp),\n', '\n', '      // AXI Write Channels\n', '      .axi_awvalid(ifu_axi_awvalid),\n', '      .axi_awready(ifu_axi_awready),\n', '      .axi_awid(ifu_axi_awid[IFU_BUS_TAG-1:0]),\n', '      .axi_awaddr(ifu_axi_awaddr[31:0]),\n', '      .axi_awsize(ifu_axi_awsize[2:0]),\n', '      .axi_awprot(ifu_axi_awprot[2:0]),\n', '\n', '      .axi_wvalid(ifu_axi_wvalid),\n', '      .axi_wready(ifu_axi_wready),\n', '      .axi_wdata(ifu_axi_wdata[63:0]),\n', '      .axi_wstrb(ifu_axi_wstrb[7:0]),\n', '      .axi_wlast(ifu_axi_wlast),\n', '\n', '      .axi_bvalid(ifu_axi_bvalid),\n', '      .axi_bready(ifu_axi_bready),\n', '      .axi_bresp(ifu_axi_bresp[1:0]),\n', '      .axi_bid(ifu_axi_bid[IFU_BUS_TAG-1:0]),\n', '\n', '      // AXI Read Channels\n', '      .axi_arvalid(ifu_axi_arvalid),\n', '      .axi_arready(ifu_axi_arready),\n', '      .axi_arid(ifu_axi_arid[IFU_BUS_TAG-1:0]),\n', '      .axi_araddr(ifu_axi_araddr[31:0]),\n', '      .axi_arsize(ifu_axi_arsize[2:0]),\n', '      .axi_arprot(ifu_axi_arprot[2:0]),\n', '\n', '      .axi_rvalid(ifu_axi_rvalid),\n', '      .axi_rready(ifu_axi_rready),\n', '      .axi_rid(ifu_axi_rid[IFU_BUS_TAG-1:0]),\n', '      .axi_rdata(ifu_axi_rdata[63:0]),\n', '      .axi_rresp(ifu_axi_rresp[1:0]),\n', '      .axi_rlast(ifu_axi_rlast),\n', '      .*\n', '   );\n', '\n', '   //AHB -> AXI4 Gasket for DMA\n', '   ahb_to_axi4 #(.TAG(DMA_BUS_TAG)) dma_ahb_to_axi4 (\n', '      .rst_l(core_rst_l),\n', '      .clk_override(dec_tlu_bus_clk_override),\n', '      .bus_clk_en(dma_bus_clk_en),\n', '\n', '      // AXI Write Channels\n', '      .axi_awvalid(dma_axi_awvalid),\n', '      .axi_awready(dma_axi_awready),\n', '      .axi_awid(dma_axi_awid[DMA_BUS_TAG-1:0]),\n', '      .axi_awaddr(dma_axi_awaddr[31:0]),\n', '      .axi_awsize(dma_axi_awsize[2:0]),\n', '      .axi_awprot(dma_axi_awprot[2:0]),\n', '      .axi_awlen(dma_axi_awlen[7:0]),\n', '      .axi_awburst(dma_axi_awburst[1:0]),\n', '\n', '      .axi_wvalid(dma_axi_wvalid),\n', '      .axi_wready(dma_axi_wready),\n', '      .axi_wdata(dma_axi_wdata[63:0]),\n', '      .axi_wstrb(dma_axi_wstrb[7:0]),\n', '      .axi_wlast(dma_axi_wlast),\n', '\n', '      .axi_bvalid(dma_axi_bvalid),\n', '      .axi_bready(dma_axi_bready),\n', '      .axi_bresp(dma_axi_bresp[1:0]),\n', '      .axi_bid(dma_axi_bid[DMA_BUS_TAG-1:0]),\n', '\n', '      // AXI Read Channels\n', '      .axi_arvalid(dma_axi_arvalid),\n', '      .axi_arready(dma_axi_arready),\n', '      .axi_arid(dma_axi_arid[DMA_BUS_TAG-1:0]),\n', '      .axi_araddr(dma_axi_araddr[31:0]),\n', '      .axi_arsize(dma_axi_arsize[2:0]),\n', '      .axi_arprot(dma_axi_arprot[2:0]),\n', '      .axi_arlen(dma_axi_arlen[7:0]),\n', '      .axi_arburst(dma_axi_arburst[1:0]),\n', '\n', '      .axi_rvalid(dma_axi_rvalid),\n', '      .axi_rready(dma_axi_rready),\n', '      .axi_rid(dma_axi_rid[DMA_BUS_TAG-1:0]),\n', '      .axi_rdata(dma_axi_rdata[63:0]),\n', '      .axi_rresp(dma_axi_rresp[1:0]),\n', '\n', '       // AHB signals\n', '      .ahb_haddr(dma_haddr[31:0]),\n', '      .ahb_hburst(dma_hburst),\n', '      .ahb_hmastlock(dma_hmastlock),\n', '      .ahb_hprot(dma_hprot[3:0]),\n', '      .ahb_hsize(dma_hsize[2:0]),\n', '      .ahb_htrans(dma_htrans[1:0]),\n', '      .ahb_hwrite(dma_hwrite),\n', '      .ahb_hwdata(dma_hwdata[63:0]),\n', '\n', '      .ahb_hrdata(dma_hrdata[63:0]),\n', '      .ahb_hreadyout(dma_hreadyout),\n', '      .ahb_hresp(dma_hresp),\n', '      .ahb_hreadyin(dma_hreadyin),\n', '      .ahb_hsel(dma_hsel),\n', '      .*\n', '   );\n', '\n', '`endif\n', '\n', '\n', '`ifdef RV_BUILD_AHB_LITE\n', '`ifdef ASSERT_ON\n', '   property ahb_trxn_aligned;\n', ""     @(posedge clk) disable iff(~rst_l) (lsu_htrans[1:0] != 2'b0)  |-> ((lsu_hsize[2:0] == 3'h0)                              |\n"", ""                                                                        ((lsu_hsize[2:0] == 3'h1) & (lsu_haddr[0] == 1'b0))   |\n"", ""                                                                        ((lsu_hsize[2:0] == 3'h2) & (lsu_haddr[1:0] == 2'b0)) |\n"", ""                                                                        ((lsu_hsize[2:0] == 3'h3) & (lsu_haddr[2:0] == 3'b0)));\n"", '   endproperty\n', '   assert_ahb_trxn_aligned: assert property (ahb_trxn_aligned) else\n', '     $display(""Assertion ahb_trxn_aligned failed: lsu_htrans=2\'h%h, lsu_hsize=3\'h%h, lsu_haddr=32\'h%h"",lsu_htrans[1:0], lsu_hsize[2:0], lsu_haddr[31:0]);\n', '\n', '   property dma_trxn_aligned;\n', ""     @(posedge clk) disable iff(~rst_l) (dma_htrans[1:0] != 2'b0)  |-> ((dma_hsize[2:0] == 3'h0)                              |\n"", ""                                                                        ((dma_hsize[2:0] == 3'h1) & (dma_haddr[0] == 1'b0))   |\n"", ""                                                                        ((dma_hsize[2:0] == 3'h2) & (dma_haddr[1:0] == 2'b0)) |\n"", ""                                                                        ((dma_hsize[2:0] == 3'h3) & (dma_haddr[2:0] == 3'b0)));\n"", '   endproperty\n', '   //assert_dma_trxn_aligned: assert property (dma_trxn_aligned) else\n', '   //  $display(""Assertion dma_trxn_aligned failed: dma_htrans=2\'h%h, dma_hsize=3\'h%h, dma_haddr=32\'h%h"",dma_htrans[1:0], dma_hsize[2:0], dma_haddr[31:0]);\n', '\n', '`endif\n', '`endif\n', '\n', '\n', '      // unpack packet\n', '      // also need retires_p==3\n', '\n', '      assign trace_rv_i_insn_ip[63:0]     = trace_rv_trace_pkt.trace_rv_i_insn_ip[63:0];\n', '\n', '      assign trace_rv_i_address_ip[63:0]  = trace_rv_trace_pkt.trace_rv_i_address_ip[63:0];\n', '\n', '      assign trace_rv_i_valid_ip[2:0]     = trace_rv_trace_pkt.trace_rv_i_valid_ip[2:0];\n', '\n', '      assign trace_rv_i_exception_ip[2:0] = trace_rv_trace_pkt.trace_rv_i_exception_ip[2:0];\n', '\n', '      assign trace_rv_i_ecause_ip[4:0]    = trace_rv_trace_pkt.trace_rv_i_ecause_ip[4:0];\n', '\n', '      assign trace_rv_i_interrupt_ip[2:0] = trace_rv_trace_pkt.trace_rv_i_interrupt_ip[2:0];\n', '\n', '      assign trace_rv_i_tval_ip[31:0]     = trace_rv_trace_pkt.trace_rv_i_tval_ip[31:0];\n', '\n', '\n', '   // constants should be hooked up at platform level\n', ""   // trace_rv_i_context_ip   = '0;\n"", ""   // trace_rv_i_privilege_ip = {3{4'b0011}};\n"", ""   // trace_rv_i_status_ip    = '0;\n"", ""   // trace_rv_i_user_ip      = '0;\n"", '\n', '   // trace_rv_halted_ip = o_cpu_halt_status;   hook this up at platform level\n', '\n', '\n', '\n', '\n', '\n', 'endmodule // veer\n', '\n']"
"['// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2019 Western Digital Corporation or its affiliates.\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the ""License"");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '// http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an ""AS IS"" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '\n', '//********************************************************************************\n', '// $Id$\n', '//\n', '// Function: Top wrapper file with veer/mem instantiated inside\n', '// Comments:\n', '//\n', '//********************************************************************************\n', '`include ""build.h""\n', '//`include ""def.sv""\n', 'module veer_wrapper\n', '   import veer_types::*;\n', '(\n', '   input logic                       clk,\n', '   input logic                       rst_l,\n', '   input logic                       dbg_rst_l,\n', '   input logic [31:1]                rst_vec,\n', '   input logic                       nmi_int,\n', '   input logic [31:1]                nmi_vec,\n', '   input logic [31:1]                jtag_id,\n', '\n', '\n', '   output logic [63:0] trace_rv_i_insn_ip,\n', '   output logic [63:0] trace_rv_i_address_ip,\n', '   output logic [2:0]  trace_rv_i_valid_ip,\n', '   output logic [2:0]  trace_rv_i_exception_ip,\n', '   output logic [4:0]  trace_rv_i_ecause_ip,\n', '   output logic [2:0]  trace_rv_i_interrupt_ip,\n', '   output logic [31:0] trace_rv_i_tval_ip,\n', '\n', '   // Bus signals\n', '\n', '`ifdef RV_BUILD_AXI4\n', '   //-------------------------- LSU AXI signals--------------------------\n', '   // AXI Write Channels\n', '   output logic                            lsu_axi_awvalid,\n', '   input  logic                            lsu_axi_awready,\n', '   output logic [`RV_LSU_BUS_TAG-1:0]      lsu_axi_awid,\n', '   output logic [31:0]                     lsu_axi_awaddr,\n', '   output logic [3:0]                      lsu_axi_awregion,\n', '   output logic [7:0]                      lsu_axi_awlen,\n', '   output logic [2:0]                      lsu_axi_awsize,\n', '   output logic [1:0]                      lsu_axi_awburst,\n', '   output logic                            lsu_axi_awlock,\n', '   output logic [3:0]                      lsu_axi_awcache,\n', '   output logic [2:0]                      lsu_axi_awprot,\n', '   output logic [3:0]                      lsu_axi_awqos,\n', '\n', '   output logic                            lsu_axi_wvalid,\n', '   input  logic                            lsu_axi_wready,\n', '   output logic [63:0]                     lsu_axi_wdata,\n', '   output logic [7:0]                      lsu_axi_wstrb,\n', '   output logic                            lsu_axi_wlast,\n', '\n', '   input  logic                            lsu_axi_bvalid,\n', '   output logic                            lsu_axi_bready,\n', '   input  logic [1:0]                      lsu_axi_bresp,\n', '   input  logic [`RV_LSU_BUS_TAG-1:0]      lsu_axi_bid,\n', '\n', '   // AXI Read Channels\n', '   output logic                            lsu_axi_arvalid,\n', '   input  logic                            lsu_axi_arready,\n', '   output logic [`RV_LSU_BUS_TAG-1:0]      lsu_axi_arid,\n', '   output logic [31:0]                     lsu_axi_araddr,\n', '   output logic [3:0]                      lsu_axi_arregion,\n', '   output logic [7:0]                      lsu_axi_arlen,\n', '   output logic [2:0]                      lsu_axi_arsize,\n', '   output logic [1:0]                      lsu_axi_arburst,\n', '   output logic                            lsu_axi_arlock,\n', '   output logic [3:0]                      lsu_axi_arcache,\n', '   output logic [2:0]                      lsu_axi_arprot,\n', '   output logic [3:0]                      lsu_axi_arqos,\n', '\n', '   input  logic                            lsu_axi_rvalid,\n', '   output logic                            lsu_axi_rready,\n', '   input  logic [`RV_LSU_BUS_TAG-1:0]      lsu_axi_rid,\n', '   input  logic [63:0]                     lsu_axi_rdata,\n', '   input  logic [1:0]                      lsu_axi_rresp,\n', '   input  logic                            lsu_axi_rlast,\n', '\n', '   //-------------------------- IFU AXI signals--------------------------\n', '   // AXI Write Channels\n', '   output logic                            ifu_axi_awvalid,\n', '   input  logic                            ifu_axi_awready,\n', '   output logic [`RV_IFU_BUS_TAG-1:0]      ifu_axi_awid,\n', '   output logic [31:0]                     ifu_axi_awaddr,\n', '   output logic [3:0]                      ifu_axi_awregion,\n', '   output logic [7:0]                      ifu_axi_awlen,\n', '   output logic [2:0]                      ifu_axi_awsize,\n', '   output logic [1:0]                      ifu_axi_awburst,\n', '   output logic                            ifu_axi_awlock,\n', '   output logic [3:0]                      ifu_axi_awcache,\n', '   output logic [2:0]                      ifu_axi_awprot,\n', '   output logic [3:0]                      ifu_axi_awqos,\n', '\n', '   output logic                            ifu_axi_wvalid,\n', '   input  logic                            ifu_axi_wready,\n', '   output logic [63:0]                     ifu_axi_wdata,\n', '   output logic [7:0]                      ifu_axi_wstrb,\n', '   output logic                            ifu_axi_wlast,\n', '\n', '   input  logic                            ifu_axi_bvalid,\n', '   output logic                            ifu_axi_bready,\n', '   input  logic [1:0]                      ifu_axi_bresp,\n', '   input  logic [`RV_IFU_BUS_TAG-1:0]      ifu_axi_bid,\n', '\n', '   // AXI Read Channels\n', '   output logic                            ifu_axi_arvalid,\n', '   input  logic                            ifu_axi_arready,\n', '   output logic [`RV_IFU_BUS_TAG-1:0]      ifu_axi_arid,\n', '   output logic [31:0]                     ifu_axi_araddr,\n', '   output logic [3:0]                      ifu_axi_arregion,\n', '   output logic [7:0]                      ifu_axi_arlen,\n', '   output logic [2:0]                      ifu_axi_arsize,\n', '   output logic [1:0]                      ifu_axi_arburst,\n', '   output logic                            ifu_axi_arlock,\n', '   output logic [3:0]                      ifu_axi_arcache,\n', '   output logic [2:0]                      ifu_axi_arprot,\n', '   output logic [3:0]                      ifu_axi_arqos,\n', '\n', '   input  logic                            ifu_axi_rvalid,\n', '   output logic                            ifu_axi_rready,\n', '   input  logic [`RV_IFU_BUS_TAG-1:0]      ifu_axi_rid,\n', '   input  logic [63:0]                     ifu_axi_rdata,\n', '   input  logic [1:0]                      ifu_axi_rresp,\n', '   input  logic                            ifu_axi_rlast,\n', '\n', '   //-------------------------- SB AXI signals--------------------------\n', '   // AXI Write Channels\n', '   output logic                            sb_axi_awvalid,\n', '   input  logic                            sb_axi_awready,\n', '   output logic [`RV_SB_BUS_TAG-1:0]       sb_axi_awid,\n', '   output logic [31:0]                     sb_axi_awaddr,\n', '   output logic [3:0]                      sb_axi_awregion,\n', '   output logic [7:0]                      sb_axi_awlen,\n', '   output logic [2:0]                      sb_axi_awsize,\n', '   output logic [1:0]                      sb_axi_awburst,\n', '   output logic                            sb_axi_awlock,\n', '   output logic [3:0]                      sb_axi_awcache,\n', '   output logic [2:0]                      sb_axi_awprot,\n', '   output logic [3:0]                      sb_axi_awqos,\n', '\n', '   output logic                            sb_axi_wvalid,\n', '   input  logic                            sb_axi_wready,\n', '   output logic [63:0]                     sb_axi_wdata,\n', '   output logic [7:0]                      sb_axi_wstrb,\n', '   output logic                            sb_axi_wlast,\n', '\n', '   input  logic                            sb_axi_bvalid,\n', '   output logic                            sb_axi_bready,\n', '   input  logic [1:0]                      sb_axi_bresp,\n', '   input  logic [`RV_SB_BUS_TAG-1:0]       sb_axi_bid,\n', '\n', '   // AXI Read Channels\n', '   output logic                            sb_axi_arvalid,\n', '   input  logic                            sb_axi_arready,\n', '   output logic [`RV_SB_BUS_TAG-1:0]       sb_axi_arid,\n', '   output logic [31:0]                     sb_axi_araddr,\n', '   output logic [3:0]                      sb_axi_arregion,\n', '   output logic [7:0]                      sb_axi_arlen,\n', '   output logic [2:0]                      sb_axi_arsize,\n', '   output logic [1:0]                      sb_axi_arburst,\n', '   output logic                            sb_axi_arlock,\n', '   output logic [3:0]                      sb_axi_arcache,\n', '   output logic [2:0]                      sb_axi_arprot,\n', '   output logic [3:0]                      sb_axi_arqos,\n', '\n', '   input  logic                            sb_axi_rvalid,\n', '   output logic                            sb_axi_rready,\n', '   input  logic [`RV_SB_BUS_TAG-1:0]       sb_axi_rid,\n', '   input  logic [63:0]                     sb_axi_rdata,\n', '   input  logic [1:0]                      sb_axi_rresp,\n', '   input  logic                            sb_axi_rlast,\n', '\n', '   //-------------------------- DMA AXI signals--------------------------\n', '   // AXI Write Channels\n', '   input  logic                         dma_axi_awvalid,\n', '   output logic                         dma_axi_awready,\n', '   input  logic [`RV_DMA_BUS_TAG-1:0]   dma_axi_awid,\n', '   input  logic [31:0]                  dma_axi_awaddr,\n', '   input  logic [2:0]                   dma_axi_awsize,\n', '   input  logic [2:0]                   dma_axi_awprot,\n', '   input  logic [7:0]                   dma_axi_awlen,\n', '   input  logic [1:0]                   dma_axi_awburst,\n', '\n', '\n', '   input  logic                         dma_axi_wvalid,\n', '   output logic                         dma_axi_wready,\n', '   input  logic [63:0]                  dma_axi_wdata,\n', '   input  logic [7:0]                   dma_axi_wstrb,\n', '   input  logic                         dma_axi_wlast,\n', '\n', '   output logic                         dma_axi_bvalid,\n', '   input  logic                         dma_axi_bready,\n', '   output logic [1:0]                   dma_axi_bresp,\n', '   output logic [`RV_DMA_BUS_TAG-1:0]   dma_axi_bid,\n', '\n', '   // AXI Read Channels\n', '   input  logic                         dma_axi_arvalid,\n', '   output logic                         dma_axi_arready,\n', '   input  logic [`RV_DMA_BUS_TAG-1:0]   dma_axi_arid,\n', '   input  logic [31:0]                  dma_axi_araddr,\n', '   input  logic [2:0]                   dma_axi_arsize,\n', '   input  logic [2:0]                   dma_axi_arprot,\n', '   input  logic [7:0]                   dma_axi_arlen,\n', '   input  logic [1:0]                   dma_axi_arburst,\n', '\n', '   output logic                         dma_axi_rvalid,\n', '   input  logic                         dma_axi_rready,\n', '   output logic [`RV_DMA_BUS_TAG-1:0]   dma_axi_rid,\n', '   output logic [63:0]                  dma_axi_rdata,\n', '   output logic [1:0]                   dma_axi_rresp,\n', '   output logic                         dma_axi_rlast,\n', '\n', '`endif\n', '\n', '`ifdef RV_BUILD_AHB_LITE\n', ' //// AHB LITE BUS\n', '   output logic [31:0]               haddr,\n', '   output logic [2:0]                hburst,\n', '   output logic                      hmastlock,\n', '   output logic [3:0]                hprot,\n', '   output logic [2:0]                hsize,\n', '   output logic [1:0]                htrans,\n', '   output logic                      hwrite,\n', '\n', '   input logic [63:0]                hrdata,\n', '   input logic                       hready,\n', '   input logic                       hresp,\n', '\n', '   // LSU AHB Master\n', '   output logic [31:0]               lsu_haddr,\n', '   output logic [2:0]                lsu_hburst,\n', '   output logic                      lsu_hmastlock,\n', '   output logic [3:0]                lsu_hprot,\n', '   output logic [2:0]                lsu_hsize,\n', '   output logic [1:0]                lsu_htrans,\n', '   output logic                      lsu_hwrite,\n', '   output logic [63:0]               lsu_hwdata,\n', '\n', '   input logic [63:0]                lsu_hrdata,\n', '   input logic                       lsu_hready,\n', '   input logic                       lsu_hresp,\n', '   // Debug Syster Bus AHB\n', '   output logic [31:0]               sb_haddr,\n', '   output logic [2:0]                sb_hburst,\n', '   output logic                      sb_hmastlock,\n', '   output logic [3:0]                sb_hprot,\n', '   output logic [2:0]                sb_hsize,\n', '   output logic [1:0]                sb_htrans,\n', '   output logic                      sb_hwrite,\n', '   output logic [63:0]               sb_hwdata,\n', '\n', '   input  logic [63:0]               sb_hrdata,\n', '   input  logic                      sb_hready,\n', '   input  logic                      sb_hresp,\n', '\n', '   // DMA Slave\n', '   input logic [31:0]                dma_haddr,\n', '   input logic [2:0]                 dma_hburst,\n', '   input logic                       dma_hmastlock,\n', '   input logic [3:0]                 dma_hprot,\n', '   input logic [2:0]                 dma_hsize,\n', '   input logic [1:0]                 dma_htrans,\n', '   input logic                       dma_hwrite,\n', '   input logic [63:0]                dma_hwdata,\n', '   input logic                       dma_hsel,\n', '   input logic                       dma_hreadyin,\n', '\n', '   output logic [63:0]               dma_hrdata,\n', '   output logic                      dma_hreadyout,\n', '   output logic                      dma_hresp,\n', '\n', '`endif\n', '\n', '\n', '   // clk ratio signals\n', '   input logic                       lsu_bus_clk_en, // Clock ratio b/w cpu core clk & AHB master interface\n', '   input logic                       ifu_bus_clk_en, // Clock ratio b/w cpu core clk & AHB master interface\n', '   input logic                       dbg_bus_clk_en, // Clock ratio b/w cpu core clk & AHB master interface\n', '   input logic                       dma_bus_clk_en, // Clock ratio b/w cpu core clk & AHB slave interface\n', '\n', '\n', '//   input logic                   ext_int,\n', '   input logic                       timer_int,\n', '   input logic [`RV_PIC_TOTAL_INT:1] extintsrc_req,\n', '\n', '   output logic [1:0] dec_tlu_perfcnt0, // toggles when perf counter 0 has an event inc\n', '   output logic [1:0] dec_tlu_perfcnt1,\n', '   output logic [1:0] dec_tlu_perfcnt2,\n', '   output logic [1:0] dec_tlu_perfcnt3,\n', '\n', '   // ports added by the soc team\n', '   input logic                       jtag_tck, // JTAG clk\n', '   input logic                       jtag_tms, // JTAG TMS\n', '   input logic                       jtag_tdi, // JTAG tdi\n', '   input logic                       jtag_trst_n, // JTAG Reset\n', '   output logic                      jtag_tdo, // JTAG TDO\n', '   // external MPC halt/run interface\n', '   input logic mpc_debug_halt_req, // Async halt request\n', '   input logic mpc_debug_run_req, // Async run request\n', '   input logic mpc_reset_run_req, // Run/halt after reset\n', '   output logic mpc_debug_halt_ack, // Halt ack\n', '   output logic mpc_debug_run_ack, // Run ack\n', '   output logic debug_brkpt_status, // debug breakpoint\n', '\n', '   input logic                       i_cpu_halt_req, // Async halt req to CPU\n', '   output logic                      o_cpu_halt_ack, // core response to halt\n', ""   output logic                      o_cpu_halt_status, // 1'b1 indicates core is halted\n"", '   output logic                      o_debug_mode_status, // Core to the PMU that core is in debug mode. When core is in debug mode, the PMU should refrain from sendng a halt or run request\n', '   input logic                       i_cpu_run_req, // Async restart req to CPU\n', '   output logic                      o_cpu_run_ack, // Core response to run req\n', '   input logic                       scan_mode, // To enable scan mode\n', '   input logic                       mbist_mode // to enable mbist\n', ');\n', '\n', '`include ""global.h""\n', '\n', '   // DCCM ports\n', '   logic         dccm_wren;\n', '   logic         dccm_rden;\n', '   logic [DCCM_BITS-1:0]  dccm_wr_addr;\n', '   logic [DCCM_BITS-1:0]  dccm_rd_addr_lo;\n', '   logic [DCCM_BITS-1:0]  dccm_rd_addr_hi;\n', '   logic [DCCM_FDATA_WIDTH-1:0]  dccm_wr_data;\n', '\n', '   logic [DCCM_FDATA_WIDTH-1:0]  dccm_rd_data_lo;\n', '   logic [DCCM_FDATA_WIDTH-1:0]  dccm_rd_data_hi;\n', '\n', '   logic         lsu_freeze_dc3;\n', '\n', '   // PIC ports\n', '\n', '   // Icache & Itag ports\n', '   logic [31:2]  ic_rw_addr;\n', '   logic [3:0]   ic_wr_en  ;     // Which way to write\n', '   logic         ic_rd_en ;\n', '\n', '\n', '   logic [3:0]   ic_tag_valid;   // Valid from the I$ tag valid outside (in flops).\n', '\n', '   logic [3:0]   ic_rd_hit;      // ic_rd_hit[3:0]\n', '   logic         ic_tag_perr;    // Ic tag parity error\n', '\n', '   logic [15:2]  ic_debug_addr;      // Read/Write addresss to the Icache.\n', '   logic         ic_debug_rd_en;     // Icache debug rd\n', '   logic         ic_debug_wr_en;     // Icache debug wr\n', '   logic         ic_debug_tag_array; // Debug tag array\n', '   logic [3:0]   ic_debug_way;       // Debug way. Rd or Wr.\n', '\n', '`ifdef RV_ICACHE_ECC\n', '   logic [24:0]  ictag_debug_rd_data;// Debug icache tag.\n', '   logic [83:0]  ic_wr_data;         // ic_wr_data[135:0]\n', '   logic [167:0] ic_rd_data;         // ic_rd_data[135:0]\n', '   logic [41:0]  ic_debug_wr_data;   // Debug wr cache.\n', '`else\n', '   logic [20:0]  ictag_debug_rd_data;// Debug icache tag.\n', '   logic [67:0]  ic_wr_data;         // ic_wr_data[135:0]\n', '   logic [135:0] ic_rd_data;         // ic_rd_data[135:0]\n', '   logic [33:0]  ic_debug_wr_data;   // Debug wr cache.\n', '`endif\n', '\n', '   logic [127:0] ic_premux_data;\n', '   logic         ic_sel_premux_data;\n', '\n', '`ifdef RV_ICCM_ENABLE\n', '   // ICCM ports\n', '   logic [`RV_ICCM_BITS-1:2]    iccm_rw_addr;\n', '   logic           iccm_wren;\n', '   logic           iccm_rden;\n', '   logic [2:0]     iccm_wr_size;\n', '   logic [77:0]    iccm_wr_data;\n', '   logic [155:0]   iccm_rd_data;\n', '`endif\n', '\n', '   logic        core_rst_l;     // Core reset including rst_l and dbg_rst_l\n', '   logic        jtag_tdoEn;\n', '\n', '   logic        dccm_clk_override;\n', '   logic        icm_clk_override;\n', '   logic        dec_tlu_core_ecc_disable;\n', '\n', '   logic        dmi_reg_en;\n', '   logic [6:0]  dmi_reg_addr;\n', '   logic        dmi_reg_wr_en;\n', '   logic [31:0] dmi_reg_wdata;\n', '   logic [31:0] dmi_reg_rdata;\n', '   logic        dmi_hard_reset;\n', '\n', '\n', '   // Instantiate the veer core\n', '   veer veer (\n', '          .*\n', '          );\n', '\n', '   // Instantiate the mem\n', '   mem  mem (\n', '        .rst_l(core_rst_l),\n', '        .*\n', '        );\n', '\n', '  // Instantiate the JTAG/DMI\n', '   dmi_wrapper  dmi_wrapper (\n', '           // JTAG signals\n', '           .trst_n(jtag_trst_n),           // JTAG reset\n', '           .tck   (jtag_tck),              // JTAG clock\n', '           .tms   (jtag_tms),              // Test mode select\n', '           .tdi   (jtag_tdi),              // Test Data Input\n', '           .tdo   (jtag_tdo),              // Test Data Output\n', '           .tdoEnable (),                  // Test Data Output enable\n', '\n', '           // Processor Signals\n', '           .core_rst_n  (dbg_rst_l),     // Primary reset, active low\n', '           .core_clk    (clk),            // Core clock\n', '           .jtag_id     (jtag_id),        // 32 bit JTAG ID\n', '           .rd_data     (dmi_reg_rdata),  // 32 bit Read data from  Processor\n', '           .reg_wr_data (dmi_reg_wdata),  // 32 bit Write data to Processor\n', '           .reg_wr_addr (dmi_reg_addr),   // 32 bit Write address to Processor\n', '           .reg_en      (dmi_reg_en),     // 1 bit  Write interface bit to Processor\n', '           .reg_wr_en   (dmi_reg_wr_en),   // 1 bit  Write enable to Processor\n', '           .dmi_hard_reset   (dmi_hard_reset)   //a hard reset of the DTM, causing the DTM to forget about any outstanding DMI transactions\n', '   );\n', '\n', 'endmodule\n', '\n']"
